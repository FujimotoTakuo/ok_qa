最新版をインストールしましたか？ 古いバージョンの場合はセキュリティの問題からプラグインが無効化されます。
HTML5で作り直してちょうだい。
一番最初は「FutureSplash」という名称でした。 その後、Macromediaが買収して、Shockwave Flashという名称に変わりました。 その後、AdobeがMacromediaごと買収して、今のFlashという名称になりました。 ※私事ですが、FutureSplashで遊んでた記憶が蘇ってきました（笑）
以前何かで読んだのですが、最新のHTML仕様であるHTML5でFLASHと似たことができるので、HTML5をサポートするブラウザであれば動いてしまうというのでかと思います。
次のページの「リリース版とデバッガー版アーカイブ 」にあるバージョン数の大きい方をダウンロード（zipファイル）して、解凍すると、フォルダの中に、flashplayer16_0r0_305_win.msiのように、.msiファイルが出ててくるようですが。 https://helpx.adobe.com/jp/flash-player/kb/228683.html#main___________
元々 http://okwave.jp/qa/q8960833.html この↑ご質問で書かれていらっしゃった内容に関して以下の回答をします。 (今回では省略されている テキストフィールドを addChild する場所などが重要なので。) ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ 元々書いていらした上記のご質問で， > としても全く違うものが削除されます。 > テキストフィールドが削除されません。 > ボタンなどが削除されます。 と書かれていらっしゃる「としても」の部分が 具体的に「どのようにしても」なのかわかりません (中身が空の関数 sakujyo2 がその上に書いてあっただけです)。 また，text_field1，text_field2，text_field3，… も どこまで存在する可能性があるのかがわかりません (text_field7 までの７個でしょうか？)。 その他も良くわからない部分がありますが， 仮に関数 go1 を修正するのであれば 次のようにすれば良いのではないかと思います。 backBtn.addEventListener(MouseEvent.CLICK, go1); function go1(event:MouseEvent):void { //変数 i に1から7まで1ずつ加算した値を代入しながらループ for(var i = 1; i <= 7; i++) { //変数 text_field○ が存在した上で なおかつ //その変数の参照インスタンスが stage の表示リストに存在すれば if(this["text_field" + i] != null && stage.contains(this["text_field" + i])) { //そのインスタンスを stage の表示リストから削除する stage.removeChild(this["text_field" + i]); //念のためその変数の参照を切っておく this["text_field" + i] = null; } } } ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ご質問では， var text_field1:TextField = new TextField(); のようにして 変数自体はそのタイムライン(root)階層に配置されていますが その変数が参照するテキストフィールドインスタンス本体は stage.addChild(text_field1); のようにして stage 階層に直接配置されています。 (変数が存在する階層とテキストフィールドが存在する階層とがズレています。) (stage 階層は メインタイムライン(root) 階層の親階層です。) したがって 少々ややこしい話になるわけですが， 変数へのパスは this (またはパス無し) になり， removeChild を実行させる対象オブジェクトは stage になるわけです。 stage.removeChild(this["text_field" + i]); ^^^^^^ ややこしいので 階層を別にする理由が特になければ， 配置する階層を揃えた方が良いと思います (「stage」ではなく「この階層」に)。 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html それと上のスクリプト中の this["text_field" + i] で使っている [ ] を「配列アクセス演算子」と言います。 「FN1107002-ドット演算子と配列アクセス演算子-Flashテクニカルノート」 http://www.fumiononaka.com/TechNotes/Flash/FN1107002.html ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ なお実際は， 「フレーム移動させる関数」と 「テキストフィールドを消す関数」とは別にしておいて 「フレーム移動させる関数」から「テキストフィールドを消す関数」を実行させるようにした方が汎用的なスクリプトになるように思います。 (これは使われ方によって変わるので何とも言えませんが。) また テキストフィールドの参照も タイムライン変数を用意してそこに代入するのではなく 配列の要素に代入した方が使い勝手が良くなる気がします。 (これも使われ方によって変わるので何とも言えませんが。)
無いっぽいねー。多分プラットフォームがWindowsオンリーになるのでそれならそこまで無理してAS3で作らなくてもよくねという事で需要が無いのだと思われる。無いので「TCPで接続を待ち受けてkinect v2からの情報（五体の位置とぐーちょきぱー）をだーだー流す」プログラムを作った事がある。C#で。 フラッシュ系列は分からないのでAS3うんぬんは不明だが、フラッシュ系列の人からの依頼で作った。一応そのプログラム経由でAIRでkinectの情報を使う事ができたようだ。 kinect v2 SDKのサンプル（黒い画面に緑とか赤とかで人のボーンが表示されるサンプル、BodyWPFだったか）をちょちょいと手直しするだけですぐできるぜ。そこからC++経由でANEを作ればそういう事もできそうだね。
HTMLでは無理ですね。本来はFlashの中にActionScriptを埋め込みますが、それが無理な場合は、表示終了時間を計算しJavaScriptで飛ばすしか無さそうですね。 JavaScriptで5秒後に飛ばすとかなら簡単にできますよ。
> flash.ocxでエラーが頻発する場合、名前を変更してもまたflashplayerのアップデートごとに同じ作業を繰り返さなければいけないということでしょうか アップデートしたらflash.ocxがなくなっていませんか? あればエラーにならないはずですが。 > その場合古いVerのOCXが残ったままになってしまうのですが、それでも問題無いでしょうか 管理者権限でログインしてからflashplayerをインストールしてみてはいかがですか。
ココでは１つの回答に対して 画像などが１枚しか添付できないため 説明がわかりにくくなるかと思いますが できる範囲で回答することにします。 まず， 作成中の Flash アニメの最初のフレームなどのステージ上には ご質問でかかれているように jpg画像 が配置されている状態なのですよね？ JPEG に限らずその他の画像であっても 画像のままではボタンとして機能しないので， その jpg画像 を選択した状態で 「修正」→「シンボルに変換」を選択します。 ※参考【添付画像】 すると， 「シンボルに変換」パネルが出てくると思うので [種類]の欄で「ボタン」を選択してボタンシンボルに変換します。 (シンボル名は「シンボル 1」でも何でも良いです。) (ボタンではなくムービークリップに変換しても良いです。) これで， ステージ上のその jpg画像 はボタン(またはムービークリップ)インスタンスになります。 次に， そのボタンインスタンスを選択した状態で 今度はプロパティパネル(プロパティインスペクタ)を表示させます。 その表示させたプロパティパネルには [<インスタンス名>　] と書かれたテキスト記入欄があると思いますから そこでこのボタンにインスタンス名を付けます。 ここでは仮にそのボタンに 「my_btn」というインスタンス名を付けることとします。 次に Flash のタイムラインに スクリプトを書く用のレイヤーを挿入します。 ※参考【添付画像】↓(下半分) そのフレームのキーフレームを選択した状態で (と言うかボタンが存在するキーフレームを選択した状態で) アクションパネル を表示させて 次のようなスクリプトを書きます。 //------------------------ //「my_btn」クリック時に関数 openMyPage を実行 my_btn.addEventListener(MouseEvent.CLICK,openMyPage); //関数 openMyPage の定義; function openMyPage(e:MouseEvent):void { //表示先のURLリクエストを作成 var page_rq:URLRequest = new URLRequest("開くページのURL"); //リクエストページを同窓で開く navigateToURL(page_rq,"_self"); } //------------------------ ※ なお， 　 new URLRequest("開くページのURL"); 　 この「開くページのURL」の部分は 　 実際に存在するページのパスやファイル名に 　 書き換えてください。 これで，ファイルを上書き保存をするなどして あとは「ファイル」→「パブリッシュ」すれば完成です。 ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ なお一般的に， 外部ファイルへのリンク動作などが入った Flash(SWF) は ローカル環境にあるファイルでは動作しません。 (PCの内部情報を外部に漏らさないためのセキュリティがはたらくため。) この状態では 実際の動作実験ができないので困りますし， またご自身で作られた Flash(SWF) に 自身のセキュリティ上都合が悪いスクリプトなど入れるはずがありません。 ですから Flash(SWF) コンテンツ開発者の方は このセキュリティを解除するのが普通です。 セキュリティを解除するには， 例えば上で作成した Flash 付き HTML をブラウザで開いて その HTML に貼り付いた Flash(SWF) を右クリックするなどして 「グローバル設定」を選択します。 すると 「Flash Player 設定マネージャー」パネルが出てくると思うので そこから「高度な設定」タブを選択し， 下の方にスクロールして 開発者向けツール--------　欄の 「信頼されている場所設定...」ボタンをクリックし 「信頼されている場所設定」パネルより 「追加」ボタンをクリックして 上で作成した Flash(SWF) を含むフォルダを 「信頼されているファイルまたはフォルダーの場所」一覧に追加します。 これで 「違うページにジャンプする」というようなリングなどが 検証実験できるようになります。 または， 次のページで「これらの場所にあるファイルを常に信頼する」に Flash(SWF) ファイルを含むフォルダーなどを指定しても良いです。 「Adobe - Flash Player：設定マネージャー - グローバルセキュリティ設定パネル」 http://www.macromedia.com/support/documentation/jp/flashplayer/help/settings_manager04.html
ココでは１つの回答に対して 画像などが１枚しか添付できないため 説明がすごくわかりにくくなると思いますが できる範囲で回答することにします。 まず， 作成中の Flash アニメーションの 最終フレームなどのステージ上に ご質問でかかれている「えんたーの画像ファイル」を配置しますよね？ 画像のままではボタンとして機能しないので， その「えんたーの画像」を選択した状態で 「修正」→「シンボルに変換」を選択します。 ※参考【添付画像】↓(おもに上半分) すると， 「シンボルに変換」パネルが出てくると思うので [種類]の欄で「ボタン」を選択してボタンシンボルに変換します。 (シンボル名は「シンボル 1」でも何でも良いです。) これで， ステージ上の「えんたーの画像」はボタンインスタンスになります。 次に， そのボタンインスタンスを選択した状態で 今度はプロパティパネル(プロパティインスペクタ)を表示させます。 その表示させたプロパティパネルには [<インスタンス名>　] と書かれたテキスト記入欄があるはずですから そこでこのボタンにインスタンス名を付けます。 ここでは仮にそのボタンに 「enter_btn」というインスタンス名を付けることとします。 次に Flash アニメーションに スクリプトを書く用のレイヤーを挿入して 最終フレームを空白キーフレームにします。 ※参考【添付画像】↓(おもに下半分) その最終フレームのキーフレームを選択した状態で (と言うかボタンが存在するキーフレームを選択した状態で) アクションパネル を表示させて 次のようなスクリプトを書きます。 //------------------------ //このフレーム(最終フレーム)で再生停止 stop(); //「enter_btn」クリック時に関数 openTopPage を実行 enter_btn.addEventListener(MouseEvent.CLICK,openTopPage); //関数 openTopPage の定義 function openTopPage(e:MouseEvent):void{ //表示先のURLリクエストを作成 var page_rq:URLRequest = new URLRequest("トップページ.html"); //リクエストページを同窓で開く navigateToURL(page_rq,"_self"); } //------------------------ ※ new URLRequest("トップページ.html"); 　上記の「トップページ.html」の部分は 　実際に存在するページのパスやファイル名に 　書き換えてください。 これでファイルを上書き保存をするなどして あとは「ファイル」→「パブリッシュ」すれば完成です。 ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ なお一般的に， 外部ファイルへのリンク動作などが入った Flash(SWF) は ローカル環境にあるファイルでは動作しません。 (PCの内部情報を外部に漏らさないためのセキュリティがはたらくため。) しかしこれでは 実際の動作実験ができないので困りますし， またご自身で作られた Flash(SWF) に 自身のセキュリティ上都合が悪いスクリプトなど入れるはずがありません。 ですから Flash(SWF) コンテンツ開発者の方は このセキュリティを解除するのが普通です。 セキュリティを解除するには， 例えば上で作成した Flash 付き HTML をブラウザで開いて その HTML に貼り付いた Flash(SWF) を右クリックするなどして 「グローバル設定」を選択します。 すると 「Flash Player 設定マネージャー」パネルが出てくると思うので そこから「高度な設定」タブを選択し， 下の方にスクロールして 開発者向けツール-------- 欄の 「信頼されている場所設定...」ボタンをクリックし 「信頼されている場所設定」パネルより 「追加」ボタンをクリックして 上で作成した Flash(SWF) を含むフォルダを 「信頼されているファイルまたはフォルダーの場所」一覧に追加します。 これで 「違うページにジャンプする」というようなリングなどが 検証実験できるようになります。 または 次のページで「これらの場所にあるファイルを常に信頼する」に Flash(SWF) ファイルを含むフォルダーなどを指定しても良いです。 「Adobe - Flash Player：設定マネージャー - グローバルセキュリティ設定パネル」 http://www.macromedia.com/support/documentation/jp/flashplayer/help/settings_manager04.html
Flash コンテンツ作成ソフトとしては Adobe Flash CS3 以上を使用されているものとして 以下の回答をします。 簡単にするには ステージ上に例えば「point_txt」というインスタンス名を付けた得点表示用のテキストフィールドと 例えば「A_mc」「A_mc」「A_mc」というインスタンス名を付けたパズルの各ピースに当たるMC(ムービークリップ)を用意します。 ※参考【添付図】↓ そして それらのインスタンスが存在するタイムラインのフレームに次のようなスクリプトを書きます。 //--------------------------------------------- //得点を代入する変数 point_num の初期化 var point_num:int = 0; //point_txt に得点を表示 point_txt.text = point_num + "点"; //パズルの各ピースをキーとする Dictionary を作成 var piece_dic:Dictionary = new Dictionary(); //piece_dic の各キーに各ピースMCと各得点値を登録 piece_dic[A_mc] = 2; piece_dic[B_mc] = 3; piece_dic[C_mc] = 4; //A_mc～C_mc を押した時に関数 addPoint を実行 A_mc.addEventListener(MouseEvent.MOUSE_DOWN,addPoint); B_mc.addEventListener(MouseEvent.MOUSE_DOWN,addPoint); C_mc.addEventListener(MouseEvent.MOUSE_DOWN,addPoint); //関数 addPoint の定義 function addPoint(e:MouseEvent):void { //変数 point_num に押されたMCの登録得点を加算 point_num += piece_dic[e.currentTarget]; //point_txt に得点を表示 point_txt.text = point_num + "点"; } //--------------------------------------------- 上記のような感じのものを変形＆発展させて行けば ご質問で書かれていらっしゃるようなものができると思います。 別に Dictionary クラスなど使わなくてもできますが 使わない場合は各ピース毎に違う得点を加算する関数を用意するとか クロージャを登場させるとか手間が増えるので Dictionary クラスを使って １つの関数(イベントリスナー)を複数のピースで使い回す形にしています。 上で書いたようにピースが MC である場合は， その中に勝手な変数を用意できるので そこに各得点を代入して行っても良いです。 しかし ピースがボタンインスタンスであった場合 その中に勝手な変数は用意できないので 汎用性を高める意味も含めて Dictionary クラスを使っています。 ◎参考URL 「FlashゲームPG講座 For AS3.0【Dictionary クラスについて】」 http://hakuhin.jp/as3/dictionary.html
「もし変数 pass が2222だったら」は if (pass = "2222") ではなく、 if (pass == 2222) と書きます。 これで試してみてください。
＃１です。 こちらでも実験してみましたが trace( bm_s.width.toString() ); の値は 0 にはなりませんでしたよ。 元の BitmapData の横幅サイズが取得できました。 もっともこれは パブリッシュ設定で Flash Player のバージョンを Flash Player 10 以上にした場合ですが。 z座標 がサポートされたのは Flash Player 10 以降だからです。 (オーサリング環境で言えば z座標 のサポートは Flash CS4 以降です。) しかし， 仮に Flash Player 9 に設定したとしても 「そんなプロパティなんて未定義だよ！」みたいなエラーが出るだけで 「0」が出力されることはありませんが。。。 それと var bm:Bitmap = new Bitmap(event.bitmapData) as Bitmap; このような意味不明なことを書かれても 第三者である私にとっては何のことか(どういう状況なのか) さっぱりわからないので こちらでは勝手に Pic というクラス名をつけた 160×120 px の BitmapData シンボルをライブラリに用意した上で var bm:Bitmap = new Bitmap(new Pic(0,0)) as Bitmap; のようにして BitmapData を呼び出していますが。 ※参考【添付図】↓ 【私が実験してみたスクリプト全文例】↓ [SWF(frameRate="20",width="550",height="400")] var app_width = 550; var app_height = 200; var def_z = 0; var bm:Bitmap = new Bitmap(new Pic(0,0)) as Bitmap; bm.x = bm.width / 2 * -1 ; bm.y = bm.height / 2 * -1 ; bm.smoothing =true var bm_s:Sprite = new Sprite; bm_s.x = app_width / 2 + def_z ; bm_s.y = app_height + def_z ; bm_s.z = def_z; bm_s.addChild( bm ); addChild( bm_s ); trace( bm.width.toString() ); //←160 が出力される trace( bm_s.width.toString() );//←160 が出力される
画像を ムービークリップ または スプライト の中に配置します。 その ムービークリップ または スプライト の中に画像を配置するとき 画像の x 座標を (-画像の幅の半分)， 画像の y 座標を (-画像の高さ半分)， にします。 そして ムービークリップ または スプライト に Tweener を適用させて回転させます。 何にしても回転(や拡大縮小などなど)の基準は「基準点」です。 単なる画像の基準点は左上です。 この基準点は変えられないので ムービークリップ や スプライト の基準点に 画像の中心が来るように配置しておいて ムービークリップ や スプライト を回転させれば 画像の真ん中が中心に来るように回転するようになるという意味です。
◎ 「_visible」の保存について SharedObject に _root.save.data.a1=_root.a1; や _root.save.data.h1=_root.h1; のような各インスタンスの参照を保存してみたり a1 = true; のようなわけのわからないことを書かれているから 一見保存されていないように見えるだけでしょう。 （２フレーム目）メインのスクリプト これ↑は変更ナシで良いです。 a1を表示するボタンのスクリプト変更例↓ ------------------------ on (release) { a1._visible = true; } ------------------------ h1を表示するボタンのスクリプト変更例↓ ------------------------ on (release) { h1._visible = true; } ------------------------ 「保存」ボタンのスクリプト変更例↓ ----------------------- on (release) { _root.save.data.check = 1; //←意味不明ですが残しました _root.save.data.a1_v = _root.a1._visible; _root.save.data.h1_v = _root.h1._visible; } ----------------------- 「読み込み」ボタンのスクリプト変更例↓ ----------------------- on (release) { _root.a1._visible = _root.save.data.a1_v; _root.h1._visible = _root.save.data.h1_v; } ----------------------- 「髪自体」や「スカート自体」のスクリプトは ドラッグしない場合はそのまま変更ナシで良いでしょう。 SharedObject には a1 や h1 などインスタンスの参照を保存するのではなくて a1 や h1 などインスタンスのプロパティを保存するのですよ。 そして そのプロパティ値を読み込んできて 各インスタンスに適用させるのです。 　 ◎ ドラッグでの座標保存の件について これは， 上に書いたことを理解すれば簡単なことでしょう？ 座標の場合は 「_x」プロパティ や「_y」プロパティを保存＆読み込みすれば良いだけです。 「髪自体」や「スカート自体」に書くスクリプト変更例↓ ------------------------ onClipEvent (load) { this._visible = false; } on (press) { this.startDrag(); } on (release, releaseOutside) { this.stopDrag(); } ------------------------ 「保存」ボタンのスクリプト変更例↓ ----------------------- on (release) { _root.save.data.check = 1; //←意味不明ですが残しました _root.save.data.a1_v = _root.a1._visible; _root.save.data.a1_x = _root.a1._x; _root.save.data.a1_y = _root.a1._y; _root.save.data.h1_v = _root.h1._visible; _root.save.data.h1_x = _root.h1._x; _root.save.data.h1_y = _root.h1._y; } ----------------------- 「読み込み」ボタンのスクリプト変更例↓ ----------------------- on (release) { _root.a1._visible = _root.save.data.a1_v; _root.a1._x = _root.save.data.a1_x; _root.a1._y = _root.save.data.a1_y; _root.h1._visible = _root.save.data.h1_v; _root.h1._x = _root.save.data.h1_x; _root.h1._y = _root.save.data.h1_y; } ----------------------- 　 ◎ 外部swfを使った着せ替えについて この件に関しては 何をどうしたいのか不明な点が多いこともありますから とりあえずは上に書いたことまでを完璧に理解して 自力でそれを応用して作れるようになってから， 一度ご自身でチャレンジしてみてください。 もしそれで行き詰まれば そのときに 「具体的な状況」と「何をどうしたいのか」ということを明記して 質問しなおされる方が良いと思います。
んーと、質問者様は何か勘違いされていませんか？ 確かにボカロ曲の PV 動画を再生する上で現在は Flash, 将来的には HTML5 を使っている/使うことになることは確かです。 しかし、それはあくまでも動画を再生するプラットフォームとして上記の技術を使っているだけで、動画作成者が全員 Flash を使っているという事ではありません。現在では Flash は選択肢の一つでしかありません。 たとえば、以下の URL のページは手書き PV の作り方の一例を書いていますが、ページを読めばわかる通り PV を作っていくうえで Flash も HTML5 も使っておりません。 http://note.chiebukuro.yahoo.co.jp/detail/n242811 また、MMD PV も制作する上で Flash は必要ありませんし、MMD 自体にも Flash の技術は使用していません。 ですので、 > ボカロ曲の動画作成などではFlashとHTML5 > どちらを使うようにしたら良いでしょうか。 という問いに対しては、「どちらも特に必要ではありません。動画作成のための学習としては的外れです」と回答いたします。
残念ながら動作しません。 Adobe AIRは現在Windows RTでの動作はサポートされていません。 Windows RT向けのAIRランタイムも無いですし、AIR SDKにはWindows RT向けに書き出す機能はありません。
◎ まずは現状のスクリプトの指摘から。 そもそも for文 を使おうとすることが間違いですが 仮に使うとしても その中に function文 を入れることがさらなる間違いです。 何度も同じ function を定義するのは変です。 さらに if文 の () 内で代入演算子「=」を使うこともこの場合は間違いです。 使うのであれば等価演算子「==」でしょう。 しかし alpha は結構イイカゲンな値になるため 通常は等価演算子「==」で判断できません。 この場合は，比較演算子「>=」を使うべきです。 　 ◎ 次に本題です。 最初に for文 を使うことが間違いということを書きましたが では何を使うのかと言えば ActionScript 3.0 から導入された「Timerクラス」を使うか もしくは ActionScript 2.0 以下 や JavaScript ではお馴染みの 「setInterval」や「setTimeout」を使うのが一般的です。 ※別法として 　「カウンター用に別の Event.ENTER_FRAME 実行関数を用意する」 　とか 　「MC のループ再生で順次 Event.ENTER_FRAME 実行関数を登録する」 　などの方法もありますが 　最近は一般的な方法とは言えません(昔は一般的)。 下のスクリプト【例１】～【例３】には 全角スペースでインデントを入れています。 そのままコピペで使用するとエラーになるので 全角スペースを削除するか TAB などに置換してください。 　 【例１】「Timerクラス」を使うスクリプト例 //カウンタ用変数 i の初期化 var i:int = 0; //Timerクラスのインスタンス tm を作成 //(遅延：2000ミリ秒(２秒)，実行回数：containers の要素数-1) var tm:Timer = new Timer(2000,containers.length - 1); //指定遅延時間毎に関数 startSlide を実行 tm.addEventListener(TimerEvent.TIMER,startSlide); //関数 startSlide の定義 function startSlide(e:TimerEvent = null):void { 　　//フェードスタート 　　containers[i].addEventListener(Event.ENTER_FRAME, slideContainer); 　　//カウンタ i に 1 を加算 　　i++; } //Timerスタート tm.start(); //関数 startSlide を即実行 startSlide(); function slideContainer(e:Event):void { 　　e.target.alpha += 0.01; 　　//(「=」を「>=」に修正) 　　if (e.target.alpha >= 1) { 　　　　e.target.removeEventListener(Event.ENTER_FRAME, slideContainer); 　　} } 　 【例２】「setInterval」を使うスクリプト例 //カウンタ用変数 i の初期化 var i:int = 0; //関数 startSlide を 2000ミリ秒(２秒) 間隔で遅延実行 var ID:int = setInterval(startSlide, 2000); //関数 startSlide の定義 function startSlide():void { 　　//フェードスタート 　　containers[i].addEventListener(Event.ENTER_FRAME, slideContainer); 　　//もし i が containers の要素数-1 であれば 　　if (i < containers.length - 1) { 　　　　//カウンタ i に 1 を加算 　　　　i++; 　　//それ以外は 　　} else { 　　　　//setInterval を解除 　　　　clearInterval(ID); 　　} } //関数 startSlide を即実行 startSlide(); function slideContainer(e:Event):void { 　　e.target.alpha += 0.01; 　　//(「=」を「>=」に修正) 　　if (e.target.alpha >= 1) { 　　　　e.target.removeEventListener(Event.ENTER_FRAME, slideContainer); 　　} } 　 【例３】「setTimeout」を使うスクリプト例 //カウンタ用変数 i の初期化 var i:int = 0; //関数 startSlide の定義 function startSlide():void { //フェードスタート containers[i].addEventListener(Event.ENTER_FRAME, slideContainer); //もし i が containers の要素数-1 であれば if (i < containers.length - 1) { //この関数 startSlide を 2000ミリ秒(２秒) 後に実行 setTimeout(startSlide, 2000); //カウンタ i に 1 を加算 i++; } } //関数 startSlide を実行 startSlide(); function slideContainer(e:Event):void { e.target.alpha += 0.01; //(「=」を「>=」に修正) if (e.target.alpha >= 1) { e.target.removeEventListener(Event.ENTER_FRAME, slideContainer); } } 　 上記３例中では 【例１】の「Timerクラス」を使う方法が ActionScript 3.0 では最も一般的だと思います。 reset() や stop() メソッドや timerComplete イベントなども用意されています。 ただ 途中から(モノによって)遅延実行時間を変更したい場合などは 【例３】の「setTimeout」の方が使い易い気がします。 【例２】の「setInterval」を使う方法は 上記３例中で最古からあって結構普及していますが， 何度も setInterval が重複セットされると ID の管理が難しくなることもあるため 個人的に私はあまり使いたくありません。
こんにちは。 さほど詳しくなくて申し訳ないのですが、問題の切り分けとして画像の容量を減らして試してみてください。 それでも同じなら何か違う要因ですし、動作が軽快になるのであれば画像のサイズの問題になります。 必要な画像は先に読み込んでおく等の対処が必要かもしれません。
◎ ご質問の(1)に関して この不具合現象は再現できないのでよくわかりません。。。 (日本語の意味がわからない部分もありますけど。) Flash ドキュメントファイルの「ライブラリ」内に ちゃんと「btn」というクラス名の ボタン もしくは ムービークリップ が用意されていたならば 指示した場所(座標)に表示されると思いますが。。。 ただ，，， 「_btn」の指示座標が _btn.x = 3; _btn.y = 462; のように y座標 の値が結構大く設定されているため 動作検証したときに私も最初見えなくて一瞬驚きました。 しかし， これは単にステージの高さが デフォルトの 450px になっていたから見えなかっただけで ステージの高さを例えば 500px くらいに設定し直せば見えました。 つまり， 私が動作検証実験した状況で _btn は見えるのですから 書かれていらっしゃる不具合現象が再現できないため _btn が見えない原因はわかりません。 少し気になった点としては //ボタン配置 var _btn:btn = new btn; ではなく //ボタン配置 var _btn:btn = new btn(); と書くのが正しい書き方ですが どちらにしても動作するのでこの点は無視できるでしょう。 それと 最初にも少し書きましたが， > レイヤーを非表示にしてみるとちゃんとボタンは見えています。 この１行の日本語の意味がわかりません。 わからないのであまり深く考えず， 動作検証では無視させていただきました。 . ◎ ご質問の(2)に関して Event.ENTER_FRAME は それを addEventListener した 次のフレーム時間に入る(ENTERする)ときから実行されるのです。 つまり， Event.ENTER_FRAME の addEventListener が実行された時点では すでに そのフレームに入ってしまって(ENTERしてしまって)いるわけですよね？ addEventListener する前に溯って そのイベントリスナーが実行されるのは変(不可能)です。 ---【例】--------------- ある日の朝のことです。 太郎君は学校に登校して先生に会いました。 しかし何も言わず先生の前を通り過ぎました。 そこでの会話です。 先生:「太郎君，これからは毎朝最初に挨拶してね！」 太郎:「はい，わかりました。」 ------------------------ ↑この状況で太郎君がいくら反省をしたとしても この日の朝最初に先生に挨拶することは不可能ですよね？ 先生に注意された時点で， 『その日の「毎朝最初」は過ぎ去っている』わけですから。 太郎君が先生の言い付けを実行できるのは この注意を受けた「次の日」以降です。 つまり， フレームがループ再生されるようなことがあって， 再び フレーム1 再生ヘッドが戻るようなことがあれば if(currentFrame == 1) この () 内は true になるので trace("初回起動") stop(); が実行されます。 でも初回の フレーム1 再生開始時には実行されないわけです。 ですから， 初回の フレーム1 再生時に trace("初回起動") stop(); を実行させたいのでしたら， Event.ENTER_FRAME のイベントリスナーの中に入れるのではなくて 例えばコンストラクタである public function main(){…} の中に直接書くなど，別の方法をとる必要があります。
そもそも， その提示されているページのサンプルは 『「ランダム問題出題」 ランダムに問題を出題して、100点になれば終了。』 という仕様(ルール)のゲームですよ。 つまり 元から100点にしかならない仕様(ルール)です。 (10問正解しないと終わらない仕様なのです。) ですから， 「点数別にエンディングのイラストを変える」 などという以前の話で 100点にしかならない仕様自体を変える必要があるということになります。 したがってまずは 「どんな仕様(ルール)にするのか？」 これを考えなければ， スクリプトも何も書けません。 本来は作成者(質問者)が仕様(ルール)を決めるべきです。 しかし何も書かれていないため何も回答できません。 これでは困ると思うので， 私(回答者)が勝手に仕様(ルール)を考えるとします。 /*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/ ◎仕様(ルール) 『ランダムに問題を出題して、 1問10点の問題を10問解いた時点で終了。 そして得点に応じた絵柄を表示する。』 このような仕様(ルール)にするものとして 以下の回答を続けます。 提示されているページの 「サンプルダウンロード」より 「00.fla」をダウンロード＆保存させてもらった上で その「00.fla」を改変する方向で回答します。 まず 「00.fla」のメインタイムラインの 「Action」レイヤー フレーム1 のスクリプトを次のようにします。 stop(); _global.point=0; //点数用変数の宣言と初期値設定 _global.seigo=0; //正誤判定用変数の宣言と初期値設定 _global.count=0; //←★付け加え そして 「正誤判定」レイヤー フレーム2 以降にある MC(ムービークリップ) である小さな○を選択し その MC 自体に書かれてあるスクリプトを 次のようにします。 onClipEvent (enterFrame) { if(_global.seigo == 1){ //正解の場合 _global.point+=10; //10点加算 _global.seigo =0; //判定初期化 this.gotoAndPlay("ok"); //ラベルokへ（○表示） _global.count++; //←★付け加え } if(_global.seigo == 2){ //不正解の場合 _global.seigo =0; //判定初期化 this.gotoAndPlay("ng"); //ラベルngへ（×表示） _global.count++; //←★付け加え } } 次にその 「正誤判定」レイヤー フレーム2 以降にある MC である小さな○内の編集に入り 「action」レイヤー フレーム19 に書かれてあるスクリプトを 次のようにします。 if(_global.count == 10){ // ←★変更 gotoAndStop(38); //38フレームへ（得点表示 } else{ ranf = Math.floor(Math.random()*10+2); _root.gotoAndStop(ranf); gotoAndStop(1); } また 同じ「action」レイヤー フレーム19 に書かれてあるスクリプトを 次のようにします。 // ↓★if else 文に変更 if(_global.count == 10){ gotoAndStop(38); //38フレームへ（得点表示） } else{ ranf = Math.floor(Math.random()*10+2); _root.gotoAndStop(ranf); gotoAndStop(1); } ここまでで 試しに ムービープレビュー または パブリッシュ してみます。 すると， 『ランダムに問題を出題して、 1問10点の問題を10問解いた時点で終了。 そして終了時に得点を表示する。』 という仕様(ルール)に変わっていると思います。 あとは， この仕様(ルール)の最後の部分 『そして終了時に得点を表示する。』 の部分を 『そして得点に応じた絵柄を表示する。』 に変えれば良いということになります。 その『得点に応じた絵柄を表示する。』方法など様々です。 例えば 上で編集していた MC 内の 「最終」レイヤーに新しいキーフレーム(フレーム39)を追加して そのフレームのステージ上に 「50点以下で不合格！」というような文字や絵でも置き， 「最終」レイヤーに新しいキーフレーム(フレーム40)を追加して そのフレームのステージ上に 「70点以下でもう少し！」というような文字や絵でも置き， 「最終」レイヤーに新しいキーフレーム(フレーム41)を追加して そのフレームのステージ上に 「80点以上で合格！」というような文字や絵でも置きます。 ※参考【添付図】↓ そして， 「action」レイヤー フレーム38 のスクリプトを 次のように変更しても良いでしょう。 //stop(); // ←★削除 // ↓★以下を追加 if(_global.point <= 50){ gotoAndStop(39); } else if(_global.point <= 70){ gotoAndStop(40); } else { gotoAndStop(41); } 実際は 『得点に応じた絵柄を表示する。』方法など無数にあります。 自分自身でどのようなことをしたいかを考えて その通りになるようにスクリプトを組めば良いと思います。
該当記事のスクリプトは、AS2.0で書かれたものなのでAS2.0書き出しにしてください。 AS3.0書き出したいという場合には、スクリプト自体をAS3.0で書き直す必要があります。
重複を無くすとか，割合を操作をする時点で， 「厳密な意味でのランダム」ではなくなってしまいますが それはそれとして以下を続けます。 ご質問本題に関してですが ご質問の【前半】と【後半】とでは 全く違う方法について質問されていると思います。 【前半】連続で再生されないようにランダム再生を続ける方法 【後半】再生させるMCの確率を変動させる方法 . ◎【前半】の方法について これについては， 「３つのMC再生を１クール」として その「１クール」を済ませる度に 「３つのMCの再生順をランダムシャッフルする」 という方向で良いのではないかと思います。 ただし 「前の１クール」の最後のMCが 「次の１クール」の最初にならないようにする。 という内容のスクリプトを加えます。 【例】 「mcB,mcA,mcC」←ランダムシャッフルした１クール目 「mcB,mcC,mcA」←mcCが先頭に来ないようにシャッフル 「mcC,mcB,mcA」←mcAが先頭に来ないようにシャッフル 具体例ですが まず，メインのタイムライン の フレーム1 に 内部が複数フレームある，mcA，mcB，mcC という３つの MC があるものとします。 ※参考【添付図】↓ その場合の メインのタイムライン の フレーム1 に書くスクリプト例です。 //------------------------ //MCの参照を登録する配列「mc_arr」を用意 var mc_arr:Array = [mcA,mcB,mcC]; //配列「mc_arr」に登録したMC内の再生停止 for (var i:int = 0; i < mc_arr.length; i++) { mc_arr[i].stop(); } //カウンタを用意 var cnt:int = 0; //配列「mc_arr」の要素数分ループ for (i = 0; i < mc_arr.length; i++) { //配列「mc_arr」の要素をランダムシャッフル mc_arr.push(mc_arr.splice(int(Math.random()*(mc_arr.length-i)),1)[0]); } //最初のMC内を再生開始 mc_arr[cnt].play(); //毎フレーム 関数 watchMC を実行 addEventListener(Event.ENTER_FRAME,watchMC); //関数 watchMC の定義 function watchMC(e:Event):void { //再生中のMC内が最終フレームになれば if (mc_arr[cnt].currentFrame == mc_arr[cnt].totalFrames) { //再生中のMC内をフレーム1で停止 mc_arr[cnt].gotoAndStop(1); //カウンタに 1 を加算するか 0 に戻す cnt = (cnt < mc_arr.length-1)? cnt+1:0; //カウンタが 0 に戻れば if (cnt == 0) { //再生されていたMCを一時記録 var tmp_mc:MovieClip = mc_arr[mc_arr.length - 1]; //配列「mc_arr」の要素数分ループ for (var i:int = 0; i < mc_arr.length; i++) { //配列「mc_arr」の要素をランダムシャッフル mc_arr.push(mc_arr.splice(int(Math.random()*(mc_arr.length-i)),1)[0]); } //mc_arr[0] が 一時記録された MC と同じであれば if (mc_arr[0] == tmp_mc) { //mc_arr[0] を ランダムな後の要素に挿入 mc_arr.splice(int(Math.random()*(mc_arr.length))+1,0,mc_arr.shift()); } } //次のMC内の再生開始 mc_arr[cnt].play(); } } //------------------------ 上記スクリプトの 『配列「mc_arr」の要素をランダムシャッフルする』 の部分については，書き方こそ全く違っていますが 根底の考え方は次のページと全く同じです。 「FN0212003-配列を偏りなくランダムに並替える」 http://www.fumiononaka.com/TechNotes/Flash/FN0212003.html . ◎【後半】の方法について 用意するものや状況は【前半】と同じで 文字数制限もあるためスクリプトのみ書きます↓。 //------------------------ //MCの参照を登録する配列「mc_arr」を用意 var mc_arr:Array = [mcA,mcB,mcC]; //配列「mc_arr」に登録したMC内の再生停止 for (var i:int = 0; i < mc_arr.length; i++) { mc_arr[i].stop(); } //ランダムな 0～「mc_arr」最終要素番号 の数を得る var rnd:int = int(Math.random()*(mc_arr.length)); //その要素を配列の先頭要素に移動 mc_arr.unshift(mc_arr.splice(rnd,1)[0]); //「mc_arr」の最初のMC内の再生開始 mc_arr[0].play(); //毎フレーム 関数 watchMC を実行 addEventListener(Event.ENTER_FRAME,watchMC); //関数 watchMC の定義 function watchMC(e:Event):void { //再生中のMC内が最終フレームになれば if (mc_arr[0].currentFrame == mc_arr[0].totalFrames) { //再生中のMC内をフレーム1で停止 mc_arr[0].gotoAndStop(1); //0～1未満の小数を得る var rnd:Number = Math.random(); //rnd の値が 0.1 未満(確率10％)であれば if (rnd < 0.1) { //「mc_arr」の最初のMC内の再生開始 mc_arr[0].play(); //それ以外は } else { //ランダムな 1～「mc_arr」最終要素番号 の数を得る rnd = 1+int(Math.random()*(mc_arr.length-1)); //その要素を配列の先頭要素に移動 mc_arr.unshift(mc_arr.splice(rnd,1)[0]); //次のMC内の再生開始 mc_arr[0].play(); } } } //------------------------
> 全てのムービークリップに１つのURLが適用されてしまい > ナビゲーションとしての意味がなくなってしまいます。 とりあえずそれは当たり前の話ですよね？ url は １つだけ↓ しか用意していないわけですから。 var url = ("http://www.yahoo.co.jp/"); > 緊急なので、早めにお返事いただけるとありがたいです。 本当に早急なのであれば， 複雑に考えず sp1～sp10 に対して１つずつ個々に sp○.onRelease=function() { getURL("○○", "_blank"); }; を指定すれば良いだけなのではないのでしょうか？ つまり 具体的に書けば，ご質問で書かれている this.onRelease = function() { getURL(url, "_blank"); }; の３行を削除して， さらに ご質問で書かれていらしゃるスクリプトの後にでも sp1.onRelease=function() { getURL("AAA.html", "_blank"); }; sp2.onRelease=function() { getURL("BBB.html", "_blank"); }; sp3.onRelease=function() { getURL("CCC.html", "_blank"); }; //… sp4～sp9 は省略… sp10.onRelease=function() { getURL("JJJ.html", "_blank"); }; のようなことを書き足せば良いだけでしょう？ これが基本です。 . ＝＝＝別法＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 以上のような基本がわかっていらっしゃる上で さらに ご質問で書かれていらっしゃるような for文 などで処理を済ませたい場合は次のようになります。 ※書き換え箇所多数のため全文を記入↓ //------------------------------- import flash.geom.Matrix; import flash.filters.BlurFilter; var composer:Array = new Array("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"); //★【追加(変更)】URLを配列に登録 var url:Array = new Array(); url[0] = "AAA.html"; url[1] = "BBB.html"; url[2] = "CCC.html"; url[3] = "DDD.html"; url[4] = "EEE.html"; url[5] = "FFF.html"; url[6] = "GGG.html"; url[7] = "HHH.html"; url[8] = "III.html"; url[9] = "JJJ.html"; var num = 10; var speed:Number; var diff:Number = 0; var rd:Number; var a:Number; var depth:Number; var v:Number; this.createEmptyMovieClip("composerNameBox", 100); composerNameBox.createTextField("tf", 120, 0, 0, 220, 25); composerNameBox._x = -10; composerNameBox._y = 145; for (i=1; i<=num; i++) { var mc = this.attachMovie("sp"+i, "sp"+i, i); mc.n = i; mc.onEnterFrame = circulating; // //★【注意】onRollOver や onRelease などは //　関数 circulating から全て出す(入れてはダメ) // mc.onRollOver = function() { this.rollover = true; composerNameBox.tf.text = composer[this.n-1]; txtFormat(composerNameBox); }; // mc.onRollOut = function() { this.rollover = false; composerNameBox.tf.text = ""; }; // mc.onRelease = function() { getURL(url[this.n-1], "_blank"); }; } function circulating() { speed = (Stage.width/2-_xmouse)*0.005*0.001*Math.PI; diff += speed; rd = diff+this.n/num*2*Math.PI; a = Math.sin(rd); b = 0.3*Math.cos(rd); c = 0; d = 1; mcx = 100-200*Math.cos(rd); mcy = 40+40*Math.sin(rd); var myMatrix:Matrix = new Matrix(a, b, c, d, mcx, mcy); this.transform.matrix = myMatrix; depth = Math.floor((3+Math.sin(rd))*2500); this.swapDepths(depth); if (this.rollover) { v = 5; } else { v = Math.floor((1-Math.sin(rd))*5.5); } blurChange(this); } function blurChange(this_mc) { //★【注意】BlurFilter の第３引数は 1～3 var myBlur:BlurFilter = new BlurFilter(v, v, 3); this_mc.filters = [myBlur]; } function txtFormat(mc) { var format = new TextFormat(); with (format) { size = 12; color = 0x000000; align = "center"; bold = true; } mc.tf.setTextFormat(format); } //------------------------------- 上記スクリプトに 次のように書いた部分があります。 //★【注意】onRollOver や onRelease などは //　関数 circulating から全て出す(入れてはダメ) これは， 今回の場合 onRollOver… や onRollOver… や onRelease… などの イベントハンドラメソッドを onEnterFrame… でわざわざ毎フレーム毎フレーム定義し直す必要がないからです。
> Flash Professional CS6のHTML5対応書き出しによる、EaseJSライブラリを使ったCanvasアニメーションで と、言う事はHTML5で作らなければならないのでしょうか？ そうです。 CanvasオブジェクトはHTML5対応ブラウザでないと動作しません。
そのBallというクラスの定義は、 class Ball extends MovieClip という継承宣言は入っていますか？ stageにaddChild()できるのは、MovieClipやSpriteクラスを継承したクラスのインスタンスだけですよ。
＃１です。 ◎ 前置き ＝＝＝ ＝＝＝ ＝＝＝ ＃１の [お礼(補足)] より引用↓ > そして、一番下にBlurFiltan様のスクリプトを > 書き込んだのですが、うまく稼働しません。 それは当たり前ですよ。 そのような勝手な変造をしたスクリプトの後に ＃１のスクリプトを追加することなど想定していません。 (私は超能力者ではないので変造される内容の予知などできません。) ＃１でも > ダウンロード＆解凍された「sample.fla」で言えば > その フレーム1 に書かれてあるスクリプトの後辺りに と "使用条件を限定" しているでしょう？ つまり "その他の条件では動作しない" という意味です。 . ◎ 本題 ＝＝＝ ＝＝＝ ＝＝＝ ＃１の [お礼(補足)] の内容からでは ご希望の動作が今ひとつ掴みにくいのですが 下に書くスクリプトのような動作をさせたいということでしょうか？ ※ ただし(条件)！ 下に書くスクリプトは ご質問で書かれていらしゃるブログのページの サンプルファイルをダウンロード＆解凍すれば出てくる 「sample.fla」内のスクリプトを 全面書き換えする場合のスクリプトです。 (繰り返しますが，その他の条件ではうまく動作しません。) 「★」を付けた数個所が ＃１ の [お礼(補足)] で書かれていらっしゃるスクリプトから さらに追加や変更をした部分です。 //======================================= // ライブラリ読込 import caurina.transitions.Tweener; // 各MCのデータ用配列を用意（※場合によって変える） var datArr:Array = new Array(); //↓★変更 (座標を元の「sample.fla」用に戻しました) datArr[0] = [0, 300, 320, panel01_mc, panel02_mc, panel03_mc]; datArr[1] = [0, 10, 320, panel01_mc, panel02_mc, panel03_mc]; datArr[2] = [0, 10, 30, panel01_mc, panel02_mc, panel03_mc]; //★↓追加 //各MCデフォルト状態のデータ用配列を用意（※場合によって変える） defaultArr = [0, 107, 223, panel01_mc, panel02_mc, panel03_mc]; //各MCをデフォルト状態に配置 for (var i:Number = 0; i<defaultArr.length/2; i++) { defaultArr[defaultArr.length/2+i]._x = defaultArr[i]; } // インターバル時間[ミリ秒]の設定（※好みによって変える） var time:Number = 3500; panel01_mc.onRelease = function():Void { getURL("tachi.html"); }; panel02_mc.onRelease = function():Void { getURL("unyu.html"); }; panel03_mc.onRelease = function():Void { getURL("souwa.html"); }; // --- 以下は変えなくても良い------ //↓★変更 カウントアップする用の変数cntの初期化 var cnt:Number = -1; // 動かすためのデータを入れる配列を作成 var movArr:Array = new Array(); // トゥイーンをさせる関数 function tw():Void { for (var i:Number = 0; i<datArr.length; i++) { Tweener.addTween(movArr[datArr.length+i], {_x:movArr[i], _y:0, time:1, transition:"easelnOutCubic"}); } } // 自動で動かす関数 function autoRollOver():Void { cnt = (cnt<datArr.length-1) ? cnt+1 : 0; movArr = datArr[cnt]; tw(); } // 自動で動かす関数 を time 時間間隔で実行 var myID:Number = setInterval(autoRollOver, time); // パネル01～0? のロールオーバー＆ロールアウト for (i=0; i<datArr.length; i++) { // 各パネル固有の変数nに i の値を格納 this["panel0"+(i+1)+"_mc"].n = i; // // パネル01～0? ロールオーバー時の動作 this["panel0"+(i+1)+"_mc"].onRollOver = function():Void { clearInterval(myID); movArr = datArr[this.n]; tw(); }; // // パネル01～0? ロールアウト時の動作 this["panel0"+(i+1)+"_mc"].onRollOut = function():Void { clearInterval(myID); cnt = this.n; //↓★追加 for (var i:Number = 0; i<defaultArr.length/2; i++) { Tweener.addTween(defaultArr[defaultArr.length/2+i], {_x:defaultArr[i], _y:0, time:1, transition:"easelnOutCubic"}); } //↓★追加(する？) cnt = -1; myID = setInterval(autoRollOver, time); }; } //======================================= ＃１の [お礼(補足)] のスクリプトで 何の説明もなく datArr[0] = [0, 800, 850, … datArr[1] = [0, 50, 850, … datArr[2] = [0, 50, 100, … などというようなことを書かれても 「具体的状況が不明」である上 「それで良いのか」の判断もできないため元に戻しました。 (私は超能力者ではないので，見もしない状況などわかりません。) それと最後の， //↓★追加(する？) cnt = -1; の部分は 全パネルからロールアウト後しばらくして自動開閉を再開する際に 『「panel01_mc」から開くのが良いのかどうかを自己判断してください。』 という意味です。
画像が透過しているかどうかでクリックイベントの出方は変わりません。 マウスの位置を見て処理を分けるなり、画像を分割しておくなりする必要があります。
基本的には，「降参！」です～。 つまり「完全なループなし」の検索方法は考え付けませんでした。 しかし， 検索(走査)用データの下準備にループを使用するだけで 検索(走査)自体にはループを使用しない方法であれば考え付きました。 一応，その半分降参状態の方法例を書きます↓。 //----------------------------------------- //配列「_array」を作成 var _array:Array = new Array(); //変数「img」に適当なダミー値を入れておく var img = "dummy"; _array.push({ data:img,_speed:0}); _array.push({ data:img,_speed:31}); _array.push({ data:img,_speed:62}); _array.push({ data:img,_speed:93}); _array.push({ data:img,_speed:124}); _array.push({ data:img,_speed:155}); _array.push({ data:img,_speed:186}); _array.push({ data:img,_speed:217}); _array.push({ data:img,_speed:248}); _array.push({ data:img,_speed:279}); _array.push({ data:img,_speed:309}); _array.push({ data:img,_speed:338}); _array.push({ data:img,_speed:367}); //走査用のキー「_scan」を下準備 (※ココにループ！) for (var i:int = 0; i < _array.length; i++) { _array[i]._scan = Math.abs(_array[i]._speed - 150); } //「_scan」をキーにして数値順でソート _array.sortOn("_scan", Array.NUMERIC); //１つ目の「_speed」キーの値を出力窓に出力 trace(_array[0]._speed);//→「155」 //----------------------------------------- 検索(走査)自体にループ文は使用していないでしょう？ (もっとも，ActionScript コンパイル後のマシン語に近い言語では，sortOn 内部でループを実行させているのかもしれませんが。) このあと， _array.sortOn("_speed", Array.NUMERIC); を実行すれば 配列の中身は元通りの順に戻ります。
こんにちは Ajaxの流行で、業務用のFlashウィジェットは最近あまり見なくなったのですが、しっかり生き残ってるものもありますねｗｗｗ 仰っている動作状況だと、環境がいまひとつわからないのですが、一般的な「Flash on ブラウザ」環境ですと、２つの条件があります。 ■Flashを表示しているHTML側の設定 開かれるFlashが大きく画面をはみ出してしまう場合は、収めているHTML側のボックスで（だいたい<object>を内包している<div>）に style="height:600px;overflow:scroll" などをつけてブラウザのスクロールバーを出せばOKです。 ■表示されているFlash自身の設定 Flash側の画面サイズ（Flashでいうステージサイズ）がそもそも大きすぎる場合は、Flash側でステージを狭めスクロールバーを出す必要があります。 > Flashのデザインを開設したサイトを見ますと とありますが、これはおそらく、Flash Professional を使って開発する場合の話だとも思うのですが、Scroll Pane Componentというものを使うと思います。ただ、ビジネス用ですと、開発はおそらくFlash Builderなので、UI定義部分でScrollPaneでラップすることになり、処理的にはそんなに難しいものではありません。 いずれの場合にも、昨今Flashで作られたアプリはエンジニアも限られ、担当者の退社やツールの開発が止まってしまったこともあり、開発側はあまり手をかけたくないのが本心ではないでしょうか。 お見受けしたところ、どうもHTML側の改修で済みそうな感じがするのですが。。
timer.start();の後ではなく、 マウスイベントなどの中に timer.stop(); timer.start() タイマーイベントを書いている場合は timer.stop(); timer.removeEventListener("timer",タイマーイベント名); timer.addEventListener("timer",タイマーイベント名); timer.start(); と書けば良いと思います。
一般的には、 1) 40個の値を昇順/降順どちらでも並べ替え 2) 端から値を２つずつ比較 3) 値が異なってれば値の種類の数を＋１ とか。 3, 7, 15, 4, 8, 7, 12, 1, 10, 8, 9, 7 だと分かりにくいけど、 1, 3, 4, 7, 7, 7, 8, 8, 9, 10, 12, 15 なら数えやすいみたいな。 -- > 実際はテキストボックスが40個ほどあり でも、入る数字が00～99の２桁なら、 1) 0～99までループ 2) 対象の数字と40個の数字と一致するものがあれば種類の数を＋１ とかでもループ回数はたかが知れてるのでＯＫだと思いますし。
Adobe Flash Playerは極端に言うと「再生するための設定」なので、インストールしたからと言ってそこらにあるFLVやSWFは再生はできないのです。 SWF対応のソフトでは、簡単で確実そうなのはGOM PLAYERだと思います。 http://www.gomplayer.jp/
スクリプトとしてはとりあえず 次のような感じ↓で良いのではないでしょうか。 //==================================== var myWall:Wall = new Wall(); myWall.x = 275; myWall.y = 200; addChild(myWall); var myBox:Array = new Array(10); for (var i:int=0; i<10; i++) { myBox[i] = new Box(); myBox[i].x = Math.random() * 550; myBox[i].y = Math.random() * 400; addChild(myBox[i]); //------↓以降を追加変更↓------ //(各Boxマウスオーバーでハンドカーソルにする(要る？)) myBox[i].buttonMode = true; //各Boxクリック時に関数 removeBox を実行 myBox[i].addEventListener(MouseEvent.CLICK,removeBox); } //関数 removeBox の定義 function removeBox(e:MouseEvent):void { //クリックされたターゲットをこの階層の表示リストから削除 removeChild(DisplayObject(e.currentTarget)); } //==================================== 上記スクリプトの最後の部分↓ですが //クリックされたターゲットをこの階層の表示リストから削除 removeChild(DisplayObject(e.currentTarget)); 以下ではこの行についてのみの説明を書きます。 この最後の行は 次↓のように変更してもかまいません。 removeChild(Box(e.currentTarget)); または Box クラスが MovieClip クラスを継承している場合は 次↓のように変更してもかまいません。 removeChild(MovieClip(e.currentTarget)); もし removeChild(e.currentTarget); のように 引数を「e.currentTarget」だけにした場合， その「e.currentTarget」は 単なる「Object」クラスのインスタンスとして認識されてしまうため removeChild(=表示リストから削除する) という命令を使うことができなくなります。 (「Object」クラスのインスタンスには，例えば「配列」や「関数」や「音」など "表示されないオブジェクト" も含まれるため「表示リストから削除する」という命令が通用しない。) したがって少なくとも クリックされたターゲットを "表示オブジェクト(DisplayObject)" として認識させる必要があります。 そのために DisplayObject(e.currentTarget) のように書いて イベントターゲットを「DisplayObject」に変換しているわけです。 MovieClipクラスも，Boxクラスも， 少なくとも DisplayObjectクラス は継承しているはずですから， Box(e.currentTarget) や MovieClip(e.currentTarget) などにしてもかまわないということになります。 もし Box クラスが MovieClip クラスを継承していれば クラスの継承関係は次のようになります。 Object > EventDispatcher > DisplayObject > InteractiveObject > DisplayObjectContainer > Sprite > MovieClip > Box これらクラスのうち DisplayObject 以下のクラスとして認識させれば removeChild できるという意味です。 認識させるクラスは作者の都合で適当に決めれば良いです。 ちなみに， Array(配列) クラスであれば継承関係は次のようになります。 Object > Array Function(関数/メソッド) クラスであれば継承関係は次のようになります。 Object > Function Sound(音) クラスであれば継承関係は次のようになります。 Object > EventDispatcher > Sound これら３つはどれも DisplayObject を継承していませんよね？ したがって これらはどれも元から表示リストに加える(addChild する)ことができないので 表示リストから削除する(removeChild する)こともできないわけです。 (他にも DisplayObject でないオブジェクトはたくさん存在します。) または， 別の書き方として次のように変更しても良いでしょう。 removeChild(e.currentTarget as DisplayObject); removeChild(e.currentTarget as Box); removeChild(e.currentTarget as MovieClip); この「as」は ActionScript の略(=AS)ではなく， 英語の前置詞である「as (…として)」が語源でしょうね。 【英文例】I looked up to him as an engineer. 【和訳文】私は技術者として彼を尊敬している。 【Script】removeChild(e.currentTarget as DisplayObject); 【和訳文】表示オブジェクトとしてのイベントターゲットを表示リストから削除
そうですね。 ＃１の方も書かれていますが 絵やアニメーションにもよりますけど Flash のみでも結構(かなり)な絵は描けますよ。 Flash は ドロー系(ベクター系/ベクトル系) ソフトですから Adobe Illustrator で描けるような絵はたいてい描けると思って良いです。 つまり「カッチリ」系の画はかなり描けるソフトだと思います。 と言うか Flash は元々 Smart Sketch (スマートスケッチ) というドロー系お絵かきソフトが前身です。 (Google検索例 http://www.google.co.jp/search?hl=ja&source=hp&q=%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B9%E3%82%B1%E3%83%83%E3%83%81 ) ですから， Illustrator では描きにくい「フワッ」としていたり味わいのある水彩画風な画や Illustrator が苦手とする写真加工などは Flash も同じく苦手とする分野です。 (つまり Adobe Photoshop で描くようなペイント系(ビットマップ系)の画や写真加工にはあまり向いていません。) ↓まずは Flash でのお絵描きの基本から 「ひっぱってつまんでほいほいほい♪」 http://f-site.org/articles/2002/01/01000000.html ※「この記事の詳細を読む」をクリック 「アクアなボタンを作ってみよう！」 http://f-site.org/articles/2002/04/01000000.html ※「この記事の詳細を読む」をクリック ↓Flash のみで描かれた画です(FLAのDL可能) 「Vectorkid.com - Tutorials - illustrating, flash, vector, art, tutorials, drawing, effects, 3d」 http://www.vectorkid.com/tutorials.html ※ PAGE 2 へも続きます ↓次に Flash でのアニメーション作成技法 「タップ割り」 http://f-site.org/articles/2003/09/22190604.html ※「ムービーを見る」をクリック 「ブレ」 http://f-site.org/articles/2003/10/12003250.html ※「ムービーを見る」をクリック 「フォロー」 http://f-site.org/articles/2005/10/13012123.html ※「ムービーを見る」をクリック 「ケシコミ」 http://f-site.org/articles/2005/12/05231617.html ※「ムービーを見る」をクリック 「歩き」 http://f-site.org/articles/2006/05/12160729.html ※「ムービーを見る」をクリック 「走り」 http://f-site.org/articles/2007/02/28170546.html ※「ムービーを見る」をクリック ↓Flash で作成されたTVアニメーションなどの例 「rumparo-tita web」 http://rumparo-tita.jp/ 「ズモモとヌペペ - Wikipedia」 http://ja.wikipedia.org/wiki/%E3%82%BA%E3%83%A2%E3%83%A2%E3%81%A8%E3%83%8C%E3%83%9A%E3%83%9A 「鷹の爪団のFlashアニメーション講座 デジハリ・オンラインスクール」 http://online.dhw.co.jp/feature/tume/ 「ブラック・ジャック ＜Flashアニメ＞」 http://www.b-ch.com/ttl/index.php?ttl_c=1533 などなど。 ↓最後に手前味噌ですが 　私が Flash のみで描いたみた 　いかにも Flash 的だと思う画例です。 　(私はココでは ActionScript 系の回答ばかりしてますが 　実は Flash などでの作画系の方が本職に近いです。)
表示したい文字列を変数に格納しておいて クリックするごとに、文字数をふやしていくのはどうでしょうか。 var word:String="Hello World"; var word_cnt:int=0; function mc(event:MouseEvent):void{ word_cnt += 1; text1.text = word.substr(0,word_cnt); }
> URLVariables　や　URLRequest　や　URLLoader　あたりが未対応なのでしょうか？ AIR for AndroidでURLLoader等を使っているサンプルもあるので、 未対応ということはなさそうです。 が、私はAIRには詳しくないので、 　http://livedocs.adobe.com/flex/3_jp/langref/flash/net/URLLoader.html この辺を参考に、 ・ioErrorイベントでエラーの有無を調べる ・httpResponseStatusイベントで通信の状態を調べる ・サーバ側のログをチェック などといった方法で調査してみてください。
譜面は1つしかありませんが、こんな感じですかね。 1フレーム目に下記のコードをコピペすれば動くと思います。 Eキーをタイミングよく押すとあたり判定が走ります。 内容はソースを読めば、すぐにわかると思います。 import flash.events.Event; import flash.display.Sprite; import flash.display.Graphics; import flash.display.MovieClip; import flash.display.DisplayObjectContainer; import flash.events.KeyboardEvent; import flash.ui.Keyboard; import flash.display.StageAlign; import flash.display.StageScaleMode; stage.align = StageAlign.TOP_LEFT; stage.scaleMode = StageScaleMode.NO_SCALE; graphics.lineStyle(1, 0xffffff, 0.6); graphics.moveTo(0, stage.stageHeight * 0.5); graphics.lineTo(stage.stageWidth, stage.stageHeight*0.5); var markList:Array = []; const speedX:Number = -5; var interval:int = 50; var count:Number = 0; var hitMC:MovieClip = createHitArea(); addChild(hitMC); function _onKeyDown(e:KeyboardEvent):void { if (e.keyCode == Keyboard.E) { hitMcScale(); checkHitMark(); } } function checkHitMark():void { for (var i:int = 0; i < markList.length; i++) { if (hitMC.hitTestObject(markList[i])) { markList[i].hit(); break; } } } function hitMcScale(s:Number = 1.4):void { hitMC.scaleX = hitMC.scaleY = s; } function createHitArea():MovieClip { var mc:MovieClip = new MovieClip(); var g:Graphics = mc.graphics; g.beginFill(0x00ffaa); g.drawCircle(0, 0, 40); g.endFill(); mc.x = 50; mc.y = stage.stageHeight*0.5; return mc; } function update():void { count ++; if (count%interval == 0) { var mark:MovieClip = createMark(); mark.position(stage.stageWidth, stage.stageHeight*0.5) .appendTo(this); markList.push(mark); } for (var i:int = 0; i < markList.length; i++) { if (markList[i].isKilled) { markList.splice(markList.indexOf(markList[i]), 1); continue; } markList[i].update(); } if (hitMC.scaleX > 1) { hitMC.scaleX -= 0.05; hitMC.scaleY -= 0.05; } else { hitMC.scaleX = hitMC.scaleY = 1; } } function createMark():MovieClip { var sp:MovieClip = new MovieClip; var _speedX:Number = speedX; var _speedY:Number = 0; var g:Graphics = sp.graphics; g.beginFill(0xffffff*Math.random()); g.drawCircle(0, 0, 30); g.endFill(); sp.cacheAsBitmap = true; sp.update = function():void { this.x += _speedX; this.y += _speedY; if (this.x < -this.width - 30 || this.y > stage.stageHeight+100 || this.y < -100) { this.kill(); } }; sp.position = function (x:int, y:int):MovieClip { sp.x = x; sp.y = y; return this; } sp.appendTo = function (d:DisplayObjectContainer):MovieClip { d.addChild(sp); return this; } sp.kill = function ():void { sp.isKilled = true; sp.parent.removeChild(this); } sp.hit = function():void { _speedX = 20; _speedY = Math.random()*30-15; } return sp; } stage.addEventListener(KeyboardEvent.KEY_DOWN, _onKeyDown); addEventListener(Event.ENTER_FRAME, function(e:Event):void{ update(); });
このような「配列の配列」はジャグ配列と呼ばれます。 2次元配列とは違い、配列の各要素が別個の配列になっているので、 行ごとに列数を変えることができるのが大きな特徴です。 test[0] □□□ test[1] □□□□□□ test[2] □□□□ test[3] □□□□□
＝＝＝【本題の回答の前に】＝＝＝＝＝＝＝＝＝＝＝＝ ２つ目の for文 の一部分に間違いがありますね。 for(var i:int; i<player01Card.length ;i++) { 　↓iの初期値が抜けてます↓ for (var i:int = 0; i<player01Card.length; i++) { と言うか... 本来 var i は最初の for文 の方などですべきです。 最初の for文↓ for(i=0;i<60;i++){ 　↓変更↓ for (var i:int=0; i<60; i++) { ２つ目の for文↓ for(var i:int; i<player01Card.length ;i++) 　↓変更↓ for (i = 0; i<player01Card.length; i++) { 　 . 　 ＝＝＝【本題の回答】＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ > 何が問題なのか、 これについては， ２つ目の for文 の後辺りに trace(i); と書いてムービープレビューしてみると その問題の原因がわかると思います。 for文 を抜けた後 変数 i に代入された値は player01Card.length (=60) になって止まっているため どのボタンをクリックしても player01Card[60].gotoAndStop(36); が動作します。 その player01Card[60] は存在しないはずなのでエラーが出るのです。 この件に関しては 書かれていらっしゃる http://oshiete.goo.ne.jp/qa/4646183.html で 超スローモーション的な動作説明を入れて詳細に書いています。 　 > ＞evnet.target.gotoAndStop(36);としてしまうと > カードの合成前の絵柄やテキストがgotoAndStopされてしまう こちらに関しては， まず第一に書かれていらっしゃる日本語の意味が良くわかりません。 「カードの合成前の絵柄やテキストがgotoAndStopされてしまう」とは？？？ さらに， 私の方で実際に作って検証してみましたが 無事にクリックした Card 内が フレーム36 で停止しましたよ。 ひょっとして Card のムービークリップは さらにその中に 子ムービークリップ が入っていて その 子ムービークリップ 内にも複数フレームがあって その中でも絵柄が変わるとか？？？ とにかく何だか良くわかりませんが， これに関しては target ではなくcurrentTarget を使えば解決するかもしれません。 evnet.target.gotoAndStop(36); 　↓変更↓ event.currentTarget.gotoAndStop(36); 　 . 　 　 ＝＝＝【オマケの回答】＝＝＝＝＝＝＝＝＝＝＝＝＝＝ target や currentTarget を使わずに Card クリック時に クロージャ(関数の一種) を実行させる方法もあることはあります。 ◎クロージャを使う方法例↓ //------------------------------------- var player01Card:Array = new Array(); //60枚のカードを生成 for (var i:int=0; i<60; i++) { player01Card[i] = new Card(); addChild(player01Card[i]); //(↓※私の個人的な動作検証用の行) //player01Card[i].x = i * 8; } for (i = 0; i<player01Card.length; i++) { //player01Card[i] クリック時に関数 onCardClick の戻り値を実行 player01Card[i].addEventListener(MouseEvent.CLICK,onCardClick(player01Card[i])); } //クロージャ を返す関数 onCardClick の定義 function onCardClick(obj:Card):Function{ //戻り値として クロージャ を返す return function():void{ obj.gotoAndStop(36); } } //------------------------------------- ※クロージャ は ActionScript 専用用語ではなく .　多くの言語で使われる一般的プログラム用語です。 　 　 その他， 私が「ただ考えてみた」というだけのことで 全くお薦めできない方法ですが 次のようにしても target や currentTarget を使わなくてもできることはできます。 (カードどうしが重なることがある上で，さらにカードの上下関係が変わる場合などは，このままでは使えません。) ◎カードの親クリックでマウスとヒットしたカードに命令する方法↓ //------------------------------------- var player01Card:Array = new Array(); //60枚のカードを生成 for (var i:int=0; i<60; i++) { player01Card[i] = new Card(); addChild(player01Card[i]); //(↓※私の個人的な動作検証用の行) //player01Card[i].x = i * 8; } //この階層に対してクリック時の関数を定義 this.addEventListener(MouseEvent.CLICK, function(event:Event){ //配列要素の最後から最初に向けてループ for(i = player01Card.length-1; i >= 0; i--){ //配列要素にマウスがヒットしていれば if(player01Card[i].hitTestPoint(player01Card[i].parent.mouseX,player01Card[i].parent.mouseY,true)){ //対象カード内をフレーム36に進める player01Card[i].gotoAndStop(36); //この for文 を抜ける break; } } } ); //------------------------------------- 　
質問内容が欲張り過ぎでしょう。 まるで業者に対する客の仕様発注書です。 質問に全て回答するなら本ができてしまいますよ。 (内容がそれだけ難しいという意味ではなく，「論理」や「手順」を説明するには相当な字数や画像が必要という意味。) 字数制限も厳しく画像が１枚しか貼れないココでは説明不可能です。 特に， >・上段の画像にマウスオーバーすると青い枠線が表示される。 それくらいのこと モーショントゥイーンとかシェイプトゥイーンとか使って自力で作成すべきでしょう。 とにかく字数制限もあるため 上記以外の項目についてスクリプトのみ(日本語説明抜き)で回答します。 CS5 で新規ドキュメントを作成し フレーム1にコピペするスクリプト例です↓。 //--------------------------- [SWF(frameRate = "20",width = "940",height = "380")] var col_arr:Array = [0xFF6666,0x66FF66,0x6666FF,0xCCCC00,0xCC66CC,0x66CCCC]; var c_len:int = col_arr.length; var cnt:int = 0; var big_mc_arr:Array = new Array(); for (var i:int = 0; i<c_len; i++) { big_mc_arr[i] = new MovieClip(); with (big_mc_arr[i].graphics) { beginFill(col_arr[i]); drawRect(0,0,900,280); endFill(); } big_mc_arr[i].x = 20; big_mc_arr[i].y = 20; addChild(big_mc_arr[i]); } var slide_mc:MovieClip = new MovieClip(); slide_mc.x = 50; slide_mc.y = 310; addChild(slide_mc); var small_mc_arr:Array = new Array(); for (i= 0; i<c_len*2; i++) { small_mc_arr[i] = new MovieClip(); with (small_mc_arr[i].graphics) { beginFill(col_arr[(i>=c_len)? i-c_len:i]); drawRect(0,0,160,50); endFill(); } small_mc_arr[i].n = i; small_mc_arr[i].x = 170 * i; small_mc_arr[i].addEventListener(MouseEvent.CLICK,setCnt); slide_mc.addChild(small_mc_arr[i]); } var mask_mc:MovieClip = new MovieClip(); with (mask_mc.graphics) { beginFill(0x000000); drawRect(0,0,840,50); endFill(); } mask_mc.x = 50; mask_mc.y = 310; addChild(mask_mc); slide_mc.mask = mask_mc; var l_btn_shape:Shape = new Shape(); with (l_btn_shape.graphics) { beginFill(0x666666); drawRect(0,0,20,50); endFill(); beginFill(0xFFFFFF); moveTo(3,25); lineTo(15,18); lineTo(15,32); endFill(); } var l_btn:SimpleButton = new SimpleButton(); with (l_btn) { upState = overState = downState = hitTestState = l_btn_shape; x = 20; y = 310; } addChild(l_btn); var r_btn_shape:Shape = new Shape(); with (r_btn_shape.graphics) { beginFill(0x666666); drawRect(0,0,20,50); endFill(); beginFill(0xFFFFFF); moveTo(5,18); lineTo(17,25); lineTo(5,32); endFill(); } var r_btn:SimpleButton = new SimpleButton(); with (r_btn) { upState = overState = downState = hitTestState = r_btn_shape; x = 900; y = 310; } addChild(r_btn); slide_mc.addEventListener(Event.ENTER_FRAME,approacheSlide); function approacheSlide(e:Event):void { e.target.x += ((cnt*170+50)-e.target.x)/5; if (e.target.x>50) { e.target.x-=c_len*170; cnt-=c_len; } else if (e.target.x < 50-c_len*170) { e.target.x+=c_len*170; cnt+=c_len; } } l_btn.addEventListener(MouseEvent.CLICK,upCnt); function upCnt(e:Event):void { cnt+=1; setBigMC(); } r_btn.addEventListener(MouseEvent.CLICK,downCnt); function downCnt(e:Event):void { cnt-=1; setBigMC(); } function setCnt(e:Event):void { cnt=2-e.currentTarget.n; setBigMC(); } function setBigMC():void { addChild(big_mc_arr[(cnt <= 2-c_len)?2-cnt-c_len:2-cnt]); } setBigMC(); var tmr:Timer=new Timer(5000,0); tmr.addEventListener(TimerEvent.TIMER,downCnt); tmr.start(); this.addEventListener(MouseEvent.MOUSE_OVER,stopTimer); function stopTimer(e:MouseEvent):void { tmr.stop(); } this.addEventListener(MouseEvent.MOUSE_OUT,startTimer); function startTimer(e:MouseEvent):void { tmr.start(); } var point_sh:Shape = new Shape(); with (point_sh.graphics) { beginFill(0x666666); moveTo(0,0); lineTo(0,-3); lineTo(74,-3); lineTo(80,-8); lineTo(86,-3); lineTo(160,-3); lineTo(160,-0); endFill(); } point_sh.x=390; point_sh.y=309; addChild(point_sh); //--------------------------- 上記スクリプトを フレーム1 にコピペして そのままパブリッシュやムービープレビューなどすれば動作確認できると思います。 本来 Sprite で済む部分にも あえて MovieClip を使っているのは 「本来そのようなものはそういうムービークリップを手作業で作れば良い。」 という意味合い(思い)を含めています。
ご質問では， Flash 作成ソフト名や，そのバージョンも書かれていない上， もしスクリプトで雪を降らせたい場合 ActionScript のバージョンも書かれていませんが。 その他，状況の説明も全く無し。。。 これでは本来回答不可能ですよ。 無数にある場合に応じた無数の回答は書けませんので， 勝手に条件を限定させていただきます。 Adobe Flash CS3 以上をお使いの上で ActionScript 3.0 を使う場合で 雪の作成も雪の動きも全て ActionScript でしてしまう場合の タイムラインのフレームに書く(コピペする)超簡易的なスクリプト例です↓。 //==================================== //(ムービーの背景を黒にする) [SWF(backgroundColor = "#000000")] //雪の数を設定(※可変) var snow_num:int = 200; //雪の最高の大きさ(直径)を設定(※可変) var max_dmt:Number = 10; //雪が落下する最高速度を設定(※可変) var max_spd:Number = 8; //雪を登録する配列「snow_arr」を用意 var snow_arr:Array = new Array(); //雪を作成する関数「makeSnow」の定義 function makeSnow():void { //配列「snow_arr」の要素数を取得 var cnt:int = snow_arr.length; // //雪スプライトを作成 snow_arr[cnt] = new Sprite(); // //雪スプライト内に雪を描く snow_arr[cnt].graphics.beginFill(0xFFFFFF); snow_arr[cnt].graphics.drawCircle(0,0,max_dmt/2); snow_arr[cnt].graphics.endFill(); // //雪の座標を決定 snow_arr[cnt].x = Math.random() * stage.stageWidth; snow_arr[cnt].y = Math.random() * stage.stageHeight; // //雪の大きさや不透明度を決定 var size:Number = cnt / snow_num; snow_arr[cnt].scaleX = snow_arr[cnt].scaleY = size; snow_arr[cnt].alpha = size / 2 + 0.2; // //雪に雪を動かす動作を設定 snow_arr[cnt].addEventListener(Event.ENTER_FRAME,moveSnow); // //雪を配置 addChild(snow_arr[cnt]); } //雪を動かす関数の定義 function moveSnow(e:Event):void { //雪を下に動かす e.target.y += max_spd * e.target.scaleX; //もし雪がステージの下に隠れれば if (e.target.y > stage.stageHeight+max_dmt/2) { //雪をステージの上に移動 e.target.x = Math.random()*stage.stageWidth; e.target.y = -max_dmt/2; } } //設定した雪の数だけループ for (var i:int = 0; i <snow_num; i++) { //雪を作成する関数「makeSnow」を実行 makeSnow(); } //---↓雪を消す方法例(オマケ)↓--- //ステージ上をクリック時に関数「removeSnow」を実行 stage.addEventListener(MouseEvent.CLICK,removeSnow); //雪を消す関数「removeSnow」の定義 function removeSnow(e:MouseEvent):void{ //設定した雪の数だけループ for (var i:int = 0; i <snow_num; i++) { //雪から雪を動かす動作を削除(降雪を止める) snow_arr[i].removeEventListener(Event.ENTER_FRAME,moveSnow); //雪を消す removeChild(snow_arr[i]); } } //==================================== ↑このスクリプトを記述したタイムラインの ループ再生などによるスクリプトの重複実行などは全く考慮していません。 (色々な状況に応じたスクリプトなど回答不可。) ※もしメインタイムラインがループ再生するのであれば ステージの左上コーナーに空のムービークリップでも作成して そのムービークリップ内のタイムラインのフレーム1にでも 上のスクリプトを書けば良いかも。 別にスクリプトなど使用しなくても ちゃんと雪粒１つを手で描いて， その雪をムービークリップなどに変換して そのムービークリップをモーショントゥイーンやクラシックトゥイーンさせても 雪を降らせることは可能ですよ(手間かもしれませんが)。 また 使用されている Flash や ActionScript のバージョンなどが 私が上で書いた条件と違う場合や イメージされている降雪の感じとは違う場合は， ご使用されているバージョンなどをキーワードとして Google 検索しても 色々な方法やスクリプトが出て来ますよ↓。 Google検索例「ActionScript 2.0 雪 降る」 http://www.google.co.jp/search?q=ActionScript+2.0+%E9%9B%AA+%E9%99%8D%E3%82%8B&hl=ja ↑これはあくまでも 検索"例" です。 「降雪 ActionScript」とか 「Flash MX 雪 降らせる」とか 何かそのようなキーワードで検索しても それらしい説明サイトは出てくると思います。
flaファイル と言うものは Adobe または Macromedia の Flash というソフト (例：Flash，Flash 2，…，Flash 5，Flash MX，Flash MX 2004，Flash 8，Flash CS3，…，Flash CS6 など)で Flashコンテンツ 作成時に使われる Flash 専用の「作業状態を保存したファイル」ですよ。 ですから Adobe や Macromedia の Flash でなければ開けません。 (正確に言えば Windowsのメモ帳 でも バイナリエディタ でも開けますが，開けたとしても作業状態を目に見える形で再現することはできません。) さらに 基本的に新(上位)バージョンで作成された flaファイル は それより旧(下位)バージョンの Flash で開くことはできません。 その理由は明白で 新バージョンになれば， 必ず新機能や新パネルや新設定などが追加されたり 仕様変更がされているため 旧バージョンの Flash では 新バージョンでの作業状態を再現することができないからです。 ですから 新バージョン製の flaファイル を旧バージョンで開こうとすると クラッシュ回避をするなどのために安全プログラムが作動して 「予期しないファイル形式です」というようなメッセージが出て 開けないようになっています。 Google検索「Flash 予期しないファイル形式」 http://www.google.co.jp/search?q=Flash+%E4%BA%88%E6%9C%9F%E3%81%97%E3%81%AA%E3%81%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%BD%A2%E5%BC%8F&hl=ja もっとも Flash MX 以降は １世代前の Flash までなら開ける形で flaファイル を保存できるようになりましたけどね。 でもそれは そういう特殊な保存の仕方をしなければなりませんし そういう保存の仕方をすれば新機能の設定などは削除されてしまいます。 したがって， 基本的には 新バージョンで作成された flaファイル は それより 旧バージョン の Flash で開くことはできないと考えるのが妥当です。 　 　 > 無償のものでWin7で動作するものを教えてください Flash CC の体験版でしたら そのお友達が使用された Flash と同位または上位になるため その flaファイル を開くことができる可能性が高いです。 しかし 体験版は期間限定で無料で使えるだけのことで 決して無償ソフトではありません。 またひょっとしたら お友達が使用された Flash のバージョンが古すぎて開けない可能性もありますし 開けたとしても こんなこと↓になるかもしれません。 「Flash Professional ヘルプ Flash Professional CC で Flash Professional CS6 ファイルを開く」 http://helpx.adobe.com/jp/flash/using/opening-cs6-files-cc.html ～引用～ >1.インバースキネマティックは >　フレームアニメーションに変換される >2. TLF テキストは静的なクラシックテキストに変換される。 >　Flash Pro CC に読み込む場合、 >　PSD ファイルや AI ファイルに埋め込まれた TLF テキストも >　クラシックテキストに変換されます。 >3.ActionScript 1／ActionScript 2： >　a.パブリッシュ設定のデフォルトが >　　ActionScript 3 に設定されます >　b.ステージ上のすべてのインスタンスに付加されている >　　AS2 コードが削除されます >　　（インスタンス上のアクションは >　　AS3 ではサポートされていない） >　c.AS2 コンポーネントはプレースホルダーとして扱われますが、 >　　ステージ上の新しいコンテンツの作成には使用できません。 >　　また、AS2 コンポーネントによって >　　AS3 でコンパイルエラーが発生します。 簡単に言えば たとえ Adobe や Macromedia の Flash を使うとしても 作成された flaファイル は その flaファイル を作成したバージョン以外ではまともに開けないのが当たり前。 と考えた方が良いということです。 ※ 補足 fla ではなく swfファイル の方でしたら そのファイルを逆コンパイル(デコンパイル)して 編集状態を独自の編集インターフェイスに持ち込んで表示させたり 再編集できたりするソフトがあるにはあります。 しかし基本的には有償のものが多いと思います。 また どんな swfのファイル でも逆コンパイル可能かどうかは知りません。 (「frimo 3」とかいう名前のソフトでありましたが，興味がないので詳細は知りません。) その他 「Flash Decompiler」などと言うような言葉で検索すれば 何かそれらしいソフトが出てくるかもしれません。 (あまりゴソゴソ嗅ぎ回ったり，安易に変なソフトをインストールしたりすると，ウィルス感染など危険性を伴うため，最近私は全くその辺を調べていません。) swfファイルデコンパイラの一種である 「HugFlash」というソフトでしたら無償でおそらく安全です。 しかし ActionScript の解析をしたり(HugDimension機能)， swfファイル 内の画像や動画などを取り出せるだけのことで 独自の編集インターフェイスを持ちませんから 作成作業状態そのものを見たり編集することはできません。 何にしても結局 fla や swf の作成作業状態そのものを見たり編集するのであれば 当たり前ですが Adobe や Macromedia Flash と同等かそれ以上の 編集作業用インターフェイス(GUI)を備えたソフトが要るということです。 仮にそんなソフトが作れたとしても， 特許やライセンス問題も絡むため， 他者がそんなソフトを堂々と無償公開したり販売することは不可能ではないでしょうか？ Adobe にしてもそんなソフトを作成販売したいがために Macromedia を会社ごと買収したのですから。
> BitmapDataの操作で、透明度を下げて次々と加算していき… その通りです！ bitmapData.draw() は、第3引数に colorTransform を取ります。 colorTransform を使えば、RGBA(赤・緑・青・透)を変更しつつ、bitmapData に転写することができます。 例えば、bitmapData に video のキャプチャを、透明度15分の1で転写するなら… - - - - - bitmapData.draw(video, null, new ColorTransform(1, 1, 1, 1 / 15)); - - - - - とすればオッケーです。 （ColorTransform の引数についての詳細については、興味がありましたら調べてみてください。） これを75回繰り返せば、75枚の画像を1枚の画像に重ね合わせられます。 ここでは video を転写するときに透明度を15分の1にしましたが、 全ての video のキャプチャを普通に bitmapData に転写してから、最後に透明度を15分の1にして統合しても、もちろん構わないです。
＃１です。 実際に作ってみましたが， ＃１の[補足]に書かれていらっしゃるような不具合現象は起きませんでしたけどね。。。 ちなにみ私は メインのタイムライン(_root)の フレーム1 に ご質問本題のフレームのスクリプトを書いて メインのタイムラインの フレーム2 に stop(); と書いています。 ↑「絶対にこうすべき」という意味ではなくて， 動作検証のために作成しているファイルにおいて， 「私はそうしている」と言うだけの意味です。 というわけで， メインのタイムライン(_root階層)の様子は 下の 【添付図】↓ のようになっています。 ＃１より修正したスクリプトは２箇所(２行)で 変更点は次の通りです。 ◎メインのタイムラインの フレーム1 のスクリプト変更点 //変数 i に 1～2を入れながらループ for (var i:Number = 1; i<=2; i++) { 　　↓変更↓ //変数 i に 1～10 を入れながらループ for (var i:Number = 1; i<=10; i++) { ◎リセットボタンのスクリプト変更点 //変数 i に 1～2を入れながらループ for (i=1; i<=2; i++) { 　　↓変更↓ //変数 i に 1～10 を入れながらループ for (i=1; i<=10; i++) { 動作検証に使用した Flash のバージョン は Flash 8 と Flash CS 4 と Flash CS 5.5 です。 (OS は Windows Vista と XP です。) SWFのパブリッシュ設定は ActionScript 2.0 です。 そして Flash Player 6 設定でも Flash Player 10 設定でも(正確には Flash Player 10 & 10.1 でも) 不具合なく動作しました。 というわけで，一応の報告まで。
ご質問内容の状況は複雑過ぎて， ActionScript のみで済む問題ではありませんね...。 話に関係するのは少なくとも３サイトで その各サイトに少なくとも１つずつのHTML(またはPHPなど)のページがあるのですよね？ 例えば サイトA，サイトB，サイトC という３つのサイトがあって サイトA には「a.html」があり サイトB には「b.html」があり サイトC には「c.html」がある。 そして流れは次のようにするということですよね？ ・サイトA の「a.html」 　→ パラメータ付きで サイトB の b.html を開く ・サイトB の「b.html」 　→ Flash(仮称「b.swf」)が貼ってあり a.html からのパラメータ を受け取る 　→ Flash(仮称「b.swf」)のボタンクリックでパラメータ付きで サイトC の「c.html」を開く ・サイトC の「c.html」 　→「b.html」の Flash からパラメータ を受け取る これを簡単に実現するには まず サイトA の「a.html」から GET(クエリ文字列付き) で サイトB の「b.html」にアクセスし サイトB の「b.html」の JavaScript で クエリ文字列 を取得して FlashVars で「b.swf」内にその値を送り込み 「b.swf」のボタンクリックによって サイトC の「c.html」に GET(クエリ文字列付き) または POST で値を送信する。 というような流れになると思います。 　 　 話の便宜上 サイトA，サイトB，サイトC では実験や説明がしにくいので 「a.html」と「b.html(b.swf付き)」と「b.swf」と「c.html」は 仮に同じフォルダにあるものとします。 その場合の 「a.html」と「b.html」と「b.swf」と「c.html」に書くコード例です。 ◎「a.html」のコード例↓ <html> <head> <title>a</title> </head> <body> <p>a.html</p> <form method="get" action="b.html"> <input type="radio" name="a" value="1" checked />a=1 <input type="radio" name="a" value="2" />a=2 <input type="radio" name="a" value="3" />a=3 <input type="submit" value="GO!" />　 </form> </body> </html> ◎「b.html」のコード例↓ <html> <head> <title>b</title> <script type="text/javascript"><!-- function showFlash(){ var query = window.location.search.substring(1); var tag = "<object classid='clsid:d27cdb6e-ae6d-11cf-96b8-444553540000' width='400' height='300' align='middle'>"; tag += "<param name='movie' value='b.swf' />"; tag += "<param name='FlashVars' value='" + query + "' />"; tag += "<embed src='b.swf' FlashVars='" + query + "' width='400' height='300' align='middle' type='application/x-shockwave-flash' />"; tag += "</object>"; document.getElementById("my_flash").innerHTML = tag; } // --></script> </head> <body onload="showFlash()"> <p>b.html</p> <div id="my_flash"></div> </body> </html> ◎「b.swf」を作成する 　「b.pfl」(新規プロジェクト 幅:400px，高さ:300px)の 　メインのイベントリストのフレーム1に書くスクリプト例↓ this.createTextField("btn_txt",0,20,10,0,0); btn_txt.autoSize = "left"; btn_txt.border = true; btn_txt.text = "　ココをクリック！　"; btn_txt.onSetFocus = function(){ getURL("c.html" + "?a=" + a); }; ※「b.html」が勝手に書き替わらないように 「b.pfl」の「ファイル」→「詳細設定」より 　□SWF生成時にHTMLも保存する 　のチェックを外しておいた方が無難 ◎「c.html」のコード例↓ <html> <head> <title>c</title> <script type="text/javascript"><!-- function showQuery(){ alert("My guery is \"" + window.location.search.substring(1) + "\"."); } // --></script> </head> <body onload="showQuery()"> <p>c.html</p> </body> </html> もちろんこれは超簡易例に過ぎません。 このようなものを発展させて行けば良いと思います。 ○参考URL Google検索例「FlashVars」 http://www.google.co.jp/search?hl=ja&source=hp&q=FlashVars Google検索例「window.location.search.substring」 http://www.google.co.jp/search?q=window.location.search.substring&hl=ja
＃１です。 ＃１で書いたスクリプトにミス(ご質問との不一致)がありました。 遅ればせながら訂正します。 ご質問の元のイベントハンドラは on(press){～～} ですから 「ボタンを押した時」であって 「ボタンをクリックした時」ではありませんでしたね。 したがって＃１で書いたスクリプトの１行目 btn1.addEventListener(MouseEvent.CLICK,changeClipVisible); の MouseEvent.CLICK を MouseEvent.MOUSE_DOWN にする必要がありました。 その部分を訂正した後の スクリプト例全文です↓。 //------------------------------------------ //「btn1」を押した時に 関数 changeClipVisible を実行 btn1.addEventListener(MouseEvent.MOUSE_DOWN,changeClipVisible); //関数 changeClipVisible の定義 function changeClipVisible(e:MouseEvent):void { //ボタンが押される度にtrue／falseを切り替える clip1.visible = !clip1.visible; } //------------------------------------------
Parafla。
２万円では、企業に発注するには難しいみたいですよ。 プログラマの手取りが、日給１万円くらいで、企業に発注する場合は一日３万くらいが相場みたいです。 また、制作に１日でも、仕様書なんかを書くのに１日つくので、最低でも６万～１０万くらいは、覚悟しておいたほうがいいみたいです。 なので、個人がお願いするには、少しムリがあるかと。 まぁ、１人の人が一日で作って、給料が発生し、経費や会社運営で消えていくので仕方がないんだとは思いますが。 それでもとおっしゃるのなら、似たようなフリーソフトを作っている人を探して、有料で改造をお願いしてみるのはいかがですかね？ 大概のフリーソフトのReadMeには、何らかの連絡方法が書いてあります。 古いソフトだとアドレス変えている可能性も高いですが、企業に発注するよりかは、安く作ってくれるかと。 フリーソフトを作る人の中には、元々プログラマだった人もいますし、きちんと作る人も多いです。 http://www.vector.co.jp/ 強いて言えば、カテゴリーがFlashなのは気になりますが。 Flashアプリって、通常のアプリの中には入れないような？入れてもいいような？（苦笑
> Actionscript2.0のもの？なのか > 入れ込んでもエラーが出てしまいます > http://okwave.jp/qa/q1838609.html そのページのスクリプトは ActionScript 2.0 と言より ActionScript 1.0 の範囲内のスクリプトです。 まあどちらにしても ActionScript 3.0 では通用しないので その "スクリプト自体" は使えません。 (考え方は使えますよ。) それと， 「ご質問の図の説明」と 「 http://glamorous.co.jp/top/ の動き」とは 違っている部分があったり(例:フッターはブラウザにフィットしてないなど) また， ご質問の図中の水色の「オブジェクト 伸縮なし」は いったいどこを基準にしてどのように配置させるのかなど不明な点があります。 それら不明な点などは こちらで勝手に決めさせていただくものとして以下を続けます。 Flash CS6 で AS 3.0 設定の「新規ドキュメント」を作成し メインタイムラインの フレーム1 にコピペするスクリプト例です↓。 　 //＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ //ステージなどを適当に設定 [SWF(backgroundColor = "#000000",frameRate = "20")] //ステージ内の整列を左上を基準にして拡大縮小なし stage.align = StageAlign.TOP_LEFT; stage.scaleMode = StageScaleMode.NO_SCALE; //---↓以下は本当は手動で作成↓--- //基準点を左上にした写真入りMC「pic_mc」を作成 var pic_mc:MovieClip = new MovieClip(); with (pic_mc.graphics) { beginFill(0xFFFF99); drawRect(0, 0, 800, 600); endFill(); } pic_mc.y = 40; addChild(pic_mc); //基準点を左下にしたMC「obj_mc」を作成 var obj_mc:MovieClip = new MovieClip(); with (obj_mc.graphics) { beginFill(0x00FFFF); drawRect(0, -150, 200, 150); endFill(); } obj_mc.x = 10; obj_mc.y = stage.stageHeight - 50; addChild(obj_mc); //基準点を左上にした左ヘッダーMC「header_l_mc」を作成 var header_l_mc:MovieClip = new MovieClip(); with (header_l_mc.graphics) { beginFill(0xFF9966); drawRect(0, 0, 5000, 40); endFill(); } addChild(header_l_mc); //基準点を右上にした右ヘッダーMC「header_r_mc」を作成 var header_r_mc:MovieClip = new MovieClip(); with (header_r_mc.graphics) { beginFill(0xFF6633); drawRect(-200, 0, 200, 40); endFill(); } header_r_mc.x = stage.stageWidth; addChild(header_r_mc); //基準点を左下にした左フッターMC「footer_l_mc」を作成 var footer_l_mc:MovieClip = new MovieClip(); with (footer_l_mc.graphics) { beginFill(0xFFCCEE); drawRect(0, -20, 5000, 20); endFill(); } footer_l_mc.y = stage.stageHeight; addChild(footer_l_mc); //基準点を右下にした左フッターMC「footer_r_mc」を作成 var footer_r_mc:MovieClip = new MovieClip(); with (footer_r_mc.graphics) { beginFill(0xFF99CC); drawRect(-200, -20, 200, 20); endFill(); } footer_r_mc.x = stage.stageWidth; footer_r_mc.y = stage.stageHeight; addChild(footer_r_mc); //---↑以下は本当は手動で作成↑--- //初期「pic_mc」の幅と高さを記録 var pic_w:Number = pic_mc.width; var pic_h:Number = pic_mc.height; //ステージサイズの変更時に 関数 changeLayout を実行 stage.addEventListener(Event.RESIZE,changeLayout); //関数 changeLayout の定義 function changeLayout(e:Event):void { //ステージのサイズを取得 var s_w:Number = stage.stageWidth; var s_h:Number = stage.stageHeight; // //ステージの幅が 500px 以上であれば if (s_w >= 500) { //右ヘッダー「header_r_mc」を移動 header_r_mc.x = s_w; } // //ステージの高さが 400px 以上であれば if (s_h >= 400) { //MC「obj_mc」を移動 obj_mc.y = s_h - 50; } // //ステージの高さ 400px 以上であれば if (s_h >= 400) { //左フッターMC「footer_l_mc」を移動 footer_l_mc.y = s_h; //右フッターMC「footer_r_mc」を移動 footer_r_mc.y = s_h; } //ステージの幅が 500px 以上であれば if (s_w >= 500) { //右フッターMC「footer_r_mc」を移動 footer_r_mc.x = s_w; } // //写真入りMC「pic_mc」を拡大縮小 pic_mc.width = s_w; pic_mc.height = s_w*(pic_h/pic_w); } //関数 changeLayout を即実行 changeLayout(null); //＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 　 ↑各MC(ムービークリップ)の作り方(基準点の場所など)の説明などを 込み込みで書いた内容のスクリプトです。 上記のようにして作成＆パブリッシュした SWF(Flashムービー) を 例えば header 内で <style type="text/css"> body {margin: 0;} </style> のように設定したHTML に 幅100％ 高さ100％ で貼り付ければ良いでしょう。 (SWF の貼り付け方は Flash の領域ではなく，HTML や CSS や，場合によっては JavaScript の領域です。) 動き(レイアウト状態)が， 思い描いていらっしゃるものと違う部分もあると思いますが MCの作り方や動きの考え方は全て書いたつもりですから レイアウト調節などはスクリプトの内容を理解して 少しずつ考えながら思い描いていらっしゃるものに近づけて行ってください。
ご質問で書かれていらっしゃるように 「フレーム移動を使う」＆ 「極力現在のスクリプトやそれを書く場所を変えない」 という条件でしたら， リセットボタンに書かれたスクリプトのみを 単純に次のように修正すれば良いと思います。 //------------------ on (release) { //変数 i に 1～2 を入れながらループ for (i=1; i<=2; i++) { //「R_mc○」を削除 this["R_mc"+i].removeMovieClip(); } gotoAndStop(1); gotoAndStop(2); } //------------------ レイヤーに配置した MC を swapDepths() すると レイヤーとの結びつきが消えて宙に浮きます。 フレーム移動をさせて またその MC が出没したフレームに戻すと レイヤーに結びついた MC が再び現れて 宙に浮いた MC と共存してしまいます。 それらの MC を共存させたくない場合は 宙に浮いた MC を消してやれば良いでしょう。 その MC を消すメソッドが removeMovieClip() です。 なお removeMovieClip() では レイヤーに結びついた MC つまり 手動で配置した MC は消えません。 removeMovieClip() では ActionScript で生成や配置した MC や swapDepths() で宙に浮いた MC のみを消すことができます。 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ しかし... そもそもフレーム移動などが要る状況なのでしょうか？ もし，フレーム移動させる必要がないのであれば 私でしたらメインのタイムラインをフレーム1のみにして さらにリセットボタン自体に書いたスクリプトは全て消して そしてそのボタンには例えば「reset_btn」というインスタンス名を付けて フレームに書くスクリプトを次のようにしますけどね↓。 //--------------------------- //深度カウント用変数を用意 var dep_cnt:Number = 1; //変数 i に 1～2 を入れながらループ for (var i:Number = 1; i<=2; i++) { //★「R_mc○」内の再生を停止 this["R_mc"+i].stop(); //★「R_mc○」内の変数 target_mc に「W_mc○」の参照を代入 this["R_mc"+i].target_mc = this["W_mc"+i]; //◆「R_mc○」内の変数 start_x に「R_mc○」自身の初期x座標を代入 this["R_mc"+i].start_x = this["R_mc"+i]._x; //◆「R_mc○」内の変数 start_y に「R_mc○」自身の初期y座標を代入 this["R_mc"+i].start_y = this["R_mc"+i]._y; //「R_mc○」押下時に関数 dragMC を実行 this["R_mc"+i].onPress = dragMC; //「R_mc○」を放した時に関数 dropMC を実行 this["R_mc"+i].onRelease = dropMC; //「R_mc○」をMC外で放した時にも関数 dropMC を実行 this["R_mc"+i].onReleaseOutside = dropMC; } //関数 dragMC の定義 function dragMC():Void { //深度カウント用変数をカウントアップ dep_cnt++; //押下されたMCをその深度に移動 this.swapDepths(dep_cnt); //押下されたMCのドラッグを開始 this.startDrag(); //★マウスが動く度に関数 watchHitW_mc を実行 this.onMouseMove = watchHitW_mc; } //関数 dropMC の定義 function dropMC():Void { //放されたMCのドラッグを終了 this.stopDrag(); //★マウスが動く度に関数 watchHitW_mc を実行するのを解除 delete this.onMouseMove; } //★関数 watchHitW_mc の定義 function watchHitW_mc():Void { //★ドラッグ中のMCがそのMC内の変数 target_mc に //　代入したMCとヒットしていれば if (this.hitTest(this.target_mc)) { //★ドラッグ中のMC内をフレーム2で停止 this.gotoAndStop(2); } else { //★それ以外はドラッグ中のMC内をフレーム1で停止 this.gotoAndStop(1); } } //◆「reset_btn」クリック時に実行するメソッドの定義 reset_btn.onRelease = function():Void { //◆変数 i に 1～2 を入れながらループ for (i=1; i<=2; i++) { //◆「R_mc○」内の再生をフレーム1で停止 this._parent["R_mc"+i].gotoAndStop(1); //◆「R_mc○」の x座標 を R_mc○.start_x に戻す this._parent["R_mc"+i]._x = this._parent["R_mc"+i].start_x; //◆「R_mc○」の y座標 を R_mc○.start_y に戻す this._parent["R_mc"+i]._y = this._parent["R_mc"+i].start_y; } }; //--------------------------- 注釈行に◆を入れたところが，付け足し部分です。 「R_mc○」の初期座標は この場合特に「R_mc○」自身内の変数に代入保存する必要はありません。 前回までのスクリプトで， 「R_mc○」内の変数に「W_mc○」の参照を保存したので それに合わせているだけです。 MC の外(メインのタイムラインなど)に勝手な変数でも作って その変数に初期座標を代入保存でも良いですし また， 座標保存用の配列でも作って その配列の要素に初期座標を代入保存しても良いです。 　 フレーム移動をさせない場合の作成状態の図↓
１つのインスタンスに対して 同じ種類のイベントハンドラメソッドを 重複していくつも定義することはできません。 もし重複定義した場合は 後から定義した方だけが残って 前に定義した方は消えます。 ご質問で書かれて書かれていらっしゃるスクリプトを 同じフレームに全てまとめて書かれたのであれば， うまく行かない原因はこの辺にあるのではないかと思います。 例えば A という MC があったとして 次のようなスクリプトを書くと A をクリックしても ２つ目に定義したメソッドしか実行されません。 A.onRelease = function() { trace("１つ目のイベントハンドラメソッド実行"); }; A.onRelease = function() { trace("２つ目のイベントハンドラメソッド実行"); }; これは 同じ変数に違う値を入れて行くのと同じことで 普通は１つの変数には違う値を重複して入れることはできないので 次のようなことをすると 変数a の値は結局 8 になりますよね？ a = 5; a = 3; a = 8; これと同じ現象が起こります。 ちなみに本題とは関係ありませんが ボタンやMCに直接書くイベントハンドラの方は重複定義できます。 例えばある MC があったとして その MC 自体に次のようなスクリプトを書くと ２つとも実行されます。 on (release) { trace("１つ目のイベントハンドラ実行"); } on (release) { trace("２つ目のイベントハンドラ実行"); } ================================== 話を本題に戻して対処法です。 考え方やスクリプトの書き方などは無数にありますが 次のように書くのも１つの方法でしょう。 //--------------------------- //深度カウント用変数を用意 var dep_cnt:Number = 1; //変数 i に 1～2 を入れながらループ for (var i:Number = 1; i<=2; i++) { //★「R_mc○」内の再生を停止 this["R_mc"+i].stop(); //★「R_mc○」内の変数 target_mc に「W_mc○」の参照を代入 this["R_mc"+i].target_mc = this["W_mc"+i]; //「R_mc○」押下時に関数 dragMC を実行 this["R_mc"+i].onPress = dragMC; //「R_mc○」を放した時に関数 dropMC を実行 this["R_mc"+i].onRelease = dropMC; //「R_mc○」をMC外で放した時にも関数 dropMC を実行 this["R_mc"+i].onReleaseOutside = dropMC; } //関数 dragMC の定義 function dragMC():Void { //深度カウント用変数をカウントアップ dep_cnt++; //押下されたMCをその深度に移動 this.swapDepths(dep_cnt); //押下されたMCのドラッグを開始 this.startDrag(); //★マウスが動く度に関数 watchHitW_mc を実行 this.onMouseMove = watchHitW_mc; } //関数 dropMC の定義 function dropMC():Void { //放されたMCのドラッグを終了 this.stopDrag(); //★マウスが動く度に関数 watchHitW_mc を実行するのを解除 delete this.onMouseMove; } //★関数 watchHitW_mc の定義 function watchHitW_mc():Void { //★ドラッグ中のMCがそのMC内の変数 target_mc に //　代入したMCとヒットしていれば if (this.hitTest(this.target_mc)) { //★ドラッグ中のMC内をフレーム2で停止 this.gotoAndStop(2); } else { //★それ以外はドラッグ中のMC内をフレーム1で停止 this.gotoAndStop(1); } } //--------------------------- 　 注釈行で★を付けたところが 主な変更部分です。 上記スクリプトのミソは //★「R_mc○」内の変数 target_mc に「W_mc○」の参照を代入 this["R_mc"+i].target_mc = this["W_mc"+i]; だと思います。 例えば「R_mc1」でしたらその「R_mc1」内に 「target_mc」という変数(プロパティとも言える)を用意して その変数にドラッグするターゲットとなる「W_mc1」の参照を代入しておくわけです。 for文 や i を使わず 単純に書けば次のようになります。 R_mc1.target_mc = W_mc1; そしてドラッグ中の「R_mc1」が それ自身の変数に格納した「W_mc1」とヒットしていれば ドラッグ中の「R_mc1」内をフレーム2に進めるているわけです。 ちなみに 文字列 や 数値 や ブール値 などを除いて ActionScript の代入とは基本的に参照代入です。 ActionScript 1.0 でも 2.0 でも 3.0 でも (ついでに JavaScript でも) その点は共通です。 R_mc1.target_mc = W_mc1; これで 「R_mc1」内の変数 target_mc に「W_mc1」への参照が格納されます。 決して 「R_mc1」内に target_mc という名で「W_mc1」自体が入り込むわけではありません。 　 ================================== あと，ちょっと気になったので確認まで。 "質問文" のMCのインスタンス名の後に付けてある 1 とか 2 とかの数字が 半角になってたり全角になってたりしていますが 実際の作成物では全角など使わずちゃんと半角を使ってますよね？
Flash CS 5.5 は良いとして 今回のご質問での ActionScript 2.0 とは微妙ですね。。。 普通は 「ActionScript 2.0 を使用→Flash Player 7 以上用 SWF をパブリッシュ」 というのが一般的なのですが ActionScript 2.0 は場合によって Flash Player 6 でも 動作するのです。 今回質問されているものの場合 ちょうどその境界部分の辺に関係する箇所があって Flash Player 6 用と Flash Player 7 以上用 SWF とでは 違って来る部分が出て来るので どう回答すべきか悩むところです。 (具体的には getNextHighestDepth が使えるか使えないかという違いがあります。) しかしまあ， 字数もそんなに多くはならないと思うので Flash Player 6 用 SWF をパブリッシュする場合と Flash Player 7 以上用 SWF をパブリッシュする場合との 両方のスクリプト例を回答することにします。 大雑把に言えば Flash Player 6 用でも Flash Player 7 以上用でも どちらにしても一般的によく使われている方法の内容は同じで マウスプレスした(またはマウスアップした) MC の深度を その MC が存在する階層での一番上の深度に swapDepths させれば良いわけです。 この説明では Flash Player 6 用でも 7 以上用でも どちらにしてもとりあえず ドラッグする４つのMCに全て違うインスタンス名を付けます。 どれがどれでも良いので ステージ上のドラッグする４つの MC を１つずつ選択して プロパティインスペクタより，例えば 「drag_mc0」「drag_mc1」「drag_mc2」「drag_mc3」 というインスタンス名を付けるとします。 その場合の Flash Player 6 用 SWF をパブリッシュする場合の ４つの MC が存在する タイムライン の "フレーム" に書くスクリプト例です。 (この例では "MC 自体" にはスクリプトは一切書きません。) 　 ◎ Flash Player 6 以上用 SWF のスクリプト //------------------------------------ //深度カウント用変数を用意 var dep_cnt:Number = 0; //変数 i に 0～3 を入れながらループ for (var i:Number = 0; i<=3; i++) { //「drag_mc○」押下時に関数 dragMC を実行 this["drag_mc"+i].onPress = dragMC; //「drag_mc○」を放した時に関数 dropMC を実行 this["drag_mc"+i].onRelease = dropMC; //「drag_mc○」をMC外で放した時にも関数 dropMC を実行 this["drag_mc"+i].onReleaseOutside = dropMC; } //関数 dragMC の定義 function dragMC():Void { //深度カウント用変数をカウントアップ dep_cnt++; //押下されたMCをその深度に移動 this.swapDepths(dep_cnt); //押下されたMCのドラッグを開始 this.startDrag(); } //関数 dropMC の定義 function dropMC():Void { //放されたMCのドラッグを終了 this.stopDrag(); } //------------------------------------ 　 ◎ Flash Player 7 以上用 SWF のスクリプト //------------------------------------ //変数 i に 0～3 を入れながらループ for (var i:Number = 0; i<=3; i++) { //「drag_mc○」押下時に関数 dragMC を実行 this["drag_mc"+i].onPress = dragMC; //「drag_mc○」を放した時に関数 dropMC を実行 this["drag_mc"+i].onRelease = dropMC; //「drag_mc○」をMC外で放した時にも関数 dropMC を実行 this["drag_mc"+i].onReleaseOutside = dropMC; } //関数 dragMC の定義 function dragMC():Void { //押下されたMCを最高深度に移動 this.swapDepths(getNextHighestDepth()); //押下されたMCのドラッグを開始 this.startDrag(); } //関数 dropMC の定義 function dropMC():Void { //放されたMCのドラッグを終了 this.stopDrag(); } //------------------------------------ 　 上のスクリプト例では２例とも MCを押した時点で(関数 dragMC 実行時に) そのMCの深度を最高深度に移動させていますが， MCを放した時点で(関数 dropMC 実行時に) そのMCの深度を最高深度に移動させても良いです。 ちなみに this["drag_mc"+i].onPress = dragMC; などで使った [ ] を「配列アクセス演算子」と言います。 (名称不明な [ ] では調べようにも検索しにくいですよね。) 「FN0507001-ドット演算子と配列アクセス演算子」 http://www.fumiononaka.com/TechNotes/Flash/FN0507001.html その他に関しての詳細などは 例えば「Flash イベントハンドラメソッド」とか 例えば「ActionScript swapDepths」とか そんな感じのキーワードでGoogleなどで検索してもらうと 色々な情報がわかると思います。
「MC(ムービークリップ)を使う」ということですから MC の特性を生かして 例えば MC内の フレーム1 と 2 との表示を切り替えることによって 色を変えるという方法をまず考え付くべきでしょうね。 (この方法を使えば，「塗りだけの色を変える」とか「形と色を変える」とかその他色々なことに対応できます。) しかし... 「使用されている Flash のバージョン」も 「使用している ActionScript のバージョン」も書かれていませんね。。。 これでは具体的なスクリプトなど回答できません。 回答できなければ困るので こちらで勝手な条件を想定させていただきます。 Flash CS3 以上をお持ちで ActionScript 3.0 を使って Flash Player 9 以上用の SWF をパブリッシュするものとします。 この条件であるものとして以下を続けます。 まず，「左の□の赤MC」内は 2フレーム にして フレーム1 と フレーム2 にキーフレームを作り フレーム1 には 赤□，フレーム2 には 黄□ の絵を用意します。 ※参考【添付図】↓ この作業が終わりましたら 「シーン 1」などメインのタイムラインの編集に戻ります。 そして ステージ上の「左の□の赤MC」を選択した状態で プロパティインスペクタ(プロパティパネル)より 例えば「L_mc」というインスタンス名を付けます。 また ステージ上の「右の□の白MC」を選択した状態で プロパティインスペクタ(プロパティパネル)より 例えば「R_mc」というインスタンス名を付けます。 その「L_mc」や「R_mc」が存在するタイムラインのフレーム (例：メインタイムラインのフレーム1)に書くスクリプト例です↓。 //--------------------------- //左の「L_mc」内の再生を停止 L_mc.stop(); //右の「R_mc」上でマウスダウン時に関数 onR_mcMouseDown を実行 R_mc.addEventListener(MouseEvent.MOUSE_DOWN,onR_mcMouseDown); //関数 onR_mcMouseDown の定義 function onR_mcMouseDown(e:MouseEvent):void { //「R_mc」のドラッグを開始 R_mc.startDrag(); //マウスアップ時に関数 onStageMouseUp を実行 stage.addEventListener(MouseEvent.MOUSE_UP,onStageMouseUp); //マウスが動く度に関数 watchHitLR を実行 addEventListener(MouseEvent.MOUSE_MOVE,watchHitLR); } //関数 onStageMouseUp の定義 function onStageMouseUp(e:MouseEvent):void { //「R_mc」のドラッグを終了 R_mc.stopDrag(); //マウスアップ時に関数 onStageMouseUp の実行するのを解除 stage.removeEventListener(MouseEvent.MOUSE_UP,onStageMouseUp); //マウスが動く度に関数 watchHitLR を実行するのを解除 removeEventListener(MouseEvent.MOUSE_MOVE,watchHitLR); } //関数 watchHitLR の定義 function watchHitLR(e:MouseEvent):void { //もし「R_mc」が「L_mc」にヒットしていれば if (R_mc.hitTestObject(L_mc)) { //「L_mc」内の再生を フレーム2 で停止 L_mc.gotoAndStop(2); } else { //ヒットしていなければ「L_mc」内の再生を フレーム1 で停止 L_mc.gotoAndStop(1); } } //--------------------------- 　 回答文字数制限にまだ少し余裕があるため 上と同様の構造を作った上での Flash MX 2004 以上をお持ちで ActionScript 2.0 を使って Flash Player 6 以上用の SWF をパブリッシュする場合の フレームに書くスクリプト例も書いておきます↓。 //--------------------------- //左の「L_mc」内の再生を停止 L_mc.stop(); //右の「R_mc」上でマウスダウン時に実行するメソッドを定義 R_mc.onPress = function():Void { //「R_mc」のドラッグを開始 R_mc.startDrag(); //マウスが動く度に関数 watchHitLR を実行 this.onMouseMove = watchHitLR; }; //右の「R_mc」上でマウスアップ時に実行するメソッドを定義 R_mc.onRelease = R_mc.onReleaseOutside = function():Void { //このMC(R_mc)のドラッグを終了 this.stopDrag(); //マウスが動く度に関数 watchHitLR を実行するのを解除 delete this.onMouseMove; } //関数 watchHitLR の定義 function watchHitLR():Void { //もし「R_mc」が「L_mc」にヒットしていれば if (R_mc.hitTest(L_mc)) { //「L_mc」内の再生を フレーム2 で停止 L_mc.gotoAndStop(2); } else { //ヒットしていなければ「L_mc」内の再生を フレーム1 で停止 L_mc.gotoAndStop(1); } } //--------------------------- ※ご質問には 　「(吸着した)とき」と書かれていますが 　「(接触した)とき」と解釈を変えています。 　 (両スクリプトとも，いわゆる吸着はさせていません。) 　 　
まずは テキストフィールドに改行入りの文字列を表示させると言うことでしょうから ファイルリストのテキストフィールドのプロパティで 「自動サイズ」にチェックを入れておくか または入れないのでしたら それ相応の「高さ」を設定する必要があります。 そしてスクリプトの方は次のようにすれば良いでしょう。 for(i=0; i<5; i++){ trace(i); text += i + "\n"; } text += i + "\n"; これの「+=」は「加算後代入演算子」です。 もし「加算後代入演算子」を使わずに 「代入演算子(=)」で済ませるのでしたら text = text + i + "\n"; となります。 "\n" は改行コードです。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ なお細かいことで ご質問の本題の内容とは直接関係はないことですが テキストフィールドインスタンスには「text」というプロパティがすでに存在していますから 変数名に「text」と付けるのはあまり良いことではありません。 (場合によっては誤作動を起こしたり，人間が混乱する可能性が出てきます。) (喩えるなら，家の猫に猫という名前を付ける感じで，どこかで間違いや混乱が生じる可能性があります。)
結論から書けば 単純に二次元目を配列定義していないからですね。 (一次元目の要素を配列定義していないからです。) 次のようにすれば良いでしょう。 var mc_array:Array = new Array(); //↓※ mc_array[3] を配列とする mc_array[3] = new Array(); mc_array[3][2]=new mark_mc(); addChild(mc_array[3][2]); mc_array[3][2].scaleX = 0.5; mc_array[3][2].scaleY = 0.5; mc_array[3][2].x = 300; mc_array[3][2].y = 200; 　↑または↓ var mc_array:Array = new Array(); mc_array[3]=[ , , new mark_mc()]; addChild(mc_array[3][2]); mc_array[3][2].scaleX = 0.5; mc_array[3][2].scaleY = 0.5; mc_array[3][2].x = 300; mc_array[3][2].y = 200; ２つ目の書き方のバリエーションは 場合に応じて無数にあります。 　 ===解説(無視しても良い雑談混じりの話)====== 驚かれることかもしれませんが そもそも ActionScript には (その他 JavaScript など ECMAScript や C++ や Java などにも) 正確(狭義)な意味での 二次元配列(多次元配列) など存在しないのです。 次元的に言えば一次元の配列までしか存在しません。 mc_array[3][2] みたいなのを 広義な意味合いで， 普通に 二次元配列(多次元配列) という言い方はしますし それで間違いではないです。 しかし厳密に言うなら それは 二段階配列(多段階配列/ジャグ配列) なのです。 ActionScript や Java などなどの配列には そもそも一次元配列しかありませんが 配列の要素としてさらに配列を入れることができるため (一次元配列はいくらでも入れ子にできるため)， その 多段階配列 をもって 多次元配列 として使っているだけです。 身近な逆例として MS Excel の VBA などには 多次元配列 が存在します。 (VBA には 多段階配列 も存在します。) 例えば Excel VBA で 配列名 = Cells(開始行,開始列).Resize(最終行,最終列).Value のようなコードを書けば 自動的に二次元配列ができます。 仮に SheetArray = Cells(1, 1).Resize(5, 5).Value のようなコードを書いたとするなら MsgBox SheetArr(3, 2) でも MsgBox Cells(3, 2).Value でも同じ「B3」セルの値が表示されます。 ※ SheetArr(3, 2) です SheetArr(3)(2) ではありません ※ SheetArr(3, 2)←多次元，SheetArr(3)(2)←多段階 一方 ActionScript では var mc_array:Array = new Array(); のようなコードを書いたとしても 一次元配列しかできないため いきなり mc_array[3][2] などとアクセスされても 「そんなもの未定義だよ！」 というエラーになってしまうのです。 もっとも ActionScript などの場合は new Array() などと一々書かなくても ○○ = [] で自動的に 配列○○ ができるため 二次元目(狭義での二段階目)に new Array() を書かない場合も出てきます。 ◎ 二次元目(二段階目)に new Array() を書かない一般例↓ 【例１】 var my_arr:Array = new Array(); my_arr.push(["00","01","02","03","04"]); my_arr.push(["10","11","12","13","14"]); my_arr.push(["20","21","22","23","24"]); my_arr.push(["30","31","32","33","34"]); trace(my_arr[3][2]); //→「32」が出力される 【例２】 var my_arr:Array = new Array(); for (var i:int = 0; i<=3; i++) { my_arr[i] = [i + "0", i + "1", i + "2", i + "3"]; } trace(my_arr[3][2]); //→「32」が出力される 【例３】(こんな書き方もできます) var my_arr:Array = [[],[],[],[]]; for (var i:int = 0; i<=my_arr.length-1; i++) { for (var j:int = 0; j<=3; j++) { my_arr[i][j] = String(i) + j; } } trace(my_arr[3][2]); //→「32」が出力される 上の【例１～３】は, どれも一見 my_arr[0] = new Array(); my_arr[1] = new Array(); my_arr[2] = new Array(); my_arr[3] = new Array(); と書いていないように見えますが 書いていないように見えるだけで 実は書いているのと同じことなのです。 細かいことを書きましたが ActionScript などで 二次元配列(多次元配列) という言葉を使うことは間違いではありません。 すごいプロの方でも普通に 二次元配列(多次元配列) という言葉を使用しています。 ですから言い方に気を付ける必要はありません。 ただ 多次元的(多段階的)な配列を作るのでしたら 配列の中に配列を定義(作成)しなければ 多次元的な配列はできないということです。 (理由：ActionScript には本当の意味での多次元配列は存在しないため一発では定義できないから) (var my_arr = new Array(2); ←これでは要素数2の配列ができるだけ)
書かれていらっしゃるスクリプトをなるべく変えない形で書くならは スクリプトは次のようになりますが。。。 for (var i:int = 1; i<=30; i++) { MovieClip(aaa.getChildByName("b" + i)).gotoAndStop(2); } しかし ActionScript 3.0 では インスタンス名を使ってインスタンスを名指ししないのが普通ですから 私なら通常は上のようには書きません。 つまり， > this["b"+i]のような便利な方法はありますか? と書かれていらっしゃいますが 通常はそのような書き方で書きます。 getChildByName などというものは普通使いません。 普通にそのようにしてできませんでしたか↓。 for (var i:int = 1; i<=30; i++) { aaa["b" + i].gotoAndStop(2); } または for (var i:int = 1; i<=30; i++) { this.aaa["b" + i].gotoAndStop(2); } このようにすれば動くはずですよ。 (上記２例も実際にしてみて正常に動いたスクリプトをコピペしています。) ※ gotoAndStop(２) の ２ が全角になっているから 　 エラーになって動作しなかっただけではないでしょうか？ 　 (ココに書かれいるスクリプトは全角の２になってます。) 　 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html ～～～ ページ下部付近より引用 ～～～ > 「オーサリング時に配置したMovieClipインスタンス」では、 > タイムラインに予め配置して > [プロパティ]インスペクタで設定したインスタンス名は、 > そのまま変数のように参照として扱うことができました。 > これは、ActionScript 3.0では、 > Flashがインスタンス名と同じ名前の変数を自動的に宣言して、 > そこにインスタンスの参照を格納する > 仕組みになっているからです。 > したがって、やはり変数によりインスタンスを参照するというのが、 > ActionScript 3.0の基本だといえます。 と言うか...， ActionScript 2.0 以下時代からみなさん aaa["b" + i].gotoAndStop(2); というような普通の書き方をされてましたよ。 なぜなら ActionScript 2.0 以下の場合は， インスタンス名で直接インスタンスにアクセスできていましたから そもそも getChildByName など不要でしたし。 とにかくいずれのバージョンにしても getChildByName などというものは よっぽど特殊な場合でない限り普通は使いません。 　
＃１です。 ＃１の【補足】を拝見させていただきましたところ なんとか全容が見えて来ました。 「スクリプトは フレーム2 に書かれていて，gotoAndPlay(2); はフレーム3に書いてある。」 ということで大筋は理解できました。 さらにまた， > この状態で、ご回答いただいたスクリプトの追加を両方試してみたのですが、 > // ボールが下に落ちたらゲームオーバー > if(ball._y>235){ > gotoAndStop(4); > } > このスクリプトがきかなくなるのか、 > ボールが下に落ちると5フレーム目のクリア画面に移動してしまいます。 この現象も確認できました。 こうなる原因ですが (あくまでも「原因」であって「悪いこと」でも「対処法」でもありません)， フレーム4 のゲームオーバー画面に， おそらくブロックが１個も置かれていないからです。 (「だから悪い」といっているわけではありません。あくまでも「原因」です。) フレーム2 でボールの位置が ball._y>235 の状態になれば(つまりボールが下に落ちれば) gotoAndStop(4); は実際に起こっているのですが， スクリプト自体は フレーム2 のその下に書かれてあることも引き続き責任を持って１回のみ実行されるのです。 (フレームの表示は フレーム4 になるのだけれど，フレーム2 のスクリプトは最後まで実行されるのです。) したがって フレーム4 に行ったときに 「ボールが１個もないぞ！」 ということになって，さらに gotoAndStop(5); も引き続き重なって実行されてしまうわけです。 したがって，見かけ上， > if(ball._y>235){ > gotoAndStop(4); > } このスクリプトが効かなくなるように見えるのです。 実際は効いているのだけど， すぐに次の命令が実行されるため，効いたように見えないだけです。 対処法は > if(ball._y>235){ > gotoAndStop(4); > } これを下に持って行けば良いでしょう。 フレーム2 のスクリプト全文例です↓。 //------------------------------------- // ボール移動 ball._x += vx; ball._y += vy; // 壁とボールの当たり判定 if (ball._x<5 && vx<0) { vx = -vx; } if (ball._x>235 && vx>0) { vx = -vx; } if (ball._y<5 && vy<0) { vy = -vy; } // パドルとの当たり判定 if (ball._x>pad._x-40-5 && ball._x<pad._x+40+5 && ball._y>pad._y-5-5 && ball._y<pad._y+5+5 && vy>0) { vy = -vy; vx = (ball._x-pad._x)/80*15; } // ブロックとの当たり判定 for (i=1; i<=40; i++) { bx = eval("block" add i)._x; by = eval("block" add i)._y; if (ball._x>bx-20-5 && ball._x<bx+20+5 && ball._y>by-5-5 && ball._y<by+5+5 && eval("block" add i)._visible == true) { eval("block" add i)._visible = false; // 左端or右端に当たった場合 if (ball._x<bx-20 || ball._x>bx+20) { vx = -vx; } else { // 上端or下端に当たった場合 vy = -vy; } } } // ---残っている(表示されている)ブロックの有無を取得--- // 変数 visible_block の初期化 visible_block = 0; //ブロックの個数分ループ for (i=1; i<=40; i++) { //もし block○ の _visible が true であれば if (eval("block" add i)._visible) { // 変数 visible_block の値を 1 にする visible_block = 1; //即この for 文を抜ける break; } } // もし変数 visible_block の値が 0 のままであれば if (visible_block == 0) { // フレーム5 へ行って停止 gotoAndStop(5); } // ボールが下に落ちたらゲームオーバー (★ココへ移動) if (ball._y>235) { gotoAndStop(4);//元々移動先が1フレーム目だったのを新たにつくった4フレーム目に変更しました。 } //-------------------------------------
単純に時計をスプライト内に作れば良いだけでしょう。 (＝スプライト内で完結する時計を作れば良いだけでしょう。) 別にそうしなくても良いですよ。 スライドショーをスプライト内に作っても良いですし スライドショーも時計も両方とも別のスプライト内に作っても良いです。 とにかく何にしても Flash とは「まず スプライト(ムービークリップ) ありき」なんです。 (メインのタイムライン自体も実は全体を包括する大きなスプライト(ムービークリップ)です。) Flash とはスプライト(ムービークリップ)をいくつも組み合わせて１つの作品を作って行くもの(作って行けるもの)なのです。 　 　 ＝＝＝例＝＝＝＝＝＝＝＝＝＝＝＝ 仮の条件として SWF6～8 のいずれかの Flash(SWFファイル) を書き出すものとします(SWF4 は無視)。 Suzuka の シンボルリスト のリスト欄を右クリックして 「アイテムを追加」→「スプライト追加」を選択します。 スプライト名は 「スプライト1」でも何でも適当で良いです。 サイズもどうでも良いですが 一応 幅[100]　高さ[20] に設定することにしておきますか。 シンボルリストで今作ったスプライトを選択し シンボルリストの左上の方にある「編集」ボタンをクリックします。 するとキャンバスの部分は スプライト内のタイムライン表示に切り替わります。 (スプライト内にもタイムラインは存在していてこの中にスライドショーでも何でも作れるのです。) (今回の説明では時計を作ることにします。) スプライト内のタイムライン部分を右クリックして 「アクションレイヤーを挿入」を選択します。 できたアクションレイヤーのフレーム1を選択して 画面右下の「スクリプトを編集」ボタンをクリックします。 するとスクリプトエディタが出てくると思うので そのスクリプトエディタのスクリプトを書く部分に次のように書きます。 //----------------------------------------- //テキストフィールド「time_txt」を作成 this.createTextField("time_txt", 0, 0, 0, 100, 20); //「time_txt」の枠線を表示 time_txt.border = true; //「time_txt」を背景アリにする time_txt.background = true; //毎フレーム実行するメソッドを定義 this.onEnterFrame = function() { // 現在の時刻オブジェクト now を作成 var now = new Date(); // 変数 h に時刻を取得 var h = now.getHours(); // 変数 m に分を取得 var m = now.getMinutes(); // 変数 s に秒を取得 var s = now.getSeconds(); // //２桁合わせ h = "0" + h; h = h.substr(-2, 2); m = "0" + m; m = m.substr(-2, 2); s = "0" + s; s = s.substr(-2, 2); // //「time_txt」に時刻を表示 time_txt.text = h + ":" + m + ":" + s; }; // 上のメソッドを即実行 this.onEnterFrame(); //----------------------------------------- これでスプライト内の編集は終わりですから 画面左上にある「スプライト1 (ID：1)」のように書かれてある部分をダブルクリックして メインのタイムラインの編集に戻ります。 そして シンボルリストで今作成したスプライトを右クリックし 「レイヤーに追加」を選択します。 これでメインのタイムラインに 時計のスプライトが配置されますから 後は「ウィンドウ」→「プレビュー」するとか または「ファイル」→「SWFファイル生成」するなどして動作確認をすれば良いです。 この時計はスプライト内で全てが完結していますから どのフレームに表示させても大丈夫です。 もちろん 上ではあくまでも仮の説明としてスクリプトで全てを作成しているだけで， 実際はスプライト内にテキストフィールドなどを好きなように手動配置しても良いです。 スプライトの中に別のスプライトを配置しても良いです。 (アナログ時計の針などはスプライトで作ると思いますし。) とにかく何重にでもタイムライン階層は作れます。
こういうこと↓でしょうか？ //------------------ var my_sound:My_Sound = new My_Sound(); var my_channel:SoundChannel; //500ミリ秒後に実行する Timer を作成 var my_timer:Timer = new Timer(500,1); //過去のマウス座標を記録する変数 var old_mouseX:Number; var old_mouseY:Number; //★再生箇所を記録する変数 var play_position:int; stage.addEventListener(MouseEvent.MOUSE_DOWN, MouseLDownFunc); function MouseLDownFunc(event:Event):void { //過去のマウス座標を記録 old_mouseX = stage.mouseX; old_mouseY = stage.mouseY; //★再生箇所を0に戻す play_position = 0; //関数 EnterFrameFunc を毎フレーム実行 addEventListener(Event.ENTER_FRAME,EnterFrameFunc); } //関数 EnterFrameFunc の定義 function EnterFrameFunc(e:Event):void { //マウスの座標が過去のマウス座標と違っていれば if (old_mouseX != stage.mouseX || old_mouseY != stage.mouseY) { //そして my_channel が null であれば if (my_channel == null) { //再生開始 (★過去の再生箇所から) my_channel = my_sound.play(play_position); my_channel.addEventListener(Event.SOUND_COMPLETE,my_chan_comp); } //マウスの座標が過去のマウス座標と同じであれば } else { //そして my_channel が null でなければ if (my_channel != null) { //★再生箇所を記録 play_position = my_channel.position; my_channel.stop(); my_channel.removeEventListener(Event.SOUND_COMPLETE,my_chan_comp); my_channel = null; } } //過去のマウス座標を記録 old_mouseX = stage.mouseX; old_mouseY = stage.mouseY; } function my_chan_comp(e:Event) { trace("再生終了"); my_channel = my_sound.play(); my_channel.addEventListener(Event.SOUND_COMPLETE,my_chan_comp); } stage.addEventListener(MouseEvent.MOUSE_UP, MouseLUpFunc); function MouseLUpFunc(event:Event):void { //my_channel が null でなければ if (my_channel != null) { my_channel.stop(); my_channel.removeEventListener(Event.SOUND_COMPLETE,my_chan_comp); my_channel = null; } //関数 EnterFrameFunc の毎フレーム実行を削除 removeEventListener(Event.ENTER_FRAME,EnterFrameFunc); } //------------------ ４箇所ある「★」を付けた部分は マウスが一度止まってから再び動きだしたときに 再生再開箇所を連続させるために勝手に入れてみたもので ご質問の本題とは全く関係のない箇所です。 上のままで行くとマウスの動きを少しでも止めるとすぐに音が鳴り止んでしまうと思います。 この感度はフレームレートに依存しますが結構敏感だと思います。 フレームレート変えずにもっと鈍感にしたい場合は Timer クラスを使うなどして マウスが動いたか動いていないかを判断する時間間隔を もっと大きくとるようにすれば良いと思います↓。 //------------------ var my_sound:My_Sound = new My_Sound(); var my_channel:SoundChannel; //過去のマウス座標を記録する変数 var old_mouseX:Number; var old_mouseY:Number; //★再生箇所を記録する変数 var play_position:int; //◆500ミリ秒毎に実行する Timer を作成 var my_timer:Timer = new Timer(500); //◆指定ミリ秒毎に関数 TimerFunc を実行する設定 my_timer.addEventListener(TimerEvent.TIMER,TimerFunc); //◆関数 TimerFunc の定義 function TimerFunc(e:TimerEvent):void { //マウスの座標が過去のマウス座標と違っていれば if (old_mouseX != stage.mouseX || old_mouseY != stage.mouseY) { //そして my_channel が null であれば if (my_channel == null) { //再生開始 (★過去の再生箇所から) my_channel = my_sound.play(play_position); my_channel.addEventListener(Event.SOUND_COMPLETE,my_chan_comp); } //マウスの座標が過去のマウス座標と同じであれば } else { //そして my_channel が null でなければ if (my_channel != null) { //★再生箇所を記録 play_position = my_channel.position; my_channel.stop(); my_channel.removeEventListener(Event.SOUND_COMPLETE,my_chan_comp); my_channel = null; } } //過去のマウス座標を記録 old_mouseX = stage.mouseX; old_mouseY = stage.mouseY; } stage.addEventListener(MouseEvent.MOUSE_DOWN, MouseLDownFunc); function MouseLDownFunc(event:Event):void { //過去のマウス座標を記録 old_mouseX = stage.mouseX; old_mouseY = stage.mouseY; //★再生箇所を0に戻す play_position = 0; //◆タイマースタート my_timer.start(); } function my_chan_comp(e:Event) { trace("再生終了"); my_channel = my_sound.play(); my_channel.addEventListener(Event.SOUND_COMPLETE,my_chan_comp); } stage.addEventListener(MouseEvent.MOUSE_UP, MouseLUpFunc); function MouseLUpFunc(event:Event):void { //my_channel が null でなければ if (my_channel != null) { my_channel.stop(); my_channel.removeEventListener(Event.SOUND_COMPLETE,my_chan_comp); my_channel = null; } //◆タイマーストップ my_timer.stop(); } //------------------ 「◆」を付けた部分が変更箇所です。
JavaScript で貼り付けることなどを考えると 場合の数が無数になってしまうので JavaScript のことは全く考えずに object タグ と embed タグについてのみ実験してみました。 実験に使った OS は Windows で Chrome の バージョンは 27.0.1453.94 m ， Flash Player のバージョンは 11.7.700.203 です。 実験に際しては 「aaa.swf」 横幅：100px　高さ：75px 「bbb.swf」 横幅：100px　高さ：75px 「ccc.swf」 横幅：100px　高さ：75px 「ddd.swf」 横幅：100px　高さ：75px という４つの Flash ムービーファイルを作成しました。 実験結果のみを先に書くと 「object embed 併用」の場合 どれか１個の Flash が出たり出なかったりで つまり書かれていらっしゃる現象が再現されました。 「object のみ」の場合は全部非表示になり 「embed のみ」の場合全部表示になりました。 実際に書いた具体的なHTMLコードは次のようなものです。 ◎「object embed 併用」 ================== <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="aaa" width=100 height=75> <param name=movie value="aaa.swf"> <embed src="aaa.swf" width=100 height=75 type="application/x-shockwave-flash"> </object> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="bbb" width=100 height=75> <param name=movie value="bbb.swf"> <embed src="bbb.swf" width=100 height=75 type="application/x-shockwave-flash"> </object> <br> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="ccc" width=100 height=75> <param name=movie value="ccc.swf"> <embed src="ccc.swf" width=100 height=75 type="application/x-shockwave-flash"> </object> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="ddd" width=100 height=75> <param name=movie value="ddd.swf"> <embed src="ddd.swf" width=100 height=75 type="application/x-shockwave-flash"> </object> ================== ◎「object のみ」 ================== <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="aaa" width=100 height=75> <param name=movie value="aaa.swf"> </object> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="bbb" width=100 height=75> <param name=movie value="bbb.swf"> </object> <br> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="ccc" width=100 height=75> <param name=movie value="ccc.swf"> </object> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="ddd" width=100 height=75> <param name=movie value="ddd.swf"> </object> ================== ◎「embed のみ」 ================== <embed src="aaa.swf" width=100 height=75 type="application/x-shockwave-flash"> <embed src="bbb.swf" width=100 height=75 type="application/x-shockwave-flash"> <br> <embed src="ccc.swf" width=100 height=75 type="application/x-shockwave-flash"> <embed src="ddd.swf" width=100 height=75 type="application/x-shockwave-flash"> ================== なお最後の「embed のみ」の場合， IE でも Firefox でも Chrome でも ４つの Flash 全てが表示されました。 Chrome で４つの Flash 表示された様子↓
http://webdrawer.net/other/nonverblaster.html http://www.basics09.de/nonverblaster-hover//index.html http://phpjavascriptroom.com/?t=strm&p=jplayer http://phpspot.org/blog/archives/2010/06/jqueryvideo_lig.html http://nkshopping.biz/index.php?%E3%83%87%E3%83%BC%E3%82%BF%E8%BB%A2%E9%80%81%E9%87%8F%E3%81%A8%E3%81%AF 動画は重いため　配信には転送量が問題になる これをまずクリアしなければ何もできない 普通なら　短時間の動画を数人のみに配信など限定的になるはず 現実的には　Youtubeなど動画投稿サイトの助けを借りるのが最善 クリアしたとして 埋め込みのプレーヤを選択することで　再生できる形式が変わる ユーザにアップする動画の形式を指定できるならflv 複数の形式に対応させるなら　サーバでエンコードが必要 配信の相手が誰かによる　ガラケ　スマホ　も対応するのか Winのみか　など必要なら処理の分岐が必要になる 個人的には　Youtubeを利用してAPIなどで利便性をはかる
ActionScript 3.0 設定の 新規ドキュメント を作成し， メインタイムライン の フレーム1 に書く(コピペする)スクリプト例です↓。 //======================================== //---ムービーの設定--- [SWF(backgroundColor="#FFFFFF",frameRate="20",width="400",height="300")] //---XMLのURLの設定--- var xml_url:URLRequest=new URLRequest("http://www3.nhk.or.jp/rss/news/cat5.xml"); //---テキストフィールドの用意--- //テキストフィールドの参照を入れる配列 var txt_arr:Array = new Array(); //各テキストフィールドの作成＆配置 for (var i:int = 0; i<=9; i++) { txt_arr[i] = new TextField(); txt_arr[i].width=380; txt_arr[i].height=25; txt_arr[i].x=10; txt_arr[i].y=40+25*i; txt_arr[i].border=true; txt_arr[i].background=true; txt_arr[i].backgroundColor=0xFFFFFF; txt_arr[i].selectable=false; addChild(txt_arr[i]); //マウスオーバー時に関数 overFunc を実行 txt_arr[i].addEventListener(MouseEvent.MOUSE_OVER,overFunc); //マウスアウト時に関数 outFunc を実行 txt_arr[i].addEventListener(MouseEvent.MOUSE_OUT,outFunc); } //関数 overFunc の定義 function overFunc(e:MouseEvent):void { e.currentTarget.backgroundColor=0xCCCCCC; } //関数 outFunc の定義 function outFunc(e:MouseEvent):void { e.currentTarget.backgroundColor=0xFFFFFF; } //---XMLのロード＆表示--- //XMLのローダーを作成 var xml_ld:URLLoader = new URLLoader(); //XMLオブジェクトの宣言 var xml_obj:XML; //開くページのURLを入れるDictionaryを用意 var page_dic = new Dictionary(); //XMLのロードを開始 xml_ld.load(xml_url); //XMLのロード完了時に関数 compFunc を実行 xml_ld.addEventListener(Event.COMPLETE, compFunc); //関数 compFunc の定義 function compFunc(e:Event):void { //XMLオブジェクトにXMLデータを代入 xml_obj=new XML(xml_ld.data); // for (i=0; i<=9; i++) { //各テキストフィールドにタイトルを表示 txt_arr[i].text=xml_obj.children()[0].child("item")[i].child("title")[0]; //Dictionaryの各テキストフィールドキーにURLRequestを代入 page_dic[txt_arr[i]]=new URLRequest(xml_obj.children()[0].child("item")[i].child("link")[0]); //各テキストフィールドクリック時に関数 openPage を実行 txt_arr[i].addEventListener(MouseEvent.CLICK,openPage); } } //関数 openPage の定義 function openPage(e:MouseEvent):void { navigateToURL(page_dic[e.currentTarget],"_blank"); } //======================================== 　 あとは パブリッシュやムービープレビューするなどして 動作確認をしてみてください。 ※ XMLのURLが途中省略されてもし見えない場合↓ エイチティーティーピー://www3.nhk.or.jp/rss/news/cat5.xml です。 ※ グローバルセキュリティ警告が出た場合 「グローバルセキュリティ設定パネル」で http://www.macromedia.com/support/documentation/jp/flashplayer/help/settings_manager04a.html 作成した SWF を含むフォルダなどのセキュリティを解除(登録)してください。
まずHTML5でもタイピングゲームが実現可能であるかという質問については「可能」。 HTML5で作るメリットはスマートフォン/タブレットなどの端末で動作する点。 逆にHTML5で作るデメリットは次のとおり。 ・今もなお32%という大きなシェアを誇る旧式IE (6～8)がHTML5に対応していない ※ http://news.mynavi.jp/news/2013/01/07/062/index.html 参照 ・動的型付け言語でレガシーなJavaScriptを使うためコンパイル時の型チェックを使うことができないためデバッグ工数が増加 ・Web標準と言われながらもブラウザ毎の挙動の差があるため、コンテンツ開発者がコードで吸収する必要がある ・Android標準ブラウザなどHTML5の挙動が不安定な端末が多い(Android OSというよりはメーカー毎のカスタマイズのため) ・マルチメディア(ビデオやオーディオ)においてブラウザ毎でサポートするコーデックやAPIが大きく異る (H.264, WebM, WebAudioあたり…) いずれもHTML5は開発者泣かせな現状かと。。 そもそもタイピングゲームであればキーボードを必要とするため、PCでの体験が想定されるのでFlashでも差し支えないはず。スマートフォンでタイピングゲームを提供するのであればHTML5での開発をしてもいいかもしれないが、そのようなケースは考えにくいと思う。 ちなみに… ・Flash Playerは11で開発は打ち切られていないし、まだまだ新機能の搭載が進んでいる ・HTML5 CanvasはFlashに比べてパフォーマンスが優れない (さらにHTML5 Canvasは再描画における消費電力が非常に高い) ・Flashの実行ファイルであるSWFファイルのフォーマットは仕様が公開されているのでブラックボックスではない ・Flash+ASの技術はHTML5+JSに比較的容易に転用が可能 (CreateJS+Haxeなどの技術を用いることで) ・Flashは表現系・ユーティリティなどのフレームワークが充実している 個人的には動作環境の選択をベースとして最適な技術を都度検討すればいいのではないかと考えている。 エンドユーザー的にそのコンテンツがHTML5であろうがFlashであろうが何で作られているかは気にしないと思うので。
ActionScript 3.0 設定の 新規ドキュメント を作成し， メインタイムライン の フレーム1 に書く(コピペする)スクリプト例です↓。 //======================================== //---ムービーの設定--- [SWF(backgroundColor="#FFCCCC",frameRate="20",width="240",height="320")] //---各テキストフィールドの作成＆設定＆配置--- //年テキストフィールド var nen_txt:TextField = new TextField(); nen_txt.autoSize=TextFieldAutoSize.LEFT; nen_txt.x=20; nen_txt.y=10; addChild(nen_txt); var nen_fmt:TextFormat = new TextFormat(); nen_fmt.font="_ゴシック"; nen_fmt.size=28; nen_fmt.bold=true; //月日テキストフィールド var gappi_txt:TextField = new TextField(); gappi_txt.autoSize=TextFieldAutoSize.LEFT; gappi_txt.x=5; gappi_txt.y=60; addChild(gappi_txt); var gappi_fmt:TextFormat = new TextFormat(); gappi_fmt.font="_ゴシック"; gappi_fmt.size=20; gappi_fmt.bold=true; //時刻テキストフィールド var jikoku_txt:TextField = new TextField(); jikoku_txt.autoSize=TextFieldAutoSize.LEFT; jikoku_txt.x=10; jikoku_txt.y=100; addChild(jikoku_txt); var jikoku_fmt:TextFormat = new TextFormat(); jikoku_fmt.font="_ゴシック"; jikoku_fmt.size=20; jikoku_fmt.bold=true; //---年月日時刻表示--- //毎フレーム 関数 showHour を実行 addEventListener(Event.ENTER_FRAME,showHour); //関数 showHour の定義 function showHour(e:Event):void { //Dateオブジェクトの作成 var date_obj:Date = new Date(); // //年の表示 nen_txt.text=date_obj.getFullYear()+"年"; nen_txt.setTextFormat(nen_fmt); // //月日の表示 var tuki_str:String = ("0" + (date_obj.getMonth() +1)).substr(-2,2); var hi_str:String = ("0" + date_obj.getDate()).substr(-2,2); gappi_txt.text=tuki_str+"月"+hi_str+"日"; gappi_txt.setTextFormat(gappi_fmt); // //時刻の表示 var ji_str:String = ("0" + date_obj.getHours()).substr(-2,2); var hun_str:String = ("0" + date_obj.getMinutes()).substr(-2,2); var byou_str:String = ("0" + date_obj.getSeconds()).substr(-2,2); jikoku_txt.text=ji_str+"："+hun_str+"："+byou_str; jikoku_txt.setTextFormat(jikoku_fmt); } //======================================== あとは パブリッシュやムービープレビューするなどして 動作確認をしてみてください。
AIRはデスクトップ・アプリケーションですので、 WEB上ではできないローカルファイルへのアクセスや ネットワーク、クリップボード、ファイルのドラッグ&ドロップなど ローカルPCのリソースを利用するアプリケーションの制作が可能です。 こちらが参考になるのではないでしょうか。 http://news.mynavi.jp/articles/2008/06/22/air/index.html また、AdobeのAIRギャラリーなるものがあり、 公開されているたくさんのAIRアプリを確認することもできるので、 ご参考になさって下さい http://adobe-ria.jp/air/
その Flash ムービーが メインのタイムラインを使ったタイムラインアニメーションであって そのメインのタイムラインの再生を１度だけで停止させる場合に限って， OBJECT タグを使って Flash を貼り付ける場合は <param name="loop" value="false" /> というタグを入れたり EMBED タグを使って Flash を貼り付ける場合は <embed src="テスト.swf" loop="false" ～略～ という属性を入れれば 再生は１度だけで停止します。 「object タグと embed タグについて 」 http://livedocs.adobe.com/flex/3_jp/html/help.html?content=wrapper_13.html 「Web Design Tips Flashで使える属性(パラメータ)」 http://webdesignerstips.blog73.fc2.com/blog-entry-7.html 　 ただし， JavaScript で Flash を貼り付けている場合は その JavaScript の仕様などによって書き方は変わるので知りません。 また， 最初にも書きましたが， これでループ再生が停止できるのは 「メインのタイムラインを使ったタイムラインアニメーションであって そのメインのタイムラインの再生を１度だけで停止させる場合」 に限ってです。 メインのタイムラインを使っていたとしても ActionScript で動かしているアニメーションは止められません。 メインのタイムラインを使わずに ムービークリップ内(ムービーの中のムービー)のアニメーションは止められません。 マウスやキーなどに反応して動作するボタンの反応なども止められません。
ParaFla を使用する上では 根本的な構造から変える必要があるので少々ややこしいですよ。 まず...， > 不透明度を０％にした画像をボタンにして > 家具の隙間や裏に貼り付けている と書かれていますが， ボタンは階層を持たない上に onClipEvent ハンドラの使用ができませんから ボタンにはインスタンス名を付けてそのボタンインスタンスに対して 「ハンドカーソルに変化させない」というプロパティを設定する必要があります。 しかし！ ParaFla ではなぜか ボタン にインスタンス名が付けられません(多分)。 したがってボタンに対してActionScriptで「ハンドカーソルに変化させない」というプロパティを設定することができません。 (Adobe Flash や Suzuka ではボタンにインスタンス名を付けることができます。) ですから ParaFla では まず画像をボタンにするのではなく ファイルリストに作成したスプライトの中に画像を入れて そのスプライトをイベントリストに追加してボタンとして使う必要があります。 スプライトは階層を持つ上に onClipEvent イベントハンドラが使えますし さらにインスタンス名も付けられますし さらにボタンと同じ on イベントハンドラも使えますから 結構たくさんの方法を使うことができます。 たくさんの方法を使うことができますが 元はボタンを使おうとされていたことからその延長路線で考えて スプライト自体に onClipEvent イベントハンドラ と on イベントハンドラ を書くのが 元をあまり変えない方法だと思います。 イベントリストにある画像を入れたスプライトのプロパティより そのスプライト自体に書くスクリプト例です↓。 //----------------------------- onClipEvent(load){ //このスプライト上でハンドカーソルに変化させない this.useHandCursor = false; } - on(release){ trace("実際にはココで何か実行させる"); } //----------------------------- ※参考【添付図】↓ なお スプライトは階層を持つため 上記スクリプト中の trace("実際にはココで何か実行させる"); の部分に this などを使った場合は そのスプライトを指しますからターゲットパスなどの変更は要注意です。
こんなところでしょうか。 「F-site ケシコミ」 http://f-site.org/articles/2005/12/05231617.html 　↓↓↓ ムービーを見る http://www.ae-suck.com/amazing/tech/keshikomi.html 「ささきち流 Suzuka ＆ ParaDraw 講座-コマ動画(パラパラ漫画-消し込み(ケシコミ))」 http://suzupara.iinaa.net/kiso025.html
おそらく new ColorTransform( ) の ( )内に入れる引数を 勝手に配列だと決めていらっしゃるところが間違いなんだと思います。 colorTransDic[this["my_btn" + i]] = new ColorTransform(colors[i - 1]); これだと 「new ColorTransform( ) の 第１引数に colors[i - 1] 全部を入れて 第２引数～第８引数には何も入れない。」 ということになってしまいます。 　↓↓↓ new ColorTransform(colors[i - 1], , , , , , , ) つまり new ColorTransform( ) の 「第１引数には想定外の変なものを入れて， 第２引数～第８引数引数はデフォルトのまま。」 ということになりますから， 実際に次のような値が入ります。 　↓↓↓ new ColorTransform(NaN, 1, 1, 1, 0, 0, 0, 0) 動作的には次のように動きます。 　↓↓↓ new ColorTransform(0, 1, 1, 1, 0, 0, 0, 0) したがってどのボタンをクリックしても myMovieClip は new ColorTransform(0, 1, 1, 1, 0, 0, 0, 0) の色(赤が飛んだ色)にしかならないのです。 　 　 　 というわけで対処法です。 ◎ 対処法１ ご質問のスクリプトの次の部分を colorTransDic[this["my_btn" + i]] = new ColorTransform(colors[i - 1]); 次のように変えるのも１つの方法だと思います。 colorTransDic[this["my_btn" + i]] = new ColorTransform(colors[i - 1][0],colors[i - 1][1],colors[i - 1][2],colors[i - 1][3],colors[i - 1][4],colors[i - 1][5],colors[i - 1][6],colors[i - 1][7]); (↑改行無しの長い１行です。) ◎ 対処法２ ご質問のスクリプトの次の部分を //------------------------- var colors:Array = [[1,1,1,1,255,255,255,0],[1,1,1,1,122,122,122,0],[1,1,1,1,0,0,0,0]]; for (var i:int = 1; i<=3; i++) { colorTransDic[this["my_btn" + i]] = new ColorTransform(colors[i - 1]); this["my_btn" + i].addEventListener ( MouseEvent.CLICK , onClick ); } //------------------------- 次のように変えるのも１つの方法でしょう。 //------------------------- var colors:Array = [new ColorTransform(1,1,1,1,255,255,255,0),new ColorTransform(1,1,1,1,122,122,122,0), new ColorTransform(1,1,1,1,0,0,0,0)]; for (var i:int = 1; i<=3; i++) { colorTransDic[this["my_btn" + i]] = colors[i - 1]; this["my_btn" + i].addEventListener ( MouseEvent.CLICK , onClick ); } //------------------------- ◎ 対処法３ またはご質問のスクリプト全体を 次のように変えるのも１つの方法でしょう。 //------------------------- import flash.geom.ColorTransform; import flash.geom.Transform; var trans:Transform = new Transform(myMovieClip); var colorDic:Dictionary = new Dictionary(); var colors:Array = [[1,1,1,1,255,255,255,0],[1,1,1,1,122,122,122,0],[1,1,1,1,0,0,0,0]]; //ColorTransformのプロパティ名を配列に登録 var colorProp:Array = ["redMultiplier","greenMultiplier","blueMultiplier","alphaMultiplier","redOffset","greenOffset","blueOffset","alphaOffset"]; for (var i:int = 1; i<=3; i++) { colorDic[this["my_btn" + i]] = colors[i - 1]; this["my_btn" + i].addEventListener ( MouseEvent.CLICK , onClick ); } function onClick ( event:MouseEvent ) { var colorTrans:ColorTransform = new ColorTransform(); for (var i:int = 0; i < colorProp.length; i++) { colorTrans[colorProp[i]] = colorDic[event.currentTarget][i]; } trans.colorTransform = colorTrans; } //------------------------- 　 ActionScript ではありませんが 関連している内容の質問だと思われるURLです。 「JavaScriptでインスタンスを生成するときに、引数を配列の内容にするにはどうした... - Yahoo!知恵袋」 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1064279940
ご質問で書かれていらっしゃるような状態を検知して イベントを発動するようなイベントリスナーは存在しませんよ。 したがって自分で状態を見張って動作を発生させるしくみを作る必要があります。 とりあえず Loader内 にロードされた 子SWF についてですが この 子SWF を 親SWF から見れば Loader の content プロパティになります。 Loader.content です。 ご質問の場合 yomu が Loader ですから つまり yomu.content で参照できるということになります。 しかし その yomu.content をそのまま参照すると DisplayObject として扱われてしまうため MovieClip に変換する必要があります。 MovieClip(yomu.content) この 子SWF である MovieClip(yomu.content) の再生フレームを取得して その再生フレームが最終フレームになれば 親SWF の再生を開始させれば良いということですよね。 ですからスクリプト(例)は次のようになります↓。 //------------------------------------ //このフレームで再生を停止 stop(); //※次の４行はご質問で書かれていらっしゃる内容 var riku:URLRequest = new URLRequest("logoAnime.swf"); var yomu:Loader = new Loader(); yomu.load(riku); openingMc.addChild(yomu); //関数 watchLogoFrame を毎フレーム実行 addEventListener(Event.ENTER_FRAME,watchLogoFrame); //関数 watchLogoFrame の定義 function watchLogoFrame(e:Event):void { //もしロードしたSWFが null ではなくて if (yomu.content != null) { //もし ロードしたSWF の再生フレームが最終フレームになれば if (MovieClip(yomu.content).currentFrame == MovieClip(yomu.content).totalFrames) { //関数 watchLogoFrame の毎フレーム実行をやめる removeEventListener(Event.ENTER_FRAME,watchLogoFrame); //フレーム2から再生開始 gotoAndPlay(2); } } } //------------------------------------ 上記スクリプトの //フレーム2から再生開始 gotoAndPlay(2); この部分は //フレーム2で再生停止 gotoAndStop(2); かもしれませんし //再生開始 play(); で良いかもしれません。 この辺は適当に変えてもらえば良いと思います。
考え方や使い勝手などによって簡素化する方向も変わりますから 下に書くことは１つ方法例です。 まずは簡素化と言うよりも 普通の単純な書き方に整理します↓。 //----------------------------------------- import flash.geom.ColorTransform; import flash.geom.Transform; var trans:Transform = new Transform(myMovieClip); my_btn01.addEventListener ( MouseEvent.CLICK , onClick01 ); function onClick01 ( event:MouseEvent ) { var colorTrans:ColorTransform = new ColorTransform(1,1,1,1,250,30,0,0); trans.colorTransform = colorTrans; } my_btn02.addEventListener ( MouseEvent.CLICK , onClick02 ); function onClick02 ( event:MouseEvent ) { var colorTrans:ColorTransform = new ColorTransform(1.15,1.05,0.85,1,244,60,-178,0); trans.colorTransform = colorTrans; } my_btn03.addEventListener ( MouseEvent.CLICK , onClick03 ); function onClick03 ( event:MouseEvent ) { var colorTrans:ColorTransform = new ColorTransform(1,2,1,1,0,0,0,0); trans.colorTransform = colorTrans; } //----------------------------------------- さらに Dictionary クラスを使って 各ボタン対応の ColorTransform を適用させる流れにします↓。 //----------------------------------------- import flash.geom.ColorTransform; import flash.geom.Transform; var trans:Transform = new Transform(myMovieClip); //Dictionaryインスタンス「colorTransDic」を作成 var colorTransDic:Dictionary = new Dictionary(); //「colorTransDic」の各ボタン要素に各ColorTransformを登録 colorTransDic[my_btn01] = new ColorTransform(1,1,1,1,250,30,0,0); colorTransDic[my_btn02] = new ColorTransform(1.15,1.05,0.85,1,244,60,-178,0); colorTransDic[my_btn03] = new ColorTransform(1,2,1,1,0,0,0,0); //「my_btn01」～「my_btn03」クリック時に関数「onClick」を実行 my_btn01.addEventListener ( MouseEvent.CLICK , onClick ); my_btn02.addEventListener ( MouseEvent.CLICK , onClick ); my_btn03.addEventListener ( MouseEvent.CLICK , onClick ); //関数「onClick」の定義 function onClick ( event:MouseEvent ) { //クリックされたボタン要素に対応するColorTransformを適用 trans.colorTransform = colorTransDic[event.currentTarget]; } //----------------------------------------- これが１つの方法例です。 もっとも //「my_btn01」～「my_btn03」クリック時に関数「onClick」を実行 の部分などは さらに for文 を使って一気に指定することもできますよね。 「ActionScript 3.0で始めるオブジェクト指向スクリプティング 第32回　Dictionaryクラスを使う」 http://gihyo.jp/dev/serial/01/as3/0032
同じ関数名の関数であれば 全シーン の 1フレーム目 に重複して書いても ムービー全体の 1フレーム目 に重複して書いても どっちにしても重複すると思います。 つまり 同じ階層に同じ関数名の関数を定義するのでしたら どのフレームに書いても重複するものは重複するのですから その点に関してだけ言えばどこに書くとかは全く関係ないでしょう。 もし，全シーンに使う関数が複数あって それら関数の内容が全く同じでしたら １つだけの関数で済むわけですから そもそも重複定義などする必要はなく メインタイムラインの最初のシーンの最初のフレームに１つ書いておけば良いだけではないでしょうか？ それで何か不都合が生じるのでしょうか？ 逆になぜ全シーンの1フレーム目に全く同じ関数を定義するのか，その意味がわかりません。 (そんな変なことを元からしなければ良いだけなのではないかという意味です。) また，全シーンに使う関数が複数あって それら関数の内容が違うのでしたら 当然名前は変えるべきですし。。。 とにかく なぜ全シーンの1フレーム目に同じ関数名の関数を定義しようとされているのかがわかりませんが もし何かのインスタンスに その関数を addEventListener することがあるのでしたら その addEventListener と関数自体は分けて考えた方が良いでしょう。 関数だけは先に定義しておいて インスタンスが登場したときに addEventListener するという意味です。 架空状況として... たとえば 「シーン 1」の フレーム1 からボタン「a_btn」が登場し 「シーン 2」の フレーム2 からボタン「a_btn」とボタン「b_btn」が登場するとします。 そして 各ボタンをクリックしたときに各ボタンのインスタンス名を出力する関数を用意するとします。 その場合 「シーン 1」の フレーム1 には //関数 test の定義 function test(e:MouseEvent):void{ //クリックした対象インスタンスのインスタンス名を出力 trace(e.currentTarget.name); } //「a_btn」のイベントリスナーとして関数 test を登録 a_btn.addEventListener(MouseEvent.CLICK,test); と書いて 「シーン 2」の フレーム1 には //「a_btn」のイベントリスナーとして関数 test を登録 a_btn.addEventListener(MouseEvent.CLICK,test); //「b_btn」のイベントリスナーとして関数 test を登録 b_btn.addEventListener(MouseEvent.CLICK,test); と書けば良いでしょう。 つまり関数の定義は１回で良いです。 具体的状況がわからないので， このくらいの漠然とした架空状況でのことしか書けませんが。。。
「photo1～photo5 がどの階層にあるのか」とか 「スクリプトはどこに書いたのか」とかがわかりませんが， もし photo1～photo5 が 仮に this 階層にあるとすれば， photo1.gotoAndStop(photo[0]); photo2.gotoAndStop(photo[1]); photo3.gotoAndStop(photo[2]); photo4.gotoAndStop(photo[3]); photo5.gotoAndStop(photo[4]); この部分は for(i=0; i<=4; i++){ this["photo" + (i+1)].gotoAndStop(photo[i]); } という感じに書き換えるとできると思いますよ。 または絶対パスで次のようにするとか。 for(i=0; i<=4; i++){ _root["photo" + (i+1)].gotoAndStop(photo[i]); } キーワード は「配列アクセス演算子」です。 ※ 配列 と 配列アクセス演算子 とは 　とりあえず全く別物と考えた方が良いです。 「FN0507001 - ドット演算子と配列アクセス演算子 - Flash テクニカルノート」 http://fumiononaka.com/TechNotes/Flash/FN0507001.html また， 次のページでダウンロード できるファイルは フリーソフト Suzuka 用なので そのサンプルファイルは使うことはできませんが やっている内容やスクリプト自体は同じようなことです↓。 「Suzuka 基礎・基本 for文 と 配列アクセス演算子」 http://suzupara.iinaa.net/kiso061.html
HTML に Flash(SWF) を貼り付ける場合 その Flash の表示サイズは HTML の指示によって決まりますよね。 Flash に限らず GIF や JPEG も全く同じくで HTML に GIF や JPEG を貼り付ける場合 その GIF や JPEG の表示サイズは HTML の指示によって決まります。 ご質問になっているページも そのことは同じくです。 つまり Flash の力で Flash の大きさを変えているのではなく HTML によるFlashの表示サイズ指示を変えているのです。 Flash は全く無関係となります。 HTML や JavaScript の知識があれば そのページのソース(HTMLソースコード)を見るとどうなっているのかわかりますよ。 ページの中の「+size」という部分は これは Flash ではなく HTML で用意されていますが， その部分をクリックすると JavaScript の「_ABSRules(1)」が実行されるようになっています。 つまり「+size」をクリックすると JavaScript で用意された関数 _ABSRules が，引数 1 で実行されるわけです。 その関数 _ABSRules も HTML ソースの中に書いてあって 下のような内容になっています↓。 function _ABSRules(d) { obj = document.getElementById("video"); if (d==0) { nw = 500; nh = 500; } else { nw = obj.width*1.1; nh = obj.height*1.1; } obj.width = nw; obj.height = nh; } 引数 0 でこの関数を実行した場合 この HTML 中の "video" の部分を 500×500 のサイズにして 引数 0 以外でこの関数を実行した場合 この HTML 中の "video" の部分を 1.1 倍のサイズにする というような内容が書いてあります。 これによって Flash を貼り付けた部分（"video" の部分）の大きさを変えているのです。 とにかく Flash の知識などあってもなくても同じです。 必要なのは HTML と JavaScript 知識です。
> gotoAndStop(10); > としてみたのですが、パブリッシュした > swf ファイルは真っ白のまま何も動いてくれません。 それは多分 SWF が 10 フレーム目までロードされるより前に gotoAndStop(10) のような無茶な動作をさせているため 再生ヘッドが変なところで止まってしまったためだと推測されます。 > gotoAndstop(10); > としてみたらstopせずにタイムラインを再生しているようで、 それは gotoAndstop の s が小文字になっているからです。 既存のスクリプトにそんな言葉は存在しません。 ActionScript 1.0 でも 2.0 でも 3.0 でも Flash Player 7 以上用の SWF をパブリッシュする場合 大文字小文字は区別されます。 Flash Player は SWF をロード再生するとき， SWF ファイルのロード完了は待たずに ロードされる端から再生される仕様になっているのです。 これをプログレッシブ再生と言いますが， 逆に言えばこの機能のお陰で「Now Loading...」のようなものも表示できるわけです。 (もしロードを完了してからしか再生しなければ「Now Loading...」も表示不可能となりますよね？) SWF がローカルPCにあるうちは まだロードは早い方ですが(それでもプログラムの実行速度よりはずっと遅い)， ネットにあるともっともっとロードは遅くなります。 ですから ご質問に書かれている方法で行くとすると 見ることのない SWF のデータのロードまでしてから ランダムなフレームにジャンプするという 無駄なロード待ち時間と無駄なメモリが必要になってくるわけです。 したがって 根本的に考え方を変えて 各ランダムに再生されるコンテンツムービーは 別々の SWF として作成し そのうちのいずれかのランダムな SWF を 別の SWF(親SWF) からロード表示させる方が良いと思いますし また一般的だと思います。 　 　 任意のフォルダに 「main.swf」とそれを貼り付ける「main.html」を用意し その同じフォルダに ランダムに選ばれるコンテンツムービー 「cont0.swf」「cont1.swf」「cont2.swf」「cont3.swf」「cont4.swf」 の５つのファイル(合計７つ)を用意したとします。 全ての SWF の縦横サイズやフレームレートは全て等しいものとします。 また全ての SWF は Flash Player 10 用の ActionScript 3.0 設定でパブリッシュするものとします。 その場合の 「main.swf」を作成する FLA(main.fla) の メインのタイムラインの フレーム1 に書くスクリプト例です↓。 //------------------------------------------ //変数 rnd にランダムな 0～4 の整数を取得 var rnd:int = Math.floor(Math.random() * 5); //ランダムな URLリクエスト インスタンス url を作成 var url:URLRequest = new URLRequest("cont" + rnd + ".swf"); //SWF のローダーを用意 var ldr:Loader = new Loader(); //SWF のローダーにランダムな SWF をロード ldr.load(url); //このタイムラインに SWF のローダーを配置 this.addChild(ldr); //------------------------------------------ こんな感じで スクリプト以外は空の「main.swf」をパブリッシュしてもらえば ランダムな SWF ローダーができます。 なお， URLリクエストインスタンスに指示するURLの文字列は SWF(上の場合は「main.swf」)を起点としたパスではなく そのSWFを貼り付ける HTML を起点としたパスになりますから SWF と HTML が別フォルダにあって 相対パスで指示するときは注意してください。 　 ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ または， JavaScript がもし御得意であれば 各コンテンツムービーSWFを 直接 HTML にランダムに貼り付けるようにしても良いとは思います。 (そうすれば上記の main.swf のようなものは要りませんね。)
全体が見えませんから何とも言えませんが， package { の下辺りに import flash.events.*; とか import flash.events.Event; のようなことを入れ忘れているのではないでしょうか。
＃１です。 > var urlLoader:URLLoader = new URLLoader(); > urlLoader.dataFormat = URLLoaderDataFormat.TEXT; > urlLoader.addEventListener(Event.COMPLETE, jsonReadHandler); > urlLoader.load(new URLRequest("json_data.json") ); > > が記述されています。 > なので、コンプリートしてから > イベントハンドラが呼び出されているはずなんですが、 > カスタムクラスのプロパティには保存されてませんでした。 だから...， ＃１で書いた意味が全くわかってらっしゃいませんね。。。 > カスタムクラスのプロパティには保存されてませんでした。 と書かれていますが それを確かめているタイミングが urlLoader に データのロードが完了する前なんですって！ データのロードが完了する前に(まだデータを見ることができる状態になっていない段階で) > trace(ImageRoadClass.number); // 出力結果：0　　保持できてない > trace(imageRoad.getNumber()); // 出力結果：0　　保持できてない など確かめても データは入っていないのは当然でしょう？ それだけのことを理解できれば 対処法はどうにでもなると思いますよ。 ということです。 （逆に言えばそれだけのことを理解しなければ何もできません。） 例えば すでに用意されている関数 function jsonReadHandler(e:Event):void{…｝ の中で 別関数(例：testFunc) を実行させるようにして その 別関数(例：testFunc) 内で カスタムクラスのプロパティに値が保存さてれいるかどうかを確かめてみれば良いのではないでしょうか？
PHP はサーバ上で動くプログラムですから 自分自身(サーバ) のことはわかって当然でしょうが Flash は基本的に クライアントPC(閲覧者の PC) で動作するものなのですから 他人様(サーバ) のファイル状況などわかるはずがありません。 (もしわかったらサーバ上のあらゆるアップファイルにカンガンアクセスされますよ。。。) どのようなファイルの有無を知りたいのかわかりませんが Flash のみでする場合で そのファイルが Flash でロードできるファイルでしたら 一旦ロードに挑戦してみてロードエラーを拾うなどという原始的な方法になると思います。 (解釈や表現を変えればブルートフォースアタックのような原始的なことならできるかもしれません(サーバに拒否されなければ)。) もっともサーバによっては 存在しないファイルをロードしようとすると 普通に エラー404 用の代替ファイルを用意するサーバもあります。 そのような場合は 存在しないファイルをロードしようとしてもロードエラーすら拾えないこともあります。 ですから Flash から PHP の file_exists のようなものを実行させる とか ロードすべきファイルの一覧データ(テキストデータ(XMLデータを))用意しておく というのが一般的です(後者の方が一般的)。
HP作成者側で解決する手段は現時点ではありません。 多分未来においてもないのかなぁ。。。（AppleとAdobeの関係性が良くなるとはちょっと思えない） なのでHP作成者側としてはモバイル用のサイトを別に設けてリンクを貼るより仕方ないと思います。 ちなみにちょっと蛇足ですが個人（見る側）の解決策はあります。 具体的にはブラウザをデフォルトではなく別のものをインストールする、ということですが まだまだFlashで作られているサイトも多いので需要はあるのだと思います。 ちなみにiOSでは以下のリンクにもありますがPuffinがオススメです。 「iPadでFlashのサイト見ることってよくあるよね～。　、、、はいっ、ウソですっ！ゲーム目的ですっ！」 http://mixture-art.net/?p=2773
メインのタイムラインは１フレームのみで mcA ～ mcE は全てその フレーム1 に置いてあるものとします。 その場合 その フレーム1 に書くスクリプト例です↓。 //======================================= // MC の参照を登録する配列を作成 var mc_arr:Array = [mcA,mcB,mcC,mcD,mcE]; // MC の再生順を登録する配列を作成 var ord_arr:Array = new Array(); // MC の再生順を各要素に登録(２次元配列) ord_arr[0] = [mcA,mcB]; ord_arr[1] = [mcA,mcB,mcB]; ord_arr[2] = [mcC,mcD,mcE]; ord_arr[3] = [mcC,mcD,mcD,mcE]; ord_arr[4] = [mcC,mcD,mcD,mcD,mcE]; //---↑以上が初期登録↑--- //登録した MC を全て非表示にして再生停止 for (var i:int = 0; i<mc_arr.length; i++) { mc_arr[i].stop(); mc_arr[i].visible = false; } //ランダムな再生順の数を入れる変数の宣言 var rnd:int; //再生順のカウンタを作成 var cnt:int = 0; //関数 randomMCPlay の定義 function randomMCPlay():void { //再生中のMCを非表示＆再生停止 ord_arr[rnd][cnt].visible = false; ord_arr[rnd][cnt].gotoAndStop(1); //ランダムな再生順の数を取得 rnd = Math.floor(Math.random() * ord_arr.length); //再生順のカウンタを初期化 cnt = 0; //ランダムな再生順の数の対応MCを表示＆再生開始 ord_arr[rnd][cnt].visible = true; ord_arr[rnd][cnt].gotoAndPlay(1); //毎フレーム 関数 watchMC を実行 this.addEventListener(Event.ENTER_FRAME,watchMC); } //関数 nextMCPlay の定義 function nextMCPlay():void { //再生中のMCを非表示＆再生停止 ord_arr[rnd][cnt].visible = false; ord_arr[rnd][cnt].gotoAndStop(1); //再生順をカウントアップ cnt++; //対応MCを表示＆再生開始 ord_arr[rnd][cnt].visible = true; ord_arr[rnd][cnt].gotoAndPlay(1); //毎フレーム 関数 watchMC を実行 this.addEventListener(Event.ENTER_FRAME,watchMC); } //関数 watchMC の定義 function watchMC(e:Event):void { //もし再生中のMCが最終フレームに達すれば if (ord_arr[rnd][cnt].currentFrame == ord_arr[rnd][cnt].totalFrames) { ord_arr[rnd][cnt].stop(); //毎フレーム 関数 watchMC を実行するのをやめる this.removeEventListener(Event.ENTER_FRAME,watchMC); //毎フレーム 関数 selectFunction を実行 this.addEventListener(Event.ENTER_FRAME,selectFunction); } } //関数 selectFunction の定義 function selectFunction(e:Event):void { //もし再生順が最後であれば if (cnt == ord_arr[rnd].length - 1) { //関数 randomMCPlay を実行 randomMCPlay(); } else { //それ以外は 関数 nextMCPlay を実行 nextMCPlay(); } //毎フレーム 関数 selectFunction を実行するのをやめる this.removeEventListener(Event.ENTER_FRAME,selectFunction); } //関数 randomMCPlay の初回実行 randomMCPlay(); //======================================= 上記スクリプト中の 「---↑以上が初期登録↑---」より上の部分を変えれば その他は触らなくても自動的にそれに従った動作になります。 内容を大まかに言えば 「関数 randomMCPlay」または 「関数 nextMCPlay」を実行させることによって 次のMCの再生を開始させています。 「関数 randomMCPlay」の方がランダムで順を選ぶ動作で 「関数 nextMCPlay」の方がその順内で次のMCを選ぶ動作です。 そして 再生中のMCのタイムラインを 「関数 watchMC」で見張らせておいて 再生中のMCが最終フレームになったとき 「関数 selectFunction」を実行させて 「関数 randomMCPlay」または 「関数 nextMCPlay」のどちらかを実行させる というようなしくみにしています。 本当は 再生中のMCのタイムラインを 「関数 watchMC」で見張らせておいて 再生中のMCが最終フレームになったとき 「関数 selectFunction」を介さずに即 「関数 randomMCPlay」または 「関数 nextMCPlay」のどちらかを実行させる というような動作にしたいところですが そのようにすると mcA～mcE の 最終フレーム(MC内の フレーム10 や 20)が表示されないまま 次の MC の再生が開始されてしまいます。 そうならないように 「関数 randomMCPlay」または 「関数 nextMCPlay」のどちらかを実行させる というタイミングを １フレーム 時間待たせるために 「関数 selectFunction」を用意して Event.ENTER_FRAME で実行させて，即削除しています。 ※ Event.ENTER_FRAME で実行される 　 イベントリスナーの初回実行タイミングは 　 addEventListener が実行された 　 次のフレーム時間に入った最初の瞬間です。
＃１です。 > テキストファイルは、同じドメイン内ですが、 > 別フォルダに入れています。 と書かれていらっしゃいますが とりあえずは状況を単純化するために 「SWF(Flashファイル)」と 「その SWF を貼り付けた HTML」と 「外部テキストデータ」の３つは すべて同じフォルダ(同階層)にあるものとします。 また 外部テキストファイルのファイル名は 「data.txt」であるものとし， その「data.txt」の文字コードは Shift-JIS であるものとします。 さらに 改行コードは...，書かれていらっしゃいませんから， 「\r(CR)」なのか「\n(LF)」なのか「\r\n(CR＋LF)」なのかは不明であるものとします。 (不明でしたら不明で処理を１つ入れれば解決できます。) そして その「data.txt」内のデータは 次のようになっているものとします。 花子 東京都 乙女座 上のような状況である場合の タイムラインのフレームに書く ActionScript 3.0 でのスクリプト例です。 //------------------------------------------- //外部テキストを Shift-JIS として扱う設定 System.useCodePage = true; //テキストの各行を各要素として格納する配列を宣言 var data_arr:Array; //外部テキストロード用インスタンス ld を作成 var ld:URLLoader = new URLLoader(); //外部テキストがロード完了時に 関数completeFunc を実行 ld.addEventListener(Event.COMPLETE, completeFunc); //外部テキストがロードされたときに実行する関数を定義 function completeFunc(e:Event):void { // //ロードされたテキストの改行コードを「\n」に統一 var data_str:String = ld.data.split("\r\n").join("\n").split("\r").join("\n"); // //ロードされたテキストを改行コード「\n」で分割して配列に代入 data_arr = data_str.split("\n"); // //配列の 要素1(data_arr[1]) を適当にテスト表示 var test_txt:TextField = new TextField(); test_txt.x = test_txt.y = 10; test_txt.width = 200; test_txt.height = 50; addChild(test_txt); test_txt.text = data_arr[1]; } //URLリクエストインスタンス rq を作成 var rq:URLRequest = new URLRequest("data.txt"); //ld にリクエストファイルをロード ld.load(rq); //------------------------------------------- 外部テキストへのファイルパス(この場合「data.txt」)は， SWF からのパスではなく， SWF を貼り付けた HTML からのパスになるので注意してください。 つまり SWF とそれを貼り付けた HTML が違うフォルダにあった上で ファイルパスを相対パスで指定するときに注意が必要です。 　 　 ＝＝＝ スクリプトの内容説明 ＝＝＝＝＝＝＝＝＝＝＝＝＝ まず， 「ld」という名の外部テキストロード用の入れ物を作成して， その「ld」内に外部テキスト「data.txt」をロードさせています。 当たり前ですが 外部テキストのロード完了後でなければ 外部テキスト内のデータを見たりいじったりすることはできません。 したがって 外部テキストのロード完了時に動作するイベントリスナー(関数)を定義して その関数内でデータをいじる作業をしています。 「ld」内にロードされたデータは ロード完了後に「ld」の「data」プロパティ(ld.data)を参照すれば得られます。 ですからロード完了後にまず //ロードされたテキストの改行コードを「\n」に統一 var data_str:String = ld.data.split("\r\n").join("\n").split("\r").join("\n"); これで その「ld.data」内の文字列を「\r\n」で分割した配列にして その配列を「\n」で結合した文字列に戻し さらにその文字列を「\r」で分割した配列にして その配列を「\n」で結合した文字列に戻しています。 結局， 改行コードが「\r」であっても「\n」であっても「\r\n」であっても 全て「\n」に統一されるわけです。 その改行コードが「\n」に統一された文字列を //ロードされたテキストを改行コード「\n」で分割して配列に代入 data_arr = data_str.split("\n"); これで「\n」で分割した配列にしています。 最初から改行コードは例えば「\r\n」だとわかっていれば 改行コードを「\n」に統一するようなことはしなくて良く ロード後に即， //ロードされたテキストを改行コード「\r\n」で分割して配列に代入 data_arr = data_str.split("\r\n"); とすれば良いだけです。 とにかく この時点で配列「data_arr」の中身は data_arr[0] = "花子" data_arr[1] = "東京都" data_arr[2] = "乙女座" という状態になります。 後はその data_arr[1] の値を取ってきて 仮にテキストフィールドに表示させています。 (実際にはどうするのか知りません。)
もし Flash(SWFファイル) をネットにアップする場合でしたら その作成されているFlash(SWFファイル)自体の ロード待ち処理などを考えたりしなければならないため 下に書く方法が適切とは言えない場合も出てきますが スクリーンセーバーは基本的にローカルファイルですから 下に書くような方法で良いのではないかと思います。 まず，下に書く内容の大まかな骨子を書きますが 全体的には 「各季節(5季節)を別々のシーンに配置して 月によって再生させるシーンを変える。」 ということをすれば良いのではないかということです。 新規ドキュメントファイル(FLAファイル)を作成して そのドキュメント内に「桜」「雨」「緑葉」「紅葉」「雪」のアニメーションをつないで行くのですが そのときに各アニメーションをシーンごとに分けてコピペします。 新規ドキュメントを作成すると メインのタイムライン(の「シーン 1」)が見えるわけですが 「挿入」→「シーン」で「シーン 2」～「シーン 6」の５つのシーンを挿入します。 そして 「シーン 2」のタイムラインには「桜」 「シーン 3」のタイムラインには「雨」 「シーン 4」のタイムラインには「緑葉」 「シーン 5」のタイムラインには「紅葉」 「シーン 6」のタイムラインには「雪」 の各タイムラインをコピペします。 ドキュメントファイル内でのシーン移動は ステージの上にあるバーの右の方にある 「ガチンコ」アイコンをクリックすればできると思います。 アニメーションのコピペは 作成した各アニメーションのタイムラインの全てのレイヤーとフレームをドラッグで選択して 右クリックなどより「フレームをコピー」を選択し ペーストしたいシーンのフレーム1を選択して 右クリックなどより「フレームをペースト」を選択すればできると思います。 ・参考↓ 「アニメーション作成の手抜きテクニック：ITpro」 http://itpro.nikkeibp.co.jp/article/COLUMN/20060705/242544/ →「フレーム全体をコピーする」の項目 各アニメーションFLAに シンボル名が同じシンボルがあると コピペするときに厄介なことが起こって困るので 各アニメーションFLAのシンボル名は違うものにしておいた方が良いと思います。 (例：「桜シンボル1」，「紅葉シンボル1」など) そして 何も配置していない 「シーン 1」のフレーム1を選択して 次のようなスクリプトを書きます。 //---------------------------------------------- //今現在の Date インスタンス my_tade を作成 var my_date:Date = new Date(); //my_date から 月番号(0～11) を取得 var month_num:int = my_date.getMonth(); //もし月番号が2～4であれば(3～5月であれば) if (month_num >= 2 && month_num <= 4) { //シーン 2 の フレーム1 から再生 gotoAndPlay(1,"シーン 2"); //もし月番号が5であれば(6月であれば) } else if (month_num == 5) { //シーン 3 の フレーム1 から再生 gotoAndPlay(1,"シーン 3"); //もし月番号が6または7であれば(7または8月であれば) } else if (month_num == 6 || month_num == 7) { //シーン 4 の フレーム1 から再生 gotoAndPlay(1,"シーン 4"); //もし月番号が8～10であれば(9～11月であれば) } else if (month_num >= 8 && month_num <= 10) { //シーン 5 の フレーム1 から再生 gotoAndPlay(1,"シーン 5"); //もし月番号が上記以外であれば(12または1または2月であれば) } else { //シーン 6 の フレーム1 から再生 gotoAndPlay(1,"シーン 6"); } //---------------------------------------------- これで 月によって違うシーンの冒頭にジャンプするようになります。 しかしこれだけでは ムービー全体がループ再生されてしまうので 各シーンの最終フレームにキーフレームを作って 次のように書いて行きます。 //---「シーン 2」の最終フレーム--------- //シーン 2 の フレーム1 から再生 gotoAndPlay(1,"シーン 2"); //-------------------------------------- //---「シーン 3」の最終フレーム--------- //シーン 3 の フレーム1 から再生 gotoAndPlay(1,"シーン 3"); //-------------------------------------- 他のシーンの最終フレームも同様に…。 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 結局のところ， new Date() で Date インスタンスを作成して getMonth() メソッド で月番号を取得し その月番号によって動作を変えれば良いのです。 シーンを使うと そんなに難しい知識は要りませんし説明も簡単であるため 各季節のアニメーションを各シーンに用意する方法を書きましたが 別にシーンを使わなくても良いのです。 例えば ５つの ムービークリップを用意して そのムービークリップ内のタイムラインに 各季節のアニメーションを用意して 月番号によって表示させるムービークリップを変えても良いわけです。 もしそういう方法を使うとすれば インスタンス名とか階層とか場合によってはクラスとか そういうものの概念などの理解も必要になってきたり 説明も難しくなってくるのでシーンで説明しただけです。 余裕があったり， 違うものを作る機会があれば， 色々な方法を考えてチャレンジしてみるのも良いかもしれません。
原因とかそういう概念(思考パターン？)など普通には何もなくて 設定フレームレートというのはリミッターみたいなものですから 例えば 30fps 設定にした場合 再生速度が１秒間に30フレームまでに制限されるというような設定をしたのと同じようなことに過ぎません。 (ただし，HTML に wmode="transparent" で貼り付けると，ブラウザによっては設定フレームレートより早く再生される場合がありますが，これは例外です。) ですから 画面描画やスクリプト処理が PC の CPU や GPU を圧迫すれば どんどんフレームレートは下がります。 フレームレートが遅くなったり不安定になるのは 当たり前で普通の現象です。 昔は(今でも)「Flash は重い」と言われてましたが 正にこれが処理落ちによるフレームレートの低下現象です。 昔は(今でも)描画処理などは GPU でなく全て CPU 任せでしたし 昔の PC は CPU や メモリ などが少ないものが多かったですから (私など CPU:233MHz　メモリ:64MB のPCで Flash を作ったり見たりしてましたから) カクッ... カクッ... としか動かない Flash を見かけることは多かったです。 自己満足に浸っている自己中な作者が公開している Flash に重いものが多かったです。 　 ＝＝＝ ＝＝＝ ＝＝＝ 第一の回避策としては アルファ(透明/半透明)やフィルタ(ぼかしフィルタなど)の使用をなるべく控えて PC の CPU や GPU に負担をかけないようにしたり ActionScript でループ文を使用したり 何でも ENTER_FRAME イベントで動作させるのをやめるとか とにかく クライアントPC をいたわるような気持を常に持ち続けながら 作品の作成に携わるということが大切でしょう。 また， 例えば 30fps を出すのが難しそうでしたら 元から 15fps などに下げた設定で作る(クライアントPCに無理をさせない)というのも回避策になります。 　 あと， SWF を HTML に貼り付けるときのタグで quality="autohigh" にするなどして 再生速度を優先して画質を下げるようにするとか， または上にも少し書いたように wmode="transparent" で貼り付けるのも１つの方法だと思います。 　 その他，裏技的なことですが， 無音の短い mp3 でも用意して その音をライブラリなどに読み込んでレイヤーに配置し そのレイヤーに配置した音のプロパティで 「同期」の項目を「ストリーミング」にしておくのも１つの手です。 ※【添付図】↓ この「同期：ストリーミング」設定は 本来アニメーションと音をシンクロ再生させる設定です。 つまり フレームレートの低下で， 音だけが普通に再生されて アニメが取り残されるのを防ぐ設定です。 (いっこく堂の衛星放送のような現象が起こるのを防ぐ設定) この設定にしておくと フレームレートが低下した場合コマ飛ばし(フレーム飛ばし)をして 無理矢理，音にアニメを合わせる再生になります。 ですから カタカタと不自然なアニメになる場合もあります。 この設定にした音を１つでも入れておくと 実際に音が鳴っている鳴っていないにかかわらず， ムービー全体の再生が設定フレームレートに近い状態になります。 あまり良い方法とは言えませんが 裏技的で強引なフレームレート維持方法です。 　 ＝＝＝ ＝＝＝ ＝＝＝ 　 兎にも角にも フレームレート設定は「だいたいの目安」「おおまかなリミッタ」に過ぎないと思った方が良いです。 アニメーションなどの内容や クライアントPC の性能や閲覧状況などによって大きく変動します。 それを怪奇現象や不具合と思うのではなく， 普通で当たり前の現象だと思って作成すべきでしょう。
＃１です。 返事が遅くなってしまいましたが。 > ０１２３４ > ５６７８９ > > が > > □□□３ ４ > ５ ６ ７ ８ ９ > ０ １ ２ なるほど， ＃１のスクリプトだと確かにそうなりますね。 私の確認不足でした。 すみません。 それではスクリプトを次のように変更してみてください。 //----------------------------------------------- //「bg○」の参照を入れる配列を用意 var objA:Array = new Array(2*5); //「bg○」の座標を入れる配列を用意 var posA:Array =[ [70, 112], [106, 112], [142, 112], [178, 112], [214, 112], [70, 148], [106, 148], [142, 148], [178, 148], [214, 148], [70, 184], [106, 184], [142, 184], [178, 184], [214, 184], [70, 220], [106, 220], [142, 220], [178, 220], [214, 220] ]; //「bg○」の入る位置番号を入れる配列を用意 var numA:Array = new Array(objA.length); //「bg○」の生成＆配置 for (var i:Number=0; i<objA.length; i++) { objA[i] = _root.attachMovie("bg", "bg"+i, i+100); //●動作確認用(本題とは関係なし) //objA[i].createTextField("tf",0,-15,-15,24,24); //objA[i].tf.text = i; objA[i]._x = posA[i][0]; objA[i]._y = posA[i][1]; } //「hitBar」をドラッグできるようにする hitBar.onPress = function():Void{ this.startDrag(); }; hitBar.onRelease = hitBar.onReleaseOutside = function():Void{ this.stopDrag(); }; //毎フレーム実行 this.onEnterFrame = function():Void{ //配列「numA」の初期化と「bg○」の配置 for (var i:Number=0; i<objA.length; i++) { numA[i] = i; objA[i]._x = posA[numA[i]][0]; objA[i]._y = posA[numA[i]][1]; } // //「bg○」に関するループ for (i=0; i<objA.length; i++) { //「bg○」が「hitBar」にヒットしている間はループ while(objA[i].hitTest(hitBar)){ //★ j:Number=0; を j:Number=i; に変更 for (var j:Number=i; j<objA.length; j++) { numA[j]++; //★座標移動をココから削除(下に移動) } //★この for 文を付け足し for (j=0; j<objA.length; j++) { //★座標移動 objA[j]._x = posA[numA[j]][0]; objA[j]._y = posA[numA[j]][1]; } } } }; //----------------------------------------------- 変更したのは ★ を付けた部分で，その他は基本的にそのままです。 (● を付けてコメントアウトしてある部分は，私自身のための動作確認用スクリプトです。)
＃１ ＆ ＃２ です。 ＃２ のお礼(補足の方ではないです) を読ませていただきましたが， フレームによって違うボタンなどが登場して そのボタンクリックによって別々の動作をさせるのでしたら その フレーム・フレーム… ごとにスクリプトを書いた方が良いと思います。 少なくともドキュメントクラスのスクリプトだけでするのは難しいでしょう。 とりあえずは ステージ上の各フレームに用意するインスタンスを書きます。 「 」内はインスタンス名です。 ◎ フレーム1 に用意するもの 　・ボタンインスタンス「start_btn」 ◎ フレーム2 に用意するもの 　・ボタンインスタンス「ok_btn」 　・ボタンインスタンス「cancel_btn」 　・ダイナミックテキストフィールド「time_txt」 　 ※↑これは フレーム3 と 4 でも継続表示させる ◎ フレーム3 に用意するもの 　・ダイナミックテキストフィールド「judge_txt」 　 ※↑これは フレーム4 でも継続表示させる 　・ダイナミックテキストフィールド「time_txt」 　 ※↑これは フレーム2 から継続表示させる ◎ フレーム4 に用意するもの 　・ダイナミックテキストフィールド「judge_txt」 　 ※↑これは フレーム3 から継続表示させる 　・ダイナミックテキストフィールド「time_txt」 　 ※↑これは フレーム2 から継続表示させる ※下の【添付図】をご参考に。 　 ドキュメントクラスは無くします。 各フレームに書くスクリプト例です。 //---フレーム1-------------------------- //このフレームで再生を停止 stop(); //経過時間を代入する変数の宣言 var old_time:uint; var now_time:uint; //「start_btn」クリック時に 関数 clockStart を実行 start_btn.addEventListener(MouseEvent.CLICK,clockStart); //関数 clockStart の定義 function clockStart(e:MouseEvent) { //変数 old_time にスタート時の時間を代入 old_time = getTimer(); //このイベントリスナーを削除 start_btn.removeEventListener(MouseEvent.CLICK,clockStart); //次のフレーム(フレーム2)で停止 nextFrame(); } //------------------------------------ 　 //---フレーム2-------------------------- //毎フレーム進む時間で 関数 tick を実行 this.addEventListener(Event.ENTER_FRAME,tick); //関数 tick の定義 function tick(e:Event):void { //変数 now_time に今の時間を代入 now_time = getTimer(); //スタート時からの時間差を取得 var mili_sec = now_time - old_time; //～時間の表示文字列を算出～ var s:int = Math.floor(mili_sec / 1000); var minutes:int = Math.floor(s / 60); var seconds:int = s % 60; var mili:int = mili_sec % 1000; //「time_txt」に経過時間を表示 time_txt.text = minutes + ":" + ("0" + seconds).substr(-2,2) +":"+ ("00" + mili).substr(-3,2); } //「ok_btn」クリック時に 関数 okFunc を実行 ok_btn.addEventListener(MouseEvent.CLICK,okFunc); //関数 okFunc の定義 function okFunc(e:MouseEvent) { //このイベントリスナーを削除 ok_btn.removeEventListener(MouseEvent.CLICK,okFunc); //フレーム3 で停止 gotoAndStop(3); } //「cancel_btn」クリック時に 関数 cancelFunc を実行 cancel_btn.addEventListener(MouseEvent.CLICK,cancelFunc); //関数 cancelFunc の定義 function cancelFunc(e:MouseEvent) { //このイベントリスナーを削除 cancel_btn.removeEventListener(MouseEvent.CLICK,cancelFunc); //フレーム4 で停止 gotoAndStop(4); } //------------------------------------ 　 //---フレーム3-------------------------- //毎フレーム進む時間で 関数 tick を実行するのをやめる this.removeEventListener(Event.ENTER_FRAME,tick); //「judge_txt」に 正 を表示 judge_txt.text = "正"; //------------------------------------ 　 //---フレーム4-------------------------- //毎フレーム進む時間で 関数 tick を実行するのをやめる this.removeEventListener(Event.ENTER_FRAME,tick); //「judge_txt」に 誤 を表示 judge_txt.text = "誤"; //------------------------------------ 　 以上のように 「何がどうなったときに，何をどうするのか。」 ということを具体的にしっかりとイメージして １つずつ確実に動作するようにスクリプトを考えて行けばできると思います。
サーバサイドの変数をFlashに渡す方法は何種類かありますが、配列やオブジェクトのまま渡せる方式を推奨します。 ■ActionScriptでXMLを読込む ・サーバサイドでXMLに吐くメソッドを用意し、FlashからURLloaderで読み出す。 その後、ActionScriptで内容をパースしてオブジェクトを生成する。 ■Ajaxで読み、Flashに渡す ・javascript / Ajaxでサーバサイドから読み、取得したオブジェクトをExternalInterface経由でFlashに渡す。 個人的には、Ajax / ExternalInterface経由の方法をよく使います。理由は、 ・AJaxという旬の技術を使えるので、javascript/サーバサイドの技術情報が多い。 ・サーバサイドデバッグがやりやすい。 ・javascript側からオブジェクトをそのまま渡すので、Flash側の手間がない。 など。 方言の強いActionScript3の命令（XML解析の部分や、固有のイベント）をあまり深く使いたくない人間は、Ajax併用のほうが向いています。 XMLを使う方法も悪くないですが、配列やオブジェクト構造が複雑に組み合わさるデータで、そのたびにXMLスキーマを決めることや、正直ActionScriptのXMLパーサより、ブラウザのjavascriptパ－サのほうが出来がいいことを考えると、Flash側の手間を最小限に抑えるのが有利かと。
＃１です。 返事が遅くなりましたが...。 > テキストの記述を１回するだけで作ることは可能でしょうか？ 基本的には１つのテキストフィールドに 例えば， 「このように 文字を表示しながら クリックを押すと 次のテキストが下から表示される方法があれば 教えていただきたいです。 よろしくお願いします！」 というような全文を打って， そのテキストフィールドを数十～数百フレームで 好きな座標から好きな座標へと動かす設定をして， 動かしている最中のフレームで stop(); または 「停止」をすれば良いと思います。 たったそれだけのことですが その作成作業の具体的な詳細説明は書くのも読むのも難しいですよ。。。 　 とりあえずは， 「テキストフィールド」も「その周りの枠(水色部分)」も １つのスプライトの中に入れて そのスプライト内で動作を簡潔させるのが良いように思います。 そうすれば メインのタイムライン(_root)を汚すことも少なくなる上 使い回しや配置なども簡単になるので良いと思います。 ですからまず， 「テキストフィールド」と「その周りの枠(水色部分)」を １つのスプライトの中に入れて 「テキストフィールド」と「その周りの枠(水色部分)」とを そのスプライト内のフレーム１から出すようにして 「テキストフィールド」を例えば 40フレーム 間で 好きな座標から好きな座標へと動かす設定をします。 その後にアクションとして 「＜ロールバック＞」で「フレームカウント＝40」を入れます。 そして「適用」をクリックします。 さらにその後にアクションとして 「＜スクリプト＞」で「スクリプトの編集」より「スクリプトエディタ」を表示させ 次のようなスクリプトを書きます。 //このスプライトを押したときに実行 this.onPress = function() { //このスプライト内の再生を開始 this.play(); }; そして「適用」をクリックします。 その後にアクションとして 「何もしない」で例えば「フレームカウント＝14」などと適当に調節した数値を入れます。 そして「適用」をクリックします。 その後にアクションとして 「停止」入れ「適用」をクリックします。 その後にアクションとして 「何もしない」で例えば「フレームカウント＝13」などと適当に調節した数値を入れます。 そして「適用」をクリックします。 その後にアクションとして 「停止」入れ「適用」をクリックします。 その後にアクションとして 「何もしない」で例えば「フレームカウント＝9」などと適当に調節した数値を入れます。 そして「適用」をクリックします。 その後にアクションとして 「停止」入れ「適用」をクリックします。 そういう作業をすると， 画面は下の【添付図】↓のような状態になります。 以上のような感じで作業をして行って 後は SWF を書き出せば良いかと思います。 こんな説明でわかりますか？ やはり構造体の作り方の詳細などは説明が難しいです。 　 　 なお， ご質問で作成されているもののテキストフィールドは 「クリック」ではなく「押したとき」に動くようになっていますから このスクリプトでも //このスプライトを押したときに実行 this.onPress = function() { というように書いています。 しかし， 一般的に「クリック」とは「押したとき」でなく「押して放したとき」です。 そういう意味での「クリック」にしたい場合は //このスプライトをクリックしときに実行 this.onRelease = function() { のようになります。 スプライトやボタン自体に書くスクリプトの場合は on (press) {…} ではなく， on (release) {…} が『「クリック」したとき … を実行』という意味になります。
> Aキーを押せばsoundA(リンゲージ名を付けた音楽ファイル)が流れる、 > Bキーを押せばsoundBが流れ、 ？？？ スクリプトと識別子がずれていますが これは > Aキーを押せばsound0(リンゲージ名を付けた音楽ファイル)が流れる、 > Bキーを押せばsound1が流れ、 と解釈変更をしてよろしいのですよね？ (以下も同様に soundC→sound2，soundD→sound3，…) > １キーもしくは２キーのどちらか押されたらsoundAもsoundBも停止 > というようにしたいのですが、可能でしょうか。 ↓解釈変更↓ > １キーもしくは２キーのどちらか押されたらsound0もsound1も停止 > というようにしたいのですが、可能でしょうか。 それでしたら普通に，単純に(超基本的に) if文 で次のような内容のスクリプトを書けば良いだけだと思いますよ。。。 if(キーが1または2のとき){ 　sound0とsound1を停止; }else if(キーが3または4のとき){ 　sound2とsound3を停止; }else if(キーが5または6のとき){ 　sound4とsound5を停止; }else if(キーが7または8のとき){ 　sound6とsound7を停止; } ↑まずはこのように基本で考えるのが第一です。 (まずはこれができて，もし余力があれば簡素化や効率化などを考えれば良いのです。) あと上の内容のスクリプトを見てもらっても， ご質問を読みなおしてもらってもわかると思いますが， キー1，2 → sound0，1 キー3，4 → sound2，3 キー5，6 → sound4，5 キー7，8 → sound6，7 という感じで キーと音とが 1 ずつずれていますよ。 これは，ずれていることが正解だとして 以下の回答を続けます。 本来は まず上で書いたif文の内容を考えて行くのが第一ですが 上のように長い(？) if文 にするのではなくて これも前回回答したスクリプトのように 少し簡素化したスクリプトを考えることにします。 その場合のスクリプト例です↓。 //------------------------------------------- //この階層を変数化 var me:MovieClip = this; //変数 i を 0～7 の間で 1 ずつ加算しながらループ for (var i:Number = 0; i<=7; i++) { //Soundオブジェクト「sound_obj0」～「sound_obj7」を作成 me["sound_obj"+i] = new Sound(); //各Soundオブジェクトに各音を割り当てる me["sound_obj"+i].attachSound("sound"+i); //各音の再生フラグ「sound_flg0」～「sound_flg7」を用意 me["sound_flg"+i] = false; } //キーを監視させるオブジェクトを作成 var key_obj:Object = new Object(); //キーを押したときに実行する関数の定義 key_obj.onKeyDown = function():Void { // //押されたキーコードを保存 var key_num:Number = Key.getCode(); // //押されたキーコードが65～72(キーがA～H)の間であれば if (key_num>=65 && key_num<=72) { //さらにそのキーの音に対応するフラグが false であれば if (!me["sound_flg"+(key_num-65)]) { trace("sound_obj"+(key_num-65)); //そのキーに対応する音を再生 me["sound_obj"+(key_num-65)].start(0,100); //その音に対応するフラグを true にする me["sound_flg"+(key_num-65)] = true; } //---↓★以下の数字を変更★↓--- //押されたキーコードが97～104(キーが1～8)の間であれば } else if (key_num>=97 && key_num<=104) { trace("sound_obj"+(key_num-97)); //そのキーに対応する音を停止 me["sound_obj"+(key_num-97)].stop("sound"+(key_num-97)); //その音に対応するフラグを false にする me["sound_flg"+(key_num-97)] = false; // //---↓★以下のif文を付け足し★↓--- //もしキーコードが奇数であれば if (key_num%2) { //そのキーに対応する音の次の音を停止 me["sound_obj"+(key_num-96)].stop("sound"+(key_num-96)); //その音に対応するフラグを false にする me["sound_flg"+(key_num-96)] = false; //もしキーコードが偶数であれば } else { //そのキーに対応する音の前の音を停止 me["sound_obj"+(key_num-98)].stop("sound"+(key_num-98)); //その音に対応するフラグを false にする me["sound_flg"+(key_num-98)] = false; } } }; //key_obj を Key のリスナーとして登録 Key.addListener(key_obj); //------------------------------------------- 上で付け加えたスクリプトに //もしキーコードが奇数であれば if (key_num%2) {…} という部分がありますが ここで使っている % を「剰余演算子」と言います。 (% では Google や ヘルプ で検索できないので日本語名を書きました。) 「key_num%2」は 「変数 key_num を 2 で割った余り」という意味です。 もし key_num が 97 だった場合 key_num%2 は 1 になります。 1 は true と等価ですから if (key_num%2) {…} の … の部分は実行されます。 (それに続く else の部分は実行されません。) key_num%2 が 1 のとき ⇔ key_numが奇数のとき key_num%2 が 0 のとき ⇔ key_numが偶数のとき という関係です。
＃１です。 ＃１の【補足】を読ませていただきましたが， ８種類の音を別々に鳴らすのでしたら 少なくとも８個のSoundオブジェクトが必要になると思います。 var soundObjA:Sound = new Sound(); soundObjA.attachSound("soundA"); var soundObjB:Sound = new Sound(); soundObjB.attachSound("soundB"); 　…略… var soundObjH:Sound = new Sound(); soundObjH.attachSound("soundH"); ↑このように。 　 しかし...， ８種類の音を制御するにしても 結局，具体的に「何をしたときに何をどうしたいのか」がわかりませんので それ以上あまり具体的なことは書けませんよ。。。 具体的な動作がわからないので， キー「A」「B」「C」「D」「E」「F」「G」「H」を押したときに それぞれに対応する音が流れ テンキーの キー「0」「1」「2」「3」「4」「5」「6」「7」を押したときに それぞれに対応する音(0ならAの音，1ならBの音)が止まる。 というルールで行くものと勝手に決めます。 また，複数の音は同時に鳴ることがあるものとします。 【動作例１】 キー「A」を押してキー「B」を押すと， 「Aの音」が鳴りさらに「Bの音」が重なって鳴る。 【動作例２】 キー「A」を押してキー「B」を押してキー「0」を押すと， 「Aの音」が鳴りさらに「Bの音」が重なって鳴り「Aの音」が消え「Bの音」だけが残って鳴り続ける。 このようなものを作成する場合の方法例ですが， まず各音シンボルのリンケージで ８つある音に，0 からの連番付きの識別子を付けます。 「sound0」，「sound1」，……，「sound7」 ※↑「soundA」，「soundB」，……，「soundH」ではありません。 そうしておいた上で， シーン１のタイムライン１フレーム目に次のスクリプトス(例)を書きます。 ActionScript 2.0 です。 //------------------------------------------- //この階層を変数化 var me:MovieClip = this; //変数 i を 0～7 の間で 1 ずつ加算しながらループ for (var i:Number = 0; i<=7; i++) { //Soundオブジェクト「sound_obj0」～「sound_obj7」を作成 me["sound_obj" + i] = new Sound(); //各Soundオブジェクトに各音を割り当てる me["sound_obj"+i].attachSound("sound"+i); //各音の再生フラグ「sound_flg0」～「sound_flg7」を用意 me["sound_flg"+i] = false; } //キーを監視させるオブジェクトを作成 var key_obj:Object = new Object(); //キーを押したときに実行する関数の定義 key_obj.onKeyDown = function():Void { // //押されたキーコードを保存 var key_num:Number = Key.getCode(); // //押されたキーコードが65～72(キーがA～H)の間であれば if (key_num>=65 && key_num<=72) { //さらにそのキーの音に対応するフラグが false であれば if (!me["sound_flg"+(key_num-65)]) { trace("sound_obj"+(key_num-65)); //そのキーに対応する音を再生 me["sound_obj"+(key_num-65)].start(0, 100); //その音に対応するフラグを true にする me["sound_flg"+(key_num-65)] = true; } //押されたキーコードが96～103(キーが1～7)の間であれば } else if (key_num>=96 && key_num<=103) { trace("sound_obj"+(key_num-96)); //そのキーに対応する音を停止 me["sound_obj"+(key_num-96)].stop("sound"+(key_num-96)); //その音に対応するフラグを false にする me["sound_flg"+(key_num-96)] = false; } }; //key_obj を Key のリスナーとして登録 Key.addListener(key_obj); //------------------------------------------- me["sound_obj" + i] などで使っている [ ] を「配列アクセス演算子」と言います。 また，各キーとキーコードには次のような規則性があります。 キーA=コード65→ 65+0 キーB=コード66→ 65+1 キーC=コード67→ 65+2 キーD=コード68→ 65+3 キーE=コード69→ 65+4 キーF=コード70→ 65+5 キーG=コード71→ 65+6 キーH=コード72→ 65+7 キー0=コード96→ 96+0 キー1=コード97→ 96+1 キー2=コード98→ 96+2 キー3=コード99→ 96+3 キー4=コード100→ 96+4 キー5=コード101→ 96+5 キー6=コード102→ 96+6 キー7=コード103→ 96+7 この規則性を利用してスクリプトを簡素化しています。
OSとの相性の問題ではないでしょうか。 「Windows7でmp3をsuzukaにぶち込むと落ちるのを改善する方法」 http://meteoblog-tana.com/?eid=115 「suzukaにflv,mp3が使えない FlashのQ&A【OKWave】」 http://okwave.jp/qa/q3544231.html 「Vistaでsuzukaを使うときは互換モードを98/Meに」 http://www.uneidou.com/907.php 「FAQ-7 - suzuka Wiki」 http://wikiwiki.jp/suzuka/?FAQ%2F7 > •MP3、WAVを取り込もうとすると、Suzukaが強制終了する。 > Suzukaを右クリック→プロパティの互換性で、 > 互換モードをWindows98/Meに設定するとできるようになるらしい。 > それ以外だと同様に強制終了するそうです。
for (var i:int=0; i<9; i++) ↑これは 0～8 で getChildByName("ka_do○") ↑この○は 0～3 で ka[●] ↑この●」は 0～4 で という具合に数が全然合っていません。 また //マイナス３ とか //マイナス２ とか //マイナス１ これらの意味がさっぱりわかりませんが。。。 つまり規則性が見いだせません。 また「ka_do」 とは ムービークリップ なのか ボタン なのか スプライト なのか その他全く別のものかもわかりません。 　 何だか良くわかりませんが 次のような感じで良いのでしょうか？ 仮にライブラリの中には ka_doClass というクラス名を付けたムービークリップを用意したものとします。 その場合のスクリプト例(全文)↓ //------------------------------------ //↓適当な付け足し↓ var ka:Array=new Array(9); //↑適当な付け足し↑ for (var i:int=0; i<9; i++) { //↓適当な付け足し↓ var ka_do = new ka_doClass(); ka_do.x=i*50; //↑適当な付け足し↑ ka_do.name="ka_do"+i;//連番名にする addChild(ka_do); getChildByName("ka_do"+i).addEventListener(MouseEvent.CLICK, K_m); } function K_m(e:MouseEvent):void { ka[Number(e.currentTarget.name.substr(5))]=1; //↓適当な付け足し↓ trace("出力テスト…" + ka); //↑適当な付け足し↑ } //------------------------------------ ※ なお 　インスタンス名などを使わずに 　Dictionaryクラス や 　関数クロージャ などを使った方が 　もっと汎用的なものが作れると思います。 「第32回　Dictionaryクラスを使う」 http://gihyo.jp/dev/serial/01/as3/0032
こんにちは。#1です。 自分の環境（Win7/SP1, Flash Professional 6, フォルダをデスクトップ上に配置）で、以下の処理を行いました。 flashmo_085_news_list.xml に部分的に日本語を入れる。 flashmo_085_stylish.fla の中の、News用ムービークリップ内部のテキストフィールドのフォント設定を、"_ゴシック"、"等幅"、"メイリオ"いずれにしても、日本語が表示されました。 （面倒くさいので埋め込みは試していません） Flash上、swf再生、html再生いずれもOKです。
> スクリプトは2.0か3.0しか使用経験がないので、 > どちらかですと助かります。 ActionScript 1.0 を拡張したのが 2.0 であって ActionScript 2.0 がわかれば同時に ActionScript 1.0 もわかるということになります。 ActionScript 3.0 は 2.0 や 1.0 とは違います。 というわけで何だかよくわかりませんが 適応範囲の広い ActionScript 2.0 で回答することにします。 まず「音楽」は すでに Flash(FLAファイル) のライブラリ内に読み込まれていて そのライブラリ内の「音楽」シンボル に 「識別子」として「mySound」という名前を付けているものとします。 ※参考↓ 「FN0402003 - Sound.attachSound()メソッド - Flash テクニカルノート」 http://www.fumiononaka.com/TechNotes/Flash/FN0402003.html 単に音楽を鳴らすだけでしたら 上のページに書かれてある３行のスクリプト(ActionScript 1.0)で音は鳴りはじめます。 ですから上のページのスクリプトを キーボード操作で実行させるようにすれば良いと言うことになります。 というわけで テンキーの「5」が押された２秒後に音楽を流す場合の フレームに書くスクリプト例です↓。 //========================================== //キーを監視させるオブジェクトを作成 var key_obj:Object = new Object(); //キーの状態を示すフラグを用意 var key_flg:Boolean = false; //インターバルIDを入れる変数の宣言 var id:Number; //Soundオブジェクト をこのタイムラインに作成 var my_sound:Sound = new Sound(this); //Soundオブジェクト に「mySound」を割り当てる my_sound.attachSound("mySound"); //キーを押したときに実行する関数の定義 key_obj.onKeyDown = function():Void { //もし key_flg が false であり if (!key_flg) { //もし押されたキーがテンキーの「5」であれば if (Key.getCode() == 101) { //２秒(2000ミリ秒)後に intervalFunc を実行 id = setInterval(intervalFunc, 2000); } // key_flg を true にする key_flg = true; } }; //キーを放したときに実行する関数の定義 key_obj.onKeyUp = function():Void { // key_flg を false にする key_flg = false; //my_sound の再生を停止 my_sound.stop(); //setInterval を解除 clearInterval(id); }; //インターバルを開けて実行する関数の定義 function intervalFunc():Void { //my_sound の再生を開始(0秒から，1000回ループ) my_sound.start(0, 1000); //setInterval を解除 clearInterval(id); } //key_obj を Key のリスナーとして登録 Key.addListener(key_obj); //========================================== ◎ActionScript 2.0 　 Flash MX 2004 以降で使用可 　 Flash Player 6 以上でパブリッシュ可 なお， HTML に貼り付けた Flash(SWF) をブラウザで閲覧する場合 その Flash にフォーカスが当たっていないと Flash でキーボードイベントは受け取れません。 したがって Flash 内に「スタート」ボタンを置いて閲覧者に一度 Flash をクリックしてもらうとか 何かそういう工夫をする必要があります。 Google検索例「Flash フォーカス」 http://www.google.co.jp/search?hl=ja&source=hp&q=Flash+%E3%83%95%E3%82%A9%E3%83%BC%E3%82%AB%E3%82%B9
照合結果を記録する配列変数 score_tbl は、選択するべき項目と一致した数（ check_on フィールドの値）が”多い順に”並べ替えられます。 これは、先頭の要素である０番に、一致した数の最大値が配置されるということです。 従って、check_on フィールドの値が score_tbl[ 0 ].check_on と同じ値である要素を抜き出すと、一致した数が最も多かった要素を全て抜き出すことができます。 スクリプトの一例です。 （↓　各行頭に全角のスペースが入っています。コピーする際は、全て半角のスペースかタブに置き換えてください） //＊＊＊ 　/* 　　初期設定 　*/ 　//チェックボックスの選択状況を格納する配列 　var check_status:Array = new Array(); 　//チェックパターンデータ 　//最後の要素はパターン名 　var check_ptt:Array = 　[ 　 [ 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , "サンプルＡ" ] , 　 [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , "サンプルＢ" ] , 　 [ 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , "サンプルＣ" ] 　]; 　//評価を格納する配列 　var score_tbl:Array = new Array(); 　//完全一致を検出する変数 　//-1の時は完全一致なし、 　//完全一致の時は配列のインデックス番号が入る 　var match:Number = -1; 　//チェックボックスの総数 　var box_max:Number = 9; 　//チェックボタンが配置されているタイムラインを保持 　var box_line:MovieClip = this; 　/* 　　照合の処理 　*/ 　function Check_Compare():Void 　{ 　　var i:Number , j:Number; 　　var score:Number , check_score:Number; 　　//完全一致を検出する変数をリセット 　　match = -1; 　　//選択状況とパターンを総当たりで照合する 　　for( i = 0 ; i < check_ptt.length ; i++ ) 　　{ 　　　//評価をリセット 　　　score = 0; 　　　check_score = 0; 　　　//項目ごとのパターンと照合 　　　for( j = 0 ; j < box_max ; j++ ) 　　　{ 　　　　//選択するべき項目との一致を照合 　　　　//両方とも１（選択されている）である場合、評価が+1、それ以外は加算されない 　　　　check_score += check_ptt[ i ][ j ] & check_status[ j ]; 　　　　//選択するべきではない項目も合わせた総合評価 　　　　//一致していた場合、評価が+1、それ以外は加算されない 　　　　score += Number( check_ptt[ i ][ j ] == check_status[ j ] ); 　　　} 　　　//完全一致判定 　　　//完全一致（＝scoreが項目の総数と同じ）の場合、インデックスを記録する 　　　if( score == box_max ) 　　　{ 　　　　match = i; 　　　} 　　　//評価を記録する配列変数に結果を記録 　　　//フィールド名 　　　//　ptt_ref：パターンへの参照 　　　//　check_on:選択するべき項目と一致した数 　　　//　total_score:総合評価 　　　score_tbl[ i ] = { ptt_ref : check_ptt[ i ] , check_on : check_score , total_score : score }; 　　} 　　//完全に一致しているパターンがある場合は、それを出力 　　if( match != -1 ) 　　{ 　　　trace( "完全一致 : " + check_ptt[ match ][ box_max ] ) 　　} 　　//完全一致がない場合は、選択するべき項目が一致していた数が 　　//多かったパターンをすべて抜き出す 　　else 　　{ 　　　Judge(); 　　} 　} 　/* 　　照合結果を評価する処理 　*/ 　function Judge():Void 　{ 　　var i:Number; 　　var high:Number; 　　var flags:Number; 　　//照合結果を、評価の高い順に並べ替え 　　//選択するべき項目と一致した数が多いものほど高評価 　　//同点の場合は総合評価で優劣を決める 　　flags = Array.NUMERIC | Array.DESCENDING; 　　score_tbl.sortOn( [ "check_on" , "total_score" ] , [ flags , flags ] ); 　　//選択するべき項目が一致している数の最大を求める 　　//最大値とは、配列変数の先頭に並んでいるcheck_onの値のこと 　　high = score_tbl[ 0 ].check_on; 　　//最大値と同じ一致数を持つパターンを抜き出す 　　for( i = 0 ; score_tbl[ i ].check_on == high ; i++ ) 　　{ 　　　/*ここに、抜き出したパターンを 　　　　　利用する処理を書く*/ 　　　trace( "パターン名 : " + score_tbl[ i ].ptt_ref[ box_max ] ); 　　} 　} //＊＊＊ 紙面の都合上、ボタンの処理を省略させていただきました。 スクリプトの解説です。 同じパターンがないものとすると、完全に一致する場合は１つしかないはずです。 完全一致は、検出するための変数を用意して考えます。上記のスクリプトでは match という変数です。 照合を始める前に、match の初期値を仮に -1 と決めます。 １つのパターンとの照合が終わった時点で、完全に一致していた場合は match にパターンのインデックス番号を入れます。 照合が全て終わった後、完全に一致したものがあれば match にはパターンの番号が入っていますが、なかった場合は、match は -1 のままです。 この点を利用して、match の値をもとに完全に一致したパターンを出力することができます。 完全に一致したものがない場合は、score_tbl の値を check_on フィールドに注目して並べ替え、最大値を持つ要素を全て抜き出します。 上記のスクリプトでは、Judge という関数内でこの処理を行います。 ActionScript の for ループは、２番目に記述した条件が成立している間、ループが継続する仕組みです。 if 文の機能を併せ持っているようなものですから、条件を工夫すると、単純に繰り返すだけでなく、様々な状況を判断しながら効率よく処理を進めることができます。 ループの条件を「 check_on フィールドの値が最大値と同じである間」と定めると、最大値と異なる check_on の値を持つ要素が出てくるまでループが継続します。 score_tbl の要素は check_on の値が大きい順に並ぶので、最大値を持つ要素は必ず連続して配置されます。 合わせますと、ループが継続している間は、ｉ の値を利用して最大値を持つ要素だけを抜き出すことができます。 なお、No.7608367 では score_tbl の ptt_no フィールドにパターンの番号（配列変数 check_ptt のインデックス）を入れていましたが、今回は各要素の参照を入れて、score_tbl[ 番号 ].ptt_ref で該当するパターンを直接参照できるように変更してみました。 フィールドの名前や参照の方法が変わりましたので、ご注意ください。 ***** 前回も不明だったのですが。 一致している、というと、「選択するべきではない項目を”選択しなかった”」ことも正解といえるはずですが、これについてはどのように評価するのでしょうか？ 完全一致以外の場合、「選択しなかった」ことによる正解数を評価する必要がないのでしたら、score_tbl に総合評価を記録する必要はなく、並べ替えも check_on フィールドにのみ注目して行うだけで済みます。
コンストラクタ中にインスタンスメソッドを呼び出しているため、インスタンス未生成で空振りしている気がします。 loadイベントを定義して、インスタンス生成時に正しくメソッドを叩けばいいいかもしれません。 // コンストラクタ // 常識的にはクラスおよびコンストラクタメソッドはPascalCase public function MyButton(){ 　addEventListener('load', onLoadMC); } public function onLoadMC(){ 　addEventListener(Event.CHANGE,myButton_Change); 　Change(); } 使っているマシンにFlashがインスコされてなくて試せていません。 外していたらごめんなさい。
そもそも、Flashはhtmlの内部に設置されていますので、描画の開始がワンポイント遅れます。 ただ、ご質問の「サイズの違い」ですが、そのFlashには、おそらく内部で使用している「フォント」のアウトライン（字形）が読み込まれています。 Flash側でフォントを「デバイスフォント」に指定しますと、ターゲットPC上のフォントを使用するようになるため、サイズも描画速度も向上すると思います。 また、Flash側で、"_ゴシック"や"_明朝"などの、ブラウザデフォルトフォント指定を行っても、字形は埋め込まれないため、サイズ・描画速度とも大幅に改善されます。 いずれにせよ、FlashファイルはHTMLへのアドオンですし、比較にならないほど「リッチ」な環境を持ち込むので、速度的には劣って当然かと思います。 複雑なhtmlに対し、ブラウザでAjax動作をさせると、Flashのほうが速いことも多いですが。 要は内容次第です。
簡単に考えるなら mc2 の 24フレーム目 スクリプトを 次のようにすれば良いでしょう。 mc3.y=260 - this.y; mc3.x=MovieClip(parent).mc1.x - this.x; この場合の this は mc2 (mc3 の親) です。 その mc2 の座標を引けば良いだけですね？ ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ または globalToLocal を使って 次のようにするとか。 var point1:Point = new Point(MovieClip(parent).mc1.x, 260); mc3.y=this.globalToLocal(point1).y; mc3.x=this.globalToLocal(point1).x;
＃１です。 > そして子のタイムラインの5フレーム目に > > trace("孫スタート"); > 孫.play(); > this.gotoAndStop(1); と書かれていらっしゃいましたね。 私が「子のタイムライン」という部分を見過ごしていました。 すみません。 スクリプトを「子のタイムライン」に書かれたのでしたら それで(書かれていらっしゃる通りで)合ってます。 うまく行かない(孫内のタイムラインが動かない)のは変なので もっと単純なものを作って実験してみることをお薦めします。 (孫内のタイムラインのみを複数フレームにして子や親のライムラインは１フレームのみにしてみるとか。) とにかくもっと『単純化』してみてください。
マウスオーバー時に trace(str); で出る str は 文字列 ですよ。 そういう意味があるからこそ 変数名に str(String の略) という名前を命名されているのではないのでしょうか？ とにかく マウスオーバー時に出力される 変数 str に代入されるところの e.target.name; とは イベント「e」が発動されたターゲット「target」の名前「name」の文字列です。 「文字列に命令する」という事自体が変でしょう？ どうしたいのか(何を意図しているのか)さっぱりわかりませんが とりあえず１つの修正案のいくつかを書きます。 ◎修正案１ //-------------------------------------------------- addEventListener (MouseEvent.MOUSE_OVER,getname); function getname (e:MouseEvent) { var str = e.target.name;//マウスカーソルを乗せたムービークリップのインスタンス名が出ます。 } addEventListener (MouseEvent.MOUSE_DOWN, onMouseDown); function onMouseDown (e:MouseEvent) { e.target.startDrag (); } addEventListener (MouseEvent.MOUSE_UP, onMouseUp); function onMouseUp (e:MouseEvent) { e.target.stopDrag (); } //-------------------------------------------------- ◎修正案２ //-------------------------------------------------- addEventListener (MouseEvent.MOUSE_OVER,getname); function getname (e:MouseEvent) { var str = e.target.name;//マウスカーソルを乗せたムービークリップのインスタンス名が出ます。 addEventListener (MouseEvent.MOUSE_DOWN, onMouseDown); function onMouseDown (e:MouseEvent) { e.target.startDrag (); } addEventListener (MouseEvent.MOUSE_UP, onMouseUp); function onMouseUp (e:MouseEvent) { e.target.stopDrag (); } } //-------------------------------------------------- ◎修正案３ //-------------------------------------------------- addEventListener (MouseEvent.MOUSE_OVER,getname); function getname (e:MouseEvent) { var str:String = e.target.name;//マウスカーソルを乗せたムービークリップのインスタンス名が出ます。 addEventListener (MouseEvent.MOUSE_DOWN, onMouseDown); function onMouseDown (e:MouseEvent) { MovieClip(getChildByName(str)).startDrag (); } addEventListener (MouseEvent.MOUSE_UP, onMouseUp); function onMouseUp (e:MouseEvent) { MovieClip(getChildByName(str)).stopDrag (); } } //-------------------------------------------------- ◎修正案４ //-------------------------------------------------- var str:String; addEventListener (MouseEvent.MOUSE_OVER,getname); function getname (e:MouseEvent) { str = e.target.name;//マウスカーソルを乗せたムービークリップのインスタンス名が出ます。 addEventListener (MouseEvent.MOUSE_DOWN, onMouseDown); function onMouseDown (e:MouseEvent) { MovieClip(getChildByName(str)).startDrag (); } addEventListener (MouseEvent.MOUSE_UP, onMouseUp); function onMouseUp (e:MouseEvent) { MovieClip(getChildByName(str)).stopDrag (); } } //-------------------------------------------------- ◎参考URL「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html
その揺らす「ゲーム画面」とは 作成した Flash 内部全体ということでしょうか？ 良くわからないので とりあえずそういうことで話を進めます。 当然ながら「画面を揺らす」という関数やメソッド(イベントリスナー)は存在しないわけですから， 「画面を揺らすとはどういうことであるのか」を自分自身で考えて定義し それをスクリプトとしてコーディングして行く必要があると思います。 下のスクリプト例は 私が「画面を揺らすとはどういうことであるのか」を考えて定義してみた例です。 ステージ上に適当に何かを配置して (何かを置かないと振動の様子が見えないため) メインのタイムラインのフレーム1に書くスクリプトです。 //============================================= //Timerインスタンス「vibrate_tm」を作成 //(20 ミリ秒間隔で 100 回実行) var vibrate_tm:Timer=new Timer(20,100); //Timerインスタンスに振動させるイベントリスナーを登録 vibrate_tm.addEventListener(TimerEvent.TIMER,vibrateStage); //振動させるイベントリスナーの定義 function vibrateStage(e:TimerEvent) { //メインタイムラインの座標をランダムな±5にする root.x=Math.random()*10-5; root.y=Math.random()*10-5; //表示を即更新 e.updateAfterEvent(); } //振動を開始させるイベントリスナーの定義 function startVibration(e:Event) { //タイマーをリセット vibrate_tm.reset(); //タイマー開始 vibrate_tm.start(); } //---↓仮の振動開始イベント↓---- //ステージ上でマウスアップしたときに振動開始 stage.addEventListener(MouseEvent.MOUSE_UP,startVibration); //============================================= 上では 「仮の振動開始イベント」 として Flash の画面の任意の位置でマウスアップ(クリック)したときに Flash の画面全体を動かすようにしています。 実際には何が起こったときに振動を開始させるのかは知りません。 もし仮に 「上のスクリプトを書いたフレームが表示されたときに振動を開始」させるのでしたら 最後のイベントリスナーなどは不要になって 次のようにもっと短くなります↓。 //============================================= //Timerインスタンス「vibrate_tm」を作成 //(20 ミリ秒間隔で 100 回実行) var vibrate_tm:Timer=new Timer(20,100); //Timerインスタンスに振動させるイベントリスナーを登録 vibrate_tm.addEventListener(TimerEvent.TIMER,vibrateStage); //振動させるイベントリスナーの定義 function vibrateStage(e:TimerEvent) { //メインタイムラインの座標をランダムな±5にする root.x=Math.random()*10-5; root.y=Math.random()*10-5; //表示を即更新 e.updateAfterEvent(); } //タイマー開始 vibrate_tm.start(); //============================================= 　 ※ なお... 揺らす「ゲーム画面」とは Flash 内部ではなくて 「HTML に貼り付けた Flash 自体」だったり 「ブラウザごと」揺らすような場合でしたら ActionScript ではなく JavaScript などになりますよ。 (もし「パソコンのモニタ」を揺らすのでしたら ActionScript でも JavaScript でも無理でしょう。)
ActionScriptは一応、Javaの流れをくむオブジェクト指向言語ですので、不要になったオブジェクトや変数を明示的に開放する必要はありません。 システムが適当なタイミングでガベージコレクションをやってくれます。 ただし、AS3では、イベントリスナは、その対象になっているオブジェクトが消滅しても残り続けるので、明示的にremoveEventListenerで開放しなければいけません。 この仕様はバグっぽい面もあるので、のちのFlashPlayerでは改善されると思いますが。
＃１です。 > Error #2101: URLVariables.decode() に渡される文字列は、 > 名前/値のペアを含む、URL エンコーディングされたクエリー > 文字列でなければなりません。 > となります。 そう出るのでしたら URL エンコーディング すれば良いのではないでしょうか↓ dataObj.search_id =escape(MovieClip(root).search_id.text); dataObj.search_pass = escape(MovieClip(root).search_pass.text);
このような半透明なモーダルを重ねるだけなら、2,3個のアクションスクリプトを利用して作ることになります。 やり方を覚えれば１つのページ遷移は初心者でも１時間もあれば作れます。
> 表示したい内容は「□□まであと○○日です。」という感じです。 それだと， 「日数」までで良いということになりますから そもそも int が絡む部分(時や分を求める部分)は不要になりますよね？ したがって ActionScript 2.0 にするには イベントリスナー の部分を イベントハンドラメソッド に変える部分が 大きな修正箇所になると思います。 //----------------------------------------------- //---テキストフィールド「cd_txt」を用意--- //(引数："インスタンス名", 深度, x座標, y座標, 幅, 高さ) createTextField("cd_txt", 0, 20, 10, 0, 0); //適当に設定 cd_txt.border = true; cd_txt.background = true; cd_txt.autoSize = "left"; //---開催の日時を設定--- //例：2012年10月20日 午前0時0分0秒 var open_date:Date = new Date(2012, 9, 20, 0, 0, 0); //開催日時の1970年1月1日からの経過ミリ秒数を取得 var open_time:Number = open_date.getTime(); //今の日時オブジェクトの宣言 var now_date:Date; //1フレーム進む時間毎に実行するイベントハンドラメソッドの定義 this.onEnterFrame = function():Void { //今の日時を取得 now_date = new Date(); //今の1970年1月1日からの経過ミリ秒数を取得 var now_time:Number = now_date.getTime(); //開催日と今の差分ミリ秒数を算出 var diff_time:Number = open_time - now_time; //カウントダウンする日数を取得(小数点以下切り上げ) var cd_days:Number = Math.ceil(diff_time/(24*60*60*1000)); cd_txt.text = "□□まであと" + cd_days + "日です。"; }; //-----------------------------------------------
eventObj.targetでまとめます。以下でどうでしょう。 function hiraku(eventObj:MouseEvent):void { //mc0を["mc"+i]としまとめて処理したい twObj=new Tween(eventObj.target,"rotation",Regular.easeInOut,0,30,1,true); } function modoru(eventObj:MouseEvent):void { //mc0を["mc"+i]としまとめて処理したい twObj=new Tween(eventObj.target,"rotation",Regular.easeInOut,30,0,1,true); }
お持ちの Flash 作成ソフトの(ソフト名やその)バージョン も さらには 使用する ActionScript のバージョンも全く書かれていないため 非常に回答しにくいわけですが。。。。。。。。。 (Flash 作成で何が最重要なのかをわかっていらっしゃらないような。) ソフトやバージョンはともあれ Flash ムービー内の拡大縮小を無しにして さらにステージの左上(0，0)を基準に整列する設定にした上で さらに全てのインスタンス(メニューとかボタンとか全て)の座標をActionScriptでコントロールするのです。 ActionScript 1.0 や 2.0 の場合は 次のページが全ての基本を押さえていると思います。 「Flashゲーム講座＆ASサンプル集【Flash の画面表示について】」 http://hakuhin.jp/as/stage.html ActionScript 3.0 の場合は 次のページが全ての基本を押さえていると思います。 「FlashゲームPG講座 For AS3.0【Stage クラスについて】」 http://hakuhin.jp/as3/stage.html Adobe Flash ではなく 例えば Suzuka を使用して ActionScript 1.0 で行く場合は次のページを熟読＆実践するとか。 「Suzuka 基礎・基本 フル画面Flash (Stageクラス)」 http://suzupara.iinaa.net/kiso411.html 逆にすんごく大まかに言えば 「リキッドデザイン」とか「リキッドレイアウト」という言葉と 「Flash 」などという言葉を足し算して検索すれば良いと思います。 Google検索「リキッドデザイン Flash」 http://www.google.co.jp/search?sourceid=navclient&ie=UTF-8&q=%e3%83%aa%e3%82%ad%e3%83%83%e3%83%89%e3%83%87%e3%82%b6%e3%82%a4%e3%83%b3+Flash
検証などしていませんが フレームのイベントとして 最初に fscommand2("FullScreen", true); と書けば良いのではないでしょうか。
>（ループはしてもしなくてもよいです。） ということですから 例えば「送るボタン」には「next_btn」というインスタンス名を付け 「戻るボタン」には「prev_btn」というインスタンス名を付けた場合 スクリプトを次のように変更すれば良いでしょう(変更例)↓ //------------------------------------------------- // タイムライン: メイン // MovieClipインスタンス // サムネイル: button0_mc～button2_mc(★変更) // 前へ・次へ: prev_btn , next_btn(★追加) // 表示画像: my0_mc～my2_mc // フレームアクション var glow:GlowFilter = new GlowFilter(0x000033); var dropShadow:DropShadowFilter = new DropShadowFilter(); var filters_array:Array = [glow,dropShadow]; //カウンタ用変数を用意(★追加) var cnt:int = 0; // 新規Objectインスタンスの生成 var showList:Object = new Object(); // インスタンス名のプロパティに対応する //[インスタンスの参照，番号] を要素にもつ配列を格納(★変更) showList.button0_mc = [my0_mc,0]; showList.button1_mc = [my1_mc,1]; showList.button2_mc = [my2_mc,2]; button0_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); button1_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); button2_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); //prev_btnクリック時に関数prevShowを実行(★追加) prev_btn.addEventListener(MouseEvent.CLICK,prevShow); //next_btnクリック時に関数nextShowを実行(★追加) next_btn.addEventListener(MouseEvent.CLICK,nextShow); function xShow(eventObject):void { // Objectからインスタンス名のプロパティに納められた対応する参照を得る var show_mc:MovieClip = showList[eventObject.currentTarget.name][0]; // Objectからインスタンス名のプロパティに納められた対応する番号を得る(★追加) cnt = showList[eventObject.currentTarget.name][1]; xClearAll(); show_mc.visible = true; show_mc.filters = filters_array; } //関数prevShowの定義(★追加) function prevShow(e:MouseEvent):void { //もしcntが0より大きければcntを-1する cnt = (cnt > 0) ? cnt-1:cnt; //関数xClearAllを実行 xClearAll(); //my○_mc を表示してフィルターをかける this["my" + cnt + "_mc"].visible = true; this["my" + cnt + "_mc"].filters = filters_array; } //関数nextShowの定義(★追加) function nextShow(e:MouseEvent):void { //もしcntが2未満であればcntを+1する cnt = (cnt < 2) ? cnt+1:cnt; //関数xClearAllを実行 xClearAll(); //my○_mc を表示してフィルターをかける this["my" + cnt + "_mc"].visible = true; this["my" + cnt + "_mc"].filters = filters_array; } xClearAll(); function xClearAll():void { my0_mc.visible = false; my1_mc.visible = false; my2_mc.visible = false; my0_mc.filters = []; my1_mc.filters = []; my2_mc.filters = []; } //------------------------------------------------- ※ ★マークを付けた辺りを変更・追加しています。 【注釈１】 //もしcntが0より大きければcntを-1する cnt = (cnt > 0) ? cnt-1:cnt; などにある「?:」を三項演算子と言います。 もしわからない場合は Google などで「ActionScript 三項演算子」などと検索してみてください。 【注釈２】 //my○_mc を表示してフィルターをかける this["my" + cnt + "_mc"].visible = true; などにある [] を配列アクセス演算子と言います。 もしわからない場合は次のページなどをご参考に。 「ドット演算子と配列アクセス演算子 - Flash テクニカルノート」 http://www.fumiononaka.com/TechNotes/Flash/FN1107002.html ( http://www.fumiononaka.com/TechNotes/Flash/FN0507001.html )
具体的にどのようなことをしようとされているのかよくわかりませんが とりあえずボタン(SimpleButton クラスのインスタンス)の入れ子はできません。 MC(ムービークリップ)の中にMCを入れたり，MCの中にボタン(SimpleButton クラスのインスタンス)を入れることはできます。 > AS3では、_rootが使えないので、どうしたらよいのか分かりません。 _root は使えませんが root でしたら使えます。 ただ root と書いても 表示オブジェクト と捉えられるだけの場合が多いですから 「MCである root のことだよ。」と明示する必要があります。 もし ActionScript 2.0 以下で 「_root.MC2.○○;」 のような命令が通じる状況でしたら ActionScript 3.0 では 「MovieClip(root).MC2.○○;」 とすると通じる場合が多いです(ただし外部SWFをロードする場合を除く) Gogle検索例「MovieClip(root) as」 http://www.google.co.jp/search?hl=ja&ie=UTF-8&q=MovieClip%28root%29+as (as は ActionScript の意味ではなく as(アズ) です。)
書かれていらっしゃる http://gihyo.jp/dev/serial/01/as3/0032?page=1 の本題は page=2 の方の Dictionaly クラスを使うということですが そのページの本題の件は全く抜きにして(全く無視して)， page=1 の方に書かれている状況と page=1 の最後のスクリプトを利用する方針で行くという意味ですか？ 良くわかりませんので， とりあえずはそういう方向(page=2 は無視する方向)で回答します。 　 そしてさらに page=1 の最後のスクリプトですが 最初の前文とスクリプト本体にあるインスタンス名とがずれています。。。 > // サムネイル: thum0_mc～thum2_mc .　↓ずれている↑ > button0_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); つまりどちらかが間違っているということですが 前文の方が間違っているということにします。 　 というわけで クロスフェードさせる場合のスクリプト変更例です↓ //------------------------------------------ // タイムライン: メイン // MovieClipインスタンス // サムネイル: button0_mc～button2_mc // 表示画像: my0_mc～my2_mc // フレームアクション //Tweenクラスとeasingクラスのインポート import fl.transitions.Tween; import fl.transitions.easing.*; var glow:GlowFilter = new GlowFilter(0x000033); var dropShadow:DropShadowFilter = new DropShadowFilter(); var filters_array:Array = [glow,dropShadow]; var showList:Object = new Object();// 新規Objectインスタンスの生成 button0_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); button1_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); button2_mc.addEventListener(MouseEvent.ROLL_OVER, xShow); // インスタンス名のプロパティに対応するインスタンスの参照を格納 showList.button0_mc = my0_mc; showList.button1_mc = my1_mc; showList.button2_mc = my2_mc; //my○_mc の表示順を一旦下に沈めておく setChildIndex(my0_mc,0); setChildIndex(my1_mc,0); setChildIndex(my2_mc,0); function xShow(eventObject):void { // Objectからインスタンス名のプロパティに納められた対応する参照を得る var show_mc:MovieClip = showList[eventObject.currentTarget.name]; //子表示インスタンスの数を得る var child_n:int = numChildren; //もし対応する my○_mc の表示順が一番上でなければ if (getChildIndex(show_mc) != child_n - 1) { //対応する my○_mc の表示順を一番上にする setChildIndex(show_mc,child_n - 1); //対応する my○_mc のアルファを 0 から 1 に 1.2 秒でトゥイーンさせる new Tween(show_mc,"alpha",None.easeNone,0,1,1.2,true); } } xClearAll(); function xClearAll():void { my0_mc.alpha = 0; my1_mc.alpha = 0; my2_mc.alpha = 0; my0_mc.filters = filters_array; my1_mc.filters = filters_array; my2_mc.filters = filters_array; } //------------------------------------------ 現状では切り替える my○_mc が３枚しかないため あまり早くグチャグチャと切り替えるとクロスフェードが変になります。 その点は御容赦ください。
前置きとして msg.text = String(event.delta); とは何でしょうか？？？ なぜそこにそんなもの(delta)がそこ登場するのかわからないので とりあえず上の１行は無かったものとして無視します。 > マウス右移動では、右回転に。 > マウス左移動では、左回転にしたいのですが・・・。 そう書かれましても 具体的にどのように動かしたいかによって 考え方やスクリプトは変わりますよ。。。 例えば次のような感じにしたいということでしょうか？ //---スクリプト全文例---------------------- //過去のマウスの座標を保存する変数を用意 var old_mouseX:Number = stage.mouseX; //マウスが動いたときに以下の function を実行 stage.addEventListener(MouseEvent.MOUSE_MOVE, function(event:MouseEvent){ //現在のマウスの座標を取得 var new_mouseX:Number = stage.mouseX; //現在と過去のマウスの座標の差に適当な定数を掛けた値を取得 var rot_speed:Number = (new_mouseX - old_mouseX)*1.5; //「mc」の回転をその角度だけ加算 mc.rotation += rot_speed; //現在のマウスの座標を過去のマウスの座標として保存 old_mouseX = new_mouseX; }); //----------------------------------------- ※注 mc.addEventListener(Event.ENTER_FRAME, function(event){…}); の部分を書いていないのは， 省略しているわけではなくて，不要なので削除しています。 　 　 ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ ＝＝＝ または， わざわざ mc.addEventListener(Event.ENTER_FRAME, function(event){…}); を用意されたのは 本当は回転する動きに重石を付けたかったからでしょうか？ つまり 例えば次のような感じにしたかったのでしょうか？ //---スクリプト全文例---------------------- //過去のマウスの座標を保存する変数を用意 var old_mouseX:Number = stage.mouseX; //回転の目標角度を入れる変数を用意 var target_rotation:Number = mc.rotation; //ダミーの角度を入れる変数を用意 var dummy_rotation:Number = mc.rotation; //マウスが動いたときに以下の function を実行 stage.addEventListener(MouseEvent.MOUSE_MOVE, function(event:MouseEvent){ //現在のマウスの座標を取得 var new_mouseX:Number = stage.mouseX; //現在と過去のマウスの座標の差に適当な定数を掛けた値を取得 var rot_speed:Number = (new_mouseX - old_mouseX)*1.5 ; //回転の目標角度をその角度だけ加算 target_rotation += rot_speed; //現在のマウスの座標を過去のマウスの座標として保存 old_mouseX = new_mouseX; }); //１フレーム進む時間ごとに毎回以下の function を実行 mc.addEventListener(Event.ENTER_FRAME, function(event){ //ダミーの角度を目標角度に 1/8 ずつ近づける dummy_rotation += (target_rotation-dummy_rotation)/8; //「mc」の回転をその角度にする mc.rotation = dummy_rotation; }); //----------------------------------------- ※注 rotation は -180～180 の間の角度になります。 したがって直接 mc.rotation を加算減算すると 回転する動きがおかしくなるので ダミーの角度を 加算減算 しておいた上で mc.rotation をそのダミーの角度にするようにしています。 以上， 具体的にどのように動かしたいかがわからなかったため 一応２つのスクリプト例を回答してみました。
ご質問で書かれていらっしゃる「素材」の方のページの最後に次のような文があります。 > 設定ファイルはswfファイルと同じフォルダ内に配置し、 > 名前は「cubicmenubar.txt」になります。 厳密に言えばこの文は間違っています。 SWFファイル(Flashファイル)は HTML に貼り付けて閲覧するわけですが ここで書かれている設定ファイルの「cubicmenubar.txt」は その SWFファイル を貼り付けた HTML と同じフォルダに置く必要があります。 ※SWFファイルと HTML とが同じフォルダにある場合に限って 　設定ファイルである「cubicmenubar.txt」を 　SWFファイルと同じフォルダ内に配置することになります。 SWFが素材ではなく自分自身で作ったものでしたら 「cubicmenubar.txt」を読み込むパスを http から始まる絶対パスにするなど他の方法もありますが SWFが素材であるため絶対パスでの指示はできませんから 相対パスで指示しているはずです。 運営されているGoogleサイトとは どのような仕組みやどのようなファイル構造になっているのかわかりませんが もし全く別フォルダにある複数の HTML に同じ SWF を貼り付ける場合は その HTML が存在する全てのフォルダ内に「cubicmenubar.txt」を置くような必要が出てきます。
こんにちは。 通常はflaという拡張子のファイル(書き出し前の編集用ファイル)をFlash作成ソフトで開いて写真の入れ替えをします。 またはタグの定義等で読み込むようにしていればそこの画像を差し替えるだけですが、おそらく前者の作りの方が多いと思います。 aaa.flaというファイルをクライアントからもらって、フラッシュ作成ソフトで編集してください。 また、なんのソフトを使って作成されたものか聞いたほうが良いです。 ActionScriptが利用されているとバージョンが合わなかったりするかもしれません。
わからないのは当然だと思います。 元からそのスクリプト(プログラムの考え方)が間違っています。 (間違っているものの説明などできない(する気はしない)ので説明は省略しますが。) スクリプトが間違っていることの実証として m_kazu を 4 固定として下のコードで確かめてみました。 //-------------------------- m_kazu = 4; for (i=1; i<=m_kazu; i++) { /*出現する場所をランダムにしてmyNumberに格納*/ eval("myNumber" add i) = random(9)+1; /*ランダムな数字が重ならないように*/ for (j=1; j<=m_kazu; j++) { while (eval("myNumber" add i) == eval("myNumber" add (i-j))) { eval("myNumber" add i) = random(9)+1; } } } trace(myNumber1 add myNumber2 add myNumber3 add myNumber4); //-------------------------- 上記スクリプトの20回試行で trace 出力より次のようなデータが得られました。 5343←× 8719 5643 1378 2375 9878←× 7685 3512 3647 4578 3615 9514 2183 2495 2779←× 5432 8667←× 8527 7954 9286 同じ数字が出にくくなっているだけのことで実際には同じ数字は出ます。 (また無限ループ(半無限ループ)に陥る可能性も秘めています。) こんなのダメでしょう。 　 Flash Lite 1.x には function や Array などはありませんからそのままは使えませんが 次のページを参考にする(考え方だけを盗む)と良いと思います。 「FN0212003 - 配列を偏りなくランダムに並替える - Flash テクニカルノート」 http://www.fumiononaka.com/TechNotes/Flash/FN0212003.html
一般的に new 演算子は，クラスのインスタンスを作成するときに使うものです。 頻繁に使います。 > １．Date()というコンストラクタを使うには"New"が必要なのでしょうか？ コンストラクタは確かに実行されますが 基本的にコンストラクタを使うとか使わないとかいうことではなくて Date クラスのインスタンスを作成するときに new Date() と書きます。 (new の n は小文字ですよ。) 上記の new Date() ように () 内に引数を書かない場合は 今現在の Dateクラス のインスタンスが生成されます。 () 内に年月日などを書けば その年月日の Dateクラス のインスタンスが生成されます。 その他 new MovieClip() と書くと， MovieClip(ムービークリップ)クラスのインスタンスが生成されます。 new Sprite() と書くと Spriteクラスのインスタンスが生成されます。 new Array() と書くと Array(配列)クラスのインスタンスが生成されます。 とにかく， new ○○() で ○○クラス のインスタンスが生成されるのです。 new ○○() だけでも○○クラス のインスタンスは生成されますが 実際にはそのインスタンスを名指しで呼ばなければ使えないことが多いです。 それで，その生成したインスタンスを呼ぶときのために var △△ = new ○○() と書いて，生成したインスタンスの参照を変数 △△ に代入して その △△ という変数名を通して そのインスタンスのメソッドを実行したり そのインスタンスからプロパティを得たり そのインスタンスにプロパティを与えたりするわけです。 ◎スクリプトの一例とその意味 //---------------------------------------------- //今現在の Dateクラス のインスタンスを生成し //そのインスタンスの参照を変数 date1 に代入 var date1:Date = new Date(); //そのインスタンスに対してgetHoursメソッドを実行し //今現在の時刻を取得して //出力ウィンドウに表示 trace(date1.getHours()); //----------------------------------------------
Flash Player 5 以上用の SWF をパブリッシュするとき テキストフィールド に変数名を付けてはいけません。 「Webコピペ屋テキストフィールドのインスタンス名と変数名について（Flash屋への道#007）」 http://www.jinlingren.com/eid29.html テキストフィールド にはインスタンス名を付けて 「そのインスタンス名.text」 や 「そのインスタンス名.htmlText」 でアクセスするようにします。 この場合は 「そのインスタンス名.text」が適切です。
問題ないと思います。
．ｆｌｖファイルはローカルではＷｉｎｄｏｗｓ　Ｍｅｄｉａ　Ｐｌａｙｅｒをそのまま使用しても見られません。デコーダーをインストールするか専用のＰｌａｙｅｒが必要です。
> アップデートした際には > このflashplayerが更新されるわけではないのでしょうか。 その Flash Player はデバッグなどをするための開発者用スタンドアローン版 Flash Player です。 ですから Flash作成ソフト(Flash CS5.5など)をアップデートすれば Flash Player のバージョンが上がることがたまにあります(あまりありません)。 Flash作成ソフトを (Flash CS6 などに)アップグレードすれば Flash Player のバージョンも普通は必ず上がります。 何にしてもムービープレビューやデバッグなどするための Flash Player ですから ブラウザで閲覧する Flash Player とは関係がありません。 また スタンドアローン版 Flash Player だけを上げても 結局 Flash作成ソフト(Flash CS5.5など) でできることが多くなるわけではありませんから Flash作成ソフト(Flash CS5.5など) を同じものを使用し続けるのでしたら スタンドアローン版 Flash Player のバージョンを上げても普通は何の意味もありません。
＃２ですが。。。 > 常に時間を監視して表示に反映させる場合、 > はどうしたら良いのでしょうか? ですから... 回答を読まれていらっしゃらないのでしょうか？ 「どのような方法で表示させるのか」という内容を 具体的に提示されないと具体的な回答はできないのです！ って。。。 場合によってムービーを作る構造やスクリプトや説明も全て変わるのですよ。 らちが明かないので ＃２で書いた ○表示方法例１ 　午前6時から午後18時までは， 　メインタイムラインの2～201を(ループ？)再生させ 　午後18時から午前6時までは， 　メインタイムラインの202～401を(ループ？)再生させる。 の方法ですると私が勝手に決めて良いのでしょうか？ 勝手にそういうことにします。 　 　 まず メインタイムラインの フレーム1 のみのキーフレームには 例えば「Now Loading...」という文字を打ちます。 (いきなりロードされていないフレームにジャンプすることはできないので。) そして メインタイムラインの フレーム1 のキーフレーム に次のように書きます。 //---------------------------------------- //再生停止 stop(); //関数「divergenceFunc」の定義 function divergenceFunc():Void { //現在のDateインスタンスを作成 var now_date:Date = new Date(); //時刻を取得 var now_hour:Number = now_date.getHours(); //もし時刻が6以上18未満(17以下)であれば if (now_hour>=6 && now_hour<18) { //フレーム2 から再生 gotoAndPlay(2); } else { //フレーム202 から再生 gotoAndPlay(202); } } //毎フレーム実行するメソッドを定義 this.onEnterFrame = function() { //もしこのFlashが全てロードされたら if (this.getBytesLoaded()>=this.getBytesTotal()) { //この毎フレーム実行するメソッドを削除 delete this.onEnterFrame; //関数「divergenceFunc」を実行 divergenceFunc(); } }; //---------------------------------------- そして， 午前6時から午後18時までに表示させる最終フレームである メインタイムラインの フレーム201 にキーフレームを作って その キーフレーム に次のように書きます。 //--------------------------------- //関数「divergenceFunc」を実行 divergenceFunc(); //--------------------------------- また， 午後18時から午前6時までに表示させる最終フレームである メインタイムラインの フレーム401 にキーフレームを作って その キーフレーム に上と同じく次のように書きます。 //--------------------------------- //関数「divergenceFunc」を実行 divergenceFunc(); //--------------------------------- これが具体的な１つの方法例です。 なお メインタイムラインのフレーム1の「Now Loading...」は 極々簡易的に「ロード中」を示しているだけです。 インジケータが動くような演出をしたい場合は 適当にその辺を検索してみてください。 Google検索「Flash NowLoading」 http://www.google.co.jp/search?sourceid=navclient&hl=ja&ie=UTF-8&q=Flash+NowLoading
それならもっとシンプルに こちらと並行でもいいので Ｗｏｒｄ-VBAのソースを提示して　新たに質問してください 2003か2007のみを利用しているのでしょうか どの場合に　どうなるのでしょうか それが回避できれば　遠回りせずに済みます HTMLからWordの利用は　 結局　Wordを起動して　Word-VBAで処理します 当然WordのVerには影響を受けます もともとの原因をクリアしないと同じ現象になります もし可能なら　別の案で 現在のWordフォーマットを　HTML形式で出力 数値/文字の入力は　HTML形式に対して行う Wordで表示する時は　HTML形式を読み込む Wordのバージョン間で　このHTMLフォーマットが共用できるなら （同じように表示され問題がないなら） VBAによるVer違いの影響を少なくできる Word書式のサンプルをください HTML化して値を入力する例を考えてみます
MCからのマウスの座標＝stageのマウスの座標－MCの座標 この考え方↑で MCからのマウスの座標を求めれば良いのはないでしょうか？ または 拡大・回転するMCの基準点の座標に 常に別の空のMCまたはスプライトを常に追従させて その別のMCまたはスプライトからのマウスの座標を求めるとか。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ それと， > 回転させても四角形の左上隅が(0,0)になるようにしたい この解釈が色々できるのですが。。。 四角形ＡＢＣＤを入れたMCがあったとして その四角形の初期状態は 　ＡＢ 　ＤＣ という状態で，MCの基準点は 頂点Ａ にあるものとします。 この四角形MCが例えば右回転して 　ＤＡ 　ＣＢ の状態になったとします。 そのときにも変わらず 頂点Ａ からのマウスの座標を求めるのでしょうか？ もしそうでしたら上に書いた方法でできると思います。 しかし 上のような状態になったときには 頂点Ｄ からのマウスの座標を求めるように変更するのでしょうか？ もしそうでしたら上の方法ではできません。 さらにまた 　　Ａ 　 ＤＢ 　　Ｃ みたいに斜めになったときはどこを基準にするのかなどを決めないと何ともできないでしょう。 例えば， getBounds() メソッドを使えばなんとかなるかもしれませんし 場合によっては， 回転させるのは親MCの中に入れた子MCにして 親MCからのマウスの座標を求めるようにするとか 何か根本的に別の方法を考える必要があるかもしれません。
＃２です。 勘違いしていた部分がありましたので、スクリプトを訂正いたします。 FlashPlayer 8 以上で動作します。 （↓　各行頭に全角のスペースが入っています。コピーする際は、全て半角のスペースかタブに置き換えてください） //＊＊＊ /* 　初期設定 */ //チェックボックスの選択状況を格納する配列 var check_status:Array = new Array(); //チェックパターンデータ //最後の要素はパターン名 var check_ptt:Array = [ 　[ 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , "サンプルＡ" ] , 　[ 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , "サンプルＢ" ] , 　[ 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , "サンプルＣ" ] ]; //評価を格納する配列 var score_tbl:Array = new Array(); //チェックボックスの総数 var box_max:Number = 8; //チェックボックスが配置されているタイムラインを保持 var box_line:MovieClip = this; /* 　照合の処理 */ function Check_Compare():Void { 　var i:Number , j:Number; 　var score:Number , check_score:Number; 　var flags:Number; 　//選択状況とパターンを総当たりで照合する 　for( i = 0 ; i < check_ptt.length ; i++ ) 　{ 　　//評価をリセット 　　score = 0; 　　check_score = 0; 　　for( j = 0 ; j < box_max ; j++ ) 　　{ 　　　//選択されるべき項目との一致を照合 　　　//両方とも１（選択されている）である場合、評価が+1、それ以外は加算されない 　　　check_score += check_ptt[ i ][ j ] & check_status[ j ]; 　　　//全体の照合処理 　　　//一致していた場合、評価が+1、それ以外は加算されない 　　　score += Number( check_ptt[ i ][ j ] == check_status[ j ] ); 　　} 　　//デバッグ 　　trace( "Score " + i + " = " + score ); 　　trace( "Check_on " + i + " = " + check_score ); 　　//評価を記録する配列変数に結果を記録 　　//フィールド名 　　//　ptt_no：パターンの番号 　　//　check_on:選択するべき項目と一致した数 　　//　total_score:総合評価 　　score_tbl[ i ] = { ptt_no : i , check_on : check_score , total_score : score }; 　} 　//評価の高い順に並べ替え 　//選択するべき項目と一致した数が多いものほど高評価 　//同点の場合は総合評価で優劣を決める 　flags = Array.NUMERIC | Array.DESCENDING; 　score_tbl.sortOn( [ "check_on" , "total_score" ] , [ flags , flags ] ); 　/*ここに、評価を利用する処理を書く*/ 　/*今回は一致した数が最も多かったパターンの名前を出力*/ 　trace( "一致数の高いパターンは " + check_ptt[ score_tbl[ 0 ].ptt_no ][ box_max ] ); } /* 　照合開始ボタンの処理 */ btn.onRelease = function():Void { 　var i:Number; 　//選択状況を配列変数に格納 　//選択されている場合1、されていない場合は0を入れる 　for( i = 0 ; i < box_max ; i++ ) 　{ 　　check_status[ i ] = Number( box_line[ "cbox" + i ].selected ); 　} 　//パターンと照合する 　Check_Compare(); }; //＊＊＊ 主な変更点ですが。 まず、パターンのデータが単調で結果を検証しにくかったので、変更しました。 選択するべき項目を選択した数が同数だった場合、選択するべきではない項目と一致している数が多いものほど評価が高くなることを検証しやすくしています。 同時に出力される、Score と Check_on の値に注目してください。 Check_on は、選択するべき項目が一致している数です。 Check_on が同点の場合は、選択するべきではない項目も含めた全体の一致数である Score が高い方が高い評価になります。 評価を配列変数に残し、関数外でも利用できるようにしました。 配列変数 score_tbl の各要素に仕切り（フィールド）を作り、複数の情報をまとめて管理しています。 フィールドの名前と内容は、スクリプト内のコメントをご参考になさってください。 並べ替えの結果、score_tbl[ 0 ] が最も評価の高いパターンの情報になります。 なお、この並べ替えを行うにあたり、FlashPlayer 8 から追加された、フィールドごとの条件を指定するソートを利用しています。 ソートの内容は、フィールド名”check_on”について降順で並べ替え、同点だった場合はフィールド名”total_score”に注目し、total_score の高い方が上位にくるソートです。 この機能を使うために FlashPlayer 8 以降の動作になりましたが、同様の内容で比較関数を自作すれば FlashPlayer 7 でも動作は可能です。 ちなみに完全一致については、 　score_tbl[ 0 ].total_score というようにフィールドの値を見て、これがチェックボックスの総数と同じであれば完全一致であると判断することができます。 Check_Compare 関数内で、選択するべき項目を正しく選択しているかどうかを調べ、一致している数を数える処理を追加しました。 この比較には、ビット演算の & （ AND ）を利用しています。 ビット演算は、２つの２進数を１桁ずつ比較し、両者の関係で 1 または 0 が決まる演算です。 今回は対象の数値がもともと 1 か 0 のどちらかなので、２進数の話はとりあえず気にしないでください。 演算の詳細はよそに譲りまして、AND は簡単にいうと、両方 1 の場合に 1 、それ以外は 0 になります。 選択されるべき項目はパターンデータの中では 1 で表わされ、選択状況の中でも選択されている項目はやはり 1 で表わされていますから、両方とも 1 であった場合に 1 （＝選択するべき項目が正しく選択されている）と判断することができます。 それ以外は 0 ですので、1 だった場合のみ、選択されるべき項目の一致数が加算される仕組みです。 そういう、おまじないだと思ってくださっても構いません。 ご質問の主旨を勘違いしまして、大変失礼いたしました。
こちら↓はご覧になりましたか？ (代表としてOKWaveのURLですが) 「AS3.0でギャラリーのボタンの透明度を変えたい OKWave」 http://okwave.jp/qa/q7584914.html とりあえずは上記のようにして 致命的な欠陥や間違いなどを修正されるべきでしょう。 それを修正してから 「何がどうなったときにフェードアウトさせるのか？」 と言う内容を具体的に考えて(←スクリプトで考えるのではありません。イメージと日本語でしっかり考えるのです。) そして， そのイメージ通りになるようにスクリプトをさらに考える必要があるでしょう。 とにかく 今のままでは 致命的欠陥はある上に 「何がどうなったときにフェードアウトさせるのか？」 もわからないので すみませんがお話しにならない状態です。。。
＃１です。 補足で書かれていらっしゃる件に関して。 > １、ifの書き方について… その if文 の書き方は中括弧を省略しているだけです。 これは ActionScript に始まったことではなく その基となった JavaScript でも さらにその基の JAVA でも さらに C でも共通でできる書き方です。 「プログラマで、生きている カッコをつけたコードはカッコわるいのか論争」 http://el.jibun.atmarkit.co.jp/hidemi/2009/07/post-29fb.html 「if文の括弧は省略できるなら省略するのは是か非か バシャログ。」 http://c-brains.jp/blog/wsg/09/08/05-004630.php その他 例えば VBA や VBS などでも if文に中括弧こそ出てきませんが 括りを省略できるという仕様自体は共通です↓。 '-------------------- aaa = 1 If aaa = 1 Then MsgBox aaa End If '-------------------- .　↓同じこと↑ '-------------------- aaa = 1 If aaa = 1 Then MsgBox aaa '-------------------- たいていの言語で共通の事柄ではないかと思います。 　 　 > ２、if (stage) がどんな状況… if文とは， そもそも () の中が true であるかどうかを判断して true であればそれに続く {} 内などの文を実行するというものです。 ※この場合の true とは Boolean とは限りません。 if(ココがtrueであれば){ ココが実行される } それでは 広義で言う(Booleanとは限らない) 「true とは何か？」というと， 「false ではないもの(false 以外のもの)」となります。 ではその 広義で言う 「false とは何か？」というと， 「false」または「0」または「」または「null」または「undefined」などになります。 新規ドキュメントを作成して 次のスクリプトをフレーム1に書き ムービープレビューしてもらうと理解が深まるかもしれません。 //------------------------------------ var aaa = 0; if(aaa) trace(aaa + " は true です。"); else trace(aaa + " は false です。"); var bbb = 1; if(bbb) trace(bbb + " は true です。"); else trace(bbb + " は false です。"); var ccc = 100; if(ccc) trace(ccc + " は true です。"); else trace(ccc + " は false です。"); var ddd = ""; if(ddd) trace(ddd + " は true です。"); else trace(ddd + " は false です。"); var eee = "あ"; if(eee) trace(eee + " は true です。"); else trace(eee + " は false です。"); var fff = null; if(fff) trace(fff + " は true です。"); else trace(fff + " は false です。"); var ggg = !null; if(ggg) trace(ggg + " は true です。"); else trace(ggg + " は false です。"); var hhh = undefined; if(hhh) trace(hhh + " は true です。"); else trace(hhh + " は false です。"); var iii = !undefined; if(iii) trace(iii + " は true です。"); else trace(iii + " は false です。"); var jjj:MovieClip; if(jjj) trace(jjj + " は true です。"); else trace(jjj + " は false です。"); jjj = new MovieClip(); if(jjj) trace(jjj + " は true です。"); else trace(jjj + " は false です。"); //------------------------------------ 感覚的に簡単に言えば 「偽」の他に「無」とか「空」とか「存在しないもの」が false です。 その false 以外が true です。 ですから if (stage) は「ちゃんと stage が存在したら」のような意味になります。 上記スクリプトで言えば 最後の jjj に関する２例がこれに最も近いケースになります。 　 　 > ３、中段のinit()と下段のリスナー関数のinitは > なぜ名前が同じものになってるのでしょうか？。 同じにしないと 関数init は実行されないからでしょう。 だから同じにしてある(というか 関数init を実行するために書いてある)のです。 init は initialize の略で initialize を英語的に言えば「初期化」などの意味があります。 しかし ActionScript においては何の意味も持ちません。 例えば TV は television の略ですが ActionScript においては何の意味も持たないのと同じです。 もちろん自分で init という名のクラスや関数やインスタンスなどを作れば意味が出てきます。 しかし ActionScript の元のキーワードには init などありません。 この場合は private function init で定義した勝手な関数名です。 なお私も使い方などを全く知りませんが initialize という名のメソッドであれば Locale クラスというクラスにあるようです。
スクリプトも全体的に変ですが それ以前に 「動かす対象物は何なのか」 「何の座標と何の座標とを比較するのか」 これをご自身の中でハッキリさせましょう。 まず， 「動かす対象物はスプライト『box1』と『box2』」 なのでしょう？ そして， 「スプライト『box1』と『box2』の座標を比較する」 のでしょう？ ↑この２点をキッチリと意識してください。 書かれていらっしゃるスクリプトの var box1:Sprite=new Sprite; と var box2:Sprite=new Sprite; で スプライト『box1』と『box2』ができます。 しかしその後， 各スプライトの座標は指定されていません。 座標を指定しなければ それらスプライトは (x,y)=(0,0) にできます。 つまり最初から 『box1』と『box2』の座標は等しくて どちらとも (x,y)=(0,0) なのです。 『box1』のx座標が『box2』のx座標の値を上回るときなど 『box1』が動きだした直後です。 土台からして考えなおす必要がありますよね。 　 それと， それぞれのインスタンスに対して別々のイベントリスナー(関数)を登録するのではなくて １つのイベントリスナー(関数)で済ませる方が管理がずっと簡単になるのではないでしょうか？ というわけで 私でしたら次のようにするでしょう。 //------------------------------------ //スプライト「box1」を作成 var box1:Sprite = new Sprite(); //スプライト「box1」の座標を指定 box1.x = 50; box1.y = 100; //スプライト「box1」内に緑■を描画 box1.graphics.beginFill(0x00FF00); box1.graphics.drawRect(0,0,50,50); box1.graphics.endFill(); //スプライト「box2」を作成 var box2:Sprite = new Sprite(); //スプライト「box2」の座標を指定 box2.x = 100; box2.y = 200; //スプライト「box2」内に緑■を描画 box2.graphics.beginFill(0x00FF00); box2.graphics.drawRect(0,0,50,50); box2.graphics.endFill(); //スプライト「box1」と「box2」を配置 addChild(box1); addChild(box2); //毎フレーム 関数 mo を実行 this.addEventListener(Event.ENTER_FRAME,mo); //関数 mo の定義 function mo(e:Event):void { //「box1」を右に1pxずつ移動 box1.x += 1; //もし「box1」のx座標が「box2」のx座標より大きくなれば if (box1.x>box2.x) { //「box2」を右に1pxずつ移動 box2.x+=1; } } //------------------------------------ ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ついでに...， > 自身で調べたところでは > そのようなプロパティーの記述は見当たりませんでした。 > isMovingについてご解説いただければ幸いです。 isMoving は anyhelp さんが適当に作られた変数ですよ。 変数と言ってもフラグの役割を果たす変数です。 「box1」のx座標が「box2」のx座標より大きくなった次の瞬間から box2.addEventListener(Event.ENTER_FRAME,mo2); をし続けるのは変ですよね？ ですからフラグを false で用意しておいて 「box1」のx座標が「box2」のx座標より大きくなった次の瞬間にだけ box2.addEventListener(Event.ENTER_FRAME,mo2); を実行させると同時にフラグを true にして その後は addEventListener を繰り返し実行させないようにしているのです。 「フラグ (コンピュータ) - Wikipedia」 http://ja.wikipedia.org/wiki/%E3%83%95%E3%83%A9%E3%82%B0_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)
最後の行には妙なHTMLタグのようなものが入っていますよね。 _root.time_secs.text = counter_secs;</span> この「</span>」さえ削除すれば問題ないと思いますが。 私がしてみたことですが。 Flash を起動させて， ActionScript 2.0 設定の新規ドキュメントを作成し フレーム1 のステージ上には 「time_days」「time_hrs」「time_mins」「time_secs」という インスタンス名を付けた４つのダイナミックテキストフィールドを用意しました。 そして 書かれていらっしゃるスクリプトを フレーム1 にそのままコピペし 「</span>」を削除しました。 これでパブリッシュやムービープレビューすれば 難無く動くカウントダウンするものができましたよ。 書かれていらっしゃるような > シーン=シーン 1, layer=ao, frame=1、行 7シンタックスエラー > ※該当箇所：var currentTime = today.getTime(); というエラーは出ませんでした。 エラーとして出るのは上にも書いた「</span>」についてのみです。 ココ(このサイトのこのページ)にコピペされたスクリプトと 実際に Flash のフレーム1に書き込んだスクリプトが違うのではないでしょうか？ 例えばその 7 行目がありますが↓ var currentTime = today.getTime(); この var の前に全角スペースなど入れていたら そのようなエラーが出ます。 (ココに書かれたスクリプトにはそのようなものは入っていないようです。)
クラス というのは MovieClip を継承するクラス(ライブラリの中にシンボルとしてあるもの)のことでしょうか？ またもしそうであれば new で呼び出した時点で，それはクラスではなく単なるインスタンスになると思うのですが。。。 > 2.1のインスタンスを渡すと中にある > 　TextFieldを根こそぎ列挙して、 >　 その中身の値を読みだす これに関してのみについて回答します。 (それ以外はよくわかりません。) 例えば ステージ上に３つのダイナミックテキストフィールドを用意するとしますよね。 そのうちの１つは無名にしておいて 後の２つには txt0 と txt1 というインスタンス名を付けるとします。 そして 無名のダイナミックテキストフィールドには 「あいう」と手入力しておいたとします。 txt0 には「123」と手入力しておいたとします。 txt1 には空(カラ)にしておいたとします。 その後適当に ステージ上にムービークリップやボタンなどをいくつか用意してみます。 その３つのテキストフィールドと いくつか用意した何かをまとめて選択し ムービークリップに変換します(シンボル名は適当)。 そしてライブラリの中の今作成したムービークリップを選択して プロパティのリンケージより「TextMC」というクラス名を付けるとします。 ※【添付図】↓ 上で作成したステージ上のムービークリップは不要なので削除します。 この状態で 例えばメインタイムラインのフレーム1に次のように書けば 一応はムービークリップ(インスタンス)内の テキストフィールドのみのプロパティが取得できますよ。 //======================================= var my_mc:TextMC = new TextMC(); //my_mc 内の表示オブジェクトを走査 for (var i:int = 0; i<my_mc.numChildren; i++) { //走査によって発見した表示オブジェクトを変数化 var prop = my_mc.getChildAt(i); // //もしその表示オブジェクトが TextField であれば if (String(prop) == "[object TextField]") { trace("発見したものは？…" + prop); trace("そのインスタンス名は？…" + prop.name); trace("その text は？…" + prop.text); trace("---------------------"); } } //(↓これはあってもなくても良いです) addChild(my_mc); //======================================= 　
「gallery.fla」ファイルの 「メインのタイムライン」の レイヤー「as」の 「フレーム1」のスクリプトの冒頭部分に とりあえずは次の★部分のような付け加えをすれば良いと思います。 //============================================= stage.scaleMode = StageScaleMode.NO_BORDER; var page:uint = 1; btn_home.addEventListener(MouseEvent.CLICK, xPage1); function xPage1(event:MouseEvent):void { //★---↓以下付け加え↓------------ if (Pict_mc != null) { removeChild(Pict_mc);//Pict_mcステージから削除 Pict_mc = null; //Pict_mcの参照を切る } //★---↑以上付け加え↑------------ if (page != 1) { page = 1; gotoAndPlay(currentFrame + 1); } } btn_hp_gallely.addEventListener(MouseEvent.CLICK, xPage2); function xPage2(event:MouseEvent):void { if (page != 2) { //★---↓以下付け加え↓------------ if (Pict_mc != null) { removeChild(Pict_mc);//Pict_mcステージから削除 Pict_mc = null; //Pict_mcの参照を切る } //★---↑以上付け加え↑------------ page = 2; gotoAndPlay(currentFrame + 1); } } //===以下略==================================== 　 その他問題点はまだあると思いますが， とりあえず書かれていらっしゃる件については何とかなるかと。 　 それと，，， Flash ではなく XML の冒頭ですが， <?xml version="1.0" encording="UTF-8" ?> ではなく <?xml version="1.0" encoding="UTF-8" ?> が正解ですね。 元のままでも Flash の動作的には問題がないかもしれませんが ブラウザは受け付けないと思いますよ。
すでに解決済みかもしれませんが、簡単にできます。mp3等のファイルを画像と同じような方法で挿入し、ASで少しプログラムを書けばすぐに完成です。
ColorShortcuts.init(); を予め実行しておく必要があります。
そもそもFMDってFlashMaker/MotionMaker独自のファイルであって、Flashではない。 本来の使い方としては、途中で作っていったん保存とか、そういうもんです。いわゆる作成中書類。 なんで、使い方が間違ってるわけですな。 本来FlashのファイルはSWFです。 メニューのファイルとかにSWF書き出しがあるはずです。それを使わないとFlashは作成できません。 SWFで書き出したら、objectなりでHTML記述で貼り付けできます。 http://kb2.adobe.com/jp/cps/228/228623.html
Flashなら凝ったものができますが、表示するだけなら、youtubeにアップロードしてホームページに貼り付けるか、HTML5で直接動画を表示してもいいと思います。
ご質問に 「JavaScript」や「Flash をランダム表示する」などが絡んでいて 「何が問題なのか？」が今一つハッキリしませんが， 結局のところ おそらく JavaScript 云々は関係なくて 「SWFファイルの中の画像に付けたリンクがブラウザによって動作したりしなかったりする」 ということでしょう？ つまり， ランダムとかそういう雑多なものは取り除いて SWFファイルを固定で(１つのSWFを普通に名指しで)貼り付けても 同じ現象は起こるのではないでのでしょうか？ もしそうであれば(おそらくそのような気がします)， ブラウザではなく， ブラウザにインストールしてある "Flash Player" に原因があると思います。 例えば IE 用の Flash Player(プラグイン) と Firefox 用の Flash Player(プラグイン) とは別物です。 IE は IE 用，Firefox は 非IE用 です。 閲覧に使用するそのブラウザで 「Get Flash Player」のページに行って http://www.adobe.com/go/getflashplayer そのブラウザ対応の Flash Player(プラグイン) を DL＆インストール する必要があります。 ※ 上のURLからリダイレクトで実際に表示されるページは 　 ブラウザやそのバージョンや国などによって異なります。 SWF をどうやって作ったのか知りませんが 例えば(あくまでも例えば)， ActionScript 3.0 設定で navigateToURL を使ったリンクなど Flash Player 8 以下では絶対に動作しませんよ。 この場合は最低限 Flash Player 9 が必要です。 どのような SWF なのか知りませんが， 例えば Flash Player 10 用に作成した SWF であれば Flash Player 11 がインストールされた IE では無事に動作しても Flash Player 9 がインストールされた Firefox では無事に動作しないということは普通に起こります。 その辺(ブラウザの Flash Player のバージョン)をチェックしてみてください。 そして最新の Flash Player にした状態で動作確認してみてください。 またこの件に関わらず閲覧者の方にも なるべく「最新版の Flash Player のインストール」を呼びかける方が良いでしょう。 「Adobe Systems Incorporated Permissions and Trademark Guidelines」 http://www.adobe.com/misc/linking.html 　　↓ページ表示例↓
＃１ です。 > ソフトのバージョンはCS5.5です。 CS5.5 だと 操作や検索などの キーワード は 「シンボルに変換」と「モーショントゥイーン(またはクラシックトゥイーン)」辺りですね。 基本的なやりかたとしては 何にしてもとりあえず写真をシンボル化すべきでしょう。 　 手順としてまずは ステージ上に４枚の画像を 描く か 読み込む かして ステージ上に配置しますよね？ 後からでも良いですが そのステージ上に配置した４枚の画像は タイムラインで別々のレイヤーに配置しておいた方が良いです。 それでそれら４枚のの画像を１枚ずつ選択して 「修正」→「シンボルに変換」より 「ムービークリップ」または「ボタン」または「グラフィック」のうちいずれかのシンボルに変換します。 以前は「グラフィック」シンボルに変換するのが一般的でしたが CS4 以降 ActionScript 3.0 設定では 3D変形の動きなども可能になった「ムービークリップ」に変換するのが無難のように思います。 シンボル名はデフォルトの「シンボル 1」～「シンボル 4」など適当で良いです。 シンボル化されたステージ上にあるものをインスタンスと言いますが 画像の場合はとりあえずこのシンボル化されたインスタンスでないと 「モーショントゥイーン(またはクラシックトゥイーン)」ができません。 「モーショントゥイーン(またはクラシックトゥイーン)」については 字数制限もありますし図もたくさん要るのでココでは説明しにくいです。 次のサイトなどを参考にしてみてください。 「シンボルとインスタンス-モーショントゥイーン-クラシックトゥイーン-シェイプトゥイーン」 http://daaa.jp/flash-animation/ 「2012年度 情報表現演習｜ 第6回」 http://www.ne.senshu-u.ac.jp/~expr/12/12_6.html 上のサイトなどを参考にしながら ご質問でも書かれていらっしゃるように インスタンスのアルファ値を 「モーショントゥイーン(またはクラシックトゥイーン)」で 0→100 にで変化させればフェードインができます。 100→0 にで変化させればフェードアウトができます。 　 　 【下の図】↓についてですが。 これは， ４枚の画像を入れたインスタンスをクロスフェードで入れ替えて なおかつループ再生させるスライドショーのようなものを作る場合のタイムラインの様子例です。 ４枚の画像を入れたインスタンスを別々のレイヤーの同じ座標に配置し 【下の図】のようにずらしてフェードインさせると，クロスフェードができます。 (※図示の都合上タイムラインの時間軸はかなり縮小しています。) それをスムーズにループ再生させる場合は 最初の画像と同じ画像を最後にフェードインさせて そのフェードインしきったフレームのキーフレームに gotoAndPlay(○○); と書いて 最初の画像がフェードインしきったフレームに戻してやります。 【下の図】では ○○ は 4 ですが，これはこの場合だけです。 作るものによって変わります。 このようにすると 画像1フェードイン →画像2フェードイン →画像3フェードイン →画像4フェードイン →画像1フェードイン →画像2フェードイン 　…　… という流れが自然にループ再生できます。 　 操作手順など技術系のことは説明が難しく わかりにくい説明だったと思いますが 一応以上で。。。
こんにちは。 Flashファイルを徐々に読み込んでいくので最初の方にローディングアニメの処理を入れておけばローディングのアニメを実行中に本編をダウンロードしているイメージです。 >この場合、ローディング用のswfと本編のswfを同じにすることは可能なのでしょうか？ 可能です。 >普通に考えたら別々のファイルでないと、 >swfファイルを全部DLしないことには、 >ローディング画面もでないと思うのですが。 そうなると現在どのくらいロードしたかが把握できないですよね。 ロードアニメ中に全体のフレームのうち何フレーム読み込みが終了したか把握しないといけません。
＞ ちなみにこのページのソースをコピペして試すとシンタックスエラーになってしまいます。 このページのソースに全角スペースが含まれているからではないでしょうか？ 参考までにPHPから変数を渡す方法はこれ一つだけではありません。 XMLやJSONを用いて渡す方法もあります。もし興味があれば調べてみるとよいでしょう。 (以前バイナリデータをそのまま受け渡していたシステムも作ったことがあります)
navigateToURLを使わず、URLLoaderで送信はどうですか？ URLLoaderの完了時にcompleteHandlerをListenerに指定。 var loader:URLLoader = new URLLoader(); var req:URLRequest = new URLRequest("http://xxx/test.php?param=data"); req.method = URLRequestMethod.POST; loader.addEventListener(Event.COMPLETE, completeHander); loader.load(req);
書かれていらっしゃる内容(絵)が いまひとつイメージしにくいですが。。。 なんとなくですね， 塗りをシンボルに変換で ムービークリップなどにしておいて ステージ上のそのインスタンスに対して 「フィルタ」より何某かのフィルタ(例：光彩のフィルタなど)をかけて 「ノックアウト」をしている感じかもしれないとも思えます。 ※【添付図】↓ これは， Flash 上で シェイプを書いた もしくは 静止テキストを打った 場合の話です。 Photoshop での効果の付け方と違えばできません。 とにかく 書かれていらっしゃる内容(絵)がいまひとつイメージしにくいので何とも言えませんが， Flash でできないのであれば Photoshop で作成したその "レイヤーのみを単独" で 透明入りPNG(PNG-24の透明入り もしくは PNG-32) に書き出して それを Flash に読み込めば解決することかもしてません(？)。
回答ですが、 私はまだ2Dでしか作ったことがありませんので、 自動で上下左右、自在(キー入力)程度くらいしか作れません。 (この程度でならお金はかからないと思います。) 3Dの場合は私は作れません。 また画像の切り替えというのは複数の画像を使用して画像を入れ替えることです。
FlashMX単体でも可能か不可能かと言えば可能ですが、スクリプト周りが ActionScript1.0(初代)と貧弱なので、画像やムービークリップだけFlashMXで 描いてパーツごとにswfに吐き出し、無料のActionScript3.0開発ツール 「FlashDevelop」でスクリプトを書いていくのが、一番楽だと思います。 洋物ツールで、慣れるまでは手強いですが、設定で日本語表示も 可能ですし、慣れると大抵のFlashゲームが作れるようになります。 Flashにこだわらないなら、FlashDevelopでAIR※を使うことによって、 iPhoneアプリやAndroidアプリなんかも作ることができます。 (※AIRとは、Flashと殆ど同じ手法・プログラムでiPhone・Android・ Windowsアプリなどを作れてしまうフレームワークです)
Flash Makerを使ったことがなく、私もまたFLASH歴は浅いのですが…。 画像はすでにシンボル化されているのですね。 されていなければ、配置された画像を右クリック→シンボルへ変換します。 種類はボタンでも良いですが、ムービークリップにした方が後々扱いやすいかなと思います。 すると「プロパティ」に<インスタンス名>というグレーの入力欄が現れます。 そこに任意のインスタンス名を入れてください。たとえばMC_Btnとしておきます。 「プロパティ」がなければCtrl+F3、もしくはウィンドウ（W）から表示させてください。 次に、ステージでそのMC_Btnを選択した状態で、「コードスニペット」より [アクション]→[クリックしてwebページに移動]をWクリックします。 「コードスニペット」がなければウィンドウ（W）から。 すると新規レイヤーが作成され、アクションスクリプトの入力欄が現れます。 コメントアウトの説明文に従い、URLを書き換えるだけでOKです。 ご希望の動作と違っていたらごめんなさい。
こんな感じでしょうか？ var markup:XML = 　<TextFlow xmlns="http://ns.adobe.com/textLayout/2008"> 　　<p>あああ<br></br>いいい</p> 　</TextFlow>; trace(markup); markup.children()[0] = <p>ううう<br />えええ</p>; trace(markup);
私の知っている範囲ではコレが近いですね。 「スライドメニュー(【Flash 8 / AS2】＆【Flash CS3 / AS3】)」 http://suzupara.iinaa.net/mixi/slide_menu_as2_as3/
ActionScript の配列変数は、１つの要素の中に仕切りを作り、同じ要素で複数の情報を管理できるようになっています。 ” {　} ”を使い、名前と値を” : ”で区切って配列変数に値を入れた場合は、仕切りを作ったものと見なされます。 この仕切りのことを”フィールド”といいます。 フィールドがある配列変数の要素から値を取り出す時は、要素の番号のほかにフィールドの名前の指定が必要です。 ご提示の例２の場合ですと、配列変数 myAry には要素が２つ（０番と１番）あり、それぞれの要素に index と souce という２つのフィールドが作られています。 要素が管理しているそれぞれの情報を取り出す場合は、 　myAry[ 0 ].index や 　myAry[ 1 ].souce というように、要素の番号に続けて取り出したいフィールドの名前を指定します。
おそらく on(release){ getURL(_root.FlashVarsで受け取った変数名); } で行けると思います。 例えば <param name="FlashVars" value="myVar=http://○○/△△/□□.html" /> みたいにしてるのでしたら on(release){ getURL(_root.myVar); } ということになります。
プログラマなら、わずらわしい座標の変更を「手入力」は無いよ？ 自動化して、楽するのがプログラマ！ ※ 出来て当然。 そのために必要な、 - 対象オブジェクトの指定方法 - 対象オブジェクトの座標の指定方法 のデータ形式をプログラマに決めさせて、 ※ もちろん、データ形式の記述がデザイナーさんにとって難しいと意味なし。 あとは、デザイナーさんに 座標変更の指示は、そのデータ形式に従って提出させればいいような気がするよ？
こちらの「Projector」が該当します。
ステージサイズを1160pxに変更し， 作るボタンの数を18個にしただけで その他はほとんど変えないままで 実際にサンプルの「scroll_menu_0501b.fla」の通りに作ってみたところ スクリプトの編集などはなしで全く無事にループ動作しましたよ。 何の応用力も工夫も必要ありません。 サンプル自体が "質問の答えそのまんま" だと思います。 う～～ん...困りましたね。 ご質問は「サンプルの通りを "そのまんま" を作ることもできない」という意味なのでしょうか？ 　 　 仮に18個の画像にＡ～Ｒという名を付けたとするなら まずはそれらを入れたボタンを18個用意しますよね。 「Ａ」「Ｂ」「Ｃ」…「Ｒ」 そしてそれらのボタンをまとめてムービークリップに変換しますよね？ 「ＡＢＣ…Ｒ」 そのムービークリップを３つ横に並べて配置し↓ 「ＡＢＣ…Ｒ」「ＡＢＣ…Ｒ」「ＡＢＣ…Ｒ」 それらをさらにまとめて左上を基準点とした１つのムービークリップにします↓。 「ＡＢＣ…ＲＡＢＣ…ＲＡＢＣ…Ｒ」 入れ子構造も図示すると次のようになるでしょうか。 『「ＡＢＣ…Ｒ」「ＡＢＣ…Ｒ」「ＡＢＣ…Ｒ」』 その長いムービークリップ内の 真ん中の「Ａ」の右端をステージの左端の位置に合わせるようにして配置し その長いムービークリップ自体に サンプルの「scroll_menu_0501b.fla」の「slideBar」レイヤーに置いてあるムービークリップの スクリプト↓をそのままコピペすれば良いだけです。 onClipEvent (load) { speed = 0.01; defX = this._x; rightSide = (this._width/3*2)*-1; } onClipEvent (enterFrame) { speed = (speed*0.7)+((_root._xmouse-300)*0.01); this._x -= speed; if (this._x>=0 || this._x<=rightSide) { this._x = defX; } } なおサンプルのスクリプトのままだと 左右のスピード変化が対象になっていません。 speed = (speed*0.7)+((_root._xmouse-300)*0.01); の部分を speed = (speed*0.7)+((_root._xmouse-Stage.width/2)*0.01); とした方が感じが良いと思います。 ("感じ" だけの問題でループするしないとは別問題です。) 「リンク先に飛ばせる」ことだけに関しては 全くそのまんまではありませんが 元のサンプルがほぼそのままが利用できます。 最初の画像はボタンにしてあるわけですから その各ボタンに on (release) { getURL("○○.html"); } のように書いて行けば良いだけです。 「getURL();を覚えよう。 」 http://www.1art.jp/flash/le/lesson20/lesson20.htm 　 　 ステージ幅を 1160px 高さ223px にして 私が実際に作ってみているところ↓。 とにかく何の問題もなくそのまんまで動きました。
全体的に何だか状況がわかりませんが。。。 「10個のボタン」というのは ステージ上に手作業で配置したSimpleButtonクラスのインスタンスで すでにプロパティインスペクタより手動で10種類のインスタンス名が付けられているのでしょうか？ よくわからないので 以下は勝手にそういうこと(上記のような条件である)とします。 そういうこととして， インスタンス名に関するご質問に関しての回答です。 「10個のボタン」には 仮に「a_btn」「b_btn」「c_btn」…「j_btn」というインスタンス名が付けられているものとします。 インスタンス名はそのインスタンスの「name」プロパティを見ればわかりますから スクリプトは次のような感じでできます。 「10個のボタン」が存在するタイムラインのフレームに書くスクリプト例です。 //------------------------------------ //ボタンの参照を登録する配列を作成 var btn_arr:Array = new Array(); btn_arr[0] = a_btn; btn_arr[1] = b_btn; btn_arr[2] = c_btn; btn_arr[3] = d_btn; btn_arr[4] = e_btn; btn_arr[5] = f_btn; btn_arr[6] = g_btn; btn_arr[7] = h_btn; btn_arr[8] = i_btn; btn_arr[9] = j_btn; //配列の要素数分ループ for (var i:int = 0; i < btn_arr.length; i++) { //各ボタンにクリック時のリスナー関数を登録 btn_arr[i].addEventListener(MouseEvent.CLICK,clickFunc); } //関数「clickFunc」の定義 function clickFunc(e:MouseEvent):void { //クリックしたボタンのインスタンス名を出力 trace(e.currentTarget.name); } //------------------------------------ 以上で「制御」→「ムービープレビュー」などで 各ボタンをクリックして出力パネルを確認すれば 「a_btn」や「j_btn」などが出力されると思います。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ しかし思うのですが...， 何の意味があってボタンのインスタンス名などを必要とするのでしょうか？ ActionScript 3.0 (ActionScript 2.0 以下は別) では スクリプトでボタンのインスタンス名など取得しても 後に何か良いことが起こるとも思えません。 ややこしくなるだけだと思います。 デメリット(遠回り)こそあってもメリット(近道)などほとんどないような。。。 ご存じの事柄かもしれませんが 次のページ全体を良く読んで理解してみてください↓。 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html 何がしたいのかはわかりませんが， 各ボタンに対して，それに対応する文字列やインスタンスなどを関連付けるときには Dictionary クラスという便利なものもありますし↓。 「第32回　Dictionaryクラスを使う」 http://gihyo.jp/dev/serial/01/as3/0032 この辺のことを理解していたり知っていれば 普通はボタンのインスタンス名など取得しようとは思わないと思います。 (私が考え付かないような何か特殊な事情があれば要ることもあるのかもしれませんが。) またその他， ActionScript だけの話ではなく， 他言語とも共通な「クロージャ」を使う方法もありますし↓。 「ActionScriptで、押したボタンの判別方法を教えてください。」 http://okwave.jp/qa/q5921604.html ※ ActionScript 2.0 以下においては 　インスタンスを インスタンス名 で名指ししていたため 　インスタンス名 は重要であり 　スクリプトで取得する必要がある場合もありました。
埋め込みって添付画像のようなカンジのことしてるって事ですか？ これしてるけど同じフォントが読み込まれちゃうカンジですか？ 名前被ってないですか？ アンダースコア以外の半角記号を変数名に使ってないですか？ フォントはフォント一覧の上の方にある 埋め込んだ方のフォントを選択してますか？
多分ファイル直接リンクでの動画呼び出しがfc2ホームページの仕様で制限されており、 ブログに外部呼び出しが出来ないんじゃないかと思います。 自分のサイト(ホームページ)のドメイン以外は外部呼び出し扱いになります。 fc2ホームページではファイル倉庫としての使用は出来ません。 例外で、ファイル名を「banner.拡張子」にすると外部呼び出し可能だとありますから、 ファイル名を「banner.swf」にしてみると出来るかもしれません。
とりあえず var i:int=0　を myFuncの外に出せば良いだけとも思うけど やりたい事から言って function myFunc(e:Event):void{ if(myArray.length){ myArray_txt.text=myArray.shift(); }else{ nextFrame(); } } でも良さそう
CS4(同じ環境)で実験してみましたら，同じ現象が起きました。 問題は 「修正」→「ドキュメント」 などより ドキュメントサイズを 950px × 339px に変更するときに発生するようです。 ドキュメントサイズを変更する前は ステージ上にある「.hfm」などが入っていてスクリプトが書かれてあるムービークリップの座標が X：0.00　Y:0.00　なのですが ドキュメントサイズを変更したとたんに同じムービークリップの座標がなぜか X：0.50　Y:0.50　に自動変更されてしまいます。 これによってズレが生じるようです。 ドキュメントサイズを変更した後に ステージ上にある「.hfm」などが入っていてスクリプトが書かれてあるムービークリップの座標を X：0.00　Y:0.00　に戻せば 上と左の隙間は消えると思います。
http://dotinstall.com/lessons/fb_connect_php まずこっちでログインしてるFacebookのIDをとる方法を学習 （『ちょっと何言ってるかわからない』状態ならとりあえず PHPの本一冊買ってにらめっこしながら見てください） あとはASでSharedObjectなりPHP+MySQLでDBなりに IDごとに今日すでにクジを引いたかを記録 その際に時間の記録をサーバー側で用意すれば クライアント側で日付の改竄はできません 集計とかとりたいだろうし PHP+MySQLとかでDBに記録するほうが 使い回しが効きやすくていろいろ捗ると思います ついでに上記の動画のFBでログインの方法で アクセス制限もかけとけば不正アクセスも防げて 一石二鳥ってやつです
一般的で普通の状態だと 質問するまでもなく普通に↓でできますけどね。 delete closs.onEnterFrame; 例えば 質問で書かれているスクリプトを書いた階層のタイムラインがフレーム2まであって フレーム1にそのスクリプトを書かれていたとします。 その場合，例えば(あくまでも例えば)， 次のようにすれば良いだけです。 //---------------------------------- //このタイムラインの再生を停止 stop(); function moveCross() { this._x = _root._xmouse; this._y = _root._ymouse; } closs.onEnterFrame = moveCross; //「closs」クリック時の動作 closs.onRelease = function(){ //★ closs.onEnterFrame を削除 delete closs.onEnterFrame; //このタイムラインをフレーム2に進めて停止 gotoAndStop(2); } //---------------------------------- もっともこの場合(に限って)は //★ closs.onEnterFrame を削除 delete closs.onEnterFrame; の部分を //★ closs.onEnterFrame を削除 delete this.onEnterFrame; としても良いです。 または //★ closs.onEnterFrame を削除 delete this._parent.closs.onEnterFrame; という回りくどい書き方をしても良いと言えば良いです。 また仮にもし スクリプトを書かれた階層が(closs を置いた階層が) _root(メインタイムライン) であれば //★ closs.onEnterFrame を削除 delete _root.closs.onEnterFrame; のように 絶対パスでターゲットパスを指定しても良いです。 どこに書いたスクリプトから delete closs.onEnterFrame をしたいのかがわかりませんが， とにかく普通に delete closs.onEnterFrame をすれば良いだけです。 もしスクリプトを書く階層が違う場合は ターゲットパス(closs に対するターゲットパス)に注意するくらいでしょうか。 「ターゲットパス」 http://homepage3.nifty.com/ginga-b/MX/targetpath.html
某所へされていた質問から進展したことと言えば > アクションスクリプト2.0 奇数と偶数… のように ActionScript のバージョンを明記されたことぐらいでしょうか。 その他は全く進展していないか，むしろ退化してますね。 なぜ「a」と「b」の２つもの入力用テキストフィールドがあるのでしょうか？ その理由も書かれていませんし「c」と「d」との関連もさっぱりわかりません。 また， > cとdに出力したいのですがうまくいきません。 と書かれていますが cとdには何を出力したいのでしょうか？ この辺もわかりません。 あくまでも例えばですよ， ご質問を次のように捉えることもできるわけです。 　↓↓↓ 「a」には十の位の数を１つ入力してもらい 「b」には一の位の数を１つ入力してもらい その「ab」(例：「13」や「81」など…)の２桁の数が もし奇数であれば「c」に「○」を出力し もし偶数であれば「d」に「○」を出力したい。 その他，捉え方など無数です。 某所へされていた質問には 「xが整数であれば 剰余演算子 (x%2) で判断できる」 という内容の回答(アドバイス)を書いてくださっている方がいるにも関わらず 整数であるのかないのかすら反応(補足)されてませんし。。。 その回答(アドバイス)はとりあえず正解なのですから， 質問者の方からさらなる反応(補足)がなければ 私も含めて他の人もそれ以上書きようがないでしょう？ 　 　 とにかく，わけがわかりませんので， 私が勝手にご質問を変更します。 　↓↓↓ ステージ上には インスタンス名「a」のテキスト入力のテキストフィールドと インスタンス名「c」のダイナミックテキストフィールドと インスタンス名「btn」のボタンがあります。 「a」にある数を１つ入力し ボタン「btn」をクリックしたとき もしその数が奇数であれば テキストフィールド「c」には「奇数」という文字列を表示し もしその数が偶数であれば テキストフィールド「c」には「偶数」という文字列を表示したいと思います。 ActionScript 2.0 でのスクリプトを教えてください。 以下は私が勝手に変更した質問に対する回答です。 「a」「c」「btn」が存在する タイムラインのフレームに書くスクリプト例です↓。 //============================================ //「btn」クリック時の動作 btn.onRelease = function():Void { // //「a」に入力された文字を数に変換 var a_num:Number = Number(a.text); // //もし「a」に入力されたものが非数であれば if (isNaN(a_num)) { //「c」に「数を入力して！」を表示 c.text = "数を入力して！"; //もし「a」に入力された数が小数であれば } else if (a_num != Math.floor(a_num)) { //「c」に「整数を入力して！」を表示 c.text = "整数を入力して！"; //もし「a」に入力された数が奇数であれば } else if (a_num%2 == 1) { //「c」に「奇数」を表示 c.text = "奇数"; //それ以外は } else { //「c」に「偶数」を表示 c.text = "偶数"; } }; //============================================ または， テキストフィールド「a」に対して 0～9 までの文字しか入力できないように制限をかけた場合 「btn」クリック時の動作は 次のような感じに変更になると思います↓。 //============================================ //「a」の入力文字制限(0～9) a.restrict = "0-9"; //「btn」クリック時の動作 btn.onRelease = function():Void { //もし「a」が未入力であれば if (a.text == "") { //「c」に「数を入力して！」を表示 c.text = "数を入力して！"; //「a」が未入力でなければ } else { //「a」に入力された文字を数に変換 var a_num:Number = Number(a.text); // //もし「a」に入力された数が奇数であれば if (a_num%2 == 1) { //「c」に「奇数」を表示 c.text = "奇数"; //それ以外は } else { //「c」に「偶数」を表示 c.text = "偶数"; } } }; //============================================ とにかく 漠然とした質問には，漠然とした回答しかできません。 つまり 質問が具体的でなければ，具体的な回答もできません。
ParaFla! は ActionScript 1.0 しか使えませんから， ActionScript 1.0 です。
「言語(ActionScript)」だけを考えて解決しようとしていらっしゃいませんか？ 「言語」など自体を考えても答えは出ませんよ。 問題は言語ではなく 「サーバ(またはローカルPC)のハードディスクからXMLをロードするのには時間がかかる」 「XMLをロードしてからでないとそれを読んだり操作することはできない」 というたったそれだけの(超当たり前な)ことだけですから。 音波も届いてからじゃないと耳で聞くことはできませんよね？ 光も届いてからじゃないと目で見ることはできませんよね？ 届いた情報について考えるのはその後ですよね？ それとまったく同じことです。 その "単純で当たり前なこと" を理解しておけば いくつかの対処法は思いつくはずです。 //------------------------------------ ～～云々(略)～～ function XMLload(e:Event):void { ～～云々(略)～～ //別の関数 traceArr を実行 traceArr(); } //別の関数 traceArr の定義 function traceArr():void { trace(ary[5]); trace(ary_name[2]); } //------------------------------------ ↑function XMLload から見れば その関数外で取り出していることになりますよね？ または メインのタイムラインを２フレームなど複数フレームにして 書かれていらっしゃるスクリプトを 例えばメインのタイムラインのフレーム1などに書いておいて stop(); をかけておきます。 そして xmlファイル のロードが完了してから フレーム2 に進めてます↓。 //------------------------------------ ～～云々(略)～～ //このフレームで再生停止 stop(); function XMLload(e:Event):void { ～～云々(略)～～ //次のフレームで停止 nextFrame(); } //------------------------------------ そしてフレーム2には //------------------------------------ trace(ary[5]); trace(ary_name[2]); //------------------------------------ と書いても良いですよね？ 完璧に関数外です。 その他 あるムービークリップを作成しておいて xml のロードが完了してから， ムービークリップ内のフレームの再生を開始させて そのムービークリップ内で trace(MovieClip(root).ary[5]); trace(MovieClip(root).ary_name[2]); を実行させても良いでしょう。 とにかく最初に書いた 「サーバ(またはローカルPC)のハードディスクからXMLをロードするのには時間がかかる」 「XMLをロードしてからでないとそれを読んだり操作することはできない」 ということをとりあえずはしっかり認識して 「Event.COMPLETE という便利なものを使うことによってXMLのロード完了時に指定した関数を実行できる」 ということを理解すれば 後はどうにでもなるという感じだと思います。 昔は Event.COMPLETE みたいな便利物はなかったので 外部データのロードなどをする場合， 例えば 「フレーム1 で外部データのロード命令を出して フレーム2 と フレーム3 をループ再生させることによって ロードされたデータに最終データ(フッターデータ や 総文字数 などから割りだす)が入っているかどうかを確かめて 最終データが届いていたなら フレーム4 に進めてデータ処理をする」 みたいなことをしていたのですよ。 ロード待ち処理装置の自作です。 全部関数外です。 それに比べれば全自動でかなり楽なものです。 (全自動で楽になった分，単純当たり前な理屈をあまり考える必要もなくなったので，逆にわかりにくくなったかもしれませんね。)
結論から言うと、FlashBuilderでも使用可能です。 ただし、マウスをポチポチして操作できるような代物ではありません。 MinimalCompsの中のソースコードをそれなり改造する必要があります。 軽くMinimalCompsの中のコードを読んだところ、これらのコンポーネントは flash.display.Spriteを継承して作られているようです。FlashBuilderの MXMLデザインモードで使用するためには、mx.core.UIComponentを継承した、 またはmx.core.iVisualElementを実装したコンポーネントしか使用できません。 http://www40.atwiki.jp/spellbound/pages/97.html MinimalCompsをFlashBuilderで使用するには、↑でも書かれているように ActionScriptをゴリゴリ書いて実装していくのが正当な方法のようです。 どうしてもMXMLデザインモードで操作したい場合は、MinimalCompsの中の ソースコードを弄って、Spriteの代わりにUIComponentを継承してやる 必要があります。(試しにやってみたのですが、数か所UIComponentと 競合する部分があり、どうにも一筋縄ではいかないようです)
「実行を○秒停止する」というニュアンスで考えるのではなくて 「実行を○秒待つ」または「実行を○秒遅延させる」と考えれば良いでしょう。 この遅延には Timer クラスを使えば良いと思います。 その場合の修正案です↓。 //--------------------------------------------- package { import flash.display.*; import flash.events.*; import flash.utils.*; //↓削除 //import fl.events.*; import flash.filters.*; //↓Timer クラスと TimerEvent クラスのインポート import flash.utils.Timer; import flash.events.TimerEvent; public class Main extends MovieClip { public var logoObj1:MovieClip = new logo1(); public var blur:BlurFilter; public var i:uint = 70; public var ii:uint = 0; //↓勝手に適当な付け加え public var w:Number = stage.stageWidth; public var h:Number = stage.stageHeight; //Timer インスタンス tm の宣言 public var tm:Timer; //↓待つミリ秒数の設定(1秒＝1000ミリ秒) public var wait_ms:uint = 5000; public function Main():void { opening(); } private function opening(e:Event=null):void { blur = new BlurFilter ; addEventListener(Event.ENTER_FRAME,BlurMinus); //↓Timer インスタンス tm を作成 tm = new Timer(wait_ms,1); //↓指定ミリ秒後に setBlurPlas を実行する設定にする tm.addEventListener(TimerEvent.TIMER, setBlurPlas); } private function BlurMinus(e:Event):void { blur.blurX = i; blur.blurY = i; logoObj1.filters = [blur]; logoObj1.x = w / 2; logoObj1.y = h / 2; addChild(logoObj1); if (i == 0) { //↓BlurMinus のイベントリスナーを削除 removeEventListener(Event.ENTER_FRAME,BlurMinus); //↓タイマースタート tm.start(); } i = i - 2; } //↓setBlurPlas の定義 private function setBlurPlas(e:TimerEvent):void { //↓毎フレームBlurPlasを実行 addEventListener(Event.ENTER_FRAME,BlurPlas); } private function BlurPlas(e:Event):void { blur.blurX = ii; blur.blurY = ii; logoObj1.filters = [blur]; logoObj1.alpha += 0 - logoObj1.alpha / 50; if (logoObj1.alpha==0) { //↓削除 //removeEventListener(Event.ENTER_FRAME,BlurMinus); removeEventListener(Event.ENTER_FRAME,BlurPlas); } ii=ii+2; } } } //---------------------------------------------
　iphone（ipad）が対応してないからではないでしょうか。 　html5で作れば、両方で表示できるので、手間が1つで済むからでは。 　flashでhtml5とかに変換出来るようになれば、ソフトは生き残ると思いますが、今のままだと、ゆるやかに衰退していくと思います。
FlashDevelop 4.0.1 / FlexSDK 4.6を使用して検証してみました。 var urlVariables:URLVariables = new URLVariables("a=1&b=2"); var obj:Object = new Object(); for (var k:String in urlVariables) { 　obj[k] = urlVariables[k]; } for (k in obj) { 　trace(k, '=>', obj[k]); } trace(obj.a); trace(obj.b); と言うコードを組んだ結果、 b => 2 a => 1 1 2 となりました。 ConnectPHPと言うものが何者だか解らないのですが、 生の戻り値データを取得することはできないのですか？ つまり、Flash側で"a=1&b=2"という文字列は取れないのですか？
肝腎なバージョンを書かれていませんが。。。 > on (release) { > nextFrame(); > } これは Flash 5 以上 で使用できる範囲の ActionScript 1.0 ですね。 しかし。。。 Flash 5(12年くらい前のバージョン) は古すぎて 構造作り直しなども大変(回答するのもかなり面倒)になりますから 勝手に Flash MX 以上をお持ちで ActionScript 1.0 を使うものということに決めます。 Flash MX 以上とは Flash MX，Flash MX 2004，Flash 8，Flash CS3，Flash CS4，… のことです。 まずは 「ドキュメント全体をおおう透明なボタン」からですが これ自体に書かれた on (release) {…} などのスクリプトを全て消します。 そして ステージ上のその透明ボタンを選択して プロパティインスペクタより「インスタンス名」を付けます。 ここでは「btn」というインスタンス名を付けることにしておきます。 ※参考【添付図】↓ そしてスクリプトを書くためのレイヤーを別に用意して (すでに用意してあればそのレイヤーで良いです)， そのレイヤーのフレーム(フレーム1 など)に次のように書きます(コピペ可)。 //---------------------------------- //このタイムラインの再生を停止 stop(); //ドラッグする px 数の設定(※適当に変える) var drag_px = 50; //マウスを監視するオブジェクトを作成 var obj = new Object(); //マウスのリスナーとして obj を登録 Mouse.addListener(obj); //マウスをプレスした x座標 を入れる変数の宣言 var press_x; //「btn」プレス時の動作を定義 btn.onPress = function() { // //マウスをプレスした x座標 を変数に入れる press_x = _xmouse; // //「btn」クリック時の動作を定義 btn.onRelease = function() { //「btn」クリック時の動作を削除 delete btn.onRelease; //マウスが動いた時の動作を削除 delete obj.onMouseMove; //このタイムラインを次のフレームに進める nextFrame(); }; // //マウスが動いた時の動作を定義 obj.onMouseMove = function() { //マウスの座標がプレスした x座標 より drag_px 以上右になれば if (_xmouse>=press_x+drag_px) { //「btn」クリック時の動作を削除 delete btn.onRelease; //マウスが動いた時の動作を削除 delete obj.onMouseMove; //このタイムラインを前のフレームに戻す prevFrame(); } }; }; //---------------------------------- ※Flash MX 以上で使用可 　 Flash Player 6 以上で動作可 　 ActionScript 1.0(パブリッシュ設定は 2.0 でもOK) 「どれくらい(どこからどこまで)右にドラッグした時に前のフレームに戻すのか？」 などがわからなかったため勝手に， //ドラッグする px 数の設定(※適当に変える) var drag_px = 50; のようにして 50px 以上右にドラッグしたときにフレームを戻すようにしていますが この数値は適当に 10 とか 100 とかに変えてください。 あと， 「ドラッグ」には「ドロップ」が付き物です。 つまり 「マウスプレス」には「マウスアップ」が付き物です。 何が言いたいのかというと 「ドラッグ終了時に Flash 上でマウスアップする」ということは， 「ドキュメント全体をおおう透明なボタンをクリックする」のと同じことになるのです。 ですから「ドラッグ」が成立したときには 「透明なボタンクリック」を無効にしなければなりませんよね？ でないと，また元のフレーム(次のフレーム)に戻ってしまいます。 そんなこんながあったり on (release) {} では スクリプトを書く場所が分散してしまってやりにくいので onRelease などを使うように変更しています。 ○○.onRelease=function(){}; や ○○.onMouseMove=function(){}; などを 「イベントハンドラメソッド」と言いますが これらは delete で削除することができるので使いやすいです。 on (release) {} など 「イベントハンドラ」の方は，スクリプトで削除できません。 もし on (release) {} などを使う方向で行く場合は 別にフラグとなる変数をいくつか用意するなどして 色々な条件分岐した動作を考える必要が出てきます。 　 ◎ 【添付図】↓ について バージョンがわからなかったので 適当に Flash 8 での画面↓を用意しましたが バージョンによって見かけは変わります。 Flash MX ～ CS3 までは比較的似ているかもしれませんが Flash CS4 以降は全く別な感じに見えると思います。
エラー大量発生の原因は単純に フレーム "inhouse" には， 少なくとも player2 が存在しないからでしょうね。 (enter1 の方も存在しないかもしれませんが。) ※【添付図】↓ 仮にもし存在していたとしても， Event.ENTER_FRAME で ずっと this.gotoAndStop("inhouse"); をさせ続けるのはおかしいと思います。 (そのフレーム以外に行けなくなってしまいます。) player2 が存在してもしなくても 何にしても removeEventListener すべきでしょう。 //------------------------------ stop(); player2.addEventListener(Event.ENTER_FRAME,go); function go(event:Event):void { player2.x += 5; if (player2.hitTestObject(enter1)) { //↓追加↓ player2.removeEventListener(Event.ENTER_FRAME,go); this.gotoAndStop("inhouse"); trace("ok"); } } //------------------------------ 　 「タイムラインに置いたMovieClipからフレーム移動するとrootやstageが参照できない」 http://fumiononaka.com/TechNotes/Flash/FN1003002.html 　 　
どのバージョンのものかわからんから3.5aでどうなっているか知らんが、何かAdobeのサイトにコンパイラのソース(Java製)っぽいものがあった http://opensource.adobe.com/svn/opensource/flex/sdk/sandbox/murph/modules/swfutils/src/java/flash/fonts/FontManager.java parseRangesのコード見る限り意図的にそうしているんじゃないかなあ？
http://movies.cmizer.com/cm/private/movie/k/Fv/ek/ryF/ywhkddgrnb.xml これが動画の本体のようです。 このXMLを見ると中身にこのようなSWFがあります。 http://movies.cmizer.com/cm/template/sushi_ninki.swf 前回返答したプレイヤーSWFがこのSWFに各種画像(imageUrls)と 各種テキスト(textUrls)を食わせて、定型の動作をさせているだけのようですね。 http://cmizer.com/movie_editor 事実、下記リンクの中ほどにある「人気の事実を伝える 人気編」を見ると、 画像とテキストが異なるだけで動作が全く同じことに気づきます。
まず大前提として、hitTestPointはシェイプにしか反応できません。 それ以外のものは表示オブジェクトの矩形で判定されます。 ビットマップも同じです。(アルファ透過している部分も画像なのです) Illustratorから読み込んで作ったシンボルの中身がシェイプでできている、 即ちシンボル(グラフィック・ムービークリップ)やグループ、 描画オブジェクトが含まれていないことをまず確認してみてください。
「TextField柄」で塗り潰すのですから その TextField がどこにあっても同じです。 場所は関係ありません。 例えば ハンカチの「花柄」。 「花柄」は「花柄」です。 「山のどの辺りに咲いていた花か」などのような 花が咲いていた位置は「花柄」には関係ありません。 もし咲いていた位置が要るのでしたら ハンカチを「山柄」などにするべきでしょう。 例えば「山柄」にした上でその中に「花」を描くべきです。 (山頂付近に花を描くとか，山の麓に花を描くとか…。) 　 というわけで， TextField の位置が要るのでしたら， TextField 入りの Sprite でも用意して その「Sprite 柄」でBitmapDataを塗れば良いと思います。 // ～～～以上は略～～～～～～～～～～～～ var tf:TextField = new TextField(); tf.defaultTextFormat = new TextFormat("ＭＳ ゴシック",50,0xFF0E0E,true); tf.width = stage.stageWidth;// 幅 tf.height = 50; tf.autoSize = TextFieldAutoSize.CENTER; tf.y = 240; tf.text = "MISS!!"; //---↑以上は変更ナシ↑--- //↓２行付け加え var sp:Sprite = new Sprite(); sp.addChild(tf); //↓引数をSpriteに変更 canvas.draw(sp); //(↓念のため参照を切っておきます) tf = null; sp = null; // ～～～～～～～～～～～～～～～～～～
不可能ではないですが、現実的ではありません。 簡単に方法を示すと、 1.PSDを読み込む(またはダウンロードする) 2.PSDのフォーマットを解析する(PSDのデータ構造に関する知識が必要。下記リンク参照) 3.Photoshopのフィルタ効果を自作する 4.最終的にできたデータからビットマップを起こす となりますが、非常に低速な、負荷のかかる処理となるでしょう。 また、そこまで作るのに多大な工数を要すると思います。(最速でも数か月レベル) もう少し何がしたいのかを具体的に説明できれば、 もっとベストな代替方法が見えてくるかもしれません。
mc.gotoAndStop(my_cb.selectedItem.data); ではなくて mc.gotoAndStop(Number(my_cb.selectedItem.data)); ですね。
連投申し訳ございません。 回答No.3のコードにおけるSnowクラスのコンストラクタ、Snow.Snow()に 誤りがありました。正しくは以下の通りです。 　/** 　 * コンストラクタ。 　 * @param id 通し番号。(番号が小さいほど大きく、速くなります) 　 */ 　public function Snow(id:int) 　{ 　　var amount:Number = id / LIMIT; 　　coefficient = amount + 0.1; 　　cacheAsBitmap = true; 　　addEventListener(Event.ADDED_TO_STAGE, onAddedToStage); 　　// ↓ Flashで予めシェイプを作ってリンケージする場合、ここからの処理は不要 　　var shape:Shape = new Shape(); 　　var r:int = 0xFF * (0.2 + amount * 0.8); 　　var g:int = 0xFF * (0.5 + amount * 0.5); 　　var b:int = 0xFF * (0.5 + amount * 0.5); 　　shape.graphics.beginFill((r << 16) + (g << 8) + b); 　　shape.graphics.drawCircle(0, 0, SIZE_MIN + (SIZE_MAX - SIZE_MIN) * amount); 　　shape.graphics.endFill(); 　　addChild(shape); 　　// ↑ Flashで予めシェイプを作ってリンケージする場合、ここまでの処理は不要 　}
当方の試験環境はAdobe Flash Builder 4.6(所謂Flex)ですが、 下記のコードで文字が大きく横に伸びるようになりました。 <?xml version="1.0" encoding="utf-8"?> <s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark" applicationComplete="onCompleteHandler(event)"> 　<fx:Script> 　　<![CDATA[ 　　　import mx.core.UIComponent; 　　　import mx.events.FlexEvent; 　　　 　　　[Embed(systemFont="Segoe UI", embedAsCFF="false", fontName="Segoe UI", mimeType="application/x-font")] 　　　private var _font:Class; 　　　 　　　protected function onCompleteHandler(event:FlexEvent):void 　　　{ 　　　　var format:TextFormat = new TextFormat(); 　　　　format.font = "Segoe UI"; 　　　　format.color = 0xCCCCCC; 　　　　format.size = 24; 　　　　var field:TextField = new TextField(); 　　　　field.autoSize = TextFieldAutoSize.LEFT; 　　　　field.embedFonts = true; 　　　　field.defaultTextFormat = format; 　　　　field.text = "Hello, world!"; 　　　　field.scaleX = 3; 　　　　field.scaleY = 0.8; 　　　　var canvas:UIComponent = new UIComponent(); 　　　　canvas.addChild(field); 　　　　addElement(canvas); 　　　} 　　]]> 　</fx:Script> </s:Application>
もしすべてのflaファイルに画像以外に何も置いていないのであれば、 ドキュメントクラスから ---------- this.getChildAt(0).x = 5; ---------- とすれば、すべての画像のx座標を動かせるかと思います。
四方に広げることはできて 左右ニ方に広げることはできない？？？ それはかなりイミフメイな(他人には理解しがたい)状況ですよ。。。 一応センターから左右に開いて次の画像を登場してますが↓。 「簡易fps(フレームレート)測定器 サンプル＆作成方法解説」 http://suzupara.iinaa.net/framerate.html
ご質問にある次の行ですが var btm_data:BitmapData=new tokyo1(); 例えば 0,0 など適当な引数を２つは入れないとエラーになりませんか？ 　↓修正例↓ var btm_data:BitmapData=new tokyo1(0,0); 以上のように１ヶ所のみを修正すれば 一応スクリプトは正常に動作しているようですが。。。 だた，気になるのが次の行です。 btm_data.draw(stage,matrix,color,BlendMode.NORMAL,rect1,true); この draw() の第一引数に stage を入れていらしゃいますが 透明でない何かを ステージ上の左上のコーナーの辺りに描いたり置いたりしていらっしゃいますか？ ステージ上の左上のコーナーの辺りに 何かを描いたり置いたりしているのでしたら それが btm_data 上に出てくると思いますが 何も描いたり置いたりしていないのしたら btm_data 上には何も出て来ません。 例えば私はステージ上に 下の図の左側のような放射状(同心円状)の塗りを描きました。 そしてムービープレビューすると PNG画像「tokyo1」(グレーの画像)に 放射状(同心円状)の塗りの一部が拡大されたものが出てきました。 特に問題なしに見えます。 　
＃１です。 すみません。 ＃１は一部書き間違えています。 まずはその訂正から。 ～＃１より引用～ > もっとも > trace(container1.numChildren); // 2 > で出力されるのは「2」ではなく「1」ですから > (container1 内には circle1 が 1 つあるだけですから) 書き間違えているのは 上記部分の最後の ( ) 内です。 　　↓書き直します↓ (container1 内には circle2 が 1 つあるだけですから) 　 　 というわけで ＃１の補足のご質問です。 > なぜ、 > container1.addChild(circle1);container1.addChild(circle2); > のように明確にcontainerにはcircle1とcircle2が > 入っている事が設定されているのに > containerの中が１つとなっているのでしょうか？ ご質問で書かれていらっしゃるスクリプトには 次の部分があります。 　～～～前略～～～ container2.addChild(container1); container1.addChild(circle1); container1.addChild(circle2); ここまでで 「container2」内の表示リストに登録されている スプライトの階層構造を書くと次のようになります。 　container2(←まだどこにも addChild されていない) 　　└container1 　　　　├circle2 　　　　└circle1 つまりここまでは確かに 「container1」 の子 として 「circle1」と「circle2」の２つのスプライトがあります。 問題は次の行からのスクリプトです。 addChild(circle1); addChild(circle3); スクリプトを書いたのが root のタイムラインであるとすれば 上記２行で表示リストに登録されているスプライトの階層構造は次のように変化します。 　root 　　├circle3 　　└circle1 　container2(←どこにも addChild されないまま) 　　└container1 　　　　└circle2 最初「container1」内にあった「circle1」は 移動させられて root の子になるということです。 ですから， trace(container1.numChildren); // 2 では「2」ではなく 「circle2」１つのみの「1」と出ます。 ちなみに 上の表示リストに登録されているスプライトの階層構造にも書いていますが 「container2」は結局最後までどこにも addChild されません。 したがって 「circle2(水色の●)」はどこにも表示されません。 (「circle1(ドーナツ)」は root に addChild されているため表示されます。)
大きく2つの方法があります。詳細はここに書くには長くなりすぎてしまうため、ぐぐって見てください。 ・ムービークリップの「リンケージ」機能を使いflaから複数のasをぶら下げる ・asにasをぶら下げる(import命令、またはinclude命令を使います)
極力元のままを変えない方針で行くとするなら次のようになります。 (★部分＝追加または変更) onClipEvent (enterFrame) { //現在の時刻を取得 now_time = new Date (); //時間と分および秒を取得 hour = now_time.getHours (); minute = now_time.getMinutes (); sec = now_time.getSeconds (); //★追加：ミリ秒を取得 msec = now_time.getMilliseconds(); //時刻を表示 /* Flash Player 6 以上の場合は、 ここに時刻をダイナミックテキストに出力するスクリプトを書く */ //★変更：ミリ秒500未満の時にコロンを表示、それ以外は非表示にする colon_clip._visible = Boolean (msec < 500); }
つまり 本(pageflip_v225.swf のアレンジバージョン)の中に 自作SWF を loadMovie するのではなくて 自作SWF の中に 本(pageflip_v225.swf のアレンジバージョン) を loadMovie するということですよね。 「pageflip_v225.fla」の中の メインタイムライン の 「actions」というレイヤーの フレーム5 のキーフレームに 長々としたスクリプトがありますが そのスクリプトの 748～750 行目に snd0 = new Sound();//adding sound objects snd1 = new Sound(); snd2 = new Sound(); と書いてある部分がありますから そこを次のように変えれば音が出るようになります。 snd0 = new Sound(this);//adding sound objects snd1 = new Sound(this); snd2 = new Sound(this); this を省略すると メインタイムラインに音が置かれて 以降のパスがずれるんです。
Flash側でソースパスの設定を行います。 標準では「.」(現在のフォルダ配下のみ探す)となっていますので 「..」(現在のフォルダの 親 の配下のみ探す)を書き換えれば解決するものと思います。 ただし、パッケージ名を設定している場合はパッケージ名とディレクトリ構造を合わせるなど、 少々ややこしいことになりますので注意してください。
一般的にWEB上で再生されるswfファイルのことをFlashと言います。 特にカタカナ表記でフラッシュと書かれている場合はほぼ100%このことです。 swfファイルはFlashPlayerで再生ができて、このFlashPlayerはPCのスタンドアロン、ブラウザプラグイン共にAdobeから無料で提供されていますし、ほぼ大体のブラウザにはデフォルトのプラグインとして組み込まれていますので、ユーザーがPlayerを意識する機会は滅多にないかもしれません。 また、モバイルプラットフォームで再生を可能にするFlashPlayerLiteというものもあって、こちらは携帯電話等に買ったときから既にインストールされている場合が多いです。 一般的なFlashという用語はそのくらいで完結するんですが、ややこしいことにこのswfファイルを作成するツールの一つとしてFlashというアプリが存在します。 Flashを作成したいと思う場合は再生側と明確にするために用語を区別する場合があります。 区別されてある場合は作る側をFlashIDEと呼んだり、もしくはFlashProfessionalとかCSとか呼んだりするのですが、作るツールの名称の歴史的経緯も長いため統一されていません。 ここらへんが、まず最初にFlashを作ってみたいと思う人をさらにややこしくしているのですが、再生する側のFlashと作る側のFlashを区別するのは今のところ読む人の理判断にゆだねている状況です。 ここから先、「Flash」という用語を再生するswfファイルの事と定義しておいて話を進めますが、 Flashを作るためには大きく分けて二つの方法があります。 １：Adobeが販売しているFlashCS5.5（もうじきCS6がでます）を買う ２：Adobeが無償提供しているFlexSDKを使う 1番は、アプリを買えば済む話しですので置いておいて、まず注目して頂きたいのは2番です。 FlexのSDKが無償で提供されているので、これを使えばFlashを作ることが出来ます。 FlexSDKそのものは無償ですが、これを便利に使うツールとしてFlashBuilderというアプリをAdobeが出しています。 > また開発ツールはFlash CS.5.5かFlash Builder4.5なのか教えて頂けると幸いです。 ですので、FlashCS5.5とFlashBuilderはどちらもAdobeの販売するアプリですので、どちらを使ってもFlashが作れます。 どちらがいいかは完全に好みですので、ご自身で選択されたらいいかと思います。 一般的にはデザインやアニメーション寄りならFlashCS、プログラム寄りならFlashBuilderがおすすめですが、 特にこうでないといけないというわけではないので、せっかくですのでいろいろ試してみることをおすすめします。 ちなみに私はどちらも特徴的なアプリですので、両方を状況に応じて使い分けています。 > いまいちFlexとAirの違いが分かりません。 Flexから作れるものがswfで、swfをアプリとしてうごかせる技術がAIRです。 違いも何も、Flexから作れるものがFlashとAIRです。 まとめます。 swfを再生＝Flashと一旦定義しておく。 FlashCS5からFlashは作れる。 FlexからもFlashは作れる。 Flexを便利に使うアプリのひとつがFlashBuilder。 FlashをアプリにできるのがAIRなので、 FlashCS5からFlashやAIRは作れる。 FlexからもFlashやAIRは作れる。 Flexを便利に使うアプリのひとつがFlashBuilder。 極端に単純化しましたので正確ではないですが、今後Flashの勉強のとっかかりになれば幸いです。
書かれていらっしゃるスクリプトのままでは モーショントゥイーンの前に， エラーの大嵐でパブリッシュ不可能ですよ。。。 スクリプトを次のように修正して 下の【添付図】↓のようなものを作ったところ 確かに，「test」のモーショントゥイーンは止まりました。 //---修正----------------------------- stop(); btn.addEventListener(MouseEvent.CLICK, black); function black(event:MouseEvent):void { var color = new flash.geom.ColorTransform(0,0,0,1); test.transform.colorTransform = color; } btn2.addEventListener(MouseEvent.CLICK, goPlay); function goPlay(event:MouseEvent):void { gotoAndPlay("10"); } //----------------------------------- 【添付図】↓では 別レイヤーで ★MC(ムービークリップ) も動かしてみていまが その ★MC の方の動きは止まらないので タイムラインの再生が止まったのではなく ご質問で書かれていらしゃる通り 「test」のモーショントゥイーンが止まったことがわかります。 クラシックトゥイーンでも同じことをしてみましたが モーショントゥイーンと同じく「test」の動きが止まりました。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ しかしですね，思うのですが，，， モーショントゥイーン(またはクラシックトゥイーン)というのは Flashオーサリングソフト内でのプロパティの連続変化補完機能ですよ。 ※ Flashオーサリングソフト＝Flash CS3 や CS5.5 など ですから 仮にモーショントゥイーンが止まらなかったとしても 普通はモーショントゥイーンの部分で 元のプロパティ(黒色にしていないプロパティ)に戻るとも考えられます。 したがって普通は 「ActionScriptでMCのプロパティを変える」 ということと 「モーショントゥイーンで同じMCのプロパティを変える」 ということを両立させようとは考えないと思います。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 対処法は簡単で(というか普通は先にこっちを考えますが)， 「test」MC の中に 子MC を作って (＝「test」MCの中身を全て 子MC 内に入れて) その 子MC を黒色に変えれば良いでしょう。 例えば 「test」MCの中の 子MC に「ko_mc」というインスタンス名を付けた場合， 上に書いたスクリプトの test.transform.colorTransform = color; の行を test.ko_mc.transform.colorTransform = color; に変えれば良いだけです。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ もしくは別の対処法として スクリプトを ActionScript 2.0(1.0) に書き換え， Flash Player 8 用の SWF をパブリッシュする方法もあります。 ActionScript 2.0 に書き換えたスクリプト↓。 //----------------------------------- stop(); btn.onRelease = function():Void { var color = new flash.geom.ColorTransform(); color.rgb = 0; test.transform.colorTransform = color; }; btn2.onRelease = function():Void { gotoAndPlay("10"); }; //----------------------------------- 上のようにすると「test」のモーショントゥイーンは止まりません。 しかしもっともこれは， 上のように色のプロパティを変えたときなど限定です。 例えば次のようにして _xプロパティ(x座標プロパティ)を変えたときには 「test」のモーショントゥイーンは止まります。 //----------------------------------- stop(); btn.onRelease = function():Void { test._x = 0; }; btn2.onRelease = function():Void { gotoAndPlay("10"); }; //----------------------------------- やはり 上で書いた「test」MCの中に 子MC を作る方法のように ActionScript でプロパティを変える対象と モーショントゥイーン でプロパティを変える対象は分けるべきでしょうね。
参考にされたページを見て 実際にそのページに書いてある通りのことをやってみて 当然そのページに書かれてあることはできたのですよね？ 思うのですが， そのページに書かれてある内容から実際に動作するものを作るには， 結構な知識や経験が必要だと思いますよ。 (つまり，書かれてある内容を見て実際に再現できるような方がするような質問でない気がします。) といわけで，当たり前ですが， そのページに書いてあることの再現方法など説明しませんよ。 (その説明の方がもっと手間と時数が必要。) そのページに書いてある状況までは当然できているものとして その続きの部分から説明します。 > 配列を読み込む手順がどうしても分かりませんでした 正確には「配列を読み込む」のではなくて， array1=1,2,3 と array2=1,2,3,4 と array3=1,2,3,4,5 という文字列データを Flash 内で配列として扱うようにするのでしょう？ 何をするのかを自身の中でハッキリさせましょう。 そういった何かのセパレータ(ご質問の場合は「,(カンマ)」)で区切られた文字列を 配列にするのでしたらStringクラスのsplitメソッドでできます。 例えば var array1 = "1,2,3"; というものがあるとするなら var arr1:Array = array1.split(","); で 配列 arr1 ができます。 これでできる配列はこんなもの↓です。 arr1 =["1","2","3"]; 具体的には private function onComplete(evt:Event):void{…} の fumction 内で var arr1:Array = vars.array1.split(","); と書けば その function 内のローカルな変数 arr1 に ["1","2","3"]という配列が代入されます。 それはさておき > 変数のみのtxtと > 配列のみのtxtとで分けての出力も可能です。 これ↑の意味がわかりません。 「配列」は「配列」であってそれをテキストフィールドに表示することはできません。 「配列」を再び文字列に戻すか もしくは「配列」の各要素である文字列をテキストフィールドに表示するのであればできますが。 つまり何が言いたいかと言うと 『「配列」をテキストフィールドに表示する』ということが得たい動作の最終形でしたら 最初から『配列にする必要などない』ということです。 テキストフィールドに表示できるのは基本的に文字列だけなのですから 最初から文字列のままで良いでしょう？ とにかく， 全体的になんだか変な質問だと思います。 質問になりえていない質問(スタートラインに立ててない質問)に見えます。
ActionScript 3.0 では ExternalInterface.addCallbackの引数は２つです。 また戻り値もありません(voidです)。 さらに _rotation などというプロパティも(既存では)存在しません。 さらに this のスコープも全く違います。 書かれていらしゃるページのスクリプトは ActionScript 3.0 設定で動作するはずがありません。 というわけで↓ 「javascriptからflash(as3)を操作する - Yahoo!知恵袋」 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1380797983
まず...， 大きく誤解をされているように思うのですが。。。 combobox_cb.selectedItem.label = ○○; ↑これだと(仮にこれが通用したとしても)， コンボボックス「combobox_cb」で選択しているアイテムのラベルが「○○」になってしまうだけですよ。 わかりますでしょうか？ 他のものに喩えるなら 「バッター(打者)をAからBに変更する」 のではなくて 「バッター(打者)の名前をAからBに変更する」 みたいな感じになるというか。。。 つまり 「選択アイテム自体を切り替える」のではなくて 「選択されたアイテムのラベルを変える」になってしまうということです。 (場合によっては同名のラベルがどんどん増えていくことになる。) そうではなく， 「選択アイテム自体を切り替える」」のでしたら， selectedItem.label ではなく selectedIndex を変える必要があります。 　 それと...， スクリプト中に次の１行↓がありますよね。 combobox_cb.prompt = 'フォント2'; この prompt を設定した場合 コンボボックスのアイテム 非選択時 には デフォルトでその prompt である「フォント2」の項目が選択されているということになるんです。 selectedIndex で言うところの -1 が選択状態になるということです。 この prompt には label というものがそもそもありません。 label などないのでそれを変えようとしても > TypeError: Error #1009: null のオブジェクト参照… となるのです。 　 あくまでも私の推測ですが ですから二重に誤解されているような気がします。 というわけで 私の推測を含む↓修正例(★の部分)です。 //--------------------------------------- package { import flash.display.*; import flash.events.*; import flash.text.*; import fl.events.*; import fl.controls.*; import fl.data.DataProvider; public class test extends MovieClip { var comboData:Array = new Array( {label:"フォント1"}, {label:"ＭＳ ゴシック"}, {label:"フォント3"} ); var combobox_cb:ComboBox; //★↓重複しているので削除↓★ //var combobox_cb:ComboBox; var format:TextFormat; var text:TextField; public function test () { init (); } private function init ():void { combobox_cb = new ComboBox(); combobox_cb.dropdownWidth = 200; combobox_cb.width = 200; combobox_cb.move (150, 50); combobox_cb.dataProvider = new DataProvider(comboData); combobox_cb.prompt = 'フォント2'; format = new TextFormat(); format.font = "ＭＳ ゴシック"; text = new TextField(); text.defaultTextFormat = format; text.text = 'テキスト'; addChild (combobox_cb); addChild (text); text.addEventListener (MouseEvent.CLICK, changeHandler); } private function changeHandler (e:Event):void { trace (e.currentTarget.getTextFormat().font); //★---↓以下変更↓---★ //コンボボックスの各アイテムをループ for (var i:int = 0; i <= combobox_cb.length-1; i++) { //もしラベルとフォント名が同じであれば if (combobox_cb.getItemAt(i).label == e.currentTarget.getTextFormat().font) { //そのアイテムを選択 combobox_cb.selectedIndex = i; //この forループ を抜ける break; } } } } } //--------------------------------------- 　
> 自分で一から、新規ファイルを作って、 > １フレーム目にスクリプトをコピペしても > 未定義である可能性が高いメソッド：createEmptyMovieClip > 未定義のプロパティ：onEnterFrame > の２つのエラーが出ています。 それはバージョンが違うからでしょう？ 参考にされたFLAファイルは そのファイル名(…fla08_as1.fla)を見ればわかりますが 「Flash 8」で作られた「ActionScript 1.0」でのサンプルです。 (ActionScript 1.0 と 2.0 は互換性があるので ActionScript 2.0 のパブリッシュ設定でも動作します。) 試しに「Flash CS4」 で 「ActionScript 3.0」設定のドキュメントを新規で作成し 参考にされたスクリプトを フレーム1 に貼り付けてパブリッシュしようとすると 書かれていらっしゃるようなエラーが出ました。 ですからおそらく 質問者さんは Flash CS3 以上をお持ちで ActionScript 3.0 パブリッシュ設定のドキュメントに スクリプトをコピペされたのだと思います。 参考にされたFLAファイルのスクリプトを使う場合は Flash でドキュメントを新規で作成するときに Flashファイル(AS2.0) を選ぶかもしくは 「ファイル」→「パブリッシュ設定」で「スクリプト」の欄を ActionScript 2.0(または 1.0) に設定する必要があります。 (「パブリッシュ設定」の「スクリプト」の欄はバージョンによって存在する場所が違うため，詳しくは書き(書け)ません。) (ActionScript 3.0 と 2.0 以下は互換性がないので必ず ActionScript 2.0 以下のパブリッシュ設定にする必要があります。) (また同じファイルで ActionScript 3.0 と 2.0 以下との混在はできません。) とにかく『Flash で最も重要なのは バージョン！』です。 バージョン抜きで話は進められませんし バージョンの考慮抜きで作成はできません。 ＝//＝//＝//＝//＝//＝//＝//＝//＝//＝//＝ というわけで 参考にされたFLAファイルのスクリプトを使う場合は パブリッシュ設定 で ActionScript 2.0 以下に設定する必要があります。 また上記では Flash Player について触れていませんが パブリッシュ設定 で「Player」のバージョンを 「Flash Player 8」以上設定する必要があります。 繰り返しますが『Flash で最も重要なのは バージョン！』です。 そういう前提条件(AS2以下 ＆ Flash Player 8 以上)である場合において > 全部で120フレームの48-72フレームの間だけ > 下記のアクションスクリプトで > ノイズ画面を表示したいと思っています。 に回答します。 フレーム48 にキーフレームを作って そのキーフレームに参考にされたFLAファイルのスクリプトを書きます。 そして フレーム72(または73) にキーフレームを作って そのキーフレームに次のスクリプトを書きます(コピペ可)。 //------------------------------------------------- //onEnterFrame(毎フレーム実行するイベントハンドラメソッド)を削除 delete onEnterFrame; //作成した「mc」を削除 mc.removeMovieClip(); //-------------------------------------------------
＃１ですが。。。 > パブリッシュプレビュー時には、下記のメッセージが表示されます。 > 「行6' { 'が必要です。」 > ～略～ > 行９とは…。 > 「 } 」となります。 は？ 何が？ 私はちゃんと作ってみて動作検証してから回答してるんです。 ちなみに もう一度最初から100フレームのムービーを作ってみて ＃１に書いたスクリプトをフレーム100のキーフレームにコピペしてみましたが エラーも出ない上，ちゃんと動作もしましたよ【図】↓。 　 　 > タイムライン最後のフレームに行っても、 > 再生停止せずに、 > すぐにループしてしまい最初のフレームに戻って再生されてしまいます。 最終フレームに stop(); だけを書いた場合も止まらないのでしょうか？ もし止まらないのであれば すでに異常なことをされているということです。
＃１です。 > ■症状 > テキストエリアをステージに配置せずASだけで作成し > プレビュー(Ctrl+Enter)すると > 必ずエラーになります。 > > ■解決策 > ASはそのままで、ステージにテキストエリアを配置しこれを削除してからプレビューすると > 問題なく表示されるのですが、これはなぜなのでしょうか？ 一体全体何を書かれているのでしょうか？ テキストエリアをステージに配置するようにしなけれなならない状況にしているのは 私ではなく質問者さん自身ですよ。 ご質問のスクリプトで > var textInput:TextArea = new TextArea(); と書かれていますよね？ こう書かれている以上， TextArea をライブラリに登録しておく必要があるのでしょう？ 質問する際にそういう状況だったからこそ，そのスクリプトが書けたのでしょう？？ 本来，そのようにしておくことに関しては 質問者の方が 「テキストエリアをライブラリに登録してある状態でスクリプトを実行しています」 などと書くべきことです。 質問者が書くべきその事項を書かれていないので 私が後にこのページを見た方が混乱しないよに 質問者に代弁して ＃１ で， 「本体FLAドキュメントのライブラリには TextAreaコンポーネントがすでに登録されているものとします。」 と書いているのです。 (なお，ステージ上に配置しただけでもライブラリに自動登録されるので使えます。) そもそも TextArea というのは Adobe の人がコンポーネントとして作ったムービークリップです。 わかりますでしょうか？ 一般的な テキストフィールド など 元の Flash に内包されているものとは違って TextAreaコンポーネントは ムービークリップの中にテキストフィールド などを入れて Adobe の人が ユーザ にとって使いやすいように ActionScript もろとも その構造を "Flashで" 作ったムービークリップです。 少なくともそういう構造をしたムービークリップを ライブラリに登録しておかなければ そのムービークリップを new で呼び出して使えないでしょう？ そういうことですよ。 とにかく。 ＃１で 「本体FLAドキュメントのライブラリには TextAreaコンポーネントがすでに登録されているものとします。」 と書かせる状況を作ったのは私ではありません。 なぜ質問者が勝手に作った状況を 回答者である私が説明にないとならないのか，，， 全くもって疑問ですし，本末が転倒しています。。。 　 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ > this["mc"+i].buttonMode = true; > > できれば、指のマークにしたいのですが > 良い解決策はありますでしょうか？ そうすれば テキストフィールド内にマウスでアクセスできなくなりますが良いのですよね？ これも， くれぐれも誤解のないように書いて置きますが そのような状況(テキストフィールド にアクセスできなくなる状況)にしようとしているのは 質問者さんですよ(つまり回答者である私ではありませんよ。) 親であるムービークリップの mouseChildren を false にすれば良いです。 具体的には for (var i:int = 1; i<=3; i++) { //ムービークリップ「mc1～3」を作成 this["mc" + i] = new MovieClip(); //「mc○」のプロパティを適当に決める this["mc"+i].x=10; this["mc"+i].y=30+(i*30); this["mc"+i].buttonMode=true; //メインタイムラインに「mc○」を配置 addChild(this["mc"+i]); の部分を for (var i:int = 1; i<=3; i++) { //ムービークリップ「mc1～3」を作成 this["mc" + i] = new MovieClip(); //「mc○」のプロパティを適当に決める this["mc"+i].x=10; this["mc"+i].y=30+(i*30); this["mc"+i].buttonMode=true; //★↓付け加え this["mc"+i].mouseChildren = false; //メインタイムラインに「mc○」を配置 addChild(this["mc"+i]); のようにすれば良いです。
そもそも なぜ "インスタンス名" 自体を考えるのでしょうか？ その辺が変(理解しがたい)です。 次のページ全体を良く理解してみてください。 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html 上記ページでは インスタンス名を使ってインスタンスにアクセスする方法なども書いてあって(つまりご質問に対する直接的な答えになっている部分もあって)全体的に重要ですが そういうインスタンス名の取り扱い方自体よりも，むしろ最後の部分が最重要だと思います。 　～最後の部分を引用～ > 「オーサリング時に配置したMovieClipインスタンス」では、 > タイムラインに予め配置して [プロパティ]インスペクタで > 設定したインスタンス名は、 > そのまま変数のように参照として扱うことができました。 > これは、ActionScript 3.0では、 > Flashがインスタンス名と同じ名前の変数を自動的に宣言して、 > そこにインスタンスの参照を格納する仕組みに > なっているからです[*1]。 > したがって、やはり変数によりインスタンスを参照する > というのが、ActionScript 3.0の基本だといえます。
> タイムライン上だけで作ると惜しいものができたのですが、 > Images5までいってImages1に戻ったときに、 > Images5の上からImages1を重ねるという操作がわからず、 > タイムラインで作るのを諦めました。 と書かれていらっしゃいますが， そこら辺をどうするかを "具体的にイメージする" ということができなければ 結局何でやっても同じだと思いますよ。。。 何にしてもまずは具体的な動作シナリオ(アルゴリズム(手品のタネ))のイメージを作って そのイメージ通りに動くように タイムラインで動きを作ったり， ActionScriptをコーディングしたりするわけですから。 タイムラインで作る方法は 定番中の定番の方法ですが下の【添付図】↓をご参考に。 【添付図】↓を見てイメージは湧きましたか？ 本来，これくらいの仕組みは自力で考え出さなければなりません。 　 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 次にスクリプトです。 例えばメインタイムラインのフレーム1など， フレームに書くスクリプト例です↓。 //--------------------------------------------- //Imagesの色分け用に色指定する配列を適当に作成 var colArr:Array=[0xFF0000,0x00FF00,0x0000FF,0xFFFF00,0x00FFFF]; //スプライト Images1～Images5 を一気に作成＆配置 for (var i:int=1; i<=5; i++) { this["Images"+i] = new Sprite(); this["Images"+i].graphics.beginFill(colArr[i-1]); this["Images"+i].graphics.drawRect(0, 0,300,-500); this["Images"+i].graphics.endFill(); addChild(this["Images"+i]); } //２秒後に関数「startImages」を実行するタイマーを用意 var myTimer:Timer=new Timer(2000,1); myTimer.addEventListener(TimerEvent.TIMER, startImages); //カウンタ用の変数cntを用意 var cnt:int=0; //Images○の動作を開始させる関数「startImages」の定義 function startImages(e:TimerEvent):void { //カウンタをカウントアップ cnt = (cnt<5)? cnt+1:1; //動かす「Images○」のy座標を0にする this["Images"+cnt].y=0; //動かす「Images○」の表示順を一番上(最高深度)に移動 this.setChildIndex(this["Images"+cnt], this.numChildren-1); //毎フレーム 関数「moveImages」を実行 this.addEventListener(Event.ENTER_FRAME,moveImages); } //関数「moveImages」の定義 function moveImages(e:Event):void { //「Images○」をスライド this["Images"+cnt].y+=10; //「Images○」のy座標が500以上になれば if (this["Images"+cnt].y>=500) { //「Images○」のy座標を500で固定して this["Images"+cnt].y=500; //毎フレーム 関数「moveImages」を実行するのを解除 this.removeEventListener(Event.ENTER_FRAME,moveImages); //タイマースタート(２秒後に「startImages」が実行される) myTimer.start(); } } //関数「startImages」を初回実行 startImages(null); //--------------------------------------------- 　 タイムラインで作るにしてもスクリプトで作るにしても やはりどちらにしても肝腎なのは， 具体的な動作シナリオのイメージでしょうね。 　
＃１です。 ◎ ＃１に書かれた「補足」の１つ目より。 > 結果として、拡大縮小の変化は起こりますが、 > 追跡は実行されませんでした。 > どの箇所が誤りと考えられますでしょうか？ 書かれているスクリプトでは 追跡が起こらない以前の問題で 「赤●」すら表示されないでしょう？ ＃１で書いたように > マウスのx座標に応じた半径の赤●を > 消しては描いて 消しては描いて… をしなければなりません。 つまり先に消すのです。 つまり _maru.graphics.clear(); が先です。 その点だけを先に修正すると function boo は次のようになります。 //---とりあえずの修正------------- function boo(eventobj:Event):void { _maru.graphics.clear(); var i:Number=mouseX; _maru.x=_maru.x*0.7+mouseX*0.195+0.005; i=_maru.x; _maru.graphics.beginFill(0xFF0000); _maru.graphics.drawCircle(0,0,i); _maru.graphics.endFill(); } //-------------------------------- これで「赤●」が描画されるようになります。 次にマウスの追跡がおこなわれていないということですが 私の見る限りマウスによってちゃんと座標は変わっていますよ。 「赤●」の大きさの変化に目がまどわされているだけではないでしょうか？ 「赤●」の大きさを固定すれば「赤●」のx座標がマウスによって変わることがハッキリ見えると思います。 //---大きさの変化を止める実験------- function boo(eventobj:Event):void { _maru.graphics.clear(); var i:Number=mouseX; _maru.x=_maru.x*0.7+mouseX*0.195+0.005; i=_maru.x; _maru.graphics.beginFill(0xFF0000); _maru.graphics.drawCircle(0,0,100); _maru.graphics.endFill(); } //-------------------------------- ↑その「赤●」の動き方が良いとか悪いとかそんなことは知りません。 「赤●」がマウスによって動くことは確かです。 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ◎ ＃１に書かれた「補足」の２つ目より。 > 上記のプログラミングに「Y軸方向の追跡」 >（要するにステージ内全体） > を追加しようと以下を記述しましたが、 > 今回は表示すらされなくなってしました。 これも上の最初に書いたことと同じです。 せっかく描いた「赤●」を消してしまっては見えませんよ。 前のフレーム時間で描いた「赤●」を消してから 今のフレームで「赤●」を描くのです。 > 消しては描いて 消しては描いて… です。 ですから function boo は次のようになります。 //---修正------------------------- function boo(eventobj:Event):void { _maru.graphics.clear(); var i:Number=mouseX; _maru.y=mouseY; _maru.x=_maru.x*0.7+mouseX*0.195+0.005; i=_maru.x; _maru.graphics.beginFill(0xFF0000); _maru.graphics.drawCircle(0,0,i); _maru.graphics.endFill(); } //-------------------------------- 　
webama_fkさんこんにちは。 ＞ものすごく動画がチラつく わたしが経験した中で、もしかしたら解決するかもというものを２つ １．フレームレートを上げる ２．配置している画像ファイル（ライブラリの中のpngやｊｐｇなど） 　　のスムージングにチェックをしてみる、圧縮の設定なんかもいろいろ変えてみる。 実際に動画みられればちらつくというのが どういう状態かわかるのですが＾＾； よかったら上記試してみてください。
リンク先の動作をあくまでも「Flash」として表示させたいのであれば仰っている通りAdobe Flash Professional CS5.5が必要となるでしょう。 ただ、CSS3やjqueryを用いても問題ないブラウザを公開対象としているのであれば「jquery スライドショー」等で調べてみてください。 Flashではなくとも、似たような動作は可能です。
そもそも「□」をステージ上に配置することすらできていない状態であるのにもかかわらず 次々と何かの動作をさせて行こうとされているのが全くおかしいと思います(ありえない考え方＆やり方です)。 とりあえず「□」をステージ上に配置させてみれば？ それをせずして 仮に 「外部からの表示可能な複数の定義は使用できません。」 のエラーをクリアできたとしても その後も続々とエラーの嵐が続きますよ。。。 全体的に無茶苦茶な上 具体的に何をしようとされているのかわからないため修正のしようもありません。 「外部からの表示可能な複数の定義は使用できません。」 に関してはクラスの中で function が定義されていないからです。 形がそもそも変です。 現状の形を書きます。 package { 　　import ○○; 　　…略… 　　public class Rakka extends Sprite { 　　　　var ○○:△△; 　　　　…略… 　　　　maru_mc=new Sprite(); 　　　　…略… 　　} 　　function onEnter(e:MouseEvent):void { 　　　　…略… 　　} 　　function goBound(e:Event) { 　　　　…略… 　　} } function の定義がクラスからはみ出ているでしょう？ だいたいの形としては次のような形にする必要があります。 (インデントに全角スペースを使っているのでコピペはできません。) package { 　　import ○○; 　　…略… 　　public class Rakka extends Sprite { 　　　　var ○○:△△; 　　　　…略… 　　　　//↓コンストラクタ 　　　　public function Rakka() { 　　　　　　maru_mc=new Sprite(); 　　　　　　…略… 　　　　} 　　　　function onEnter(e:MouseEvent):void { 　　　　　　…略… 　　　　} 　　　　function goBound(e:Event) { 　　　　　　…略… 　　　　} 　　} } ↑このような形に修正したとしても まだまだエラーの嵐が続きます。 細かいことを挙げていてもキリがありませんが > maru_mc.graphic.lineStyle(6,0xee0033) > maru_mc.graphic.drawRect(0,0,120,120) この部分は maru_mc.graphic.… ではなく maru_mc.graphics.… です。 > stage.addEventListener(Event.MouseEvent,onEnter); ↑意味が全くわかりません。 何のイベントが発生したときに 関数「onEnter」を動作させたいのでしょうか？ > mouse_mc.y = mouse_mc.y +i*y/100 「mouse_mc」って何？ どこから出てきた何なのでしょうか？？？ ある程度の雰囲気で推測ができる人間すらわからないことだらけです。 PCにわかるはずがありません。 とにかくイベントや関数は抜きにして 次のような状態から， 実際にできるかどうかをやってみて 動作確認をしながら順々にスクリプトを組むべきです(コピペ可)。 //------------------------------------ package { import flash.display.Sprite; public class Rakka extends Sprite { var maru_mc:Sprite; public function Rakka() { maru_mc=new Sprite(); maru_mc.graphics.lineStyle(6,0xee0033); maru_mc.graphics.drawRect(0,0,120,120); this.addChild(maru_mc); } } } //------------------------------------ とにかく↑この状態すらできていないのに この先に進むのが間違いです。
スクリプト自体は間違っていないです。 text0の元のカラーは何色でしょうか。 ------------------------------------------------------------------------ new flash.geom.ColorTransform(0.9, 0, 0, 1, 0, 0, 0, 0); ------------------------------------------------------------------------ これだと、R（赤）の値が若干(10%)弱くなる程度なので、 変化に気づいていないだけという可能性があります。 また、元のテキストのカラーが黒(0x000000)など、 赤の値を含まない色だとすると、そもそも色は変わりません。 下記のようにアルファ値を変えてみても変化がないようでしたら、 ボタンのMouseEvent.CLICKが反応していないか、 text0が指定した階層に存在していないか、 どちらかだと思います。 ------------------------------------------------------------------------ new flash.geom.ColorTransform(0.9, 0, 0, 0.25, 0, 0, 0, 0); ------------------------------------------------------------------------ ちなみに、テキストを赤にする場合は下記のように指定します。 ------------------------------------------------------------------------ new flash.geom.ColorTransform(0, 0, 0, 1, 255, 0, 0, 0); ------------------------------------------------------------------------
おそらく，そのスクリプトの使い方をわかっていらっしゃらないのです。 慣れれば一瞬でわかるのですが 書かれていらっしゃるスクリプトは， FLAドキュメントのフレームに書くためのスクリプトではなく， ドキュメントクラスのクラスファイル用のスクリプトで， 外部の ASファイル(中身はテキストファイル) に記述するものです。 以下で使い方(手順)を説明します。 ********************************************** Flash CS5 を起動させます。 「新規作成」で「ActionScriptファイル」を選択します。 出てくるスクリプトエディタパネルに書かれていらっしゃるスクリプトをコピペします。 (チェックなどの理由も含めて念のため「自動フォーマット」ボタンで自動フォーマットします。) そのActionScriptファイルを「任意のフォルダ」に「GraphicsSample.as」というファイル名で保存します。 次に「ファイル」→「新規」で ActionScript 3.0 のドキュメントを作成します。 作成したドキュメントのステージ上を一度クリックした状態で ステージ右横に表示される「プロパティ」インスペクタ(パネル)より 　クラス：[　　　　　　] となっている部分に「GraphicsSample」と記入します。 そして「GraphicsSample.as」を保存したフォルダと同じフォルダに 「名称未設定-1.fla」のような任意の名前でドキュメントを保存します。 そして「制御」→「ムービープレビュー」または「ファイル」→「パブリッシュ」をして動作確認をします。 ********************************************** 「GraphicsSample.as」というファイル名はそのファイル名でなければなりません。 public class GraphicsSample extends Sprite のクラス名「GraphicsSample」と一致している必要があります。
おそらくflaファイルのフレームに書かれているスクリプトだと思いますが、 仰る通り、上記のimport文はなくとも動作します。 記述の意味がないというわけではなく、 フレームのスクリプトの場合、よく使うimport文は 自動的に追加されるようになっているためです。 (勉強中であれば、覚えるために書いた方がいいかもしれないですが) 具体的には下記の一連のパッケージのクラスは自動的に追加されますので、 import文の記述は必要ありません。 --------------------------- adobe.utils.* flash.accessibility.* flash.display.* flash.errors.* flash.events.* flash.external.* flash.filters.* flash.geom.* flash.media.* flash.net.* flash.printing.* flash.system.* flash.text.* flash.ui.* flash.utils.* flash.xml.* --------------------------- しかし、この先、クラスファイル(asファイル)に分けて書くようになった場合、 すべてのパッケージのクラスにimportの記述は必須です。 とはいえ、Flash Builderなどのエディタを利用すれば スクリプトにクラスを追加した時点で import文は自動的に追加されるようになるので、 自分で書く機会はそれほど多くありませんが・・・。
まず， > flashにflvの動画を埋め込んだらループしない などと書かれていますが，参考にされたページ http://itpro.nikkeibp.co.jp/article/COLUMN/20090609/331572/ には 「flvの動画の読み込み方」が書かれてあるのです。 「flvの動画の埋め込み方」など書かれていません。 ご自身の中でこの辺のことをハッキリさせてください。 もし「flvの動画の埋め込んだ場合」は SWFのタイムラインを使ってflvを再生させるのですから > 「パブリッシュ設定」の[HTMLラッパー] - > [再生]内にある項目の[ループ] などが関係します。 しかし 参考にされたページのように「flvの動画の読み込んだ場合」は FLVPlaybackコンポーネント内 で外部flvが再生されるのですから > [再生]内にある項目の[ループ] などは全く関係しません。 普通はSWFのタイムラインは基本的には止めておくものです。 (ループ再生どころか再生させること自体も普通はしない。) ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ というわけで FLVPlaybackコンポーネントに "読み込んだ" 外部flv動画を 無限にループさせる方法です。 まずステージ上に配置した FLVPlaybackコンポーネント を選択して プロパティインスペクタ(プロパティパネル)を表示させて 「インスタンス名」を付けます。 ここでは仮に「myPlayback」というインスタンス名を付けるとしておきます。 その「myPlayback」が存在するタイムラインのフレーム (例：メインのタイムラインのフレーム1 など)に 次のようなスクリプトを書きます(コピペでもOK)。 ◎ ActionScript 3.0 の場合 //------------------------------------- //VideoEventクラスのインポート import fl.video.VideoEvent; //「myPlayback」の再生が完了したときに関数「videoPlay」を実行 myPlayback.addEventListener(VideoEvent.COMPLETE,videoPlay) //関数「videoPlay」の定義 function videoPlay(e:VideoEvent):void{ //ビデオの再生を開始 e.currentTarget.play(); } //------------------------------------- ActionScript のバージョンを書かれていませんが Flash CS5.5 ということですから おそらく上の ActionScript 3.0 用スクリプトで良いと思います。 しかし ActionScript 2.0 設定のドキュメントを作成されている可能性も全くないとも言いきれませんので 念のため ActionScript 2.0 での場合のスクリプトも書いておきます。 ◎ ActionScript 2.0 の場合 //------------------------------------- // リスナーオブジェクトを作成 var videoListener:Object = new Object(); //ビデオ再生完了時の動作を定義 videoListener.complete = function(e:Object):Void { //ビデオの再生開始 e.target.play(); }; //「myPlayback」にイベントリスナーを登録 myPlayback.addEventListener("complete", videoListener); //-------------------------------------
> 横に弾んでいくのではなく、 > 同じ場所で縦にのみバウンドする動き つまり単純に 「x座標方向(横方向)移動関係のスクリプトを全て消せば良い。」 それだけのことでしょう？ 横に動く理由(原因)は 「x座標方向に動かしているからx座標方向に動く」 それだけのことです。 ですからこの理由(原因)を取り除けば良いだけです。 最初の「move_05_00_fla05_as1.fla」内の 「player(ボールMC)」自体に書かれたスクリプトを変更する場合は 次のようになります(x座標に関係する行を消しただけ)。 //--------------------------- onClipEvent (load) { _y = 150; dy = -10; } onClipEvent (enterFrame) { dy += 0.5; // 下方向に移動量を増やす _y += dy; // 地面に着いたらyの移動量を反転 if (_y>250) { _y = 250; dy *= -0.8; } } //--------------------------- 　 　 > また、バウンドがその場で止まったあと、 > 横に少し転がって止まる 私が上に書いたスクリプトでも 元のスクリプトでも，バウンドは決して止まりません。 -0.8倍 ずつ小さくなるだけです。 ですからまずは， 「『バウンドが止る』とはどういうことなのか」 を定義する必要があります。 その定義した状態(条件)になれば 『横に転がる』という動きをさせるわけですが 「どのように『横に転がる』のか」 これも書かれていないのでわかりません。 さらに「少し転がって」の 「『少し』とはどういうことなのか」 もわかりません。 『少し』とは 時間的に『少し』なのか，距離的に『少し』なのかすらもわかりません。 すべてにおいてアヤフヤですね(考える気すらもないのでしょうか？)。 もしスクリプトをコーディングするのでしたら その前にこの辺のことはしっかりと "具体的に" 考えておく必要があります。 スクリプト以前(以下)の話です。 とにかく他人まかせ(または PCまかせ)でアヤフヤなことだらけなので 私が勝手に決めた定義と動きで行きます。 //--------------------------- onClipEvent (load) { _y = 150; dy = -10; } onClipEvent (enterFrame) { dy += 0.5; // 下方向に移動量を増やす _y += dy; // 地面に着いたらyの移動量を反転 if (_y>250) { _y = 250; dy *= -0.8; //もし dy の絶対値が 1 未満になれば if (Math.abs(dy)<1) { //x座標を 80 に向けて 1/20 ずつ近づける this._x +=(80-this._x)/20; } } } //--------------------------- 　 気に入らない動きであれば自由に変更してください。 　 思うのですが， 何故このような動きにスクリプトを使う必要があるのでしょうか？ もし，ActionScript やそれ以前(以下)のことすら考える気もないのでしたら 最初からスクリプトなど使わずにモーショントゥイーンで作成すれば良いだけだと思います。 モーショントゥイーンを使えばもっと良い動き(情緒や感性あふれる動き)を簡単に作ることができますよ。 「移動するバウンドボール（オレンジのサンプルFLASH講座）」 http://orange.2-d.jp/flash/anime/03.html 「FLASH活用講座 トゥイーンアニメーションを作る」 http://juen-cs.dl.juen.ac.jp/html/flash/04/03/explanation.html 「24　リアルなボールのバウンド - MdN Design Interactive」 http://www.mdn.co.jp/di/articles/655/?page=4
1.まず、開発者登録をしていない場合、開発者登録をします。 https://developers.facebook.com 2． 何でもいいですがFacebookページを作ります。 http://www.facebook.com/pages/create.php 3． 次にHTMLで埋め込むためのアプリを追加します。 (※以前はFBMLというFacebook独自の言語を使用するアプリを使って ページに表示させていましたが、 現在はiFrameで通常のHTML/Javascriptも利用できるようになったので、 iFrameで追加できるアプリを使った方がいいです。 一応、iFrameとFBMLのFlashの挙動の違いはこちら。 http://www.adobe.com/jp/devnet/facebook/articles/iframe_fbml_flash_platform_comparison.html) 自分はStatic HTMLというアプリを利用しています。 http://apps.facebook.com/static_html_plus/?ref=ts iFrameを追加できるアプリであれば何でもいいです。 ここから「Add Static HTML to a Page」をクリックして作成したページに追加します。 4.ページのメニューに「Welcome」というタブが追加されているので、 　あとはそこからswfを埋め込むHTMLコードを入れるだけです。 とりあえず、単純に ----- <embed src="swfのURL" width="100" height="100"/> ----- と入れるだけで表示されるはずです。 ■参考 FacebookページにiFrameを組み込もう http://socialmediaexperience.jp/2889
Event.ENTER_FRAME は 毎フレーム毎フレーム（１フレーム進む時間ごとに毎回(例：20fpsだと１秒間に約20回)）実行し続けるイベントです。 ムービー自体の構造などがわからないため何ともいえませんが， その Event.ENTER_FRAME イベントで function playerActions を実行し続けているために player2.gotoAndStop("up"); が毎フレーム毎フレーム実行されて player2 の内部のフレームが 「up」フレームを表示され続けているために 行進をやめてしまうのではないでしょうか？ もしそうであれば player2 の内部のフレームが 「up」フレームに さらに内部で行進するムービークリップを作成すれば良いと思います。 つまり player2 内のタイムラインそのものを使って行進させるのではなく player2 内のさらにムービークリップ内のタイムラインを使って行進させれば良いと思います。 ActionScript とは まずはインスタンスがあって そのインスタンスのプロパティを設定したり そのインスタンスに動作命令をしたり そのインスタンスにイベントリスナーを登録していくものです。 インスタンスが見えない以上(まずはインスタンスを思惑通りに作成しないと)， ActionScript など書けません。 インスタンスを思惑通りに作成して そのインスタンスを思惑通りに動かすのです。 ActionScript だけをタラタラ書いたり 何の思惑もなくごちゃごちゃ変えても 無事に動くはずがありません。 結局，ActionScript などの前に 「何をどうしたいの？」ということです。 「何をどうするのか」という方針(思惑)がない以上スクリプトは書けませんし 「何をどうするのか」という方針(思惑)によってムービーの構造やスクリプトは変わります。
Fladeは元々が ActionScript 1.0 用に作られた古い物理演算ライブラリですから なんとかすれば Flash Lite 2.0 で動くかもしれません(不明)。 Google検索「Flade」 http://www.google.co.jp/search?hl=ja&ie=UTF-8&q=Flade ActionScript 3.0 でも良いとかになると 次のように検索すればある程度情報が出てくると思います。 Google検索「物理演算 ライブラリ Flash」 http://www.google.co.jp/search?hl=ja&ie=UTF-8&q=%e7%89%a9%e7%90%86%e6%bc%94%e7%ae%97+%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa+Flash
function moveMC(e:Event):void { この書き方からすると、なんらかのイベントに関連付けた(addEventListenerした)関数であるように思いますが。 それなら、その関数を停止させたい場面でremoveEventListenerすれば良いだけだと思います。 書かれたソースを見る限り、moveMCはあくまで関数であり、オブジェクトではありません。 オブジェクトではないので、メソッドを定義させる事ができません。 moveMC.stop();は、stopメソッドの呼び出しという意味になるので、存在しないものを呼び出そうとしている間違いですね。 そんな間違いにエラーメッセージが「stopが定義されていない」と出るのだとしたら親切じゃないですね。 それとも、ActionScriptの内部的には関数であってもオブジェクトなのでしょうか？ ま、そんな疑問は余談ですが。
> 未定義である可能性のあるメソッドstop～ 未定義なんでしょ。 実装してやればＯＫ
よく分かりませんが、startMM内の mc.addEventListener(Event.ENTER_FRAME,moveMM); を mm.addEventListener(Event.ENTER_FRAME,moveMM); に、したらどうでしょう？
もう解決されてしまったかもしれませんが、 デフォルトの設定が記述されたxmlを書き直せば、 Flash再起動後、一括で設定が変わるはずです。 Macの場合は下記の場所にあるファイルを変更します。 (Windowsの場合はAdobe以下は一緒だと思ったので検索等で調べてください。) /Users/[ユーザー名]/Library/Application Support/Adobe/Flash CS5/ja_JP/Configuration/Publish Profiles/ default.xml おそらく設定を変更してなければ64行目 ---------------------------------------------------------- <OmitTraceActions>0</OmitTraceActions> ---------------------------------------------------------- ↓ 0を1に変更 ---------------------------------------------------------- <OmitTraceActions>1</OmitTraceActions> ----------------------------------------------------------
cntが0の場合 (mc.x<cnt*50) の部分は、(mc.x < 0) ですよね mc.xが0になると、(0 < 0) となり、条件式は偽(false)です。 10加算されることもなくなり、その後ずっと0のままになるのではないでしょうか？ if (mc.x<=cnt*50) { にしてみては？
mc.x などという書き方をされているところから推測して ご使用の ActionScript のバージョンは 3.0 ですよね？ また何の説明もありませんが mc.x の mc とはステージ上にあるムービークリップのインスタンス名ですよね？ その辺のことはちゃんと記述すべきです。 その他に関しても説明が不足し過ぎているため 「いったい何だ？ どうしたいんだ？」と思うことが多々多々ありますが 私の推測を含めて一応スクリプトを考えてみました。 /*===========================================*/ //カウンタとなる変数「cnt」を用意 var cnt:int=0; //「mc」を右に 5px 動かす関数「moveMC」を作成 function moveMC(e:Event):void { if (mc.x<200) { if (mc.x<cnt*5) { mc.x+=1; } else { //「mc」から毎フレーム実行する関数「moveMC」を削除 mc.removeEventListener(Event.ENTER_FRAME,moveMC); } } else { //指定時間間隔で関数「startMC」を実行するのをやめる myTimer.removeEventListener(TimerEvent.TIMER, startMC); } } //5秒間隔で動作するTimerインスタンスを作成 var myTimer:Timer=new Timer(5000,0); //指定時間間隔で関数「startMC」を実行 myTimer.addEventListener(TimerEvent.TIMER, startMC); //タイマースタート; myTimer.start(); //関数「startMove」の定義; function startMC(te:TimerEvent):void { //カウンタに１を加算 cnt++; //「mc」に毎フレーム実行する関数「moveMC」を登録 mc.addEventListener(Event.ENTER_FRAME,moveMC); } //関数「startMove」をすぐに実行 startMC(null); /*===========================================*/ 5秒間隔で5pxずつ動くのですから かなり地味な動きですよ。。。
事前にmc.xの初期値を控えておいて、 差分が10未満の時だけ+1するようにしたら良いんじゃない？ mc.addEventListener(Event.ENTER_FRAME,function(event){ mc.scaleX += 0.01; mc.scaleY += 0.01; if ((mc.x - mc.xの初期値)< 10) { mc.x = mc.x+1; } }); イベントそのものがいらないなら、removeEventListenerしちゃっても良いけど。
FLASHというプログラムでのオブジェクト移動や変換などこれらは大変優れた環境です。 死んだジョブスがウチの製品はFLASHつかわないよといって　混乱を招きましたけど 貴方のとこの特殊な環境に合わせるほうが面倒だったわけで 代替案で出されたHTML5ではFLASHに成り代わるどころかそもそも、プラットホームが違うわけです。 結局FLASHと言っても　高々動画の変換した際に動くかどうかだけの話を向こうは持ち出しただけで プログラムを絡んだ開発プラットフォームは　必要なわけです。 結局それに変わる代替案もなくジョブスは死にましたが 動画形式はFLVからMP4へ変わっていってますが それ以外の部分ではまだまだFLASHは生きてきます。 たかだか　動画だけならFLASHにする必要はなくなった　だけです。
「ひとつ前のシーン」の件は少しややこしい(色々な場合がある)のでとりあえず置いておいて 「Shiftキー」を押すことで シーン「P33」のフレーム「P33end」に移動するスクリプトを書きます。 リスナー関数の仮引数(ご質問のスクリプトの場合は「event」)には 発生したキーボードイベントオブジェクトの参照が入ります。 そのキーボードイベントのkeyCodeプロパティを調べると そのキーボードイベントを発生させたキーコードがわかります。 『もしそのキーコードが「SHIFT」キーであれば…』というif文を付け加えれば良いので 次のようになります↓。 //************************************** stop (); stage.addEventListener (KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_033); function fl_KeyboardDownHandler_033 (event:KeyboardEvent):void { if (event.keyCode == Keyboard.SHIFT) { MovieClip(this.root).gotoAndPlay ("P33end", "P33"); stage.removeEventListener (KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_033); } } //************************************** Keyboard.SHIFT は Keyboardクラスの定数です。 このような書き方を知らなくても(ヘルプなどで調べなくても)別にかまいません。 fl_KeyboardDownHandler_033 内に trace(event.keyCode); などと書いて「制御」→「ムービープレビュー」すれば キーコード(コード番号)得られます。 「SHIFT」キーのキーコードは 16 です。 ですから上のコードの if文 の部分を次のように変えても良いです。 if (event.keyCode == 16) ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ さて「ひとつ前のシーン」です。 上のスクリプトを原型にして 関数名だけを変えて「ひとつ前のシーン」に移動する場合は次のようになります。 //************************************** stop (); stage.addEventListener (KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_034); function fl_KeyboardDownHandler_034 (event:KeyboardEvent):void { if (event.keyCode == Keyboard.SHIFT) { MovieClip(this.root).prevScene(); stage.removeEventListener (KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_034); } } //************************************** この prevScene() ですが これは gotoAndStop(○○) と同じで そのシーンの先頭フレームで止まります。 gotoAndPlay(○○) と同じように シーンの先頭フレームから再生を開始させたい場合は MovieClip(this.root).prevScene(); の後に MovieClip(this.root).play(); と書く必要があります。 ただし この MovieClip(this.root).play(); を付け加えて動作するのは Flash Player 10 以上(要 Flash CS4 以上)のみの場合があります。 この辺は場合(その他の条件)によって変わるので実際にやってみないと何とも言えません。
ムービークリップ内に子ムービークリップを作って 親元の方のムービークリップを回転させれば良いのではないでしょか？ と言ってもここでは 図なども１枚しか提示できませんしサンプルＦＬＡも提示できないので そういう技術系(図画工作系)の回答は難しいですね。。。 私の言っているのはこんな感じ↓のことです。 「Flash CS4 で 3D をやってみる！」 http://suzupara.iinaa.net/mixi/cs4_3d_1/
「function」は SWF4(携帯用Flash) では通用しません。 と言うことは， 作成しようとされている SWF は，SWF6以上(SWF8以下)ですよね？ そうだとするなら ご質問本題の回答以前の問題で， まずテキストフィールドに変数名を付けること自体が間違ったやり方です。 テキストフィールド に変数名を付けるのは Suzuka の場合は SWF4 を作成するときのみです。 (Adobe(Macromedia) Flash の場合は Flash Player 5 用以下の SWF をパブリッシュするときのみです。) 要するに昔の遺物で， テキストフィールド に変数名を付けた Flash は不具合が多々起こります。 (今回のご質問の件の不具合とは全く別の不具合です。) 「テキストフィールドのインスタンス名と変数名について」 http://help.adobe.com/ja_JP/AS2LCR/Flash_10.0/help.html?content=00000270.html > 変数名をダイナミックテキストフィールドや > テキスト入力フィールドに割り当てることができます。 > これによって、変数に値を割り当てることができます。 > これは、旧バージョンの Flash Player (Flash Player 4 など)用 > のアプリケーションを作成するときに使用する可能性のある > 非推奨の機能です。 　~~~~~~~~~~~~ SWF6 以上では ダイナミックテキストフィールドには "インスタンス名" を付けて ダイナミックテキストインスタンス.text = ○○; でテキストフィールド内に○○を表示させます。 ダイナミックテキストインスタンス.text = ○○; この意味をもうちょっと厳密に書くと 「ダイナミックテキストインスタンスのtextプロパティに○○という値を代入せよ」 となります。 Suzuka の場合は さらにこうすることによって シンボルリスト内のダイナミックテキストを １つにできるというメリットも増えます。 ご質問本題に関してですが テキストフィールドの中の文字列を使ってさらに演算を繰り返すこともできます。 しかしそれは普通はしません。 「演算は演算」です。 そして 「その演算結果をテキストフィールドに表示する。」です。 このように別々に処理(キッチリと明示的に処理)をするのが一般的な方法です。 シンボル名「スコアスプライト」(インスタンス名「scoreBoard」)内には 例えば「message_txt」というインスタンス名を付けたダイナミックテキストと 「score_txt」というインスタンス名を付けたダイナミックテキストとを用意します。 また変数名は削除します。 その場合の 「スコアスプライト」内のフレーム1のスクリプト変更例です↓。 //---------------------------------- this.score = 0; this.message_txt.text = this.score_txt.text = this.score; function scorePlus() { this.score ++; this.message_txt.text = this.score_txt.text = this.score; } //---------------------------------- もし 演算用の変数(上記の場合のscore)は用意せずに テキストフィールド内の表示文字列を軸にして演算を繰り返す場合は 次のようになります(普通はしない方法)。 //---------------------------------- this.message_txt.text = this.score_txt.text = 0; function scorePlus() { this.score_txt.text = Number(this.score_txt.text) + 1; this.message_txt.text = this.score_txt.text; } //---------------------------------- 　
＃１～３です。 FLA 拝見しました。 なるほど，そういう状況でしたか。 同じムービークリップインスタンス内で 順次「右へ」とか「左へ」とか「止まれ」を実行させるわけですね。 その状態であれば， this.addEventListener(Event.ENTER_FRAME, moveRandom); とか this.addEventListener(Event.ENTER_FRAME, moveRandom2); とか this.addEventListener(Event.ENTER_FRAME, moveRandom3); を解除(削除)しない状態のままで， 次々に次の addEventListener をしているので 各関数の命令が重複してしまって動作がおかしくなっているのです。 各それぞれの this.addEventListener(Event.ENTER_FRAME, moveRandom○); が不要になるタイミングは ムービークリップ内の各ブロックの最終フレーム(31，62，90)ですよね？ その辺で removeEventListener しておかないと どんどん動作が重複していってしまいます。 例えば ムービークリップ内の フレーム31 には 次のように書かれていますが gotoAndPlay(1); ここを次のようにします。 this.removeEventListener(Event.ENTER_FRAME, moveRandom); gotoAndPlay(1); ムービークリップ内の フレーム62 も同様に 次のようにします。 this.removeEventListener(Event.ENTER_FRAME, moveRandom2); gotoAndPlay(1); ムービークリップ内の 最終フレーム の場合は 次のようにします。 this.removeEventListener(Event.ENTER_FRAME, moveRandom3); Math.floor(Math.random()*5)+1; if (dice == 1) { gotoAndPlay(63); }…以下略… こうすれば それまでに動いている ENTER_FRAME動作 が削除されるので 動作の重複がなくなります。 「イベントリスナーを取り除く removeEventListener() - ActionScript 3.0入門ノート CS4」 http://oshige.com/flash/as3note_cs4/2009/09/-removeeventlistener.html 「FlashゲームPG講座 For AS3.0【EventDispatcher クラスについて】」 http://hakuhin.jp/as3/event.html#EVENT_02
まず確認ですが， Flash で「動画」と書かれると FLV などのいわゆる動画ファイルをイメージしてしまいます。 [Figure53-11:Telnetでのデータの転送]を見る限りでは そのいわゆるところの「動画」は全く関係なくて 単なるタイムラインを使ったアニメーションのタイムライン制御のご質問ですよね？ ＝＝＝ ＝＝＝ ＝＝＝ 例えば【下の図】↓のように 全部で30フレームのアニメーションがあって その フレーム10 で再生を停止させてボタンクリックで再生開始 また フレーム20 でも再生を停止させてボタンクリックで再生開始 というものを作るとします。 その場合 まず再生開始させるボタンには 例えば「play_btn」というインスタンス名を付けます。 ※下の図にはありませんが 　 インスタンス名は 　 ステージ上のボタンを選択して 　 デフォルトではステージ右側にあるはずの 　 「プロパティ」パネルの 　　　[ ＜インスタンス名＞ 　] 　 となっている欄に名前を記入して命名します。 その「play_btn」を フレーム10 と フレーム20 のキーフレームのみに配置します。 そして フレーム10 には次のようなスクリプトを書きます。 //----------------------------------------------- //(このタイムラインの)再生停止 stop(); //ボタン「play_btn」クリック時に 関数「playBtnClick」 を実行 play_btn.addEventListener(MouseEvent.CLICK,playBtnClick); //関数「playBtnClick」 の定義 function playBtnClick(e:MouseEvent):void{ //(このタイムラインの)再生開始 play(); } //----------------------------------------------- 見るからに「そのまま」という感じのプログラムですよね？ そして フレーム20 では 一旦消えた同じ「play_btn」に 「全く同じ動作(関数)」を実行させるようにするわけです。 しかしその「全く同じ動作(関数)」は すでに フレーム10 で定義してありますから ２度も３度も同じ定義をする必要はありません。 ですから フレーム20 に書くスクリプトは 次のように(たった２行分だけに)なります。 //----------------------------------------------- //(このタイムラインの)再生停止 stop(); //ボタン「play_btn」クリック時に 関数「playBtnClick」 を実行 play_btn.addEventListener(MouseEvent.CLICK,playBtnClick); //----------------------------------------------- 　
「どうするのか」というのは作者の意図で決めることが大半です。 ですから 「こうすべき」とか「これが良い」というような回答はできません。 というわけで 以下に書くことはあくまでも「たとえばの一例」です。 例えば「url.xml」の内容は次のようにします。 ------------------------------ <?xml version="1.0" encoding="UTF-8"?> <top> <menu> <title>Google</title> <url>http://www.google.co.jp/</url> </menu> <menu> <title>Yahoo!</title> <url>http://www.yahoo.co.jp/</url> </menu> <menu> <title>Bing</title> <url>http://www.bing.com/</url> </menu> </top> ------------------------------ この場合， 例えばフレームに書くスクリプトは次のようにします。 ※「制御」→「ムービープレビュー」での 　 動作検証用にいちいち trace を入れています。 　 (trace行は本来不要です。) //---------------------------- function startIndexMenu(success) { if (success) { //親のノードを取得 rootNode = index_xml.firstChild; trace("rootNode→ " + rootNode); // //親の持つ子ノードの数を取得 child_len = rootNode.childNodes.length; trace("child_len→ " + child_len); // //子の数だけ i の数を 0 から 1 ずつ加算しながらループ for (var i = 0; i < child_len; i++) { //子ノードを(一時的に)取得 var child = rootNode.childNodes[i]; // //_root の 変数「child○_title」に各 「title」を代入 _root["child" + i + "_title"] = child.childNodes[0].firstChild.nodeValue; trace("_root.child" + i + "_title→ " + _root["child" + i + "_title"]); //_root 変数「child○_url」に各 「title」を代入 _root["child" + i + "_url"] = child.childNodes[1].firstChild.nodeValue; trace("_root.child" + i + "_url→ " + _root["child" + i + "_url"]); } } } index_xml = new XML(); index_xml.onLoad = startIndexMenu; index_xml.load("url.xml"); index_xml.ignoreWhite = true; //---------------------------- そして 例えば１つ目のボタンには次のように書きます。 //---------------------- on (release) { getURL(_root.child0_url, "_self"); } //---------------------- ２つ目のボタンであれば次のように書きます。 //---------------------- on (release) { getURL(_root.child1_url, "_self"); } //---------------------- ３つ目のボタンであれば次のように書きます。 //---------------------- on (release) { getURL(_root.child2_url, "_self"); } //---------------------- ※以上の全スクリプト 　 ActionScript 1.0 　 Flash 5(CS5 ではなくてただの5)以上で使用可 　 Flash Player 5 以上で動作可 今現在のような こういう各ボタンの決め打ちのようなやり方では XMLのデータ量(XMLのリンク個数)の変更によって ボタンの数を変えたりすることはできません。 しかし フレームのスクリプトの方では //親の持つ子ノードの数を取得 child_len = rootNode.childNodes.length; によってデータ数を得て その個数によって forループ の数を変えていますから XMLに応じた動的コンテンツの作成にも一応は対応させているつもりです。 つまり さらに工夫することで， XMLからURLもそのリンク数自体も変えるというような さらなる発展につなげられるような形にはしているつもりです。
2から呼び出し方法が変わったようですよ。 http://www.hakkaku.net/articles/20080917-269
こんにちは。 <?php echo $_POST["test"] ?> または <?= $_POST["test"] ?> 文字列として出力しないといけないので上記のようにすればOKだと思います。
stage.addEventListener(KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_P1); これがずっと効き続けているから，そういうエラーが出るのでしょう。 ご質問の件に限ったことではなく 動作させ続ける必要がないイベントリスナーは なるべくその都度 removeEventListener で 登録を抹消する方が良いでしょう↓。 stage.addEventListener(KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_P1); function fl_KeyboardDownHandler_P1(event:KeyboardEvent):void { this.gotoAndPlay("P1ending"); stage.removeEventListener(KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_P1); } 再び必要になれば、 そのときにまた addEventListener をしなおせば良いです。 例えば上の例では、 上のスクリプトを書いたフレーム(シーン P1 の フレーム1？)に戻ってきたときには 自動的に再び addEventListener されるわけですから 普通はこのままで問題ないと思います。 または、 「シーン P1」内のみで this.gotoAndPlay("P1ending"); を実行させるようにするのも１つの方法です↓。 stage.addEventListener(KeyboardEvent.KEY_DOWN, fl_KeyboardDownHandler_P1); function fl_KeyboardDownHandler_P1(event:KeyboardEvent):void { if (this.currentScene.name == "P1") { this.gotoAndPlay("P1ending"); } }
HTMLのソースを見ればすぐにわかりますが，jQuery を使ったものですね。 「jQuery スライドショー」などのような感じで検索すれば情報はわんさか出てきますよ。 http://www.google.co.jp/webhp?hl=ja#hl=ja&site=webhp&q=jQuery+%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%89%E3%82%B7%E3%83%A7%E3%83%BC&fp=6882ffc793926b61
xx0から始まる連番だと楽なのですが… for (var i:int = 0; i < numChildren; i++ ) { getChildByName( parseInt ("xx" + i)).alpha = 0; getChildByName( parseInt ("xx" + i)).buttonMode = ture; getChildByName( parseInt ("xx" + i)).addEventListener(MouseEvent.ROLL_OVER, xxxOver); getChildByName( parseInt ("xx" + i)).addEventListener(MouseEvent.ROLL_OUT, xxxOver); getChildByName( parseInt ("xx" + i)).addEventListener(MouseEvent.CLICK, xxxOver); } しかし、名前がばらばらということで、 for (var i:int = 0; i < numChildren; i++ ) { getChildAt( parseInt (i)).alpha = 0; etc....... } で、できますが、これだと、ステージ上 (もしくはMovieClipの中)のすべてのMovieClipに適用されてしまいます。 そこで、適用したいMCを選択して新たにシンボル化してyyと名前をつけ、 for (var i:int = 0; i < numChildren; i++ ) { yy.getChildAt( parseInt (i)).alpha = 0; etc....... } もしくは、シンボル化したyyの中で、 for (var i:int = 0; i < numChildren; i++ ) { getChildAt( parseInt (i)).alpha = 0; etc....... } ただこれだと、addEventListener、alphaをそれぞれ個別に適用できませんし、 シンボル化してしまうので、FLASH上での取り回しが少し大変になります。 ほかにもやり方あると思いますけど...。
モバイル用HTMLで、Flash Playerがオワコンになったってこと。 なので、iOSアプリやAIRアプリの制作環境としては残ります。 ただこの分野は、圧倒的にネイティブアプリが強いので、サイズが大きく、動作も遅いFlashが生き残れるかどうかは微妙。 PC用HTMLでも、Windows 8のMetroインターフェースでは、Flashはおろか、Silverlightすらも動作しない。Appleに続き、Microsoftもプラグイン系技術は捨てると思われる。 元々、Flashには３つの側面があった。 ・映像再生 ・アニメーション再生 ・ビジネスアプリのインターフェース 「映像再生」はHTML5がネイティブ機能でサポート、「インターフェース」機能はAjaxに移行、アニメーションはHTML5のSVGに移行するのが世の流れのようだ。 SVGアニメーションでは、近々発売される、AdobeのSVGツール「EDGE」をチェックするのが早道かな？ 単純なものなら結構いけそうと思う。 悲しいことだが、Flashは完全に縮小に向かいつつある。 仕事依頼でも最近は「タブレット対応もあるのでなるべくFlashを使わずに」なテイストのものが増えてきた。 これからFlash習得を目指すのであれば、AS3.0のようなややこしい独自規格の学習は最小限にし、アニメーション制作程度に留めるのがいいのでは。その分、HTMLやCSS、JavaScriptに力をいれるべきだと思います。
＃１です。 Actionscript で不可能というわけではありませんよ。 例えば Flash の(Flex の場合は知りません) ドキュメントクラスのクラスファイルのスクリプトでしたら 次のような感じで近いような(遠いような)ものはできます。 「CountDown.as」 //--------------------------------------- package { import flash.display.MovieClip; import flash.display.Sprite; import flash.display.LineScaleMode; import flash.display.CapsStyle; import flash.display.JointStyle; import flash.events.Event; import flash.text.TextField; import flash.text.TextFormat; import flash.text.TextFieldAutoSize; public class CountDown extends MovieClip { //カウント数の設定 var cnt:int = 3; //中心点の設定(一応ステージ中央) var c_x:Number = stage.stageWidth / 2; var c_y:Number = stage.stageHeight / 2; //円の半径の設定 var c_r:Number = 100; //フレームレートの設定 var fr:int = 20; // var i:int = 0; // var circle:Sprite; var cnt_txt:TextField; var txt_fmt:TextFormat; // public function CountDown() { // circle = new Sprite(); circle.x = c_x; circle.y = c_y; this.addChild(circle); // cnt_txt = new TextField(); cnt_txt.autoSize = TextFieldAutoSize.LEFT; this.addChild(cnt_txt); // txt_fmt = new TextFormat(); // this.addEventListener(Event.ENTER_FRAME,makeCircle); } public function makeCircle(evt:Event):void { if (i == 0) { circle.graphics.clear(); circle.graphics.lineStyle(15, 0xCCCCCC, 1, false, LineScaleMode.VERTICAL,CapsStyle.NONE, JointStyle.ROUND); circle.graphics.moveTo(c_r*Math.sin(2*Math.PI/fr*i) , -c_r*Math.cos(2*Math.PI/fr*i)); // cnt_txt.text = cnt.toString(); txt_fmt.color = 0xCCCCCC; txt_fmt.size = 60; cnt_txt.setTextFormat(txt_fmt); cnt_txt.x = c_x - cnt_txt.width / 2; cnt_txt.y = c_y - cnt_txt.height / 2; } else { circle.graphics.lineTo(c_r*Math.sin(2*Math.PI/fr*i) , -c_r*Math.cos(2*Math.PI/fr*i)); } // if (i < fr) { i++; } else { cnt--; if (cnt == 0) { this.removeChild(circle); this.removeChild(cnt_txt); this.removeEventListener(Event.ENTER_FRAME,makeCircle); } i = 0; } } } } //--------------------------------------- しかし，，， こんなチャチで薄っぺらなものを時間かけて考えて作るよりも タイムラインアニメーションで作った方が もっと風情のあるものがもっと簡単にできますよ。 さらに質を高めるスクリプトをゴチャゴチャ考えたり進むよりも タイムラインアニメーションの SWF または FLV を作るなどして(＃１で書いたサンプルを自分の良いように作り替えるなどして)， Flash Builder 製の SWF 内にロードする方が現実的で良いと思います。 ロードすると言うのは SWF を loader.load でロードするとか FLV を FLVPlayback にロードするとかいう意味です。 ※ちなみに私は Flex のことは全く知りません。 　 何ができて，何ができないかもわかりません。 　 loader.load の件などは Flash の感覚で書いてます。 　 　
書かれていらっしゃるスクリプトの後に trace(Ldate); と書き加えて「制御」→「ムービープレビュー」をすると 出力窓にはちゃんと 「SAT, November 26, 2011」のように表示されます。 ですから書かれていらっしゃる範囲のスクリプトの問題ではありません。 したがって問題は表示のさせ方です。 どこにどのようにして表示しようとされているのかが全く書かれていませんが その表示をさせるスクリプト,または, 表示させようとしているテキストフィールド(？)、テキストエリア(？)、それともコンボボックスなどコンポーネント(？) なにかわかりませんが、 その表示させようとしているもののフォントなどの設定が悪いのだと思います。 そこら辺が全く見えないため何とも言えません。 とりあえずはスクリプトを書かれたフレームに 文字色を黒に設定し フォントを「_ゴシック」など前にアンダースコアの付いたデバイスフォント使用に設定した 枠付きで大きめのダイナミックテキストのテキストフィールドを用意して 例えば「my_txt」などというインスタンス名を付け 書かれていらっしゃるスクリプトの後に my_txt.text=Ldate; と書いてムービープレビューするとかパブリッシュしてみてください。 ちゃんと表示されるはずです。 ちゃんと表示されたとしたならば 今した内容と，質問する前にした内容との差の部分に問題があるということになります。
「 Ctrl」+「Alt」+「Delete」キーを押してタスクマネージャーを起動してください。 「プロセス」タブを開き問題となる「basic」があれば「プロセスの終了」をクリックして 終了してください。
『「フラッシュ」の携帯端末向けの開発を終える』ではなく、『モバイルむけFlash Playerの開発を終える』の間違い。 要するに、『スマホのHTMLに埋め込むFlash SWF』がオワコンになる、ということ。ガラケー（Flash Lite）も同じだと思う。 まあ、iPhoneやWindows Phoneは最初からFlash完全アウトなので、Androidしか影響ないが。 AIRアプリやiOSアプリ変換など、単体動作のものは残るようだ。 あと、PC用のHTMLも危ないよ。 Windows 8 MetroインターフェースだとInternet Explorer 9ではFlash Playerは頭から動かないし、次のSafariもなんだか危なそう。 最新ブラウザが一つでも非対応になれば、いっぺんでSWFは死滅してしまう。 要するに、もうHTMLの中でFlashを使うな、ということじゃないのかな。 ゲームやアプリ開発者でない、大多数のWebデザイナは、Flash捨ててHTML5やCSS4、JavaScriptなんかに真剣に取り組んだほうがいいと思う。 でも不可解なのは、現在、モバイル上で、多数のAndoroidでちゃんとFlash Playerが動くし、Chromeなんかはサポート止める言ってない事実。第一、Androidキャリアでは、「WebのFlashもちゃんと動きます」がセールストークだったはず。 何でこんなことになったのか、全く分からない。Adobeは何を考えてんだか。
具体的には 何ができて何ができないのかわかりませんが。 > ボタンを押して回数を数えさせるのは、 > on (press) { > point = +1; > } > > で出来るようになりました。 とにかく何だかわかりませんが， 少なくともそれでは回数は数えられないと思います。 加算後代入演算子は += です。 point = +1; これだと point は何度クリックしようとも 1 にしかならないはずです。 まず初めに point に初期値があって 例↓ var point = 0; その上で point += 1; のようなことをすれば 変数 point に 1 が加算されて行きます。 または point += 1; ではなく point++; です。 またボタンのある階層などの状況や構造によっても on (press) { point += 1; } で無事に加算されるかどうかは変わります。 つまり, 説明の範囲では状況説明も不足している上，スクリプトもおかしいのでこれ以上何とも言えません。
Flash上で映像とアニメーションを同期再生するのは、非常に難しいテーマです。 理由 ■Flashフレームに映像を読み込に、タイムライン上でアニメーションを合成する方式だと、映像の１コマ１コマが個々の画像として取り扱われるため、映像品質が劣化し、出力swfのサイズも巨大になって、再生不能になります（swfに書き出したらどういう意味かわかる）。 ■SWF再生時に、FLV Player等のコンポーネント（や自作のムーニークリップ）上に外部動画をローディングする方式だと、サイズは軽くなりますがが、映像とアニメーションの同期に問題が出ます。 映像は基本的に正しく再現されますが、Fkashアニメーションの再生速度は環境によって異なるため、ほとんどの場合、アニメーションの再生が遅れて酷いことになります。 なので。Flashで映像とアニメーションが同期再生するコンテンツを作るとすれば、 ■タイムライン合成 映像が小さサイズ、かつ短時間モノ（ループ再生など）の場合。 できるだけ映像を小さく作ってメモリの増大を抑える。 ■外部動画ローディング 映像とアニメを同期する必要がない場合は有望。 動機が必要な場合は、映像キーフフレーム位置にイベントを埋め込み、再生時にそのメッセージに合わせてタイミングをとりながら再生させる。 （"Person in presentation"などで使われている手法です） となります。 なので、ほとんどの場合は、FlashなどではなくAfterEffectsでリアルフレーム合成動画とするか、どうしてもFlashを使いたければ、動画フォーマットに書き出したものを、AfterEffectsやPremiereで、キー合成してムービーにするべきでしょう。
イベントリスナー(リスナー関数)の 引数 e には イベント が入り その イベント e の currentTarget または target プロパティで その イベント を受けた対象インスタンスが得られます(というかそのために e がある)。 ですから e.currentTarget で マウスオーバーイベント を受けた インスタンス を取得すれば良いです。 それと， そのイベントリスナー(リスナー関数)は何度も定義しても同じなので forの外に出した方が良い(出すべき)です。 //----------------------------------- for (var i:uint=1; i<4; i++) { var test_list:test = new test(); test_list.x=i*50; test_list.num=i; this.addChild(test_list); test_list.addEventListener(MouseEvent.MOUSE_OVER,test_func); } function test_func(e:MouseEvent) { trace(e.currentTarget.num); } //-----------------------------------
とりあえずバージョンにかかわらず， この「戻るボタンなどで」の「など」が１つの分岐ですね。 Flash 単独では， 「戻るボタン」で同じ SWF が表示されたのか 「お気に入り(ブックマーク)」経由で同じ SWF が表示されたのか 「他のページのリンク」経由で同じ SWF が表示されたのかは区別できません。 つまり， 『何でも良いのでSWFが表示されたとき』であれば Flash 単独で検知できます。 しかし 『「戻るボタン」または「お気に入り(ブックマーク)」経由で同じ SWF が表示されたとき』を 「など」とするなら その「など」の判別は Flash では無理です。 上のことは全く考えないとして次に行きます。 > 日付が変わって改めてアクセスし直すと、シーン1から再生される > （日付ではなく1時間後、等でも構いません） これに関しては， バージョンによってできる場合もできない場合もあります。 一応， 「ActionScript 1.0 以上」の 「Flash Player 6 以上」であれば SharedObject が使えると思います。 (Flash オーサリング で言うなら「Flash MX 以上」であればです。) スクリプトや具体的なことは バージョンや状況によって変わります。 「SharedObject」を軸に検索すれば 何か参考になるページが見つかるかもしれません。 (場合や状況によっては，調べるだけ無駄で，参考になるページなど存在しない可能性もあります。) http://www.google.co.jp/search?q=SharedObject
デバッガを使うと、タイムラインだけでなく、エラーが発生したレイヤーやフレーム・行も特定できます。 例えば、ムービークリップシンボル「シンボル 2 」に、名前を”スクリプト”と付けたレイヤーを作り、そのフレーム 10 に、次のようなスクリプトを書いたとします。 　var mc:MovieClip = null; 　mc.stop(); ↑　mc にはあえて null を入れていますから、当然、このフレームが再生された途端にエラー番号 1009 「 null のオブジェクト参照の～」が発生します。 このシンボルのインスタンスを配置した作品を、デバッガを通して動作確認します。 ムービー編集画面の「デバッグ」メニュー→「ムービーのデバッグ」で、デバッガが起動します。 （ CS5 では、メニューの配置や名称が変わっているかもしれません。デバッガの起動方法や詳しい使い方については、ヘルプ等をご参考になさってください） 問題がなければ、ムービーが再生されます。 しかし、スクリプトにエラーがあるとその箇所で再生が停止し、デバッグウィンドウが開いて、エラー発生時に再生していたシーンとシンボル名・レイヤー・フレームが表示されます。 反転表示になっているシンボルが、エラーが検出された箇所です。 先ほどの問題含みの作例をデバッガで見ると、 　シンボル名：シンボル 2　　レイヤー名：スクリプト　 フレーム：10 に問題があるらしいという情報が、デバッグウィンドウから得られます。 （表示例として画像を添付しましたので、よろしければご参照ください。青く反転しているシンボルが、エラーが検出されたシンボルです） さらに、エラーメッセージの最後 　　[○○○_fla.Timeline_○::frame10:2] の” frame10:2 ”の部分は、フレーム 10 に書かれているスクリプトの２行目、という意味です。 合わせますと、「シンボル２の”スクリプト”レイヤー、フレーム 10 に書かれているスクリプトの２行目」でエラーが発生した、と分かります。 つまり、シンボル 2 のフレーム 10 に書いた 　var mc:MovieClip = null; 　mc.stop(); ↑　この２行目の mc.stop(); 、特に mc のあたりが怪しいと、エラーの原因を突き止めていくことができます。
まずその前の AS2 版 ですが それは duplicateMovieClip(ステージ上にあるMCの複製) を使っているので 左上コーナーの１つは配置したままにしています。 AS3 では duplicateMovieClip(ステージ上にあるMCの複製) は使えないので 左上コーナーに MC を残す意味がありません。むしろ邪魔です。 ですからステージ上には 100×100 の ■MC は１つも残さない方が良いです。 そして if (i != 0) も削除します。 とりあえずそういうこととして このご質問で書かれているスクリプトでは 単に my_mc.addEventListener(MouseEvent.ROLL_OVER,onrollOver); の位置(書き場所)が悪いだけです。 「my_mc」は動的に参照を変える変数ですが 「my_mc」が生成した 各MC １個体 を対象としているときに my_mc.addEventListener(MouseEvent.ROLL_OVER,onrollOver); をすれば良いのです↓。 //------------------------------------------- import fl.transitions.*; import fl.transitions.easing.*; for (var i:int = 0; i<=15; i++) { //元あった if は削除 var my_mc:MC = new MC(); my_mc.x=i%4*100; my_mc.y=Math.floor(i/4)*100; addChild(my_mc); //ココに移動 my_mc.addEventListener(MouseEvent.ROLL_OVER,onrollOver); } function onrollOver(eventObj:Event):void { //ロールオーバーイベントを受けたインスタンスを取得 var target_mc:MovieClip=MovieClip(eventObj.currentTarget); //そのインスタンスをフェードアウト TransitionManager.start(target_mc, {type:Fade, direction:Transition.OUT, duration:2, easing:None.easeNone}); //そのインスタンスのイベントリスナーを削除 target_mc.removeEventListener(MouseEvent.ROLL_OVER,onrollOver); } //------------------------------------------- 配列などを使って 個々のインスタンスを参照する変数(要素)を別々に用意してもいいですよ。 そうするにしても 結局 生成した 各MC １個体 を対象として配列の要素に入れなければなりませんし 効率の良い書き方をするなら(何度も for文 を回さないとするなら) 結局，上の書き方と同じになります↓。 //------------------------------------------- import fl.transitions.*; import fl.transitions.easing.*; //生成する MC を格納する配列を用意 var mcArr:Array = new Array(); for (var i:int = 0; i<=15; i++) { //配列の各要素に生成した MC の参照を格納 mcArr[i] = new MC(); mcArr[i].x=i%4*100; mcArr[i].y=Math.floor(i/4)*100; addChild(mcArr[i]); //生成した MC の参照に対してイベントリスナーを登録 mcArr[i].addEventListener(MouseEvent.ROLL_OVER,onrollOver); } function onrollOver(eventObj:Event):void { //ロールオーバーイベントを受けたインスタンスを取得 var target_mc:MovieClip=MovieClip(eventObj.currentTarget); //そのインスタンスをフェードアウト TransitionManager.start(target_mc, {type:Fade, direction:Transition.OUT, duration:2, easing:None.easeNone}); //そのインスタンスのイベントリスナーを削除 target_mc.removeEventListener(MouseEvent.ROLL_OVER,onrollOver); } //配列に MC が入っているかどうかの検証(本題とは関係なし) mcArr[5].alpha = 0.5; mcArr[6].rotation = 45; //------------------------------------------- 細かい部分も変えていますが 要するに 配列を作っても作らなくても addEventListener(MouseEvent.ROLL_OVER,onrollOver); をする位置は同じ(この位置を考えましょう)ということです。
まずは大前提の条件が必要です。 『必ず先に testA_mc 内の var testC_mc:TestC = new TestC(); が実行されていて その後に 「テストC」の removeChild が実行される』 という場合について書きます。 また「テストA(testA_mc)」と「テストB」は 両者ともメインタイムライン(root) のステージ上にあるものとします。 この前提がある場合 「テストB」内のフレームには 次のように通常の 絶対パス でターゲットを指定するのが１つの方法例です。 MovieClip(root).testA_mc.removeChild(MovieClip(root).testA_mc.testC_mc); また次のように相対パスで指定しても良いでしょう。 MovieClip(this.parent).testA_mc.removeChild(MovieClip(this.parent).testA_mc.testC_mc); あまり使いませんが 場合によっては次のようにして stage まで遡った 絶対パス でターゲットを指定しても良いかもしれません。 MovieClip(stage.getChildAt(0)).testA_mc.removeChild(MovieClip(stage.getChildAt(0)).testA_mc.testC_mc);
＃１です。 > C1_mc.onEnterFrame = c1EnterFrame;//←★付け足し★ > があるとなぜ存在できるのか（なぜこれがないとダメなのか） > を教えていただければ幸いです。 ということですが C1_mc.onEnterFrame = c1EnterFrame;//←★付け足し★ これで C1_mc.onEnterFrame イベントハンドラメソッドに function c1EnterFrame () を代入しているわけです。 つまりそこで 「C1_mc君，毎フレーム毎フレーム 関数 c1EnterFrame を実行してくださいよ。」 と命令しているということになります。 ＃１では， スクリプトの修正を最小限にしているために， そういう書き方をしましたが 次のように書いても良い(同じこと)です。 //----------------------------------------------- A1_mc.onEnterFrame = function() { if (this.hitTest(_root.B1_mc)) { _root.B1_mc.gotoAndPlay(2);//2フレーム目（空のキーフレーム）にとび、B1を消す this.gotoAndPlay(2);//○⇒☆（２フレーム目）に姿を変える this._name = "C1_mc";//インスタンス名をA1_mcからC1_mcに変える trace(this._name);//インスタンス名の変更を確認する。 delete this.onEnterFrame; //↓★下にあったものをココ以下に移動★ C1_mc.onEnterFrame = function () { if (this.hitTest(_root.C2_mc)) { this.visible = false;//姿を消す _root.C1_mc.visible = false; _root.D_mc.gotoAndPlay(2);//D_mcの出現（D_mcの1フレーム目は透明で見えなくしている。2フレーム目からアニメーションさせたいのでvisibleは使わない） delete this.onEnterFrame; } else{} }; } else{} }; A2_mc.onEnterFrame = function() { if (this.hitTest(_root.B2_mc)) { _root.B2_mc.gotoAndPlay(2);//2フレーム目（空のキーフレーム）にとび、B1を消す this.gotoAndPlay(2);//○⇒☆（２フレーム目）に姿を変える this._name = "C2_mc";//インスタンス名をA2_mcからC2_mcに変える trace(this._name);//インスタンス名の変更を確認する。 delete this.onEnterFrame; } else{} }; //★ココにあったものを上に移動★ //----------------------------------------------- この書き方をすれば「付け足し」ではなくなりますよね。 大移動です。 結局どちらにしても＃１にも書いたように 「C1_mc」という名前のインスタンスが登場してから その「C1_mc」に対して onEnterFrame イベントハンドラメソッド を設定する。 ということをしていることに変わりはありません。
前置きとして， root の階層には変数「fuga」とその「fugaの値」がすでに与えられている(定義されている)ものとします。 その場合， 普通は次のように書きます。 //---------------------------------------- var my_mc:MovieClip = MovieClip(root); my_mc.hoge = my_mc.fuga; //---↓検証してみるとするなら↓--- trace(my_mc.hoge); trace("↑↓同じでしょう？") trace(MovieClip(root).hoge); //---------------------------------------- もし仮に root の階層には変数「hoge」とその「hogeの値」までもが すでに与えられている(定義されている)場合に限っては with も使えますが...(使えますがあまり推奨されていませんよ。)。 //---------------------------------------- var my_mc:MovieClip = MovieClip(root); my_mc.hoge = 0; with(my_mc){ hoge = fuga; } //---↓検証してみるとするなら↓--- trace(my_mc.hoge); trace("↑↓同じでしょう？") trace(MovieClip(root).hoge); //----------------------------------------
とりあえずは TransitionManager.start(this, {type:Fade, …略… と書かれている部分の this がダメです。 この場合ここで書いた this は「このタイムライン(階層)」という意味になります。 「このタイムライン(階層)」＝「スクリプトを書いたタイムライン全体」 ですから，このタイムラインに置いた表示オブジェクトは全てフェードアウトしてしまいます。 その上さらに for文 までブン回してますし...。 for文 も要りません。 書かれているリスナー関数の冒頭ですが↓ function onrollOver(eventObj:Event):void { これで，ここの引数である変数 eventObj には，ロールオーバーイベントが入ります。 さらに eventObj.target や eventObj.currentTarget で そのイベントを受けたインスタンスの参照が取得できます。 ですからそれを使います。 というわけで，書き換え例です↓。 //---------------------------------------------- import fl.transitions.*; import fl.transitions.easing.*; mc0.addEventListener(MouseEvent.ROLL_OVER,onrollOver); mc1.addEventListener(MouseEvent.ROLL_OVER,onrollOver); mc2.addEventListener(MouseEvent.ROLL_OVER,onrollOver); mc3.addEventListener(MouseEvent.ROLL_OVER,onrollOver); function onrollOver(eventObj:Event):void { //ロールオーバーイベントを受けたインスタンスを取得 var target_mc:MovieClip = MovieClip(eventObj.currentTarget); //そのインスタンスをフェードアウト TransitionManager.start(target_mc, {type:Fade, direction:Transition.OUT, duration:2, easing:None.easeNone}); //そのインスタンスのイベントリスナーを削除 target_mc.removeEventListener(MouseEvent.ROLL_OVER,onrollOver); } //----------------------------------------------
> フレーム2の画面(TツールでCLEARを書いているだけ) ということでしたら フレーム2 には「mc」も「mc1」も「myb」も存在しないわけですよね。 そうでしたら 「mc」や「mc1」や「myb」を参照するイベントリスナーは全て削除しておかなかればダメでしょう。 つまり具体的には， 書かれていらっしゃるスクリプトの原型をなるべく変えない形で書くとすれば 最後の function ↓ function mymc(e:Event):void{ if(mc1.hitTestObject(mc)){ gotoAndStop(2); } これを次↓のように変更する必要があります。 function mymc(e:Event):void { if (mc1.hitTestObject(mc)) { //↓きれいに掃除をしてから myb.stage.removeEventListener(MouseEvent.CLICK, mystart); mc.stage.removeEventListener(MouseEvent.MOUSE_MOVE,mymouse); mc.stage.removeEventListener(Event.ENTER_FRAME,mymc); //↓フレーム2 で停止 gotoAndStop(2); } } イベントリスナーはすべて削除してから 何もないフレーム2へ gotoAndStop です。 本題は，一応以上です。 ===その他===================================== 本題と関係ないと言えば関係ないことですが， (関係あると言えば関係あることですが，) myb.stage.addEventListener(MouseEvent.CLICK, mystart); とか mc.stage.addEventListener(…略…); のように書かれていること自体が そもそも変ではないでしょうか。 特に myb.stage.addEventListener(MouseEvent.CLICK, mystart); は変だと思います。 これだと「myb」など関係なくて ステージ上のどこをクリックしても関数 mystart が実行されてしまいます。 「myb」をクリックしたときに「myb」が消えて 同時にマウスが「mc」表示に変わるようにさせるのでしたら， myb.addEventListener(MouseEvent.CLICK, mystart); です。 さらにまた， 上の部分を書き換えたとしても 「myb」をクリックする前であっても マウスを適当に動かしていると マウス(mc) が「mc1」に当たって わけもわからないまま勝手に「CLEAR」になってしまう(フレーム2に行ってしまう)ことがあります。 そんなこんなを考えて スクリプト全体を書き替えると次のようになります。 //------------------------------- stop(); mc.visible=false; //↓「myb」に対して addEventListener をする myb.addEventListener(MouseEvent.CLICK, mystart); function mystart(e:MouseEvent):void { myb.visible=false; Mouse.hide(); mc.visible=true; //↓ココで addEventListener しないと勝手に「CLEAR」になる stage.addEventListener(MouseEvent.MOUSE_MOVE,mymouse); stage.addEventListener(Event.ENTER_FRAME,mymc); } function mymouse(e:MouseEvent):void { mc.x=stage.mouseX; mc.y=stage.mouseY; e.updateAfterEvent(); } function mymc(e:Event):void { if (mc1.hitTestObject(mc)) { //↓きれいに掃除をしてから myb.removeEventListener(MouseEvent.CLICK, mystart); stage.removeEventListener(MouseEvent.MOUSE_MOVE,mymouse); stage.removeEventListener(Event.ENTER_FRAME,mymc); //↓フレーム2 で停止 gotoAndStop(2); } } //-------------------------------
調べてもらえばわかると思いますが [] を 配列アクセス演算子 と言います。 Google検索「配列アクセス演算子 」 http://www.google.co.jp/search?hl=ja&source=hp&q=%E9%85%8D%E5%88%97%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90& いろんなものに動的にアクセスする場合に使えるのですが 多いのは "インスタンス(名)" や "変数(名)" へのアクセスを動的に変える変えるときに使用することが多いです。 例えば 変数 v0 ～ v4 に 1 という値を入れる場合 v0 = 1; v1 = 1; v2 = 1; v3 = 1; v4 = 1; としても良いですが これでは少し大変ですし書き間違いや抜けも起こる可能性が高くなります。 また v0 ～ v4 が固定的なものであれば上のように書くこともできますが V0 ～ v? で ? が不定の場合も多いです(クリックした回数 とか XML のノード数 によって変わるなど) ですから上の場合は 配列アクセス演算子 を使って for(i = 0; i <=4 ; i++){ this["v" + i] = 1; } のように書くことが多いです。
書かれている ActionScript 1.0 のものを "単純に" 書き替えるだけで良いと思いますが。。。 vx=0; vy=0 となっているところをあえて var vx ; var vy ; と書き替えてみたり vx=vx*0.65+…; vy=vy*0.65+…; となっているところをあえて vx= my_mc.x*0.65+…; vy= my_mc.y*0.65+…; と書き替えてみたりと なんだかあえて(わざと)妙な変形をしているようにしか見えませんよ。 ほとんど何も考えず "単純に" 書き替えると次のようになります。 my_mc.addEventListener(Event.ENTER_FRAME,onEnterframe); var vx = 0; var vy = 0; function onEnterframe(eventObj:Event):void { vx=vx*0.65+(stage.mouseX-my_mc.x)/2; vy= vy*0.65+(stage.mouseY-my_mc.y)/2; my_mc.x+=vx; my_mc.y+=vy; }
＃１です。 > 進んだり戻ったり、最初と最後で違う表示にしたりするには、 > どういった方法があるのでしょうか・・ 何というか...ですね， 最初からなぜ同じ深度に同じムービークリップを出すのか，その意味を私は全くわかってないのですよ。 つまり根本的に何をされているのかわかっていないのです。 ですから 「普通はご質問のようなこと(私が回答したようなこと)はしない。」 としか言えませんね。。。 また _root.slidePos の意味もわかっていませんから 何をどうすれば良いと言うことも書けませんし。 ３種類のボタン(クリックするムービークリップ)を出す必要があるのであれば， 普通は最初から３つとも出しておきます。 出したり引っ込めたりしません。 そして最初から３種類のボタンに動作定義をしておきます。 そうしておいた上で そのボタン(クリックするムービークリップ)の _visible プロパティを切り替えます。 例えば 「Amc」「Bmc」「Cmc」という３つのボタンが要るのであれば 最初から３つともステージ上に出しておいて Amc.onRelease = function(){…云々…}; Bmc.onRelease = function(){…云々…}; Cmc.onRelease = function(){…云々…}; としておいた上で 最初は「Amc」と「Cmc」が不要である場合は Amc._visible = false; Cmc._visible = false; として「Amc」と「Cmc」を非表示にしておきます。 また _visible が false である間はボタン機能(マウスに反応すること)が消えていますからクリック動作も働きません。 それで Bmc.onRelease によって 何某かのカウンタをカウントアップするなどして 例えば カウンタが 3 以上であれば Amc._visible = true; にするとかします。 もっとも一般的にはそうするというだけで， 別に _visible の true や false を切り替えなくても良いです。 例えば 「Amc」や「Bmc」や「Cmc」内の フレーム1 を空白キーフレームだけにしておいて Amc.gotoAndStop(1); で 「Amc」を非表示しにて Amc.gotoAndPlay(2); などで表示させたり動かしても良いです。 Amc._alpha = 0; だけでの非表示はダメです。 この場合見た目は非表示ですが透明になるだけでボタン機能は働いてしまします。 上で書いたイメージの雰囲気はこんな感じです↓。 FLASH道場「方法切替ボタン」 http://www2.netwave.or.jp/~light/houkou_kirikae_btn.html
＃１です。 ＃１の補足より引用 > 判定後の画面で、 > TypeError: Error #1009: null のオブジェクト参照の > プロパティまたはメソッドにアクセスすることはできません。 最初のご質問に書かれているスクリプトの mc.event.updateAfterEvent(); を event.updateAfterEvent(); に書き換えたものでは，そう言ったエラーは出ませんよ。 スクリプトに書いてある状況であれば ステージ上には少なくとも「mc」と「mc1」と「myb」の３つのインスタンスが必要です。 この３つのうちどれか１つを消したとしても全く違うエラーが出ます。 ・「mc」を消した場合 →1120:未定義のプロパティmcへのアクセスです。 ・「mc1」を消した場合 →1120:未定義のプロパティmc1へのアクセスです。 ・「myb」を消した場合 →1120:未定義のプロパティmybへのアクセスです。 したがって 「最初の質問段階のスクリプトから大幅に変更をしている。」 または 「最初の質問のスクリプトとは全く別のスクリプトでエラーが発生している。」 としか考えられません。 とにかく 書かれていらっしゃらない部分に問題があると思うので どこをどうすれば良いということは書けません。 良くはわかりませんが， > 判定後の画面で、 と書かれていらっしゃる その全く何の説明のない 「判定後の画面」 とやらに 何か問題があるのかもしれません(ないのかもしれません)。
> 何が原因でこのような現象になるのでしょうか。 その my_mc と my_mc1 と my_mc2 を配置したときの手順 または my_mc と my_mc1 と my_mc2 を addChild したときのスクリプト を書かれていないため なぜそうなるのかは，そうした人物以外わかりません。 逆に言えば， my_mc と my_mc1 と my_mc2 を配置したときの手順 または my_mc と my_mc1 と my_mc2 を addChild したときのスクリプト に問題があるとしか言いようがないですね。 もし my_mc と my_mc1 と my_mc2 を手動で配置したのでしたら その上下順を入れ替えて配置すれば良いだけです。 あえて my_mc と my_mc1 と my_mc2 を配置するレイヤーを分けて そのレイヤーの順序で管理するのも１つの立派な方法です。 もし my_mc と my_mc1 と my_mc2 を手動で同じレイヤーに配置したのでしたら my_mc2 → my_mc1 → my_mc の順に１つずつのインスタンスを選択して 「修正(または右クリック)」→「重ね順」→「最背面へ」を繰り返せば良いでしょう。 もし my_mc と my_mc1 と my_mc2 をスクリプトで my_mc → my_mc1 → my_mc2 の順に addChild したのでしたら my_mc2 → my_mc1 → my_mc の順に addChild するように変更すればいいのではないでしょうか。 つまり my_mc2の重なりが最も手前になってしまうように配置したから my_mc2の重なりが最も手前になっているだけのことで それがmy_mc2の重なりが最も手前になる原因です。 そのようにしなければ良いだけではないか(そのようにしなければ良いだけだ)と思います。
「Frame.as」内の次の部分↓を public function go(event:MouseEvent):void { gotoAndStop(my_Frame); } 次のように↓変更すれば一応動作すると思います。 public function go(event:MouseEvent):void { MovieClip(my_btn.parent).gotoAndStop(my_Frame); } 書かれている元の gotoAndStop(my_Frame); だと this.gotoAndStop(my_Frame); のような意味になります。 この場合の this は 作成している「Frameクラス」自身のことです。 そこで Flash Player が 『「Frameクラス」の gotoAndStop メソッドとは何？？？』 という状態になって 「gotoAndStopなんか未定義だよ！」というエラーを出すのです。 もっとも var Obj1:Frame = new Frame(aaa,"A"); をする段階で，this を引数に入れても良いです。 そうしない場合は 上に書いたスクリプトのように 『ボタンの親タイムライン』.gotoAndStop(my_Frame); つまり 『ボタンが存在するタイムライン』.gotoAndStop(my_Frame); などのようにして Flash Player に gotoAndStop させる対象物を教える必要があります。
著作権法はおもに無断使用の禁止を規定する物ですから、 逆に言えば、許可を得れば、著作物を（契約範囲内で）自由に使う事ができます。 必要があれば、著作権所有者（つまりOKWave）に問い合わせてみてください。 包括契約や個別契約、無料であったり有料であったりと、契約体系も様々です。 いわゆるオープンソースと呼ばれている物は、公開と同時に使用許可が出されていますので、無断でも使用できます。 （厳密にはソースコードを公開している事と、自由に使える事は同一ではありません。） BBSやメーリングリストなどの投稿は、歴史的背景も含めて「投稿者の暗黙的了解により自由に使っても良い」ということになっていますが、 それ（著作物を自由に使えること）を明確に定義した文書はありません。 JavaScriptになりますが、 http://okwave.jp/qa/q6130109.html No.8お礼の最後に「著作権放棄、またはMIT、GNU GPLにて」などと書いてみた物の、たぶん、著作権はOKWaveに帰属、利用規約10条により利用禁止でしょうね。 他に書きようがないコードだと思いますが、実際に使うときは可能ならアレンジした方が良いと思います。
＃１です。 > 100枚の画像から100枚をランダムな順にチョイスしたい > と考えています。（ページを開くたびに順番は変わる） > 重複についてはしても大丈夫です。 と言うことでしたら 次のようにすれば良いのではないかと思います。 //------------------------------------------- import mx.transitions.Tween; import mx.transitions.easing.*; var num:Number = 10; //最高数字の設定(「img/p100.jpg」まであった場合) var max_num:Number = 100; var bar_h:Number = 200; var bar_w:Number = 150; var bar_n:Number = 10; var margin:Number = 0; var lag:Number = 1000; var speed:Number = 1; var transMode:Boolean = true; //setInterval参照用IDの宣言 var ID:Number; //ランダムな整数を入れる変数rの宣言 var r:Number; //ロード監視用にするObjectインスタンス「obj」を作成 var obj:Object = new Object(); //MovieClipLoaderインスタンス「mcl」を作成 var mcl:MovieClipLoader = new MovieClipLoader(); //カウンタの初期化 var cnt:Number = 0; //JPEGロード完了時の動作定義 obj.onLoadInit = function(target:MovieClip):Void { cnt++; if (cnt == 10) { ID = setInterval(bar_trans, lag); } }; //「mcl」のリスナーとして「obj」を登録 mcl.addListener(obj); for (i=1; i<=num; i++) { mc = this.createEmptyMovieClip("p"+i, i); mc.createEmptyMovieClip("inner", i); //r に 1～max_num のランダムな整数を代入 r = Math.floor(Math.random()*max_num)+1; //ランダムな外部JPEGをロード mcl.loadClip("img/p" + r + ".jpg", mc.inner); mc._x = margin+(bar_w+margin)*(i-2); mc._y = 0; mc._alpha = 100; //mc内の変数nにrを代入 mc.n = r; mc.onRollOver = rollover; mc.onRollOut = rollout; mc.onRelease = releas; } function rollover() { this._alpha = 100; transMode = false; } function rollout() { this._alpha = 100; transMode = true; } function releas() { transMode = true; url = _root["link"+this.n]; getURL(url); } function bar_trans() { if (transMode) { for (i=1; i<=num; i++) { bar_mc = _root["p"+i]; bar_mc.x0 = bar_mc._x; if (bar_mc.x0>margin+(margin+bar_w)*(num-3)) { bar_mc._visible = false; bar_mc.targetx = -bar_w; //r に 1～max_num のランダムな整数を代入 r = Math.floor(Math.random()*max_num)+1; //ランダムな外部JPEGをロード bar_mc.inner.loadMovie("img/p" + r + ".jpg"); //bar_mc内の変数nにrを代入 bar_mc.n = r; } else { bar_mc._visible = true; bar_mc.targetx = margin+bar_w+bar_mc.x0; } myTween(bar_mc); } } } function myTween(bar_mc) { new Tween(bar_mc, "_x", Regular.easeOut, bar_mc.x0, bar_mc.targetx, speed, true); } #include "Links.as" //------------------------------------------- 　
スクリプトはASファイルにして外に出すと タイムラインに書くのと違って thisがムービーのフレームじゃなくて そのクラスのインスタンスになります つまるところstageの参照切れてるから 多分コンストラクタに入れてるだろう Clock.addEventListener(Event.ENTER_FRAME,getdate); time1.addEventListener(Event.ENTER_FRAME,count); mc1.addEventListener(Event.ENTER_FRAME,changecolor); btn1.addEventListener(MouseEvent.CLICK, ST); このへんが動かない 一番書き直しが少なく済むのは コンストラクタでthisとか渡して そっから動かしたいインスタンスをたどる方法 ■タイムライン new MyClass(this) ■ASファイル public function MyClass(tgt:DisplayObjectContainer){ tgt.getChildByName('Clock').addEventListener(Event.ENTER_FRAME,getdate); tgt.getChildByName('time1').addEventListener(Event.ENTER_FRAME,count); tgt.getChildByName('mc1').addEventListener(Event.ENTER_FRAME,changecolor); tgt.getChildByName('btn1').addEventListener(MouseEvent.CLICK, ST); } そんなカンジ
＃１ですが。 > 指摘していただいたとおりに設定しましたが > move_mcまでうごいてしまっています。 意味がわかりません。 書いたとおりにするとドラッグで「move_mc」が動くのです。 言い換えるとドラッグで「move_mc」を動かそうとしているのです。 ですから動いて良いのです。 動くのが正常です。 (move_mc が動かないのが異常です。) 私が想定している状況において 用意された次のページのSWFで http://adv-bluepipit.way-nifty.com/blog/flash/drag_menu.html 困ったことになっているのは そこ(move_mcまでうごくこと)ではなくて 右エリア(青い塗り)上でドラッグしても move_mc がドラッグされてしまうことです。 良いですか？ 私が想定している状況において ドラッグで「move_mc」は動くのです。 そこは良いのですが 右エリア(青い塗り)上でドラッグしても move_mc がドラッグされてしまうことが問題なのではないのか？ と言っているわけです。 ですから 青い塗りをムービークリップに変換して そのステージ上の青いムービークリップに 例えば「menu_mc」というインスタンス名を付けて "ダミーのクリック動作" を設定すれば良いのではないかと言っているのです。 繰り返しますよ 青い塗りをムービークリップに変換して そのステージ上の青いムービークリップに 例えば「menu_mc」というインスタンス名を付けるのです。 そして フレームに //menu_mcにダミーのクリック時動作を設定 menu_mc.onRelease = function(){ //ダミー動作 実際は何もしない } を書きます。 すると，「menu_mc」がボタン化されてしまうので その下の「move_mc」がその部分で反応しなくなります。 本当はそれだけで良いのです。 それだけで良いのですが， それだけだと上レイヤーの「menu_mc」にマウスを持っていったとき ハンドカーソルになってしまうので //menu_mcのハンドカーソルを無効にする menu_mc.useHandCursor = false; もついでに書いておきましょう。 という内容を書いているのです。 なお， Flash 8 をお持ちだと言うことですから パブリッシュ設定で Flash タブを選択して Player の設定で Flash Player 8 での SWF を書き出すことを前提として書いています。 Flash Player 5 以下では，これらのスクリプトは通用しません。 (最低限 Flash Player 6 である必要があります。)
配列にイージングを入れるのは良いのですが イージング自体ではなく "文字列" を入れているのが動作しない原因ではないでしょうか？ こんな感じ↓で動くと思います。 //----------------------------------------- //Tweenクラスを使用できるようにインポート import mx.transitions.Tween; import mx.transitions.easing.*; var easeList:Array = new Array(); //イージングの種類 easeList[1] = Elastic.easeOut; easeList[2] = Strong.easeOut; easeList[3] = Elastic.easeOut; easeList[4] = Back.easeOut; easeList[5] = Bounce.easeOut; bt1.onRelease = function() { //インスタンス「ball」の動きをTweenクラスを使って制御 for (var i:Number = 1; i<=5; i++) { var myTween:Tween = new Tween(_root["ball"+i], "_x", easeList[i], 39, 400, 2, true); } }; //----------------------------------------- または 配列の要素は普通 0 から始まりますから 次のようにするとか。 //----------------------------------------- //Tweenクラスを使用できるようにインポート import mx.transitions.Tween; import mx.transitions.easing.*; var easeList:Array = new Array(); //イージングの種類 easeList[0] = Elastic.easeOut; easeList[1] = Strong.easeOut; easeList[2] = Elastic.easeOut; easeList[3] = Back.easeOut; easeList[4] = Bounce.easeOut; bt1.onRelease = function() { //インスタンス「ball」の動きをTweenクラスを使って制御 for (var i:Number = 0; i<=4; i++) { var myTween:Tween = new Tween(_root["ball"+(i+1)], "_x", easeList[i], 39, 400, 2, true); } }; //----------------------------------------- さらに Tween を個別に管理したい場合は 次のようにします。 //----------------------------------------- //Tweenクラスを使用できるようにインポート import mx.transitions.Tween; import mx.transitions.easing.*; var easeList:Array = new Array(); //イージングの種類 easeList[0] = Elastic.easeOut; easeList[1] = Strong.easeOut; easeList[2] = Elastic.easeOut; easeList[3] = Back.easeOut; easeList[4] = Bounce.easeOut; bt1.onRelease = function() { //インスタンス「ball」の動きをTweenクラスを使って制御 for (var i:Number = 0; i<=4; i++) { _root["myTween"+i] = new Tween(_root["ball"+(i+1)], "_x", easeList[i], 39, 400, 2, true); } //個別呼び出し例 _root.myTween2.onMotionFinished = function() { this.yoyo(); }; }; //-----------------------------------------
これはよくできてますねー。 ただ、ロジックを言葉で説明するのは難しいですね・・・。 それだけ単純なものではないので。 まず、このあたりの仕組みは理解されていますでしょうか？ ■ランダムな大きさのグリッドがスクロールするアレ http://wonderfl.net/c/ttb1 このようにグリッドに矩形を配置してから、 次にロールオーバー時に変形した際、 拡大した矩形がどのオブジェクトと重なるのか、 そして、重なったオブジェクトはどの方向に縮小、移動させなければならないのかを オブジェクト毎に計算します。 オブジェクトには「最低限保つ大きさ」なども設定されていますので、 そのあたりも考慮に入れます。 例えば、一番左下のオブジェクトのヨコ方向だけの動きを考えてみます。 ロールオーバー時に、右に150px伸びるとして、 その右のオブジェクトを150px右に縮小させればいいのですが、 その右のオブジェクトは「120pxから80pxまで40pxしか縮小できない」と設定していたとなると、 残り110pxは右に移動させなければなりません。 さらにその右のオブジェクトも「150pxから80pxまで70pxしか縮小できない」となると、 そのオブジェクトも残り40px右に移動する必要がありますので、 さらにまたその右のオブジェクトも40px縮小しなければなりません。 ・・・という具合に玉突き事故が同時に起こっていると考えてください。 この計算を上下方向それぞれに同時に行ってから、 拡大縮小のモーションを行います。 動きを加えると一見複雑そうですが、 変形前と変形後にどのように配置されているのかを グリッド上に物が置かれていると考えれば理解しやすくなると思います。
> サムネイルに50％程度のフェードをかけ この「50％のフェード」の意味がよくわかりません。 まず思いついたのは フェードではなくてアルファ(_alpha/不透明度)ではないかということです。 「50％のアルファをかける」であれば意味がわかります。 その「50％のアルファをかける」場合の とりあえず元のスクリプトをそんなに変えないバージョンのスクリプト例です↓。 //---------------------------------------- import mx.transitions.Tween; import mx.transitions.easing.*; //bt1～bt4のアルファを変える 関数changeAlpha の定義 //(引数:アルファを100にするボタンインスタンス) function changeAlpha(btn:Button):Void { for (var i:Number = 1; i<=4; i++) { this["bt"+i]._alpha = 50; } btn._alpha = 100; } //関数changeAlpha を初回実行(引数:ボタン「bt1」) changeAlpha(bt1); bt1.onRelease = function() { var mcTween = new Tween(Photo, "_x", Regular.easeOut, Photo._x, 0, 1, true); var mcTween = new Tween(waku, "_x", Regular.easeOut, waku._x, 0, 1, true); //関数changeAlpha を実行(引数:クリックされたボタン自身) changeAlpha(this); }; bt2.onRelease = function() { var mcTween = new Tween(Photo, "_x", Regular.easeOut, Photo._x, -400, 1, true); var mcTween = new Tween(waku, "_x", Regular.easeOut, waku._x, 100, 1, true); changeAlpha(this); }; bt3.onRelease = function() { var mcTween = new Tween(Photo, "_x", Regular.easeOut, Photo._x, -800, 1, true); var mcTween = new Tween(waku, "_x", Regular.easeOut, waku._x, 200, 1, true); changeAlpha(this); }; bt4.onRelease = function() { var mcTween = new Tween(Photo, "_x", Regular.easeOut, Photo._x, -1200, 1, true); var mcTween = new Tween(waku, "_x", Regular.easeOut, waku._x, 300, 1, true); changeAlpha(this); }; //---------------------------------------- 上のスクリプトは 同じこと(お決まりのパターン)を何度も書きすぎなので 上と同じ内容をもう少しまとめると 次のように書くこともできます。 //---------------------------------------- import mx.transitions.Tween; import mx.transitions.easing.*; //bt1～bt4のアルファを変える 関数changeAlpha の定義 //(引数:アルファを100にするボタンインスタンス) function changeAlpha(btn:Button):Void { for (var i:Number = 1; i<=4; i++) { this["bt"+i]._alpha = 50; } btn._alpha = 100; } //関数changeAlpha を初回実行(引数:ボタン「bt1」) changeAlpha(bt1); //bt1～bt4に関するループ for (var i:Number = 1; i<=4; i++) { //各ボタンの 変数n に i-1 を保存しておく this["bt"+i].n = i-1; //各ボタンクリック時の動作 this["bt"+i].onRelease = function() { var mcTween = new Tween(Photo, "_x", Regular.easeOut, Photo._x, -this.n*400, 1, true); var mcTween = new Tween(waku, "_x", Regular.easeOut, waku._x, this.n*100, 1, true); //関数changeAlpha を実行(引数:クリックされたボタン自身) changeAlpha(this); }; } //---------------------------------------- 最初の話に戻ります。 > サムネイルに50％程度のフェードをかけ の解釈についてですが， 次のような意味に捉えることもできます。 スクリプトでの状態説明になりますが 「50％のフェード」とはこんな感じのことでしょうか↓？ //---------------------------------------- import mx.transitions.Tween; import mx.transitions.easing.*; //bt2～bt4のアルファを50にする for (var i:Number = 2; i<=4; i++) { this["bt"+i]._alpha = 50; } //bt1～bt4に関するループ for (var i:Number = 1; i<=4; i++) { //各ボタンの 変数n に i の値を保存しておく this["bt"+i].n = i; //各ボタンクリック時の動作 this["bt"+i].onRelease = function() { var mcTween = new Tween(Photo, "_x", Regular.easeOut, Photo._x, -(this.n-1)*400, 1, true); var mcTween = new Tween(waku, "_x", Regular.easeOut, waku._x, (this.n-1)*100, 1, true); for (i=1; i<=4; i++) { if (i != this.n) { var btTween = new Tween(this._parent["bt"+i], "_alpha", Regular.easeOut, this._parent["bt"+i]._alpha, 50, 1, true); } else { var btTween = new Tween(this, "_alpha", Regular.easeOut, this._alpha, 100, 1, true); } } }; } //---------------------------------------- 　 　 ＝＝＝＝＝＝＝＝＝＝＝ ◎オマケ > これをフレームにアクションを記述して > 修正しようとしたがうまく出来ず、 元のファイルのムービークリップやボタン自体に書いてあるスクリプトを全部消して ４つのボタンに「bt1」～「bt4」というインスタンス名を付けた場合 _rootのフレームに書くアクションは次のようになります↓。 //---------------------------------------- var position:Number = 0; Photo.onEnterFrame = function() { this._x -= (this._x+position)/3; }; for (var i = 1; i<=4; i++) { this["bt"+i].n = i; this["bt"+i].onRelease = function() { position = Photo["p"+this.n]._x; }; } //---------------------------------------- ※「Photo」の動く先の座標指定は 　 「Photo」内にあるMC(p1～p4)の 　 各座標が使われています。 ※上記全スクリプト 　 Flash Player 6 以上で動作 　 ActionScript 2.0
おそらく ボタンでも play(); を実行してるのだと思いますが， ボタンで play(); を実行した場合 ３秒が経つ前に次の setInterval がセットされてしまって グチャグチャになるのだと思います。 stopID にはID番号が入るのですが その番号は順次繰り上がりで変動します。 setInterval の管理は結構大変です(補足↓)。 グチャグチャにならないようにするには ボタンクリック時に，前の setInterval をクリアする方法も考えられますが， ボタン以外にも次の setInterval がセットされてしまうこともあり得るので setInterval をする前に，前の setInterval をクリアしておいた方が良い(無難)と思います。 //---------------------------- stop(); //前の setInterval をクリア clearInterval(stopID); stopID = setInterval(stopFRAME,3000); function stopFRAME() { clearInterval(stopID); play(); } //---------------------------- 　 　 ＝＝＝ 補足 ＝＝＝＝＝＝＝＝＝＝＝＝ 「setInterval の管理は大変だ」という話です。 新規ドキュメント作成でフレーム1にコピペし， 「制御」→「ムービープレビュー」してみる例です↓。 //------------------------------------ myID = setInterval(traceID, 3000); trace(myID); //→「1」が出力される myID = setInterval(traceID, 3000); trace(myID); //→「2」が出力される clearInterval(myID); trace(myID); //→「2」が出力される function traceID() { trace(myID); //→3秒ごとに「2」が出力され続ける clearInterval(myID); //←こんなの効かない！ } //------------------------------------ 上記スクリプトでは setInterval を２回連続でセットしています。 ２回セットしたうち clearInterval(myID); でクリアされるのは ID番号が「2」の方(２回目)の setInterval だけです。 ID番号が「1」の方の setInterval はクリアされないので 3秒ごとに「2」が出力され続けます。 ここでもし， 3秒ごとに「2」が出力され続けるのを止めさせたいとするなら， つまり setInterval を完全にクリアしたいとするなら， スクリプトを次のような感じにする必要があります。 //------------------------------------ myID = setInterval(traceID, 3000); trace(myID); //→「1」が出力される myID = setInterval(traceID, 3000); trace(myID); //→「2」が出力される clearInterval(myID); trace(myID); //→「2」が出力される //↓最初の方の setInterval をクリア clearInterval(1); function traceID() { trace(myID); //→何も出力されない } //------------------------------------ 上の場合は わかっていて(わざと意識して)このようにしているので 私も setInterval をクリアする方法はわかります。 しかし わかっていなくて(想定外の状況で)上のようになってしまったら setInterval をクリアする方法はわからないかもしれません。 (またグチャグチャになることすら気付かないこともあり得ます。) setInterval の管理は大変です。 一度グチャグチャになったら終わりなので グチャグチャになる前にクリアしておく方が無難です。 それでも何かの都合で グチャグチャになってしまった場合の対処法↓。 //------------------------------------ myID = setInterval(traceID, 3000); trace(myID); //→「1」が出力される myID = setInterval(traceID, 3000); trace(myID); //→「2」が出力される myID = setInterval(traceID, 3000); trace(myID); //→「3」が出力される //setInterval強制クリア if (myID != undefined) { for (i=1; i<=myID; i++) { clearInterval(i); } } function traceID() { trace(myID); //→何も出力されない } //------------------------------------
ボタンつくって ボタン.addEventListener(MouseEvent.CLICK,fuction(e){loaderTxt.load(new URLRequest(次のファイル))}) する 次のファイルを動的に判断した方が効率いいだろうから ファイルを"テキスト1.txt"とか連番にしておいて var i=0 ボタン.addEventListener(MouseEvent.CLICK,fuction(e){i++;loaderTxt.load(new URLRequest("テキスト"+i+".txt"));}) みたいにするとか
ムービークリップ内に 最初から２つとか３つの(場合によっては４つや５つの) そのル画像を(または画像入りムービークリップを) 横並びに入れておけば良いのではないでしょうか。 １つの画像が例えば |谷山川山谷| だったとすると |谷山川山谷|谷山川山谷|谷山川山谷|… みたいに入れておくわけです。 その横長ムービークリップの基準点は ムービークリップの左上コーナーにしておくものとします。 そして， その横長ムービークリップを コンスタントに ＋方向(右方向) に20pxずつ動かすのですが 基準点がステージの左端(x座標=0)を超えた瞬間だけ その瞬間の座標から画像１枚分の横幅だけ －方向(左方向) に一気に移動させます。 するとループしているように見えます。 //------------------------------------------- //ステージ内の拡大縮小なし(？) stage.scaleMode = StageScaleMode.NO_SCALE; //ステージの左上コーナーを基準として整列 stage.align = StageAlign.TOP_LEFT; var speedX:Number=20; //画像１枚の横サイズ(例：320px) var pictureW:Number = 320; back_mc.addEventListener(Event.ENTER_FRAME, onEnterframe); function onEnterframe(eventObj:Event):void { var mc:MovieClip=eventObj.target as MovieClip; // //コンスタントに右移動 mc.x+=speedX; // //基準点のx座標が0を超えた瞬間だけ //(この瞬間の姿は実際には見えない) if (mc.x > 0) { //画像１枚分左に移動 mc.x -= pictureW; } } //------------------------------------------- ↓イメージ図↓
自分も同様の環境ですが、 「Cmd+'」の挙動については、Flash CS5のデフォルトでは「Cmd+Shift+7」に「反時計回りに回転」のキーボードショートカットが設定されているため、macの場合、そちらが優先されてしまっているようです。 ［ファイル］→［キーボードショートカット]から、どちらかのショートカットを変更するしかないですね。 自分はグリッドの表示は「Cmd+.」に割り当てています。 「Cmd+Tab」についても同様に、必要であれば別のショートカットを設定した方がいいでしょう。
1です。 どの程度と言う事ですが、C言語に近いと言う事での保険的な感覚で言いました。C言語については、私自身の感想と言う感じです。それで似ていると言うだけで、AS3でのプログラミングを、そのまま活用出来ると言う様な誤解をされた様に思いますが、そんな事は当然ありません。後、C言語については、コンパイラーが必要です。 そう言う意味では軽率な発言すいませんでした。 独学という事で、結局会社側に有利な証明出来る資格を取得しとく事で一応、基本情報技術者検定を取ったら有効な資格だと思います。 後、最低でもAdobeの画像ソフトの理解も必要かと思います。
＃１です。 > やってみましたが、動作しないのです。 と書かれましても どこで何がどう動作しないのかがわかりません。 例えば 「エラーが出て全く動作しない(パブリッシュも不可)」 「エラーは出ないがmc0～15がランダムに配置されない」 「mc0～15はランダムに配置されるがボタンで並び変わらない」 などなど様々なことが考えられます。 その状況を見ていない第三者にとっては 状況を見ている人よりももっと何のことかわからないのですよ。 一応私の方は ActionScript 2.0 設定であれば Flash Player 6 以上 SWF パブリッシュ設定 で動作確認済みです。 どこで詰まっているのかさっぱりわかりませんので スクリプトを次のように書き替えて(★部分の trace を追加しただけ)， 「制御」→「ムービープレビュー」で詰まっている部分を確認してみてください。 //---------------------------------------------------- //動くスピードの設定 var spd:Number = 12/100; //mc0～15 の最初の座標を一時的に記録する配列 var tempPosArr:Array = new Array(); //変数 i を 0～15 まで 1 ずつ加算しながらループ for (var i:Number = 0; i<=15; i++) { //mc0～15 の最初の座標(「正しい座標」)を各MC内の変数に記録 this["mc"+i].start_x = this["mc"+i]._x; this["mc"+i].start_y = this["mc"+i]._y; //mc0～15 の最初の座標を一時的に記録する配列に記録 tempPosArr[i] = [this["mc"+i]._x, this["mc"+i]._y]; trace("★↓ mc" + i + ".star_x に値が入っているか"); trace(this["mc"+i].start_x); trace("★↓ tempPosArr[" + i + "] に値が入っているか"); trace(tempPosArr[i]); } //mc0～15 を配置するランダムな座標の配列 var randPosArr:Array = new Array(); //テンポラリ配列からランダムな要素を抜き取りランダムな座標の配列に代入 for (var i:Number = 15; i>=0; i--) { randPosArr.push(tempPosArr.splice(Math.floor(Math.random()*(i+1)), 1)[0]); } trace("★↓ randPosArr に値が入っているか"); trace(randPosArr); //mc0～15 をランダムな座標に配置 for (i=0; i<=15; i++) { this["mc"+i]._x = randPosArr[i][0]; this["mc"+i]._y = randPosArr[i][1]; trace("★↓ mc" + i + " の座標はランダムになっているか"); trace(this["mc"+i]._x + "，" + this["mc"+i]._y); } //ボタンクリック時の動作 btn.onRelease = function():Void { trace("★↓ ボタンは動作しているか"); trace("ボタンがクリックされました"); //変数 i を 0～15 まで 1 ずつ加算しながらループ for (var i:Number = 0; i<=15; i++) { //mc0～mc15に毎フレーム実行する動作を定義 this._parent["mc"+i].onEnterFrame = function():Void { //「正しい座標」に向けてspdの割合ずつ移動 this._x += (this.start_x-this._x)*spd; this._y += (this.start_y-this._y)*spd; }; } }; //---------------------------------------------------- それと 他のスクリプトや他のインスタンスがじゃまをしているということはないでしょうね？ 例えば， 同じインスタンス名を付けた別物があるとか 他の onEnterFrame が重なって動作しているとか。 「制御」→「ムービープレビュー」で 下の【図】↓のような感じになれば良いのです。 この↓状態から btn をクリックすれば「正しい位置」に戻ります。
> 基本はactionscriptを使用しないで、 > 作っているのですが、 その方針だと， 本来，逆にすぐ思いつくはず(思いつくべき)ですよ。 　　　↓↓↓ 「ムービークリップの中に雪を降らせば良い。」 ActionScript 云々は関係なく， これは Flash の基本中の基本(ベースの考え方)です。 Flash を作成をあまりしたことがないバリバリのプログラマでしたら逆に思いつかないかもしれません。 しかしFlashアニメーターやデザイナーでしたら(だからこそ)まず最初に思いつくべきことです。 (ムービークリップやタイムラインがあってこその Flash です。) ＝＝＝具体的方法など＝＝＝＝＝＝＝＝＝＝＝ スクリプトは メインのタイムライン のフレームに書いても良いです。 しかし， その場合は ActionScript を少しはいじらなければなりません。 またムービークリップにはインスタンス名なども付けなければなりません。 そういうことはできればパスなんですよね？ そうでしたら， "書かれているスクリプトそのまま" を ムービークリップの中のフレーム1に書けば良いです。 それだけです。 ここまで書けばわかると思いますが， そのムービークリップは 「最背面の背景」と「その上にある画像」との間(間のレイヤーなど)に作成します。 それと そのムービークリップの基準点(＋印)がステージの左上のコーナーに来るように配置します。 気を付ける点はそれだけです。 ～ムービークリップ内に雪を降らせるその他メリット～～～ 降雪を止めたいときも， 雪を止めるスクリプトを調べたり考たりしなくても ムービークリップをタイムラインから消すだけで 自動的に雪も消える。 雪全体を フェードインやフェードアウトさせたい場合も スクリプトなど考えずに モーショントゥイーンで簡単にできる。 メインのタイムラインにはスクリプトを書かないので ループ再生による重複定義や重複動作に気を使わなくて良い。 その他 雪を横や斜めに降らせるのも簡単。 雪空全体の拡大縮小も簡単。 などなど... (アニメーターだからこそのメリットばかりでしょう？) ～～～～～～～～～～～～～～～～～～～～～～～～～～～ ※以上のことは 　 いつもこうすれば良いというものではありません。 　 また 　 スクリプトはムービークリップ内に書くべき 　 ということを言っているのでもありません。
Flas CS5.5でiOS用に書き出すコンテンツは、SWFのようなWebコンポーネントではなく、完全なiOSアプリです。 したがいまして、内容と動作に問題なければ、問題なくAppStoreの審査に通ると思います。 ただし、Flashから生成されたアプリは、ランタイムを内包するためサイズが大きく、かなり低速で、動作中のメモリエラー発生確率も高く、品質的にはネイティブアプリに比べ相当に落ちることを覚悟してください。 所詮Flash。現状では、アプリケーションとして評価を受けることはかなり難しいと思います。 XCode / Objective Cで開発した正統なアプリには遠く及びません。
Flash 作成ソフトも，そのバージョンも， ActionScript のバージョンも書かれていないため 具体的で詳細な回答はできませんが 大まかに言えば普通はマスクをマウス追従させますよ。 「マスクをマウスに追従させる [Flash] All About」 http://allabout.co.jp/gm/gc/66803/ 「マスクとマスクの追従　FLASHRAVE - FLASH 講座 -」 http://flashrave.org/as/mask/ ---その他(Adobe Flash 以外の Flash 作成ソフト)------- 「Suzuka ＆ ParaDraw 講座-マスク・グラデーションマスク」 http://suzupara.iinaa.net/kiso111.html 「Paraflaのマウスカーソルとマスク - 福祉用具と障害をお持ちの方のパソコン利用」 http://blogs.yahoo.co.jp/kouseinenkinnan/12430078.html
放射状のグラデーションを作る時、グラデーションの終端の方の色に「アルファ」を設定してみてはいかがでしょう。 「アルファ」は、カラーミキサーのＲ・Ｇ・Ｂの要素の下にあります。０％に近いほど透明になり、背景が透けて見えるようになります。 アルファが適用されている色で塗りつぶしたオブジェクトを選択すると、透過部分が真っ黒に表示されることがありますが、実際には透明になっています。
問題点は， var mc:Candy = new Candy(); のようにして たくさんの違う Candy インスタンスを，その場しのぎの変数 mc に代入しているところです。 個々の Candy(MC) インスタンスには その場しのぎではなくちゃんと個別の名前を付ける必要があります。 (個々のCandyインスタンスを参照する個別の変数が必要です。) そうしないと個々のインスタンスを名指しで呼ぶことができません。 あと，ボタンの名前が少しよろしくないので Stratボタンには「start_btn」というインスタンス名を付け Stopボタンには「stop_btn」というインスタンス名を付けるものとします。 以下はその場合の変更例(２例)です。 【例１】 Stratボタン の連続クリックで Candy インスタンスを何度も増殖させる場合 //---フレームのスクリプト例----------------- var stageH:int = stage.stageHeight; var stageW:int = stage.stageWidth; //カウンタ用変数cnt var cnt:int = 0; //Stratボタン start_btn.addEventListener(MouseEvent.MOUSE_DOWN,gene); function gene(e:Event):void { for (var i:int = 0; i < 20; i++) { this["mc" + cnt] = new Candy(); this["mc" + cnt].x = Math.random() * stageW + 10; this["mc" + cnt].y = Math.random() * stageH + 10; addChild(this["mc" + cnt]); //カウンタに1を加算 cnt++; } } //Stopボタン stop_btn.addEventListener(MouseEvent.MOUSE_DOWN,stp); function stp(e:Event):void { for (var i:int = 0; i < cnt; i++) { //インスタンス内のイベントリスナーを削除 this["mc" + i].removeEventListener(Event.ENTER_FRAME,this["mc" + i].loop); //インスタンスを表示リストから削除 removeChild(this["mc" + i]); //インスタンスへの参照を切る this["mc" + i] = null; } cnt = 0; } //------------------------------------------ 【例２】 Stratボタン を連続クリックをさせない場合 //---フレームのスクリプト例----------------- var stageH:int = stage.stageHeight; var stageW:int = stage.stageWidth; //Stopボタンのマウス反応を無効にしておく stop_btn.mouseEnabled = false; //Stratボタン start_btn.addEventListener(MouseEvent.MOUSE_DOWN,gene); function gene(e:Event):void { for (var i:int = 0; i < 20; i++) { this["mc" + i] = new Candy(); this["mc" + i].x = Math.random() * stageW + 10; this["mc" + i].y = Math.random() * stageH + 10; addChild(this["mc" + i]); } //Stratボタンのマウス反応を無効にする start_btn.mouseEnabled = false; //Stopボタンのマウス反応を無効にする stop_btn.mouseEnabled = true; } //Stopボタン stop_btn.addEventListener(MouseEvent.MOUSE_DOWN,stp); function stp(e:Event):void { for (var i:int = 0; i < 20; i++) { //インスタンス内のイベントリスナーを削除 this["mc" + i].removeEventListener(Event.ENTER_FRAME,this["mc" + i].loop); //インスタンスを表示リストから削除 removeChild(this["mc" + i]); //インスタンスへの参照を切る this["mc" + i] = null; } //Stratボタンのマウス反応を有効にする start_btn.mouseEnabled = true; //Stopボタンのマウス反応を無効にする stop_btn.mouseEnabled = false; } //------------------------------------------ this["mc" + i] などで出てくる [] を 「配列アクセス演算子」と言いますが， これを使わずに個々のインスタンスを配列の要素に入れても良いです。 そうすれば this などのタイムラインを参照するパスは不要になります。 //---例---------------------------------- var stageH:int = stage.stageHeight; var stageW:int = stage.stageWidth; //インスタンスの参照を格納する配列を作成 var mc_arr:Array = new Array(); 　～ 中略 ～ function gene(e:Event):void { for (var i:int = 0; i < 20; i++) { //配列の各要素に作成したインスタンスを格納 mc_arr[i] = new Candy(); 　～ 後略 ～ //--------------------------------------- その他諸々のことに関して 「[AS3] DisplayObjectインスタンスの削除とガベージコレクション 」 http://f-site.org/articles/2010/05/09072731.html
ぴったり正確に整数座標で原寸（または整数倍拡大で）配置しています？ ビットマップオブジェクトの解像度は72dpiや96dpiになっていますか？ ムービークリップの場合は、整数座標で配置しても、テキストフィールドなどが上左に配置されていて、そちらの座標が対象になり、ビットマップオブジェクトが結果的に整数座標配置になっていない、など。
結論から言いますと、startDragでは矩形の範囲しか選択できません。 ですが、ドラッグ対象のオブジェクトにMOUSE_DOWNした段階で MOUSE_MOVEイベントなどで常にマウスの位置を監視して、 特定の図形の上にマウスが納まっているかチェックすれば 台形であろうが円であろうがどんな形状でも可能です。 チェックする方法としては、hitTestObjectなどを使用するのが一番簡単でしょうか。 簡単な例としては以下のような感じです。 ----- import flash.display.MovieClip; import flash.events.MouseEvent; var c:MovieClip; //ドラッグするMC var m:MovieClip; //ドラッグ範囲のMC (台形) c.addEventListener(MouseEvent.MOUSE_DOWN, startDragObj); stage.addEventListener(MouseEvent.MOUSE_UP, stopDragObj); function startDragObj(e:MouseEvent):void { this.addEventListener(MouseEvent.MOUSE_MOVE, onDrag); } function onDrag(e:MouseEvent):void { // ドラッグ範囲上にマウスがあれば、マウスの位置にドラッグ if (m.hitTestPoint(mouseX, mouseY, true)) { c.x = mouseX; c.y = mouseY; } } function stopDragObj(e:MouseEvent):void { this.removeEventListener(MouseEvent.MOUSE_MOVE, onDrag); } -----
FlashEffは一般的なトランジションライブラリなので、トランジション実行時、必ずその対象であるムービークリップをメモリ中に読み込んでいる必要があります。 でないと動作中にハングアップしかねないし、また、トランジションはどのようなタイミングで行われるかわからない（極端なことをいえば最初のフレームから全画像がトランジションする場合もありえます）ので、その対象である画像のリンケージプロパティにかかわらず、開始前に強制的にプリロードを発生させているのではないでしょうか？ なので、FlashEffの対象画像を、別ムービーで手動プリロードし、遷移後のムービーで同一ソースファイルの画像オブジェクトをFlashEffでトランジションさせる、ということになるかと。 両者はあくまで別swfです。シーンはあくまでタイムライン編集の方便であり、内部的には一本のタイムラインとして処理されますので、シーン分けは無意味だと思います。 FlashEffの新版（v2）を持たないので、確実な検証はできませんが、Eff1や他のトランジションライブラリでは明らかにそうでした。「あらかじめmc化してプリロードしておくように」と明記されたものもあります。 Effは高価な製品で完成度も高いので、いろいろとお節介だということですね。きっと。
移動位置が狂うのは「R_btn」や「L_btn」クリックで お互いのボタン機能を操作していないからでしょう。 書かれているスクリプトでは 「R_btn」をクリックしても「L_btn」をクリックしても "クリックしたボタンのみ" の機能を無効にしています。 そうではなくて 「R_btn」をクリックしても「L_btn」をクリックしても どちらにしてもTweenが終わるまで "両方" のボタン機能を無効にしておく必要があります。 書かれているスクリプトを そのまま延長した場合のスクリプト例です↓。 (「★」を付けた部分が変更点) //------------------------------ //クラスのインポート import mx.transitions.Tween; import mx.transitions.easing.*; //画像１枚の横幅を設定 var g_w:Number = 120; //画像の枚数を設定 var g_n:Number = 7; //カウンタ用変数 var cnt:Number = 0; //「L_btn」を非表示にしておく L_btn._visible = false; //「R_btn(→ボタン)」クリック時の動作を定義 R_btn.onRelease = function():Void { //もしカウンタが 画像の枚数-1 未満であれば if (cnt<g_n-1) { var myTween = new Tween(my_mc, "_x", Regular.easeOut, my_mc._x, my_mc._x-g_w, 3, true); //★L_btn & R_btn のボタン機能を無効にする L_btn.enabled = false; R_btn.enabled = false; //myTweenのモーション終了時に実行するメソッドを定義 myTween.onMotionFinished = function() { //★L_btn & R_btn のボタン機能を有効にする L_btn.enabled = true; R_btn.enabled = true; }; //L_btnを表示する L_btn._visible = true; //なおかつカウンタが 画像の枚数-2になれば if (cnt == g_n-2) { //R_btnを非表示にする R_btn._visible = false; } //カウンタに1を加算 cnt++; } }; //L_btnクリック時の動作を定義 L_btn.onRelease = function():Void { //もしカウンタが 0 より大きい場合は if (cnt>0) { var myTween = new Tween(my_mc, "_x", Regular.easeOut, my_mc._x, my_mc._x+g_w, 3, true); //★L_btn & R_btn のボタン機能を無効にする L_btn.enabled = false; R_btn.enabled = false; //myTweenのモーション終了時に実行するメソッドを定義 myTween.onMotionFinished = function() { //★L_btn & R_btn のボタン機能を有効にする L_btn.enabled = true; R_btn.enabled = true; }; //R_btnを表示する R_btn._visible = true; //なおかつカウンタが 1 になれば if (cnt == 1) { //L_btnを非表示にする L_btn._visible = false; } //カウンタから1を減算 cnt--; } }; //------------------------------ 一応は以上です。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ しかし... 私はせっかちですから 閲覧者の立場で上のスクリプトを動作させると非常にイライラします。 私でしたらボタン機能は無効にせずに次のようにします。 (本題とは関係のない ★オマケ 機能も勝手に入れてます) //------------------------------ //クラスのインポート import mx.transitions.Tween; import mx.transitions.easing.*; //画像１枚の横幅を設定 var g_w:Number = 120; //画像の枚数を設定 var g_n:Number = 7; //表示する文字列の設定(★オマケ) var str_arr:Array = ["画像1", "画像2", "画像3", "画像4", "画像5", "画像6", "画像7"]; //文字列を表示するテキストフィールドを作成(★オマケ) //(本当は好きな場所に手動で「my_txt」を作成する) createTextField("my_txt", 0, 10, 10, 0, 0); my_txt.autoSize = "left"; my_txt.border = true; my_txt.background = true; //カウンタ用変数 var cnt:Number = 0; //「my_txt」に文字列を表示(★オマケ) my_txt.text = str_arr[cnt]; //「L_btn」を非表示にしておく L_btn._visible = false; //「R_btn(→ボタン)」クリック時の動作を定義 R_btn.onRelease = function():Void { //もしカウンタが 画像の枚数 未満であれば if (cnt<g_n) { //カウンタに1を加算 cnt++; //-g_w*cnt に向けて x座標 をTween var myTween = new Tween(my_mc, "_x", Regular.easeOut, my_mc._x, -g_w*cnt, 3, true); //L_btnを表示する L_btn._visible = true; //なおかつカウンタが 画像の枚数-1になれば if (cnt == g_n-1) { //R_btnを非表示にする R_btn._visible = false; } //「my_txt」に文字列を表示(★オマケ) my_txt.text = str_arr[cnt]; } }; //L_btnクリック時の動作を定義 L_btn.onRelease = function():Void { //もしカウンタが 0 より大きい場合は if (cnt>0) { //カウンタから1を減算 cnt--; //-g_w*cnt に向けて x座標 をTween var myTween = new Tween(my_mc, "_x", Regular.easeOut, my_mc._x, -g_w*cnt, 3, true); //R_btnを表示する R_btn._visible = true; //なおかつカウンタが 0 になれば if (cnt == 0) { //L_btnを非表示にする L_btn._visible = false; } //「my_txt」に文字列を表示(★オマケ) my_txt.text = str_arr[cnt]; } }; //------------------------------ とりあえずは関係のない「(★オマケ)」部分の動作は無視してください。 動く先の座標を 動いている最中かもしれない(不安定な)「my_mc」を基準にして決定するのではなく， しっかりと安定した数「-g_w*cnt」で決定するようにしています。 こうすれば見たい画像までイライラせずにスムーズに my_mc を移動させることができます。 ※以上のスクリプト 　 ActionScript 2.0 / Flash Player 6 以上で動作 ※後にこのページを見る方がいらした場合の状況説明図↓
携帯電話のキーで直接選択できるようにするためのショートカットである keyPress に両方とも <Enter> が指定されているので、２つのボタンが同時に反応してしまっているのではないでしょうか。 例えば、上のボタンに keyPress "1" 、下のボタンに keyPress "2" というように、別のキーを割り当ててみてはいかがでしょう。 Enter は、選んだ対象を決定するために使われるキーです。 ゲームのスタート画面などのようにボタンが１つしかない画面では Enter キーでもいいのですが、複数のボタンがある時は、ボタンを決定するつもりで押したのに意図しないボタンが反応してしまった、というようなことが起こりやすいので、Enter キーは割り当てない方が無難だと思います。
>>FLASHを使用して作っているのでしょうか。 Flash ではありませんね。 右クリックしても「Flash Player ○ について」とか出てきませんし 右クリックで表示されている画像を保存することもできますし。 JQuery か JQuery のようなものを使った JavaSctipt 製の横スライドです。 この辺とかが参考になるかと思います、 「JQueryを使ったスライド表現を集めた「10 Best jQuery Sliders」 DesignDevelop」 http://design-develop.net/web-design/10-best-jquery-sliders.html その他 でも Google などで 「JQuery 方法」のような検索をするとかなりのページが見つかると思います。
> 1フレームめにアクションスクリプトを記述するのが > 当たり前と思っているのですがこれは間違いになりますか。 そこに間違いとか正解とかはないでしょう。 １フレーム目のにスクリプトを書ける状況であった上で １フレーム目のみにスクリプトを書きたい場合はそうすれば良いだけです。 １フレーム目のみにスクリプトを集約することができない場合はそうする必要はありません。 また １フレーム目のみにスクリプトを集約することができたとしても，そうしたくない場合もそうする必要はありません。 「こうすべき」とかはありません。 「できることを臨機応変に最大限に生かす」という方向で考えるのが大切だと思います。 ちなみにご質問のものの場合は， １フレーム目のみにスクリプトを集約することができます。 (過去のバージョンでしたらできない場合もありますが ActionScript 2.0(Flash Plaeyr 6 以上) でしたら十分できます。) また "私は" １フレーム目のみにスクリプトを集約させたいと思います。 ですから "私だったら" 次のようにします。 まず 「→」ボタンと「←」ボタンと「my_mc」をフレーム1だけに配置します。 そして 「→」ボタンと「←」ボタンにインスタンス名を付けます。 ここでは 「→」ボタン には「R_btn」というインスタンス名を付け 「←」ボタン には「L_btn」というインスタンス名を付けるものとしておきます。 ※【図↓】参照のこと そしてタイムラインのフレーム1には次のように書きます。 //---------------------------------------- //画像１枚の横幅を設定 var g_w:Number = 120; //画像の枚数を設定 var g_n:Number = 7; //「L_btn(←ボタン)」を非表示にしておく L_btn._visible = false; //カウンタ用変数 var cnt:Number = 0; //「R_btn(→ボタン)」クリック時の動作を定義 R_btn.onRelease = function():Void { //もしカウンタが 画像の枚数-1 未満であれば if (cnt < g_n-1) { //画像の横幅分 左へ移動 my_mc._x -= g_w; //「L_btn(←ボタン)」を表示する L_btn._visible = true; //なおかつカウンタが 画像の枚数-2になれば if (cnt == g_n-2) { //「R_btn(→ボタン)」を非表示にする R_btn._visible = false; } //カウンタに1を加算 cnt++; } }; //「L_btn(←ボタン)」クリック時の動作を定義 L_btn.onRelease = function():Void { //もしカウンタが 0 より大きい場合は if (cnt > 0) { //画像の横幅分 右へ移動 my_mc._x += g_w; //「R_btn(←ボタン)」を表示する R_btn._visible = true; //なおかつカウンタが 1 になれば if (cnt == 1) { //「L_btn(→ボタン)」を非表示にする L_btn._visible = false; } //カウンタから1を減算 cnt--; } }; //---------------------------------------- 　
JavaScript も ActionScript も，両方とも間違っていますね。 私の推測も入れて書き直します。 ---HTML(index.html)内に記述したJavaScript--------- <script type="text/javascript"> function winopen(P,W,H) { window.open(P, "my_name", "toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=1,resizable=0,width=" + W + ",height=" + H + "\""); } </script> ---ここまで------ ---Flash(SWFファイル)のボタン記述したActionScript----- on (release) { getURL("javascript:winopen('top.html',1024,768);"); } ---ここまで------
↓次のようにすれば良いと思います。 //------------------------------------- import mx.transitions.Tween; import mx.transitions.easing.*; bt1.onRelease = function() { // var myTween = new Tween(my_mc, "_x", Regular.easeOut, my_mc._x, my_mc._x-200, 3, true); // //bt1のボタン機能を無効にする bt1.enabled = false; // //myTweenのモーション終了時に実行するメソッドを定義 myTween.onMotionFinished = function() { //bt1のボタン機能を有効にする bt1.enabled = true; }; }; //-------------------------------------
＃１です。 PC の外部に何かを保存するのでしたら Windowsプロジェクター（.exe） を選ぶこと自体が間違っていますね。 SWF(HTML や HTA に貼り付けた SWF) でしたら， まだ JavaScript や VBScript 経由で何らかのファイルが書き出せたり通信できますが Windowsプロジェクター（.exe）でしたら八方塞がりですね。 (セキュリティ関係でその辺は塞がれまくってます。) 一般的には唯一(？)外部に何かを残せるとすれば 「SharedObject」 くらいでしょうか。 http://www.google.co.jp/search?hl=ja&q=SharedObject いわゆるクッキーですから その居場所やデータの仕様は自己研究してみてください。 または，超マニアックですが EXEのあるフォルダ内に「fscommand」という名のフォルダを作って そのフォルダ内にFlash製とは別のEXEを仕込んでおいて何かを保存させるとか(通信はほとんど不可かも)。。。 http://www.google.co.jp/search?hl=ja&q=fscommand+%E3%83%95%E3%82%A9%E3%83%AB%E3%83%80 この辺も自己研究あるのみです。 もしくは EXE などというものを捨てて，根本を変えて「AIR」です。
自分で確かめていないので恐縮ですが、次のクジラ飛行机さんのWebページが参考になるのではないでしょうか。 http://hima.chu.jp/flash/tips/flash_with_arg.htm つまり、対象のSWFの第1フレームに、_root_引数 を評価するif文を設定して、その内容が正しくなければ、次に進めないか、そのSWFを閉じる命令を用意します。そして、呼び出し元のswfでは引数付きで呼び出すように記述しておきます。 そうすれば、引数の文字列を知らなければ開けないSWFファイルが作れるでしょう。
Apple が、スタイリッシュで在り続ければ iOS は残ると思う。 Adobe AIR は残りそうだけど、Android が台頭しても、ウェブ上の Flash は HTML5 の浸透と共に下火になるんじゃないかな？とおもう。 というかそういう Web 標準の Web 社会が形成されて欲しい。 Flash が残って欲しいというのは、一部の開発者と Adobe の単なる都合だし、 同じ機能が実現できていれば、使うユーザ側には関係ないことだけじゃなくて、 プラグインを入れなくっちゃならないとか、 バージョンアップに気を使ったりとか いちいちめんどう。 それなら、ウェブブラウザをバージョンアップしたら、それで安心して使えるのが楽かな？
AS2 でも AS3 でも基本的に同じ問題は起こりますよ。 とにかく問題は i です。 for文を抜けた後に(JPEGのロード完了時には) i は 4 になっています。 この辺をとう対処するかです。 対処案を３つほど書きます。 //===対処案１================== for (var i:int=1; i<4; i++) { this["myLoader"+i] = new Loader(); this["myLoader"+i].load(new URLRequest("img/img00"+i+".jpg")); this["myLoader"+i].contentLoaderInfo.addEventListener(Event.COMPLETE, xSetContent); this["myLoader"+i].x = -69+(i*97); this["myLoader"+i].y = 115; addChild(this["myLoader"+i]); } function xSetContent(eventObject:Event):void { var myContent:DisplayObject = eventObject.target.content; myContent.width = 93; myContent.height = 68; } //============================= ↑i の値がまだ 1～3 のときに その値を使って座標指定してしまえば あっさりと問題が解決するという方法です。 AS2(AS1)でも同じ方法(考え方)は使えます。 　 　 //===対処案２================== for (var i:int=1; i<4; i++) { this["myLoader"+i] = new Loader(); this["myLoader"+i].load(new URLRequest("img/img00"+i+".jpg")); //ロード完了時に関数xSetContentの戻り値を実行 this["myLoader"+i].contentLoaderInfo.addEventListener(Event.COMPLETE, xSetContent(i)); addChild(this["myLoader"+i]); } //戻り値として関数を返す 関数xSetContentを定義 function xSetContent(n:int):Function { //戻り値として返す関数 return function():void{ var myContent:DisplayObject = MovieClip(root)["myLoader" + n].content; myContent.width = 93; myContent.height = 68; myContent.x = -69+(n*97); myContent.y = 115; } }; //============================= ↑クロージャという関数を使っています。 これも AS2(AS1)でも同じ方法(考え方)は使えます。 また ActionScript に関わらず多くの言語でこのクロージャは使われます。 　 　 //===対処案３================== //Dictionaryインスタンス「my_dic」を作成 var my_dic:Dictionary = new Dictionary(); for (var i:int=1; i<4; i++) { this["myLoader"+i] = new Loader(); this["myLoader"+i].load(new URLRequest("img/img00"+i+".jpg")); this["myLoader"+i].contentLoaderInfo.addEventListener(Event.COMPLETE, xSetContent); //「my_dic」にLoaderをキーとして i の値を登録 my_dic[this["myLoader"+i]] = i; addChild(this["myLoader"+i]); } function xSetContent(eventObject:Event):void { var myContent:Bitmap = eventObject.target.content; myContent.width = 93; myContent.height = 68; //「my_dic」からLoaderをキーとして i の値を取得 myContent.x = -69+(my_dic[myContent.parent]*97); myContent.y = 115; } //============================= ↑Dictionaryクラスのインスタンスには インスタンスをキーとしてインスタンスを登録することができます。 (インスタンスどうしを関連付けることができます。) これは AS3 のみで使える方法で AS2(AS1) では使えません。 この場合は Loader インスタンスをキーとして i の値を関連付けています。 他にも例えば 「ボタンインスタンスをキーとしてムービークリップを関連付ける」 「テキストフィールドをキーとしてスプライトを関連付ける」 などのことができます。 フレームにコピペ＆ムービープレビューするだけで検証できる簡易例↓。 //============================= //テキストフィールド「my_txt」を作成 var my_txt:TextField = new TextField(); my_txt.border = true; my_txt.autoSize = TextFieldAutoSize.LEFT; my_txt.x = my_txt.y = 20; my_txt.text = "ココをクリックしてください"; addChild(my_txt); //スプライト「my_sp」を作成 var my_sp:Sprite = new Sprite(); my_sp.x = my_sp.y = 120; my_sp.graphics.beginFill(0xFFCC00); my_sp.graphics.drawRect(-50, -25, 100, 50); my_sp.graphics.endFill(); addChild(my_sp); //Dictionaryインスタンスを作成 var my_dic:Dictionary = new Dictionary(); //「my_txt」をキーとして「my_sp」を関連付ける my_dic[my_txt] = my_sp; //「my_txt」クリック時に関数rotateMCを実行 my_txt.addEventListener(MouseEvent.CLICK,rotateMC); //関数rotateMCの定義 function rotateMC(evt:MouseEvent):void { //「my_txt」をキーとして関連付けたインスタンスを回転 my_dic[evt.currentTarget].rotation += 10; } //=============================
flashで作成する場合、何らかのソフトをご購入されたほうが良いかと思います。 (普段flashを使用されていないのであれば。。。) お奨めはWindowsMovieMakerです。(Windowsに標準でついているはずです。) 写真の効果を埋め込むくらいだと簡単にできます。 私も実際に披露宴での動画作成に利用しました。
お使いの Flash のバージョンも書かれていませんし パブリッシュ対象の Flash Player のバージョンも書かれていませんし ActionScript のバージョンも書かれていませんし 前後(周辺)の状況も全く書かれていませんね。 これでは現象の再現ができないので 「こうすれば良い」とか「ここが間違っている」などが言えません。 私の方でも現象を再現しようと色々してみましたが 私がやってみた中ではダイナミックテキストが印刷されないという現象は起きませんでした。 フレームに書いたスクリプト例↓ ---ActionScript 2.0 ＆ Flash Player 7 ------ //ムービークリップ「my_mc」内に //ダイナミックテキストフィールド「my_txt」を作成 createEmptyMovieClip("my_mc",0); my_mc._x = 100; my_mc._y = 100; my_mc.createTextField("my_txt",0,0,0,0,0); my_mc.my_txt.type = "dynamic"; my_mc.my_txt.autoSize = "left"; my_mc.my_txt.text = "あいうえお"; //「my_mc」を印刷 var my_pj:PrintJob = new PrintJob(); my_pj.start(); my_pj.addPage(my_mc); my_pj.send(); -------------------------------------------- 　　↓結果↓ 「あいうえお」は印刷される ---ActionScript 3.0 ＆ Flash Player 10------ //ムービークリップ「my_mc」内に //ダイナミックテキストフィールド「my_txt」を作成 var my_mc:MovieClip = new MovieClip(); my_mc.x = 100; my_mc.y = 100; var my_txt:TextField = new TextField(); my_txt.type = TextFieldType.DYNAMIC; my_txt.autoSize = TextFieldAutoSize.LEFT; my_txt.x = 0; my_txt.y = 0; my_txt.text = "あいうえお"; my_mc.addChild(my_txt); addChild(my_mc); //「my_mc」を印刷 var my_pj:PrintJob = new PrintJob(); my_pj.start(); my_pj.addPage(my_mc); my_pj.send(); -------------------------------------------- 　　↓結果↓ 「あいうえお」は印刷される 当然， 他のバージョン(型指定を削除して ActionScript 1.0 の Flash Player 8 に設定するなど)でも検証してみましたが 結果は同じで 私がやってみた中では，どの場合でもダイナミックテキストの内容は印刷されました。 (ただし PrintJob が使えるのは Flash Player 7 以降なので，それより以下の条件はないものとして無視しました。) また上記のものは， 質問者さんの方でもコピペだけで再現がしやすいように全てActionScriptで作成していますが， この外にも手動でムービークリップやテキストフィールドを作成してみたりもしました。 さらに テキストフィールドにボーダーの枠を入れてみたり，背景の色を設定してみたり，色々してみました。 しかしやはり結果は同じで 私がやってみた中では，どの場合でもダイナミックテキストの内容は印刷されました。 そもそも， ご自身でシンプルな状況を作って，同じ現象が起こるこを確認されてから質問されたのでしょうか？ (状況をシンプルにして問題を単純化すると， 「解決策」まではわからないにしても 「原因」だけはわかることが多いです。 また問題解決をしようとするときにまずすべきことです。) とにかく， 状況などは無数にあって，質問者さんの状況など特定できないので， 『何かの条件が合わされば「ダイナミックテキストの部分が印刷されない」という現象は起きることもあるでしょうね。』 くらいのことしか言えません。 また， Flash や Flash Player や ActionScript 内の問題ではなく OSやプリンタやそのドライバやフォントなどが関係することかもしれません。 何にしても，状況がわからない以上は何とも言えません。 　 　
new URLRequest() の ()内で指定する引数は１つです。 というか「リクエストするURL」の指定は１つです。 "_self" などのような「ウィンドウ」を指定するのはそこではなく navigateToURL() の () 内の方です。 navigateToURL(new URLRequest("ttp://～","_self")); 　↓変更↓ navigateToURL(new URLRequest("ttp://～"),"_self"); これで出来ませんか？
> 質問の仕方もわかりにくく申し訳ないのですが 大まかなことはわかるのですが 少し細かいこと(中まかなこと？)がわかりませんね。 その「中まかなこと？」によって考え方や可能/不可能が変わります。 問題は添付された図の「線(壁)」です。 この「線(壁)」の解釈のしかたによって変わります。 > （壁）をすり抜けないようにする とだけ書かれていらっしゃいますが その「線(壁)」の向こう(右側)には,行けるのか行けないのかがわかりません。 もし 『「線(壁)」の向こう(右側)には行けない』 とするなら比較的簡単な話で その「線(壁)」の x座標 でドラッグの x座標 を制限するか もしくは 「線(壁)」の向こう(右側)に「透明な塗り」でも描いておいて その「線(壁)」＋「透明な塗り」 のエリアに侵入したドラッグ物を 何らかの方法で排除すれば良いというようなことになります。 私の勝手な推測ですが， そうではなくて 「線(壁)」の上や下を迂回すれば 『「線(壁)」の向こう(右側)には行ける』のですよね？ ※ 参考図↓ その場合は， 次のようにするのが１つの方法です。 「線(壁)」をムービークリップに変換して 例えば「line_mc」というインスタンス名を付けます。 またドラッグするものもムービークリップに変換して 例えば「ball_mc」というインスタンス名を付けます。 その「line_mc」と「ball_mc」が存在するタイムラインのフレームに書くスクリプト例です↓。 --------------------------- //「ball_mc」を押したとき ball_mc.onPress = function():Void { //このMCをドラッグ開始 this.startDrag(); }; //「ball_mc」を放したときと外で放したとき ball_mc.onRelease = ball_mc.onReleaseOutside=function ():Void { //このMCのドラッグを終了 this.stopDrag(); }; //「ball_mc」の座標を保存しておく変数を用意 var tmp_x:Number = ball_mc._x; var tmp_y:Number = ball_mc._y; //マウスが動いたとき ball_mc.onMouseMove = function() { //もし「line_mc」がこのMCにヒットしていなければ if (!line_mc.hitTest(this)) { //このMCの座標を保存 tmp_x = this._x; tmp_y = this._y; } else { //「line_mc」がこのMCにヒットしたときは //このMCの座標を保存していた座標に戻す this._x = tmp_x; this._y = tmp_y; } }; --------------------------- ◎ ActionScript 2.0 　 要 Flash MX 2004 以上 ただこれ↑には 大きな問題点があります。 > 迷路のゲーム（イライラ棒みたいなもの）は > たくさん見つかるのですが それらのよく見るものは，たいてい壁が分厚くないでしょうか？ Flash Player は，というか PC自体は， マウスの座標を連続的(アナログ的に)に検知しているのではなくて パルス的(デシタル的に)に検知しています。 つまり 数十分の１秒 間隔でマウスの座標を検知しています。 ですから「線(壁)」が薄い(細い)場合， 高速ドラッグされると「線(壁)」に当たった瞬間など無くなって 「線(壁)」をスッポ抜けてしまうのです。 ですから たいていの迷路のゲーム（イライラ棒みたいなもの）は壁を分厚くしています。 または ドラッグではなくキー操作などで物を動かす仕様にして速度制限をかけています。 (みなさんそういう工夫をして問題を乗りこえているのです。) もし 『「線(壁)」は厚さの無い線であってドラッグするものも点である』 みたいなものの場合， 本格的に壁のすり抜けを厳密に判定しようとすれば 独自で軌跡を線の方程式にして， その軌跡を線と壁の線との交点を求めるような数学的に複雑なスクリプトが必要になって来ます。 (条件などもさらに必要で私も頭が回らないのでココでは回答できません。) そこまでのことを求めないのでしたら， 高速ドラッグ時の壁のスッポ抜け問題を対処する工夫としては， 次のようにスクリプトを変更するのも１つの方法です。 --------------------------- //「ball_mc」を放したときと外で放したとき ball_mc.onRelease = ball_mc.onReleaseOutside=function ():Void { //このMCのドラッグを終了 this.stopDrag(); }; --------------------------- 　↓変更↓ --------------------------- //「ball_mc」を放したときとマウスが外れたとき ball_mc.onRelease = ball_mc.onDragOut=function ():Void { //このMCのドラッグを終了 this.stopDrag(); }; --------------------------- こうすると高速ドラッグできなくなるので， 壁のスッポ抜け問題がかなり生じにくくなります。 (ただしドラッグしにくくなります。) ものによっては さらに色々な問題点が出てくることもあると思います。 しかし何にしても 状況によって自分なりに工夫をすることが大切だと思います。
条件の詳細が分かりませんが、参照URLの記事がお役に立つかと思います。 ↓２線の交点の求め方教えて下さい。 http://questionbox.jp.msn.com/qa24651.html ↓２点を通る２直線の交点の求め方 http://youfc2.blog10.fc2.com/blog-entry-11.html
私も同様の事象で悩んでおりました。 私の場合は、Flash MX で過去に作ったflaファイルを cs5 にて開こうとしましたが、 同様に「予期しないファイル形式です」とのメッセージが表示され、開くことができませんでした。 Flash MX　はPCにはもうインストールされておらず、半ば諦め気味でしたが、 先程、●●.fla と一緒に作成してあった　●●.swf　ファイルを CS5 にて開くことができたため 先に●●.swf　ファイルを CS5 にて開き、その状態で　●●.fla ファイルを開くと、 ●●.fla ファイルを開くことができました。 その後、cs5 形式で別名保存を行い、問題は解消できました。 ただ、新バージョンで保存した場合、 「うまく表示されないフォントがでてくる可能性もある」　 のようなメッセージが表示されます。 これで解決するかわかりませんが、 私の本日の経験談です。 ご参考までに。
Sound オブジェクトである soundCtl が消えたのではなく、this が指す対象の変化に伴い、loadComplete メソッド内で soundCtl を参照できていないことが原因だと思います。 onLoad イベントハンドラにより loadComplete メソッドが呼び出されると、その中での this は、呼び出した者である soundCtl を指します。 すると、loadComplete メソッド内の this.soundCtl.start は soundCtl.soundCtl.start を指定していることになってしまい、これは存在しないので何も起こらない、というわけです。 この問題は、this が指す対象を他の変数に保護しておき、匿名関数とこの変数を使ってイベント処理関数を呼び出すと回避できます。 SoundUtil メソッド（コンストラクタ）内に 　//thisが指す対象（＝SoundUtilクラス自身）を保護 　var owner:SoundUtil = this; ↑　このように、this が指している対象を保護する変数を追加し、イベント処理の定義を 　this.soundCtl.onLoad = function( success:Boolean ):Void 　{ 　　owner.loadComplete( success ); 　}; 　this.soundCtl.onSoundComplete = function():Void 　{ 　　owner.endSound(); 　}; に、変更してみてください。 （各行頭に全角のスペースが入っています。コピーする際はご注意ください） イベントハンドラに登録した匿名関数の中にある owner には、SoundUtil クラスのオブジェクト自身の参照が入っています。 onLoad イベントハンドラによりまず呼び出されるのはこの匿名関数で、この中では owner の値を参照できます。 匿名関数の中で owner を介して loadComplete メソッドを呼び出すと、loadComplete メソッドを呼び出した者は変数 owner で示される者、つまり SoundUtil クラスのオブジェクト自身になるので、this もクラスのオブジェクト自身を指します。 従って、this.soundCtl や、this を省略して soundCtl とした時も、soundCtl を参照することができます。 onSoundComplete イベントハンドラの場合も同様です。 － － － － － ところで、クラスファイルの冒頭の 　public var soundCtl:Object; の型は、Object 型ではなく Sound 型ではないでしょうか。 それから、コンストラクタの引数は、ボリュームなどを音声ごとに細かく設定できるようにするチャンネル分けのためと思いますが。 その場合は、 　this.soundCtl = new Sound(); ↑　この部分は 　this.soundCtl = new Sound( target ); でなければ、意味がないと思います。
そういう基本的でオーソドックスなものは 普通，全てスクリプトでするものではありません。 「たくさんの四角インスタンスがトゥイーンで拡大するアニメーション」をムービークリップ内のタイムラインに作って そのムービークリップで写真にマスクを掛ければ良いだけのことです。 場合によっては stop(); １つくらいでできます。 初心者がすべき重要かつ簡単な内容です。 回答を待ったりスクリプトを考えている間に， 手作業だと数十回はいろいろなバリエーション作成できていたと思います。 スクリプトでもできなくはありませんが カスタマイズとかが難しくなるだけですし またこういうものは「手作業」で作れてはじめてスクリプトが組めたり使い回しが可能になるのです。 と言いつつ一応作ってはみましたが... やはりマクロ(手作業でする操作を自動化しただけのプログラム)的なスクリプトが大半を占めてしまいました。 手作業をサボる分，頭をフル回転させばければならないスクリプトです。 ステージ上に 「pic0」「pic1」…「pic5」というインスタンス名を付けた 800×400pxの写真入りムービークリップを作成し それらムービークリップがあるタイムラインのフレームにコピペするスクリプト例です。 ※ 図↓参考のこと //=========================================== //---↓マスク用MCの作成(ほぼマクロ)↓--- import fl.transitions.*; import fl.transitions.easing.*; var mc:MovieClip; function makeMask():void { // mc = new MovieClip(); // for (mc.i=0; mc.i<=3; mc.i++) { for (mc.j = 0; mc.j<=7; mc.j++) { mc["rec" + mc.i + mc.j] = new Shape(); mc["rec" + mc.i + mc.j].graphics.beginFill(0xFF6666, 1); mc["rec" + mc.i + mc.j].graphics.drawRect(0, 0, 100, 100); mc["rec" + mc.i + mc.j].graphics.endFill(); mc["rec" + mc.i + mc.j].x = mc.j * 100; mc["rec" + mc.i + mc.j].y = mc.i * 100; mc["rec" + mc.i + mc.j].width = 0; mc.addChild(mc["rec" +mc.i + mc.j]); } } // mc.dic = new Dictionary(); // for (mc.i = 0; mc.i<=3; mc.i++) { mc["tm" + mc.i] = new Timer(100,8); mc.dic[mc["tm" + mc.i]] = mc.i; mc["j" + mc.i] = 0; mc.timerHandler1 = function(e:TimerEvent):void { mc["twn" + mc.i] = new Tween(mc["rec" + mc.dic[e.target] + mc["j" + mc.dic[e.target]]],"width",Regular.easeOut,0,100,0.5,true); mc["j" + mc.dic[e.target]]++; }; mc["tm" + mc.i].addEventListener(TimerEvent.TIMER, mc.timerHandler1,false,0,false); } // mc.cnt = 0; // mc.tm = new Timer(200,4); // mc.timerHandler0 = function(e:TimerEvent):void { mc["tm" + mc.cnt].start(); mc.cnt++; }; // mc.tm.addEventListener(TimerEvent.TIMER, mc.timerHandler0,false,0,true); // mc.tm.start(); // this.addChild(mc); } //---↑マスク用MCの作成(ほぼマクロ)↑--- //カウント用変数 var cnt:int = 0; //「pic0」を最高の深度に移動 this.setChildIndex(pic0,this.numChildren-1); //関数nextPicの定義 function nextPic(e:TimerEvent):void { this["pic" + cnt].mask = null; if (mc != null) { this.removeChild(mc); mc = null; } cnt = (cnt>=5) ? 0 : cnt+1; //マスクを作成 makeMask(); //次の「pic○」を最高の深度に移動 this.setChildIndex(this["pic" + cnt],this.numChildren-1); //次の「pic○」にマスクを適用 this["pic" + cnt].mask = mc; } //10秒間隔で実行するTimerインスタンスを作成 var tm:Timer = new Timer(10000,0); //関数nextPicを指定ミリ秒間隔で実行 tm.addEventListener(TimerEvent.TIMER,nextPic ,false,0,false); //タイマースタート tm.start(); //=========================================== 繰り返しますが 上のスクリプトをどうのこうの考えるより マスクにするムービークリップをチャッチャと手作業で作ってしまった方が早いですよ。 どうのこうのと細かいこと考えていても発想が乏しくなるだけです(＝デメリットの方が多い)。 手作業だと形もパターンも色々自由に無数に簡単にできるはずです。 そのムービークリップを使い回したりすれば良いだけです。 作ったムービークリップをリンケージでクラス化して var mask_mc:クラス名 = new クラス名(); addChild(mask_mc); みたいにして呼び出しても良いわけですし。 そんなことせずに 普通に写真のマスクレイヤーに配置しても良いです。 　
所詮 Flash は， ユーザーの視覚上のインターフェイスに過ぎないわけですから その他一切合切の本体プログラムシステムは別に作成するわけですよね。 (Flash だけではカード云々の前に履歴を保存することすら無理ですからね。) ですから まず Flash は その本体プログラムシステム内にSWFを埋め込み表示させる必要があります。 (土台が変わるだけで，IEの中のHTMLの中にSWFを表示させるのと同じ事，ExcelのシートにSWFを埋め込むのと同じ事。) それで， そのプログラムシステムとSWFとを通信させるわけですが 貼り付けるものがHTML(ブラウザ)ではないので，いわゆる JavaScript は使えません。 ですから FScommand 辺りでデータをやりとりするのが， 直接的＆無難ということになります。 (システムでテキストファイルを生成してそのテキストファイルをLoadVarsでロードする方法も無きにしもあらずですが遠回り。) 結局 その本体プログラムシステムは何で作るかを決めないと検索のしようもありませんね。 「その言語＋FSCommand」辺りで検索するとヒントになるページが出てくるのではないでしょうか。 「C#の中にFlashを埋め込む」 http://memo.sappari.org/flash-in-csharp 「Macromedia Flash and VB:A Potent Combination の日本語訳」 http://www.himco.jp/articles/pdf/FLASHandVB.swf
まずコレを理解しないと↓。 /*トゥイーンをさせる関数*/ function tw(_x1:Number,_x2:Number,_x3:Number,_mc1:MovieClip,_mc2:MovieClip,_mc3:MovieClip):Void{} ↑ココで「tw」という関数を定義しているのです。 それで この関数「tw」を実行させるときの引数が６つあって 第一引数から順に _x1(座標数値)，_x2(座標数値)，_x3(座標数値)，_mc1(MovieClip)，_mc2(MovieClip)，_mc3(MovieClip) となっているわけです。 ActionScript 2.0 設定の新規ドキュメントでも作成し フレーム1 に次のようなスクリプトを書いて(コピペして)， 「制御」→「ムービープレビュー」してみてください。 //----------------------------------------------------- //関数 jikken を定義（引数 a(数値)，b(MovieClip)） function jikken(a:Number, b:MovieClip):Void { trace("aを出力→"+a); trace("bを出力→"+b); } //関数 jikken を実行（引数 数値，MovieClip） jikken(5, this); //----------------------------------------------------- わかりますでしょうか？ //関数 jikken を実行 jikken(5, this); これで関数 jikken が実行されるわけですが そのときに第１引数に 5 という数値と，第２引数に this というムービークリップ(MovieClip)を渡しているわけです。 この場合の this は _root と同じ意味になります。 _root もムービークリップの一種です。 その第１引数である 5 と，第２引数 this を， 関数 jikken が 変数 a と b として受け取って 関数 jikken の中でそれら変数 a(値は5) と b(値はthis) が使われて何某かの動作をするわけです。 上のように 一度，function jikken… を定義しておけば， その関数の一部に違う値を入れながら使い回しができるわけです。 　　↓ ↓ ↓ //----------------------------------------------------- //関数 jikken を定義（引数 a(数値)，b(MovieClip)） function jikken(a:Number, b:MovieClip):Void { trace("aを出力→"+a); trace("bを出力→"+b); } //関数 jikken を実行（引数 数値，MovieClip） jikken(5, this); trace("------------------"); //関数 jikken を実行（引数 数値，MovieClip） jikken(10, this._parent); trace("------------------"); //関数 jikken を実行（引数 数値，MovieClip） jikken(20, _root); //----------------------------------------------------- ですから ご質問で書かれていらっしゃるスクリプトですが↓ /*トゥイーンをさせる関数*/ function tw(_x1:Number, _x2:Number, _x3:Number, _x4:Number, _x5:Number, mc1:MovieClip, _mc2:MovieClip, _mc3:MovieClip, _mc4:MovieClip, _mc5:MovieClip):Void { この部分を，このようにする(＝引数を１０個にする)のでしたら これを実行させる時にも同じ数の引数が必要になるということになりますよね？ しかがって コレ↓ではダメでしょう？ // パネル01 //～略～ tw(0,400,40,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); まず数が合ってません。 また たとえば 関数「tw」の_x4:Number に入るべき値が panel01_mc になっているのもダメです。 例えば次のようにしなければなりません。 tw(0,260,280,300,320,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); 0,260,280,300,320 のような具体的数値は作る物によるのでどういう数値にすべきかは知りません。 元のサイトと近いようなもの(同じサイズのもの)を作るのでしたら 次のような感じの数値になると思います。 /*パネルごとの動作*/ // パネル01 panel01_mc.onRollOver = Delegate.create(this, function ():Void { tw(0,260,280,300,320,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); }); // パネル02 panel02_mc.onRollOver = Delegate.create(this, function ():Void { tw(0,10,280,300,320,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); }); // パネル03 panel03_mc.onRollOver = Delegate.create(this, function ():Void { tw(0,10,30,300,320,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); }); // パネル04 panel04_mc.onRollOver = Delegate.create(this, function ():Void { tw(0,10,30,50,320,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); }); // パネル05 panel05_mc.onRollOver = Delegate.create(this, function ():Void { tw(0,10,30,50,70,panel01_mc,panel02_mc,panel03_mc,panel04_mc,panel05_mc); });
外部JPEGのファイルパスがズレたからでしょう。 loadMovie() にしても LoadVars.load() にしても MovieClipLoader.loadClip() にしても はたまた getURL() にしても， これらで指示する外部ファイルや外部ページのパスは すべて「 HTML から見たパス」になります。 HTML というのは SWFを張り付けている HTML のことです。 ・そうなる理由 loadMovie() ～ getURL() などは 「ブラウザに対するリクエスト」なんです。 ブラウザはどこにいるのか(何を表示しているのか)と言えば HTMLの場所にいます(HTMLを表示しています)。 loadMovie() ～ getURL() などは「ブラウザに対するリクエスト」なので ブラウザの居場所(ブラウザが表示しているもの)からのパスになるのです。 ですから その参考にされたページの fileName = ["a", "b", "c", "d", "e"]; のような部分を HTMLから見たパスに変更しなければなりません。 【例】 　任意のフォルダ 　　├○○.html (○○.swf を貼り付けている) 　　└files(フォルダ) 　　　　├○○.swf 　　　　├a.jpg 　　　　├b.jpg 　　　　├c.jpg 　　　　├d.jpg 　　　　└e.jpg 　　↓この場合↓ fileName = ["files/a", "files/b", "files/c", "files/d", "files/e"]; なお HTML が複数あってそれぞれからのパスが変わる場合は ファイルパスを 絶対パス に変える必要がある場合もあります(ローカルでの検証がしにくくなります)。
> Flash→php→Flashという流れで値を > 表示させる方法はわかるのですが、 意味がわかりません。 どう考えてもそれの方が難しいでしょう？ Flash→php→Flash だと， 「送信する手段」も「受信する手段」も両方とも用意しなければならないのですよ？ Flash→php だけだと Flashで用意するのは「送信する手段」 だけで良いじゃないですか。 > (getURLでphpファイルを表示) その延長だと 例えば(あくまでも一例として)， getURL でURLクエリを付けて PHP を表示させれば良いじゃないですか。 簡単でしょう？ Google を PHP に見立てますか？ Google検索「Flash」↓ http://www.google.co.jp/search?&ie=UTF-8&q=Flash 例えば上のように Google に &ie=UTF-8&q=Flash というクエリを引っ付けてアクセスすると Flash と表示された検索窓と検索結果が表示されると思います。 つまり Flash でするなら getURL(http://www.google.co.jp/search?&ie=UTF-8&q=Flash); をすれば良いというだけのことです。 値をGETで渡すのと同じです。 何が難しいのかがわかりません。 もっとも getURL は MovieClip クラスのメソッドで， MovieClip 内に変数を仕込んでおいて MovieClip.getURL("○○.php" , "_self", 'POST'); などとすると，POSTでも送信可能です。 「FlashのAS2のgetURLで別サイトを開いてPOST送信する方法｜本を買わずに解決するWeb制作の小技」 http://ameblo.jp/linking/entry-10278331607.html また MovieClip クラスのメソッドを使うのは変だと思えば LoadVars.send() を使っても良いですし。 「loadVars.send()メソッドを使用して変数を受信」 http://1art.jp/flash/le/lesson46/lesson46.htm 何にしろ， Flash→php だけだと Flashで用意するのは「送信する手段」 だけで良いのでかなり簡単なはずです。
4:3なら640x480だよ。
参考URLの一番下にあるサンプルで動作を確認してください。 stage.focus で、フォーカスの移動は可能ですが、「swfが読込まれたとき」を判定するイベントが必要です。 サンプルではkeyCodeを取得するイベントリスナーがstageではなくSpriteに設定されています。 SpriteをクリックされるとフォーカスがSpriteに指定され、keyCodeを取得できる流れだと思います。 >stageよりもムービークリップを先にクリックされた場合、stageをクリックしていないのでキーボードを押しても無反応ですよね？ そのMovieClipにイベントリスナーを持たせるか、MovieClipをクリックされた時にkeyCodeを取得するイベントリスナーを設定した対象へ[stage.focus]を設定すれば、イベントの取得が可能ではないでしょうか？ 細かいファイルの状況等は分かりませんので、おおまかにイメージだけ。
Papervision3D 参考URL[注）PDF]によると ・商用・非商用ともに無償利用が可能 だそうです。
クリックする度にフラグとなる変数の値を入れ替えて そのフラグの値によってTweenを変えれば良いと思います。 //------------------------------------------- //クラスのインポート import mx.transitions.Tween; import mx.transitions.easing.*; //「grobal_btn」の初期の大きさと座標を変数に保存 var g_btn_xs:Number = grobal_btn._xscale; var g_btn_x:Number = grobal_btn._x; var g_btn_ys:Number = grobal_btn._yscale; var g_btn_y:Number = grobal_btn._y; //フラグとなる変数を用意 var g_flg:Boolean = false; grobal_btn.onRelease = function() { //フラグがfalseであれば if (!g_flg) { mc_tween = new Tween(grobal_btn, "_xscale", Elastic.easeOut, grobal_btn._xscale, 150, 1, true); mc_tween = new Tween(grobal_btn, "_x", Elastic.easeOut, grobal_btn._x, 300, 4, true);//スタートx座標、移動した後の座標 mc_tween = new Tween(grobal_btn, "_yscale", Elastic.easeOut, grobal_btn._yscale, 150, 1, true); mc_tween = new Tween(grobal_btn, "_y", Elastic.easeOut, grobal_btn._y, 100, 4, true);//スタートy座標、移動した後の座標 //フラグをtrueにする g_flg = true; } else { mc_tween = new Tween(grobal_btn, "_xscale", Elastic.easeOut, grobal_btn._xscale, g_btn_xs, 1, true); mc_tween = new Tween(grobal_btn, "_x", Elastic.easeOut, grobal_btn._x, g_btn_x, 4, true);//スタートx座標、移動した後の座標 mc_tween = new Tween(grobal_btn, "_yscale", Elastic.easeOut, grobal_btn._yscale, g_btn_ys, 1, true); mc_tween = new Tween(grobal_btn, "_y", Elastic.easeOut, grobal_btn._y, g_btn_y, 4, true);//スタートy座標、移動した後の座標 //フラグをfalseに戻す g_flg = false; } }; //------------------------------------------- 　
フレーム1 に count を 1 にする条件を付ける必要があります。 もし count に int(整数値) という型指定を入れる場合は次のようになります。 -------------------------------- var count:int; if (count==0) { count=1; } -------------------------------- 型指定など入れない場合は次のようになります。 -------------------------------- if (count==undefined) { var count=1; } --------------------------------
「一番深度が深い」というのは 「一番下の」とか「Z軸方向で一番向こう側の」という意味ですよね？ インスタンスの一プロパティに過ぎないインスタンス名など知って何になるのか知りませんが 例えば， スクリプトを記述するタイムライン階層で一番深度が深い(下の)インスタンスのインスタンス名であれば， this.getChildAt(0).name で取得できます。 「制御」→「ムービープレビュー」で確認するのであれば trace(this.getChildAt(0).name); で確認できます。 もし全部のインスタンス名を確認したいのでしたら，次のようにすれば良いでしょう。 //この階層の子の個数分ループ for (var i:int =0; i< this.numChildren; i++) { //下のインスタンスのインスタンス名から順に出力 trace(this.getChildAt(i).name); } 特に難しいこともありません。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝ しかし， 最初に少し書きましたが，インスタンス名など知っても普通はあまり得しませんよ。 (私は知るメリットが思い浮かばない。) なぜ得しないかというと， 例えば一番深度が深い(下の)インスタンスを右に100px移動させたいとすると そのときは次のようにすれば良いだけです。 //この階層の一番下のインスタンスを100px右に移動 this.getChildAt(0).x += 100; ↑インスタンス名など登場しません。 あえてインスタンス名を登場させようとするとすごく大変(遠回り)になります。 //この階層の一番下のインスタンスのインスタンス名を取得 var name_str:String = this.getChildAt(0).name; //その名前のインスタンスを取得して //そのインスタンスを100px右に移動 this.getChildByName(name_str).x += 100; ActionScript 3.0 では インスタンス名自体の出番はほとんどなくなりました。 （インスタンス個体を一意に定める必要があるときなど，かなり特殊な場合に限って使うこともありますが。） 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html 　
当方の環境がFlashCS5なので、あくまで推測ですが。 お使いのスタンドアロンのFlash Playerがデバッグ版でない ということはないでしょうか？ 参照URLからFlash Playerがデバッグ版の入手が可能です。 ご参考まで。
「URLLoaderをメソッドの中に入れる入れない」は根本的に関係がありませんよ。 関係あるのはそこではなく 『「ロードしなさい！」＝「ロードしたよ～♪」 ではない。』 ということです。 > txtloader02.load(urlReq02); ↑これは 「ロードしなさい！」 です。 「ロードしなさい！」 と言っただけでまだ目的のデータをSWF上にロードしていません。 それどころか 目的のファイルを開いてもいません。 またそれどころか ロードの開始さえもされていません。 「ロードしなさい！」 の後に 「ロード開始!!」 となって その信号がローカルやサーバに伝わり ローカルやサーバのHDDに記録されているデータをヘッダが読んだり そのデータが光ケーブルやローカルの電線を伝わってくるなどして ブラウザ や Flash Player 経由でSWF上にたどりついてから 「ロードしたよ～♪」 になるのです。 この 「ロードしたよ～♪」 状態になってはじめて， ロードしたデータがSWF上で処理できるのです。 当たり前ですがデータの到着前にデータの処理などできません。 ｈttp:// と C:/ とでは 「ロードをしなさい！」 →「ロードしたよ～♪」間の所要時間は変わりますが 時間がかかるということ自体は変わりありません。 ですからまず 「ロードしたよ～♪」を検知する必要があって その「ロードしたよ～♪」検知の後にロードしたデータを処理する必要があります。 したがって 例えば次のような感じにスクリプトを変更する必要があります。 (mc_1 など第三者が見てわけがわからないものはカット。) //----------------------------------- //URLRequestとURLLoaderインスタンスを作成 var urlReq02:URLRequest = new URLRequest("C:/swf_xsplit/twitter.txt"); var txtloader02:URLLoader = new URLLoader(); //ロードが完了したとき関数onLoadCompを実行する設定 txtloader02.addEventListener(Event.COMPLETE, onLoadComp); //関数onLoadCompの定義(★「ロードしたよ～♪」部分) function onLoadComp(e:Event):void { if (e.target.data != null) { var twitterStr02:String = e.target.data; var lines:String = twitterStr02; lines = lines.replace("\r\n"," ").replace("\n"," ").replace("\r"," ").replace("<br>"," ").replace("< /br>"," "); trace("timer = " + lines); trace("その他色々な動作 をする"); } } //関数init02の定義(★「ロードしなさい！」部分) function init02(event:Event):void { txtloader02.load(urlReq02); } //２秒間隔で関数init02を実行 var my_timer:Timer = new Timer(2000,0); my_timer.addEventListener(TimerEvent.TIMER, init02); my_timer.start(); //----------------------------------- 最初にも書きましたが 「URLLoaderをメソッドの中に入れる入れない」は関係ありません。 最初のこの３行↓ ------------------ //URLRequestとURLLoaderインスタンスを作成 var urlReq02:URLRequest = new URLRequest("C:/swf_xsplit/twitter.txt"); var txtloader02:URLLoader = new URLLoader(); //URLLoaderのロードが完了したとき関数onLoadCompを実行 txtloader02.addEventListener(Event.COMPLETE, onLoadComp); ------------------- これを 関数init02 の中に入れても無事に動作します。 動作しますが， ２秒間隔で何度も同じものを作り続けるのはおかしいので外に書いています。 ～～～プログラム動作の時間的流れ～～～ ・「２秒経ったよ！」イベントをTimerが受けとり .　そのリスナー関数init02が実行される。 .　　↓ ・関数init02内で「ロードしなさい！」命令が発生する。 .　　↓ ～データ情報の読み取りや伝達動作が行われ～ ～やがてデータがSWF内に届く(ロードされる)～ .　　↓ ・「ロードしたよ～♪」イベントをURLLoaderが受けとり .　そのリスナー関数onLoadCompが実行される。 .　　↓ ・関数onLoadComp内でロードしたデータの処理が行われる。 Flash は 「ロードは待ちたいヤツだけが待てば良い」 という仕様なのでわざわざ「待ちたいヤツを待たせる処理」が必要になります。 ロードでアニメーションなどの動作や他の処理を犠牲にしないためです。 例えば VBAなどはこのようなロードを待たせる処理を用意する必要はありません。 しかしその代わり「ロードは勝手に全体が待つ」という仕様になっています。 仮に Flash が VBA のような仕様ではギクシャクしてとても見れたものではなくなるでしょう。
こんな感じでできると思います。 for(var i:int = 0; i <= 9; i++){ this["mc" + i].gotoAndPlay("main"); } Google検索「配列アクセス演算子」 http://www.google.co.jp/search?sourceid=navclient&hl=ja&q=%e9%85%8d%e5%88%97%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e6%bc%94%e7%ae%97%e5%ad%90
Flash とか，作成時点での問題ではありません。 ファイルが壊れています。 test.html test.swf test.flv ArcticOverAll.swf これらは全て書かれていらっしゃる場所にあります。 個別にDLしてもさっぱり再生できません。 すでにファイルは壊れています。 壊れていないのは 「test.html」 だけです。 FTPソフトの設定(バイナリデータをテキストとして送ってしまっているなど)か， またはサーバがファイルを壊したかです。 どちらともあり得ますが 確率的にはFTPソフトの仕様が悪いか設定が悪いかだと思います。 何にしても Flash とは無関係のようです。
そのサイトの作品内容の説明にも書いているじゃないですか。 > 本ソフトはAdobe AIRがインストールされている環境であれば > OSの種類に関係無く遊ぶことができます。 Flash(など) で AIR を作成すれば良いんです。 「Flash制作のAIRアプリの背景透明化とドラッグ移動｜iPhone-AndroidアプリをFlashで作る！」 http://ameblo.jp/makotok1/entry-10389931862.html 背景透過などの前に Flash CS3 以上をお持ちかどうかということが問題で その他，まずはこの辺のこと↓から理解する必要があると思います。 「Adobe AIR プログラミング講座【Flashを使ってAdobe AIRを作成する】」 http://hakuhin.jp/air/air.html
クロスドメインのセキュリティがはたらいて 外部テキストファイルがロードできないため 表示がおかしくなるのだと思います。 絶対パスで data="http://scrapbits.jp/topmenu4.swf" や value="http://scrapbits.jp/topmenu4.swf" と貼り付けている部分を 普通のサイトで一般的にするように data="topmenu4.swf" や value="topmenu4.swf" と相対パスに変えて貼り付ければ おそらくクロスドメインの問題は解決するのではないかと思われますが 何か普通のサイトで一般的にするようなパスの書き方ができない理由でもあるのでしょうか？
えらく長いスクリプトを書かれていらっしゃいますし 動作検証などはしてみていませんが 結局のところ 「最初の配列「photoArr」の 要素[0]～[6] に 用意した 20枚 の画像のうちの 7枚 をランダムに入れれば良い。」 というだけのことでしょう？ そうでしたら 最初の部分を次のようにすれば良いと思います。 //=========================================== // 元の全画像URLを保存する配列 var sourceArr:Array; // 表示する写真のURLを保存する配列 var photoArr:Array; //～数行略～ //-------------------------------- // 初期化の処理 //-------------------------------- // 元の全画像URLの配列を設定する sourceArr = new Array(); sourceArr[0]="b00.jpg"; sourceArr[1]="b01.jpg"; sourceArr[2]="b02.jpg"; sourceArr[3]="b03.jpg"; sourceArr[4]="b04.jpg"; sourceArr[5]="b05.jpg"; sourceArr[6]="b06.jpg"; sourceArr[7]="b07.jpg"; sourceArr[8]="b08.jpg"; sourceArr[9]="b09.jpg"; sourceArr[10]="b10.jpg"; sourceArr[11]="b11.jpg"; sourceArr[12]="b12.jpg"; sourceArr[13]="b13.jpg"; sourceArr[14]="b14.jpg"; sourceArr[15]="b15.jpg"; sourceArr[16]="b16.jpg"; sourceArr[17]="b17.jpg"; sourceArr[18]="b18.jpg"; sourceArr[19]="b19.jpg"; // 表示する7枚の画像URLの配列を作成する photoArr = new Array(); for (var i:int=0; i<7; i++) { //配列 sourceArr からランダムな要素を１つ抜き取って //配列 photoArr の 要素[i] に代入 photoArr[i]=sourceArr.splice(Math.floor(Math.random()*sourceArr.length),1); } //「ムービープレビュー」時検証用(本来は不要) trace(photoArr); //～以下略～ //=========================================== 現在作成されているものは一時置いておいて， 新規ドキュメントを作成して 上のスクリプトをフレーム1に書き(コピペし)， 「制御」→「ムービープレビュー」すると，即動作確認できると思います。
if(myLSO.data.p01a != null) のようにして null で値の有無を判定していることもでもありますし 個別の値を削除する場合は普通に null を代入すれば良いだけなのではないでしょうか？ また ボタン「A」による一斉削除に関しては myLSO.clear (); でできますよ。 実際に作ってみましたがそれで別に不具合は起きませんでした。 (フレーム4 の myLSO.data.p04a～myLSO.data.p04c の３つはどうしているのかは知りませんけど。) ＝＝＝例＝＝＝＝＝＝＝＝＝＝＝＝ ---フレーム1------------- stop (); // myLSO = SharedObject.getLocal ("Flashcookie", "/"); // if (myLSO.data.p01a != null) { p01a.text = myLSO.data.p01a; } p01a.onChanged = function () { myLSO.data.p01a = p01a.text; }; // if (myLSO.data.p01b != null) { p01b.text = myLSO.data.p01b; } p01b.onChanged = function () { myLSO.data.p01b = p01b.text; }; // if (myLSO.data.p01c != null) { p01c.text = myLSO.data.p01c; } p01c.onChanged = function () { myLSO.data.p01c = p01c.text; }; //--- A.onRelease = function () { myLSO.clear (); }; // B.onRelease = function () { myLSO.data.p01a = null; myLSO.data.p01b = null; myLSO.data.p01c = null; }; //--- next_btn.onRelease = function () { nextFrame (); }; back_btn.onRelease = function () { prevFrame (); }; ----------------------- ---フレーム2------------- if (myLSO.data.p02a != null) { p02a.text = myLSO.data.p02a; } p02a.onChanged = function () { myLSO.data.p02a = p02a.text; }; // if (myLSO.data.p02b != null) { p02b.text = myLSO.data.p02b; } p02b.onChanged = function () { myLSO.data.p02b = p02b.text; }; // if (myLSO.data.p02c != null) { p02c.text = myLSO.data.p02c; } p02c.onChanged = function () { myLSO.data.p02c = p02c.text; }; //--- B.onRelease = function () { myLSO.data.p02a = null; myLSO.data.p02b = null; myLSO.data.p02c = null; }; ----------------------- ---フレーム3------------- if (myLSO.data.p03a != null) { p03a.text = myLSO.data.p03a; } p03a.onChanged = function () { myLSO.data.p03a = p03a.text; }; // if (myLSO.data.p03b != null) { p03b.text = myLSO.data.p03b; } p03b.onChanged = function () { myLSO.data.p03b = p03b.text; }; // if (myLSO.data.p03c != null) { p03c.text = myLSO.data.p03c; } p03c.onChanged = function () { myLSO.data.p03c = p03c.text; }; //--- B.onRelease = function () { myLSO.data.p03a = null; myLSO.data.p03b = null; myLSO.data.p03c = null; }; ----------------------- ---フレーム4------------- myLSO.data.p04a = 0; myLSO.data.p04b = 0; myLSO.data.p04c = 0; // for (i = 1; i <= 3; i++) { if (myLSO.data["p0" + i + "a"] != null) { myLSO.data.p04a += Number (myLSO.data["p0" + i + "a"]); } if (myLSO.data["p0" + i + "b"] != null) { myLSO.data.p04b += Number (myLSO.data["p0" + i + "b"]); } if (myLSO.data["p0" + i + "c"] != null) { myLSO.data.p04c += Number (myLSO.data["p0" + i + "c"]); } } // p04a.text = myLSO.data.p04a; p04b.text = myLSO.data.p04b; p04c.text = myLSO.data.p04c; //--- B.onRelease = function () { myLSO.data.p04a = null; myLSO.data.p04b = null; myLSO.data.p04c = null; }; ----------------------- ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ※注意 話がややこしくならないように， ボタン「A」 や ボタン「B」 のクリック時には SharedObjectに保存されるデータしか null にしていません。 したがって， それらボタンをクリックした瞬間には， テキストフィールド内の文字まで一緒に "" にはなりません。 もしそこまでするのでしたら，それは別に p01a.text = ""; p01b.text = ""; p01c.text = ""; のように指示する必要があります。 それとちなみに， delete ステートメントは 指定したオブジェクトへの参照(関連付け)を破棄する(切る)スクリプトです。 delete で参照を破棄するするのではなくて， データ自体を "" や null のように操作する必要があると思います。 //---delete検証例------------ //オブジェクト「obj」を作成 var obj:Object = new Object(); obj.data = "あいう"; // //変数「A」と「B」にそれぞれ「obj」への参照を代入 var A:Object = obj; var B:Object = obj; // trace(obj.data); //→出力：あいう trace(A.data); //→出力：あいう trace(B.data); //→出力：あいう trace("------"); // delete A; trace(obj.data); //→出力：あいう trace(A.data); //→出力：undefined trace(B.data); //→出力：あいう trace("------"); /* 　↑delete A では 　変数「A」の参照が破棄されるだけで 　「obj」自体やその中のデータが削除されるわけではない。 */ // B.data = null; trace(obj.data); //→出力：null trace(A.data); //→出力：undefined trace(B.data); //→出力：null /* 　↑B.data = null で 　変数「B」の参照オブジェクトの data も null になる。 　つまり，本家本元の「obj」内の data も null になる。 */ //------------------------- 作ってみたもののスクリーンショット↓
＃１です。 一部訂正します。 > その組み合わせでは共同開発は不可能です。 と書きましたが， データ(FLAファイル)を CS3→CS5 の一方向に流すようにすれば共同開発できますね。 CS3の人がまず骨組みになるFLAや素材部品になるFLAを作って CS5の人がその骨組みに肉付けをしたり素材部品を組み立てたりする流れ限定にすればできます。 CS5で手を加えたFLAはCSで開くことはできないので 最終的にどのようなFLAファイルができたのかをCS3の人が確認することはできません。 それと > CS5 の iPone 系は，… 　　↓訂正↓ CS5 の iPhone 系は，… です。 失礼しました。
こんなところでいかがでしょうか。 onClipEvent (enterFrame) { n_date = new Date(); now_time = ""; str = "0"+n_date.getHours(); now_time += str.substr(-2, 2)+" "; str = "0"+n_date.getMinutes(); now_time += str.substr(-2, 2); }
大前提の前置きですが ActionScript 2.0 と 3.0 は別物で基本的に互換性などがないのです。 しかしですね， ActionScript 2.0 は ActionScript 1.0 の拡張であって完全に互換性があるのです。 つまり ActionScript 1.0 はそのままで ActionScript 2.0 とも言えるのです。 (ActionScript 1.0 で書いても パブリッシュ設定は 2.0 で何の問題もないはずです。) ですから 書かれていらっしゃるスクリプトも ActionScript 1.0 の範囲内 ですから，すなわち ActionScript 2.0 の範囲内なんです。 (「15歳は 18歳未満でもあり，20歳未満でもある。」これと同じです。) したがって 書かれていらっしゃるスクリプトを ActionScript 2.0 範囲内で書き直しても 全く同じということになります。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ただですね， 書かれていらっしゃるスクリプトは Flash 5 時代のスクリプトです。 そこにはほとんどメリットがありません。 Flash 5 流では自由度が少なかったり， 携帯(Flash Lite 1.x)では Flash 4 以下のものしか動かなかったりで Flash 5 形式で止まっていることが一番意味がないです。 具体的には onClipEvent (load) { mode = true; } ↑この onClipEvent ハンドラが Flash 5 特有の書き方です。 どうしましょうか？ 上で書きましたが，別にこれはこれで ActionScript 2.0 範囲内なんですよ。 ですから変えるにしても 変え方は作者の意志によって全く変わるわけです。 (「『15歳を大人っぽく』と言っても，『少女時代』風にすることもあれば，『松任谷由実』風にするのもアリなわけで...。」これと同じです。) そうですね。。。 onClipEvent (load) { mode = true; } などを削除して これを書いた "ムービークリップ内" の "フレーム1" に 同じ内容の ActionScript 2.0 コードを書くことにしますか↓。 //--------------------------------------- //もし mode が未定義であれば if (mode == undefined) { //変数 mode：ブール値 を true にする var mode:Boolean = true; } //このムービークリップをクリックしたときの //イベントハンドラメソッドを定義：戻り値なし this.onRelease = function():Void { //変数modeのtrueとfalseを入れ替える mode = !mode; //もし変数modeの値がtrueであれば if (mode) { //このムービークリップの再生を開始 this.play(); //もし変数modeの値がfalseであれば } else { //このムービークリップの再生を停止 this.stop(); } }; //--------------------------------------- 本格的 ActionScript 2.0 という感じではないですが 少なくとも ActionScript 1.0 の範囲内ではありません。 (パブリッシュ設定を ActionScript 1.0 にするとエラーが出るはずです。) (完全な20歳とは言い切れないとしても少なくとも18歳以上です。)
とりあえずすることは 「すでに作成済みの時計のことは忘れること」でしょうね。 作成済みの時計のことは忘れて 「5枚の画像を1分ごとにループさせる」のみを単独で考えるべきです。 (もし余裕があって，作成済みの時計のエンジンとどうしても結合したいという気になれば，そのときに結合すれば良いと思います。) (「二兎を追う者は一兎を得ず」 です。) というわけで 以下，時計は忘却！ ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ５枚の画像は背景なのですから ステージ直下の一番下の方のレイヤーにムービークリップを作成して そのムービークリップ内の フレーム1～5 にそれぞれ１枚ずつ５枚の画像を配置しているわけですよね？ そして，例えば携帯を開いたときは →ムービークリップ内の フレーム1 を表示 その次の分→ムービークリップ内 フレーム2 を表示 その次の分→ムービークリップ内 フレーム3 を表示 その次の分→ムービークリップ内 フレーム4 を表示 その次の分→ムービークリップ内 フレーム5 を表示 その次の分→ムービークリップ内 フレーム1 を表示 その次の分→ムービークリップ内 フレーム2 を表示 　～続く～ というような感じにするわけですよね？ その場合 その背景の「５枚の画像入りムービークリップ」に 例えば「bg_mc」というインスタンス名を付けます。 それとは別に， ステージ直下に空のムービークリップを作成します。 その空のムービークリップ内を３フレームにして 各フレームを空白キーフレームに変換します。 そして その空のムービークリップ内のフレーム1には次のように書きます。 //---------------------------- //親階層の「bg_mc」に命令 tellTarget("../bg_mc"){ //再生停止 stop(); } //変数minに分を保存 min = fscommand2("GetTimeMinutes"); //---------------------------- さらに その空のムービークリップ内のフレーム2には次のように書きます。 //---------------------------- //もし今の分と過去に保存したminの値が違えば if (min<>fscommand2("GetTimeMinutes")) { // //親階層の「bg_mc」の再生フレームが最終フレーム未満であれば if (../bg_mc:_currentframe<../bg_mc:_totalframes) { //親階層の「bg_mc」に命令 tellTarget ("../bg_mc") { //次のフレームで停止 nextFrame(); } // //親階層の「bg_mc」の再生フレームが最終フレームに達していれば } else { //親階層の「bg_mc」に命令 tellTarget ("../bg_mc") { //フレーム1に戻って停止 gotoAndStop(1); } } } //変数minに分を保存 min = fscommand2("GetTimeMinutes"); //---------------------------- さらに その空のムービークリップ内のフレーム3には次のように書きます。 //---------------------------- //このムービークリップ内をフレーム2に戻して再生 gotoAndPlay(2); //---------------------------- 以上のような感じでできると思います。 なお フレーム1 の最初ですが， //親階層の「bg_mc」に命令 tellTarget("../bg_mc"){ //再生停止 stop(); } こう↑ではなくて こんな感じ↓にしても良いと思います。 //親階層の「bg_mc」に命令 tellTarget("../bg_mc"){ //ランダムなフレームで再生停止 gotoAndStop(random(_totalframes)+1); } 全般的には スラッシュシンタックスによる特殊なターゲットパスの表記のしかたと くせのある tellTarget() 関数で他ムービークリップに命令することに慣れるのがポイントですかね。 それらに慣れれば 階層などムービーの構造も変更可能になりますから 色々自由にできるようになると思います。
> フレームに配置したインスタンスを配列に格納する方法 フレームに配置とは 作成したムービークリップを ８個 手動でステージ上に配置して 「r_machi01_1」～「r_machi01_8」というインスタンス名を付けた。 ということでしょうか？ その状態で その８個が存在するタイムラインのフレームに スクリプトを書く場合でしたら var mapBtStr:String = "r_machi01_"+ i; var mapBt:MovieClip = mapBtStr; mapBtMcArr.push(mapBt); 　　↓３行を１行に変更↓ mapBtMcArr.push(this["r_machi01_"+ i]); と変更すれば良いのではないでしょうか。 Google検索「配列アクセス演算子」 http://www.google.co.jp/search?hl=ja&ie=UTF-8&q=%e9%85%8d%e5%88%97%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e6%bc%94%e7%ae%97%e5%ad%90
書かれていらっしゃることが確認できません。 状況をもっとシンプルにして原因を追及すべきではないでしょうか。 ActionScript 3.0 の「新規ドキュメント」を作成し フレーム1 にコピペして，即， 「制御」→「ムービープレビュー」で確認するスクリプト例↓。 //---------------------------------- //適当に矩形のスプライトを用意 var sp:Sprite = new Sprite(); sp.graphics.beginFill(0xFFCC00); sp.graphics.drawRect(10, 10, 100, 50); addChild(sp); //書かれていらっしゃるまったくそのままのスクリプト addEventListener(MouseEvent.MOUSE_DOWN, mDown, false, 0, true); addEventListener(MouseEvent.MOUSE_UP, mUP, false, 0, true); addEventListener(MouseEvent.CLICK, mClick, false, 0, true); //各リスナー関数の定義 function mDown(e:MouseEvent):void{ trace("mDown実行"); } function mUP(e:MouseEvent):void{ trace("mUP実行"); } function mClick(e:MouseEvent):void{ trace("mClick実行"); } //---------------------------------- 矩形をクリック時の出力結果↓ ----------------------- mDown実行 mUP実行 mClick実行 ----------------------- 全て実行されます。 =============== 今回の内容とはおそらく別件ですが なぜ addEventListener の引数をそんなに多く設定されていらっしゃるのか，その意図もわかりません。 何か意味があるのでしたら良いとは思いますが 動かない原因がどこにあるのかわからないのですから その辺もシンプルにデフォルトすべきだと思います。 (第５引数を true にすると ガベージコレクション の対象(動かない原因)になってしまいますよ。)
リスナー関数の引数はイベントで そのイベントのターゲット(カレントターゲット)が そのイベントを受けたものですよ。 testFunc を次のように変更すれば 何か見えてくるものがあるのではないでしょうか？ function testFunc(evt:MouseEvent):void { trace(evt.currentTarget.name); evt.currentTarget.text = "私，クリックされました！"; }
そんな難しくないんですが、初心者ではけっこうハードル高いです。やめたほうがいいでしょう。 でもチャレンジは大切なので、以下にヒントをあげてみました。 非常に簡素に書いてくれているところはこんなところでしょうか。 http://flashrave.org/as/fullsize/ 「全画面表示　flash」で検索すればある程度は見つかると思います。 検索する力も就職活動には必要です。
FireFoxのアドオンDownloadHelperであっさりと抜けましたよ 当該ページのSONGの所のPLAYからとんだ歌詞付きの再生ページから抜きました ファイルの情報 [kanjukuoh.mp3] MPEG1-LayerIII 44.10kHz 128.00kb/s CBR JointStereo/MS 6614f 00:02:52.382 (172.382sec) / 2,758,112Bytes 真空波動研SuperLite 100805 / DLL 100805 Unicode
既存ソースに機能追加をされるという事で、多少なりともAction Scriptを理解されていることを前提に回答します。 作業としては (1) ボタンインスタンスを作成、配置する (2) 拡大表示されている画像Noが参照できる状態にする (3) (1)で作成、配置したボタンに対するアクション記述する (1) お好みのボタンを作成し、写真読込用「picMC」内にボタンを作成、配置する。 (2) ライブラリ内MC「thumb」のボタン「btn」アクション on (release)に _root.selectNum = txtNum.text; を追加。 (3) 次へボタンであればon (release)時に_root.selectNumをインクリメントし、_root.loadPic(_root.selectNum);を呼び出す。 戻るボタンであればデクリメントすれば良いでしょう。 インクリメント時、「_root.selectNum」が「_root.thumbTotal」を超えたら1へ戻してやり、 デクリメント時0になったら「_root.thumbTotal」にしてやれば、最初の画像と最後の画像が繋がります。 上記方法で、簡単ではありますが言われているような動作はできます。（確認済み） 頑張ってみてください。
＃１＆２ です。 めちゃくちゃ間違いではないですが無駄(負担)が多いでしょう。 人間にとっても，またPCや携帯にとっても。 ところで ＃２ で書いた内容はわかりましたか？ 　ムービークリップ内の， 　フレーム1 には 0 の画像 　フレーム2 には 1 の画像 　フレーム3 には 2 の画像 　　　…略… 　フレーム10 には 9 の画像 　というように用意をしていれば 　「得られた数+1」フレームに 　gotoAndStop すれば良いだけ。 ということですよ。 三項演算子(if文でも同じく)を使うから 人間にとってもややこしくて PC(携帯)にとっても処理に負担がかかるのです。 　「得られた数+1」フレームに 　gotoAndStop すれば良いだけ。 これを substring を使うならこのようにすれば良いということです↓。 year = fscommand2("GetDateYear"); year1 = substring(year, 4, 1); year2 = substring(year, 3, 1); year3 = substring(year, 2, 1); year4 = substring(year, 1, 1); trace("year1→gotoAndStop(" add (year1 +1) add ")"); trace("year2→gotoAndStop(" add (year2 +1) add ")"); trace("year3→gotoAndStop(" add (year3 +1) add ")"); trace("year4→gotoAndStop(" add (year4 +1) add ")"); 元に近い形で 同じことをするなら次のようになります↓ year = fscommand2("GetDateYear"); year4 = int(year/1000); year3 = int((year-year4*1000)/100); year2 = int((year-year4*1000-year3*100)/10); year1 = year-year4*1000-year3*100-year2*10; trace("year1→gotoAndStop(" add (year1 +1) add ")"); trace("year2→gotoAndStop(" add (year2 +1) add ")"); trace("year3→gotoAndStop(" add (year3 +1) add ")"); trace("year4→gotoAndStop(" add (year4 +1) add ")"); さらに 三項演算子(if文でも同じく)を使うなら もっと複雑で人間にとってもＰＣや携帯にとっても負担が増えるのはわかりきったことです。 上記の２つの方法のどちらでするにしても 処理は一瞬で終わりますから どちらが処理が早いかはわかりません。 負荷として 1000 回 同じことをして その処理時間を比べてみることにします。 上の例の変形↓ time = getTimer(); for (i=1; i<=1000; i++) { year = fscommand2("GetDateYear"); year1 = substring(year, 4, 1); year2 = substring(year, 3, 1); year3 = substring(year, 2, 1); year4 = substring(year, 1, 1); } trace(getTimer()-time); trace("year1→gotoAndStop(" add (year1+1) add ")"); trace("year2→gotoAndStop(" add (year2+1) add ")"); trace("year3→gotoAndStop(" add (year3+1) add ")"); trace("year4→gotoAndStop(" add (year4+1) add ")"); ↑私のPCの場合，16ミリ秒かかりました。 下の例の変形↓ time = getTimer(); for (i=1; i<=1000; i++) { year = fscommand2("GetDateYear"); year4 = int(year/1000); year3 = int((year-year4*1000)/100); year2 = int((year-year4*1000-year3*100)/10); year1 = year-year4*1000-year3*100-year2*10; } trace(getTimer()-time); trace("year1→gotoAndStop(" add (year1 +1) add ")"); trace("year2→gotoAndStop(" add (year2 +1) add ")"); trace("year3→gotoAndStop(" add (year3 +1) add ")"); trace("year4→gotoAndStop(" add (year4 +1) add ")"); ↑私のPCの場合，32ミリ秒かかりました。 substringを使う方が， 速さも倍くらいになるようです。 この場合， 人間にとってもPCや携帯にとっても substring を使うのが負担が軽いということになるでしょう。
> 普通の画像をそのまま使っても > 容量が変わらないのはなぜでしょうか？ 「普通の画像」の定義が，少なくとも私とはズレています。 Flash におけるネイティブな普通の画像とは 何と言ってもFlash自体で描いたベクタ画像です。 (JPEGなどビットマップ画像はよそ者の特殊画像です。歴史的に見てもこれらが使えるようになったのは遅いです。) 例えば「線ツールやバケツツールを使って描いた車の絵」が普通の画像です。 私の言う普通の画像は，描いただけではライブラリに入りません。 この車を10台コピペでステージ上に並べるよりも グラフィックシンボルなどのシンボルに変換して そのインスタンスを10個ステージに並べる方が容量が軽くなりますよということです。 JPEGはよそ者ですからFlash内に存在する時点ですでにライブラリに入っています。 ですからJPEGをグラフィックシンボルに変換しても それだけでは容量は減りません。 また「車の絵」をシンボル化しておけば ＃１ の方も書かれているように １台の車の色を赤から緑に変えると全て車の色も赤から緑に変わるので 編集が楽になると言えます(これは他シンボルでも同じですが)。 またそもそも JPEGにしても私の言う普通の画像にしても モーショントゥイーンはかけらません。 グラフィックまたはムービークリップまたはボタンシンボルに変換する必要があります。 ＃２の方も書かれていますが Flash のアニメーションというのは基本的にシンボルの入れ子で作って行きます。 簡単な例で言うと 「羽ばたくだけの鳥」アニメーションを入れたシンボルを作成して そのシンボルのインスタンスをステージ上で左から右にモーショントゥイーンをさせれば 「羽ばたきながら飛ぶ鳥」ができます。 もしシンボルを入れ子にせず「胴体だけ」「羽根だけ」を作成したなら 「羽ばたきながら飛ぶ鳥」を作成するのにものすごく大変なことになってしまいます。 この最初の「羽ばたくだけの鳥」をムービークリップで作成したとします。 ムービークリップは，その親タイムラインとは独立して動くので 仮に親タイムラインを stop() させると 「鳥が左から右に移動する」という動きは止まりますが 「鳥がはばたく」という動きは止まりません。 一方グラフィックインスタンス内のタイムラインは その親タイムラインと同期して動くので 仮に親タイムラインを stop() させると 「鳥が左から右に移動する」という動きが止まると同時に 「鳥がはばたく」という動きも止まります。 「時間よ止まれ！」的なアニメーションを作るのには グラフィックシンボルの入れ子が便利です。 上の場合はまだムービークリップ内も親と同じタイミングで stop() させれば良いわけですが さらに逆生成をさせる場合などはムービークリップのスクリプト管理では困難になってきます。 他のQ&A掲示板の回答用サンプルとして見かけたページです。 「逆再生鉢植え(ツーポイント アドバイス)」 http://suzupara.iinaa.net/mixi/potted_plant/ これまた，他のシンボルでも同じことが言えますが， 私はココ(教えて！goo や OKWave)などの回答添付用や 何かのときに簡易的にパッと使えるように モノトーンでボタン用画像などをたくさん用意しています。 グラフィックシンボルでそれらを作っておけば そのグラフィックインスタンスの「プロパティパネル」より「カラー」を変えるだけで 色んな色の画像ができます【添付図】↓ これをボタンの中に入れて使えば 簡単に色々な色ボタンが作成できますよね。 (現に下の画像を作成するのに３分くらいかかっただけです。) 非常に便利です。
JavaScript とか考えずに 普通に HTMLの <OBJECT>タグ もしくは <EMBED>タグ で 縦横を 100% にして Flash を表示させれば良いだけではないでしょうか？ 何でしたら， Flash (Adobe または Macromedia Flash) 作成ツールの 「ファイル」→「パブリッシュ設定」で出てくる「パブリッシュ設定」パネルで「HTML」タブを選択して 　　サイズ：[ パーセント ] 　　幅(W)　 高さ(E) 　　[100 ]×[100 ] パーセント のような設定にして SWF とともに HTML をパブリッシュしてもできますが。 (あくまでもこれは簡易作成例で，本当はCSSなどでマージンなどを設定する必要がありますが。)
Flash 内のことに jQuery つまり JavaScript が出てくる意味がわかりません。 そんなことは普通はできませんし，あえてすることでもありません。 (新幹線の中で車を走らせるようなものです。) ドコモ辺りがすることを，他社などが良く真似て，一時的に同じようなものが多くなるんですよ。 それだけのことです。 どうやって作るかなどは Flash 作成ソフトやそのバージョンやActionScriptのバージョンによって変わりますし この文字だけのQ&Aサイトでは説明できませんよ。 説明できませんが，論理は比較的簡単なことです。 他掲示板での説明サンプルで見かけたことがありますが たとえばこんなのの変形です。 「モスもどき」 http://suzupara.iinaa.net/mixi/mos/ (Flash CS4 以上用 / ActionScript 3.0 サンプルですね。)
フレーム "ATTACK1" のスクリプトですが。 まず，次の部分に問題があります↓。 　if( time <= 0 ){ 　　　timeCount = false; 　　　if( count >= 10 ){ 　　　　　gotoAndPlay("ATTACK3"); 　　　　　count=0; 　　　　　delete this.onEnterFrame(); 　　　} 　　　gotoAndPlay("ATTACK2"); 　　　count=count+1; 　　　delete this.onEnterFrame(); 　} これだと 仮に count の値が 10 以上であったとしても 仮に count の値が 10 未満であったとしても どちらにしても 　gotoAndPlay("ATTACK2"); が実行されます。 ですから この部分をまずは次のように変更する必要があります。 (インデントを全角空白文字で入れていますからコピペはできません) 　if (time<=0) { 　　　timeCount = false; 　　　if (count>=10) { 　　　　　gotoAndPlay("ATTACK3"); 　　　　　trace(_currentframe); 　　　　　count = 0; 　　　　　delete this.onEnterFrame(); 　　　} else { 　　　　　gotoAndPlay("ATTACK2"); 　　　　　count = count+1; 　　　　　delete this.onEnterFrame(); 　　　} 　} これで 仮に count の値が 10 以上であれば 　gotoAndPlay("ATTACK3"); が実行されて 仮に count の値が 10 未満であれば 　gotoAndPlay("ATTACK2"); が実行されるようになります。 しかし！ ですね。 これで無事に動作するようになるのは Flash Player 6 用の SWF をパブリッシュする場合だけです。 Flash Player 7 以上用 SWF では 初期値のない変数の値は undefined になるため 初期値のない変数には何の数も足せません。 ・Flash Player 6 までの場合 　count = count + 1; 　　→countの初期値は空白文字列または0と認識されるので 　　　加算後のcountの値は 1 になる ・Flash Player 7 以上の場合 　count = count + 1; 　　→countの初期値はundefinedなので 　　　undefined + 1 で NaN(非数)になる したがって Flash Player 7 以上用の SWF をパブリッシュする場合 count には初期値 0 が必要になります。 ただし ご質問のスクリプトの場合は 何度も何度も フレーム "ATTACK1" に戻って来るので 単純にフレーム "ATTACK1" の最初の行辺りに count = 0; だけを書くわけには行きません。 (フレーム "ATTACK1" に戻って来る度に count が 0 になってしまう。) したがって フレーム "ATTACK1" の最初の行辺りに //もし変数countがundefinedのときに限って if(count == undefined){ //変数countの値を0にする count = 0; } というようなスクリプトを付け加える必要が出てきます。 上の２件を合わせると フレーム "ATTACK1" のスクリプトは 次のような感じになります。 (インデントは付けていないのでコピペ可能です。) //------------------------------------------- var timeCount = true; var endTime = getTimer()+0.2*1000; stop(); //もし変数countがundefinedのときに限って if(count == undefined){ //変数countの値を0にする count = 0; } onEnterFrame = function () { if (timeCount) { time = Math.ceil((endTime-getTimer())/1000); if (time<=0) { timeCount = false; if (count>=10) { gotoAndPlay("ATTACK3"); trace(_currentframe); count = 0; delete this.onEnterFrame(); } else { gotoAndPlay("ATTACK2"); count = count+1; delete this.onEnterFrame(); } } } }; //-------------------------------------------
ゆっくり点滅させたいってだけなら intro.alpha=Math.abs((getTimer()/2000)%2-1) ってカンジに時間に連動してやるのもあり これを言っちゃあ元も子もないですが TweenerとかTweenMax使っちゃえば楽ですよ 例えば２秒毎にゆっくり点滅させたいなら TweenMax.fromTo(intro,2,{alpha:0},{alpha:1,yoyo:true,repeat:-1}) この１行で済んじゃいます とりあえずなんらかトゥイーンライブラリは 一つは使えた方がいろいろと楽できますよ TweenクラスってもともとFlashにいるのがありますけど これを選ぶ理由って正直あんまりないです
とりあえず書かれていらっしゃるサイトのFlashは 横幅 100％ で HTML に貼り付けています。 書かれていらっしゃるサイトのFlashは次のように指定しています↓。 var so = new SWFObject('/asset/swf/top.swf', 'preloader', '100%', '385', '9', '#FFFFFF'); もちろんSWFObjectなどは使っても良いですし使わなくても良いです。 そんなことはどうでも良いことで とにかく width = 100% で貼り付けています。 そして Flash のムービー内の「拡大縮小なし」にしています。 ActionScript 2.0 の場合は メインのタイムラインの(_rootの)フレーム1の最初の行辺りにでも次のように書けば良いです。 Stage.scaleMode = "noScale"; ActionScript 3.0 の場合は メインのタイムラインの(MovieClip(root)の)フレーム1の最初の行辺りにでも次のように書けば良いです。 stage.scaleMode = StageScaleMode.NO_SCALE; それらに関係する色々な詳細について↓ ・ActionScript 2.0 の場合 「Flashゲーム講座＆ASサンプル集【Flash の画面表示について】」 http://hakuhin.jp/as/stage.html ・ActionScript 3.0 の場合 「FlashゲームPG講座 For AS3.0【Stage クラスについて】」 http://hakuhin.jp/as3/stage.html#STAGE_04 > 当方のFlashのスキルは、actionscript2.0を使ってサイト構築ができる程度です この文からでは， 結局 ActionScript 2.0 でしたいのか 3.0 でしたいのかわかりませんよ。 短い回答なので両方回答しましたが，たいていは回答できません。
まあtraceぐらいはつかえますが 正直AS3ってすくなくともAS1とは別物です クラスベースのオブジェクト指向を徹底してます（擬似的に） AS3でしかできないこととか AS3になって簡単にできるようになったこと AS3になってやり方が変わったこととか結構あります AS3でもplayer9までとplayer10以降でもいろいろやり方変わりました DictionaryとかVectorとか GraphicsDataとかDrawTriangleとか TLFとか3DとかIKとか それまで難しかったことが簡単に速くできるようになったりしてて いままでの努力が無駄になったりならなかったり… 新しい表現を取り入れていきたいっていうなら ちゃんとAS3の教材でやったほうがいいです
Flashの任意のタイムライン(例：メインのタイムライン)に ムービークリップ 「mc」 と ComboBox 「my_cb」 とが すでに配置されているものとします。 それら 「mc」 と 「my_cb」 が存在するフレーム(フレーム1ならフレーム1)に書くスクリプト例です。 //----------------------------------- //ComboBox「my_cb」の初期表示を設定 my_cb.prompt = "あいさつの魔法。"; //ComboBox「my_cb」の表示ラベルとデータを設定 my_cb.addItem( { label: "こんにちワン", data:4 } ); my_cb.addItem( { label: "ありがとウサギ", data:3 } ); my_cb.addItem( { label: "こんばんワニ", data:2 } ); my_cb.addItem( { label: "さよなライオン", data:1 } ); //「my_cb」チェンジ時に 関数 changeFunc を実行 my_cb.addEventListener(Event.CHANGE, changeFunc); //関数 changeFunc の定義 function changeFunc(e:Event):void { //もし選択されたアイテムのdataが2であれば if(my_cb.selectedItem.data == 2){ //mc内の再生をフレーム2で停止 mc.gotoAndStop(2); } } //----------------------------------- もっとも上のスクリプトの場合， 関数 changeFunc 内には 必ずしも if文 が必要なわけではありませんよね。 仮にあらかじめ 「ComboBox の data には mc を停止させるフレーム数を入れる」 というルールを決めておいたとすれば次のようにもできます。 //関数 changeFunc の定義 function changeFunc(e:Event):void { //mc内の再生を選択アイテムのdataフレームで停止 mc.gotoAndStop(my_cb.selectedItem.data); } あと ComboBox などを始めとする UIコンポーネント は Flash に付属する オマケ 的な存在ですから 本にもあまり使い方は書かれていませんし ネットでもそういうものを一々解説してません。 (UIコンポーネント は Adobe の人が ActionScript を駆使して作ったムービークリップの一種です。) ですからUIコンポーネント系は，基本的に ヘルプを見て，簡単な実験を繰り返して，その仕様を理解するのが誰でもがする普通の使い方です。 わからないことがあれば一にも二にも「ヘルプ」です。 http://livedocs.adobe.com/flash/9.0_jp/ActionScriptLangRefV3/fl/controls/ComboBox.html http://help.adobe.com/ja_JP/FlashPlatform/reference/actionscript/3/fl/controls/ComboBox.html
ムービークリップが停止しているか再生しているかというプロパティは存在しないようです。 しかし、そのようなものは無くても普通は困らないわけで、 グローバルな場所(例：MovieClip(root) や MovieClip(stage) )などに 適当な変数でも作って(例：mc_play_flag)、 再生や停止させる度にその変数の値を true や false にすれば良いだけです。 ※ムービークリップの再生状態は 　必ずActionScriptで変化させるはずです。 　ActionScriptで変化させるのでしたら 　それを把握できないのはおかしいです。 　(勝手に 再生状態 が変化するのであれば 　把握できなくても当然だと思いますが。) ＝*＝ ＝*＝ ＝*＝ 以上のような当たり前の普通な方法ではなくて、 「真に再生/停止状態を取得する方法を知りたい」 というご質問でしたら次のようにすればできます。 //----------------------------------------- //mcの再生状態を取得する関数getMCStateの定義 function getMCState(e:Event = null):void { //この関数が実行された時点でのmcの再生フレームを取得 var mc_flame:int = mc.currentFrame; //毎フレーム時間 以下のfunctionを実行 addEventListener(Event.ENTER_FRAME, function():void{ //もし上で取得したmcの再生フレームと //現在のmcの再生フレームが同じフレームであれば if(mc_flame == mc.currentFrame){ //関数aaaを実行 aaa(); //もし上で取得したmcの再生フレームと //現在のmcの再生フレームが違うフレームであれば }else{ //関数bbbを実行 bbb(); } //毎フレーム時間 このfunctionを実行するのをやめる removeEventListener(Event.ENTER_FRAME, arguments.callee); } ); } //関数aaaの定義 (例) function aaa():void{ trace("mcは停止してます"); } //関数bbbの定義 (例) function bbb():void{ trace("mcは再生してます"); } //----------------------------------------- ＝*＝ ＝*＝ ＝*＝ ...と、書いてはみましたが こんなことを毎回(同様にある あらゆるたくさんの場合について毎回)考えるより 最初に書いたように 適当な変数を用意してその値を見る方が良いですよ。 ActionScript 1.0 なのでそれ自体は参考になりませんが 「同様にある あらゆるたくさんの場合」の一例として 考え方自体は参考になると思います↓。 「if文 ＆ else if 文」 http://suzupara.iinaa.net/kiso051.html 　
要するにクリックしたら別ページに飛ぶようにしたいだけですか？ ボタン.addEventListener(MouseEvent.CLICK,onClick) function onClick(e){ navigateToURL(new URLRequest("行き先のURL") }
Timerクラスを使うなら import flash.utils.Timer; import flash.events.TimerEvent; var tmr:Timer=new Timer(40,3000/40) tmr.addEventListener(TimerEvent.TIMER,onTime) function onTime(e){ ugoki1() } setTimeOutを使うなら addEventListener(Event.ENTER_FRAME,frameTick) setTimeout(3000,function(){removeEventListener(Event.ENTER_FRAME,frameTick)}) function frameTick(){ ugoki1() } ただ気になるのはugoki1がmcを再生してるって 具体的になにしてんのかってこと gotoAndPlay()で動的に行き先フレームを 決めてるとかならわかるんですが もしugoki1がmc.play()してるだけで mcを三秒後に停止したいってだけなら setTimeoutでmcを3秒後に停止すればいいだけで ugoki1を何度も実行する必要はないかと
フレーム１～３を１秒ずつ再生すればいいんですよね？ 仮にそのムービーをmcとして for(var i=1;i<=3;i++){ setTimeout(function(n){return function(){mc.gotoAndStop(n)}}(i),1000*i) }
どうしたら良いかと問われましても ActionScript のバージョンを明記されないと 場合によっては１文字たりとも回答できませんよ。 勝手に ActionScript 3.0 を使うという条件で 方法の一例を回答します。 　 まず横長の外部画像は「gazou.jpg」というファイル名で Flash の SWF ファイルやそれを貼り付ける HTMLファイル と同じフォルダ内に置くものとします。 　任意のフォルダ 　　　├○○.fla (○○.swf １を作る) 　　　├○○.swf 　　　├○○.html (○○.swf を貼り付ける) 　　　└gazou.jpg (外部画像) また，ステージ上のフレーム1には， 「＜」のボタン，「□」のボタン，「＞」のボタンの３つが用意されていて 「＜」 ボタンには「L_btn」(Lは左の意味)， 「□」のボタンには「S_btn」(Sは Stop の意味)， 「＞」のボタンには「R_btn」(Rは右の意味) というインスタンス名が それぞれのボタンに付けてあるものとします。 (インスタンス名は各ボタンを１つずつ選択した状態で，プロパティパネルより命名する。) それら３つのボタンとは別に ActionScript を書く用にするレイヤーを挿入し フレーム1 のキーフレームに 次のスクリプトをコピペします。 /////////////////////////////////////////////// //外部画像ファイルへのパスを設定 var url:URLRequest = new URLRequest("gazou.jpg"); //外部画像を動かすスピードを設定 var spd:Number = 7.5; //外部画像を配置するy座標を設定 var y_pos:Number = 20; //外部画像の左端が来る限界位置を設定 var L_lim:Number = 0; //外部画像の右端が来る限界位置を設定 var R_lim:Number = stage.stageWidth; //---↑以上が適当に変更する設定↑--- //Loaderインスタンスを作成＆配置 var ld:Loader = new Loader(); ld.x = L_lim; ld.y = y_pos; addChild(ld); //外部画像の横幅を入れる変数の宣言 var gazou_w:Number; //Loaderを動かすpx数を入れる変数の宣言 var move_px:Number; //外部画像にアクセス可能になった時に関数onLoadINITを実行 ld.contentLoaderInfo.addEventListener(Event.INIT,onLoadINIT); function onLoadINIT(e:Event):void { //外部画像の横幅を記録 gazou_w = e.target.width; //L_btnクリック時に関数 onLClick を実行 L_btn.addEventListener(MouseEvent.CLICK,onLClick); //S_btnクリック時に関数 onSClick を実行 S_btn.addEventListener(MouseEvent.CLICK,onSClick); //R_btnクリック時に関数 onRClick を実行 R_btn.addEventListener(MouseEvent.CLICK,onRClick); } //Loaderに外部画像をロード ld.load(url); //L_btnクリック時に実行する関数 onLClick を定義 function onLClick(e:MouseEvent):void { //Loaderを動かすpx数を spd にする move_px = spd; //１フレーム時間ごとに毎回 関数 moveLoader を実行 addEventListener(Event.ENTER_FRAME,moveLoader); } //S_btnクリック時に実行する関数 onSClick を定義 function onSClick(e:MouseEvent):void { //１フレーム時間ごとに毎回 関数 moveLoader を実行するのをやめる removeEventListener(Event.ENTER_FRAME,moveLoader); } //R_btnクリック時に実行する関数 onRClick を定義 function onRClick(e:MouseEvent):void { //Loaderを動かすpx数を -spd にする move_px = - spd; //１フレーム時間ごとに毎回 関数 moveLoader を実行 addEventListener(Event.ENTER_FRAME,moveLoader); } //関数 moveLoader を定義 function moveLoader(e:Event):void { //Loaderのx座標を move_px 動かす ld.x += move_px; //Loaderの左端x座標が限界を超えたら if (ld.x>L_lim) { //Loaderの左端x座標を左の限界にする ld.x=L_lim; //１フレーム時間ごとに毎回 関数 moveLoader を実行するのをやめる removeEventListener(Event.ENTER_FRAME,moveLoader); //Loaderの右端x座標が限界を下まわっていたら } else if (ld.x < - gazou_w+R_lim) { //Loaderの右端x座標を右の限界にする ld.x=- gazou_w+R_lim; //１フレーム時間ごとに毎回 関数 moveLoader を実行するのをやめる removeEventListener(Event.ENTER_FRAME,moveLoader); } } /////////////////////////////////////////////// パブリッシュ または 「制御」→「ムービープレビュー」で動作確認できると思います。 //外部画像ファイルへのパスを設定 var url:URLRequest = new URLRequest("gazou.jpg"); これ↑で設定する外部画像のパスは ○○.html (○○.swf を貼り付ける) から見たパスです。 ○○.swf から見たパスではないので階層を変える場合は注意してください。 ◎例 　任意のフォルダ 　　　├○○.html (○○.swf を貼り付ける) 　　　└files(フォルダ) 　　　　　├○○.fla (○○.swf １を作る) 　　　　　├○○.swf 　　　　　└gazou.jpg (外部画像) この場合は var url:URLRequest = new URLRequest("files/gazou.jpg"); になります。 　 ＝*＝*＝ ＝*＝*＝ ＝*＝*＝ > 1フレームでストップして、ボタンで2フレームに移動して > トゥイーンで動かしたら良い。 その路線で単純に行くとすれば左右どちらかにしか進めませんよね。 左右どちらにでも動かす場合は フレームを逆再生させる必要が出てきます。 逆再生させるのでしたら次のページが参考になると思います。 (ただし次のページは ActionScript 3.0 ではありません。ActionScript 1.0 です。) 「ロールアウトで逆戻りするアニメーション」 http://fumiononaka.com/TechNotes/Flash/FN0303003.html また，外部画像ですから編集中は見えないので， トゥイーンで動かすにしても結構頭を使うと思います。 　
このページをみると、flash も、ただの TCP ソケットみたいだから、 http://livedocs.adobe.com/flash/9.0_jp/ActionScriptLangRefV3/flash/net/Socket.html tcpdump http://linuxjm.sourceforge.jp/html/tcpdump/man1/tcpdump.1.html とか、 Windows なら、WinPcap かな？ http://www.winpcap.org/ がつかえるはずだよ。 でも、ふつうの TCP ソケットなら、ほかの 通信と区別がつかないから、flash を実行している PC で、どのプログラムでの TCP 通信かをしらべないと、わからないとおもう。
こうします。 function machiClick(e:MouseEvent):void { var i:int=e.target._id; imgPhoArr[i].visible = true; } つまり「e.target」がイベントの発生したオブジェクトになります。
スクリプトを見れば見るほど だんだん何をどうしようとされているのかがわからなくなりました。 ですからスクリプトや全体の解読とそれに対する具体的な回答はやめます(あきらめ)。 次の部分についてのみ回答します。 > for文を使って各変数の「1」等のナンバーにiを適用させて、 > ループさせれば良いとは思うのですが、 > ["MC"+i]等と入力してもエラーになってしまいます。 this["MC"+i] 等とすれば良いのではないでしょうか。 Googleやヘルプなどで「配列アクセス演算子」と検索してみてください。 http://www.google.co.jp/search?sourceid=navclient&hl=ja&q=%e9%85%8d%e5%88%97%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e6%bc%94%e7%ae%97%e5%ad%90
以下のようにやればそれなりのものが出来ます。 １個のオブジェクト(obj0)内に アイコン(objI)と表示したいプルダウンメニュー(objM)を配置します。 （私はFlexでAction Script3.0を行っているのでこのあたりの説明が出来ません） //プルダウンメニューを非表示 objM.visible=false; //マウスオーバー・アウトのイベント obj0.addEventListener(MouseEvent.MOUSE_OVER,myOver); obj0.addEventListener(MouseEvent.MOUSE_OUT,myOut); //イベント関数 private function myOver(e:MouseEvent):void { objM.visible=true; } private function myOut(e:MouseEvent):void { objM.visible=false; }
こんな形でなら動くと思います。 Var ｙ: Array=new Array(2); ｙ[0]= □□; ｙ[1]= ■■; if(x[ｉ]>=5){ y[ｉ].text="A" }else if(x<5){ y[ｉ].text="B" } ---------------- 変数にセットする時String、Numberはその値がコピーされます。 つまり元のものとは独立した存在になります。 □□（テキストフィールド？）はアドレス（？）の値がコピーされます つまり元のもの同じものとして扱えます。 （この説明はたぶん不完全なので雰囲気を感じ取ってください）
いわゆる配列変数として、Array クラスのプロパティやメソッドで並び替えや値の検索といった配列変数ならではの機能を発揮できるのは、数字でインデックスを付けたものだけです。 配列変数を扱う Array クラスは MovieClip クラスなどと同様に、プロパティやメソッドを後から追加できるクラス（ダイナミッククラス）です。 [　] の中に数字以外の名前を指定した場合は、その名前のプロパティが作成されます。こちらは配列変数とは見なされません。 ActionScript の [　] 演算子は、配列変数の操作と、文字列を参照に変換するという、２つの機能があります。 配列変数の操作には [　] が使われるために、arr[ "川" ] も配列変数になるような気がするのですが、これは、"川"の文字列を参照に変換してこの名前のプロパティを参照するという意味です。プロパティが存在しない場合は、新たに作成されます。 つまり、ご提示の例ですと、arr は [ 0 ] ～ [ 2 ] の要素を持つ配列変数を管理すると同時に、そのほかに「川」「魚」「鳥」という名前のプロパティを持っていることになります。 この中で、いわゆる配列変数として機能し、Array クラスのプロパティやメソッドを適用できるのは、arr[ 0 ] ～ arr[ 2 ] の部分だけです。 length は配列変数の要素数を表します。数字以外で命名された「川」や「鳥」はプロパティであって配列変数の要素とは見なされないので、arr.length は 3 となります。 「川」や「鳥」は配列変数ではないものの、arr の持つプロパティではあるのですから、 　arr[ "川" ] と、文字列を [　] 演算子で参照に変換すると値を取り出すことができます。 プロパティの名前が全角文字なので意外ですが、実は 　arr.川 でも参照できます。 ただ、エラーにはならなくても、スクリプトで制御するものの名前に全角文字は、避けた方が無難です。 － － － － － ActionScript には、連想配列の発想がありません。 しかし、Object クラスか、ActionScript 3.0 であれば＃１の方がおっしゃる通り Dictionary というクラスを使い、連想配列を擬似的に表現することはできます。 先ほどの件も、連想配列という１つのデータ管理形態があったのではありません。Array クラスのオブジェクトに作られた、独立したプロパティの１つ１つにそれぞれ値が入っていて、そのプロパティの名前が連想配列のキーのような役割を果たしていたのです。 Object クラスを使う場合も、キーの名前のプロパティを作る形になります。 （↓　各行頭に全角のスペースが含まれています。コピーする際はご注意ください） //＊＊＊ 　var obj:Object = new Object(); 　obj.earth = "地球"; 　obj[ "sun" ] = "太陽"; 　//値を出力 　for( var key:String in obj ) 　{ 　　trace( "キー：" + key + "　値：" + obj[ key ] ); 　} //＊＊＊ ↑　オブジェクトに含まれるプロパティの名前に規則性がなくても、for in という制御文を使って列挙することは可能です。（列挙できないものもあります） プロパティの総数を返すメソッドはないのですが、for in の中でカウントを取ると総数を調べることができます。 このような使い方は、例えば生徒の名前と住所というように、重複しない固有のキーと値をペアにして管理したい時に向いています。 なお、ActionScript 1.0 と 2.0 では、for in は後に入れたものの方から先（上記の例では sun → earth の順）に取り出される場合があります。取り出す順序が重要になる時はご注意ください。 － － － － － これとは別に、配列変数の持っている”フィールド”という機能を使って、複数の情報を組にして管理することもできます。 //＊＊＊ 　var arr:Array = new Array(); 　arr = 　[ 　　{ en : "earth" , jp : "地球" } , 　　{ en : "sun", jp : "太陽" } 　]; 　//別の書き方で追加してみる 　arr[ 2 ] = { en : "moon" , jp : "月" }; 　//配列変数の要素を全てチェック 　for( var i:Number = 0 ; i < arr.length ; i++ ) 　{ 　　//各フィールドの値を出力 　　trace( "arr[ " + i + " ].en = " + arr[ i ].en ); 　　trace( "arr[ " + i + " ].jp = " + arr[ i ].jp ); 　} //＊＊＊ ActionScript の配列変数は、各要素の中にさらに仕切りを作り、１つの要素で複数の情報を管理できるようになっています。 この仕切りのことを”フィールド”といい、{　} を使って { フィールド名 : 値 , …　} というように複数のフィールドをまとめて定義することもできます。 フィールド名と値の数は統一されていなくても構いませんが、全ての要素間で統一しておくと、何かと便利です。 上記の例では arr は配列変数になりますから、Array クラスの持つ機能を活かすことができます。 （ちなみに Array クラスの sortOn メソッドは、フィールドごとの値に注目して並べ替えることができます） この使い方は、複数のデータの間に共通の項目名を設けて値を持つ、表やデータベースのようなものに向いています。Flash でも、ComboBox や DataGrid など、データを表のように表示するタイプのコンポーネントでのデータの管理に利用されています。 上記の例の arr は全部で６つの情報を管理しているように見えますが、実際は、arr に含まれる [ 0 ] ～ [ 2 ] の３つの要素がそれぞれ” en ”と jp ”というプロパティを持って値を管理している形になります。 arr の length プロパティは、あくまでも自分が持っている配列変数の要素（ [ 0 ] ～ [ 2 ] ）の総数を表すので、arr.length は 3 です。
＃１です。 > 普通のアニメーション >（人が歩く、観覧車が回る、ライトが光る）などは、 > ＰＣ用のplayerでも動く、という認識で > よろしいでしょうか。 動くでしょう？ 現に Flash(SWF) を作成されているのは PC のはずですから その PC では動作していると思います。
極普通の考え方ですが 最初のボタン出没時に stop(); で，そのタイムラインの再生を止めておき ボタンクリックでそのタイムラインの再生を開始させ アニメーション後に「リンクの表示」をさせて そこでまた stop(); させれば良いのではないでしょうか？ ボタンクリックでそのタイムラインの再生を開始させるには ボタン自体に on(release){ play(); } とか on(release){ gotoAndPlay(5); } のようなことを書けば良いと思います。
ColorMatrixFilterとAdjustColorで ムービーの彩度を５０に落とすなら import fl.motion.AdjustColor import flash.filters.ColorMatrixFilter var ajc:AdjustColor=new AdjustColor() ajc.saturation=50 ムービー.filters=[new ColorMatrixFilter(ajc.CalculateFinalFlatArray())] みたいなカンジでやります
パケ代セキュリティの仕様上，無理でしょう。 １クリックイベント(１キーイベント)動作に付随して １リンクまたは１ロードです。
#2です 線はaとdをアンカーポイント bとcをコントロールポイントにした ベジェ曲線なので それらのx座標を調整すれば長さは変えれます 幅を1000にしたいなら a=new Point(0,100) b=new Point(200,100) c=new Point(350,100) d=new Point(550,100) ↓ a=new Point(0,100) b=new Point(300,100) c=new Point(700,100) d=new Point(1000,100) というかんじです 本来はここは簡単に変えれるようにしとくべきだけど まあ波打つ線のグラフィクのやり方みせる為だけのサンプルで 使い回す事もないだろうってことで面倒なので数値固定にしてました レンダリングの限界ということでいうなら 長さ2万ピクセル越えの線とか描いたり 画面の１０倍近い大きさのMCに フィルタ効果かけたりしない限り大丈夫です
質問の映像は、映像編集ソフト（おそらくはAfterEffects）で作成されたもので、時間構わず、あくまで「映像」としてレンダリングされたものです。 プレゼンテーションソフトである、KeynoteやPowerPoiontに比べればマシですが、Flashは基本的に、リアルタイム・アニメーションを行うためのソフトであり、映像で書出さない限り、このような動きを再生することはできません。そして、映像制作ならば、もっと強力なAfterEffectsがあります。 プレゼンのために、コストをかけてわざわざ映像を作成するか否かは、その重要度次第なので、いちがいには言えませんが、この映像品質がFlashで不可能なことに気づかないうちは、Flashプレゼンなどに浮気しないほうがいいと思います。 苦労してアニメーション作っても「この動きじゃあ」、ということですかね。
ASで0,0以外を中心に回転させたいときは MatrixTransformer使います var mtx:Matrix=ムービークリップ.transform.matrix fl.motion.MatrixTransformer.rotateAroundExternalPoint(mtx, x, y, 角度) ムービークリップ.transform.matrix=mtx みたいなカンジです
当方も初心者なのであまり詳しくはないのですが、「エスケープシーケンス as3」で検索したら以下のようなページが出てきました(ページ下の方に\マークに関する記述があります)。 http://oshige.com/flash/as3note/2007/05/22.html "\u00A5" + 1000; もしくは String.fromCharCode(0x00A5) + 1000; でやってみたところ当方の環境ではいずれも出来ました。 as3以外でも出来るかは分かりません。
おそらくしようとされているのは次のような感じではないかと思います。 //--------------------------------------------------- MovieClip(root).comment1.visible=false; var pointX:Number=70; var pointY:Number=50; mc.addEventListener(MouseEvent.MOUSE_OVER, fl_MouseOver); function fl_MouseOver(event:MouseEvent):void { MovieClip(root).comment1.visible=true; stage.addEventListener(MouseEvent.MOUSE_MOVE,mouseMoveFunc); } function mouseMoveFunc(e:MouseEvent):void { MovieClip(root).comment1.x=stage.mouseX+pointX; MovieClip(root).comment1.y=stage.mouseY+pointY; } mc.addEventListener(MouseEvent.MOUSE_OUT, fl_MouseOver2); function fl_MouseOver2(event:MouseEvent):void { stage.removeEventListener(MouseEvent.MOUSE_MOVE,mouseMoveFunc); MovieClip(root).comment1.visible=false; } //--------------------------------------------------- 本題とは関係ないですが スクリプトを書かれていらっしゃる場所が rootのフレームでしたら そんなに律儀に MovieClip(root) などと書く必要はありませんよ(と言うか書かないのが普通)↓。 //--------------------------------------------------- comment1.visible=false; var pointX:Number=70; var pointY:Number=50; mc.addEventListener(MouseEvent.MOUSE_OVER, fl_MouseOver); function fl_MouseOver(event:MouseEvent):void { comment1.visible=true; stage.addEventListener(MouseEvent.MOUSE_MOVE,mouseMoveFunc); } function mouseMoveFunc(e:MouseEvent):void { comment1.x=stage.mouseX+pointX; comment1.y=stage.mouseY+pointY; } mc.addEventListener(MouseEvent.MOUSE_OUT, fl_MouseOver2); function fl_MouseOver2(event:MouseEvent):void { stage.removeEventListener(MouseEvent.MOUSE_MOVE,mouseMoveFunc); comment1.visible=false; } //---------------------------------------------------
tellTarget(○○){} というのはくせ者で その {} 内の変数などは全て ○○ 階層のものを指すのです。 ですから tellTarget("/qt"){gotoAndPlay("q" add m1);} などとすると この m1 は /qt:m1 (_root 内の qt 内の変数 m1) になるんです。 ですから tellTarget("/qt"){gotoAndPlay("q" add /:m1);} のような感じにする必要があります。
イベントリスナの関数はremoveEventListenerしても実は生きていて その関数が参照してるものもそれに応じて実は生き続けてる だからremoveEventListenerしたときに リスナー関数がガーベージコレクションに入るように addEventListenerするときに第5引数useWeakReferenceをtrueにしておく addEventListener(イベントタイプ,関数,false,0,true) これでどうでしょうかね
>2フレーム目で初めてインスタンスが生成されるのでしょうか？ そうですよ。 > 再び1フレーム目に戻ってきた時にはどうなっているのでしょうか？ レイヤーに依存しないように深度(表示順)をスクリプトで変えているなどのことをしない限り，普通は消えてる(存在していない)でしょう。 以上。 ＝＝＝＝＝＝＝＝＝＝＝＝ 以上で終わりたいところですが 単純に考えて， 例えばそのインスタンスのy座標を50にしたいとしましょうか。 または 例えばそのインスタンスのy座標を取得したいとしましょうか。 「y座標を50にしたい」として 何フレーム目のそのインスタンスのy座標を50にするのでしょうか？ インスタンスはどこに配置されるかもわかりませんし動き回る可能性もあるのです。 仮にそのインスタンスが1フレーム目で生成されていたとしても その時点で指示などできないでしょう？ 「y座標を取得したい」として 何フレーム目のそのインスタンスのy座標を取得するのでしょうか？ インスタンスはどこに配置されるかもわかりませんし動き回る可能性もあるのです。 仮にそのインスタンスが1フレーム目で生成されていたとしても その時点で2フレーム以降に出没するインスタンスの座標など取得などできないでしょう？
Flash CS4 Proの書き出しについて、Adobeでは「Flash では、Adobe Illustrator 88、3、5、および 6 の形式の書き出しをサポートしています。」とユーザーガイドに記載されていますし、書き出しの際にIllustratorのバージョンを選択する際に、多分6でされていると思います。 ご存知だと思いますが、Illustrator 11がCSに当たりますので、CS4はバージョン１４になります。 上手く表示できたらラッキー！ぐらいに思われたらどうでしょうか。 私はＣＳ３で検証しましたが、当然質問者様と同じ現象になりました。 ＡＩ形式でないといけない理由が質問者様にはあるのでしょうか？　ＥＰＳ形式ではだめなのですか？ＥＰＳならそのような現象もなくIllustratorで使えますよ。
ActionScript 2.0 → 3.0 変換といよりも ActionScript 1.0(一番初期) → 3.0 変換ですね。。。 ムービークリップ「mc」が存在する任意のタイムラインの， 任意の "フレーム(キーフレーム)" に書くスクリプト例です↓。 //============================ var pointX:Number=10; var pointY:Number=20; stage.addEventListener(MouseEvent.MOUSE_MOVE,mouseMoveFunc); function mouseMoveFunc(e:MouseEvent):void { MovieClip(root).mc.x=stage.mouseX+pointX; MovieClip(root).mc.y=stage.mouseY+pointY; } //============================
例えば次のような感じでしょうか。 ActionScript 3.0 設定の新規ドキュメントを作成し メインタイムラインのフレーム1に書くスクリプト例(コピペ可)↓ //------------------------------------ //～テキストフィールド「my_txt」を適当に用意～ var my_txt:TextField = new TextField(); my_txt.x = 20; my_txt.y = 20; my_txt.width = 40; my_txt.height = 22; my_txt.border = true; my_txt.background = true; //タイプ＝テキスト入力 my_txt.type = TextFieldType.INPUT; //入力文字制限 my_txt.restrict = "0-9"; //入力値制限 my_txt.addEventListener(Event.CHANGE,textChangeFunc); function textChangeFunc(e:Event):void{ var str:String = e.target.text; if(str == "0"){ e.target.text = "1"; }else if(Number(str) >= 21){ e.target.text = "20"; } } this.addChild(my_txt); //(座標をずらすために変数を用意：なくても良い) var xy:Number = 0; //キーダウン時に 関数keyDownFuncを実行 my_txt.addEventListener(KeyboardEvent.KEY_DOWN, keyDownFunc); //関数keyDownFuncの定義 function keyDownFunc(e:KeyboardEvent):void { //もし「Enter」キーが押されたら if (e.keyCode == Keyboard.ENTER) { //関数makeShapeを実行 makeShape(); } } //関数makeShapeの定義 function makeShape():void { // //「my_txt」の入力文字列を数値として取得 var txt_num:int = Number(my_txt.text); // //シェイプ「my_shape」を作成 var my_shape:Shape = new Shape(); // //太さ1pxの青線の輪郭を設定 my_shape.graphics.lineStyle(1, 0x0000FF); // //赤い塗りの開始 my_shape.graphics.beginFill(0xFF0000); // //---↓★本題ココから★↓------- //もし「my_txt」の数値が 1 以上 10以下であれば if (txt_num >= 1 && txt_num <= 10) { //四角を描画 my_shape.graphics.drawRect(xy,xy,100,100); //もし「my_txt」の数値が 11以上 20以下であれば } else if (txt_num >= 11 && txt_num <= 20) { //丸を描画 my_shape.graphics.drawCircle(50+xy, 50+xy, 50); //---↑★本題ココまで★↑------- } else { //それ以外はこの関数を抜ける return; } // //(座標をずらす：ずらさなくても良い) xy += 5; // //塗りの終了 my_shape.graphics.endFill(); // //シェイプ「my_shape」を配置 this.addChild(my_shape); // //「my_txt」の表示順を一番上に移動 this.setChildIndex(my_txt,this.numChildren-1); } //------------------------------------ 上記スクリプトをメインタイムラインのフレーム1にコピペし 「制御」→「ムービープレビュー」でSWFを表示させます。 すると左上の方に表示されているテキストフィールド(四角い枠)が表示されると思うので そこに適当な数値を入力して "「Enter」キーを押す" と 入力した数値に対応した四角または丸が描画されると思います。 ※適当に入力しても 　 1以上20以下しか入力できないようにしています。 やたら長くてごちゃごちゃと書いていますが 上記スクリプト中の本題は，関数makeShape 内の次の部分だけです。 　//もし「my_txt」の数値が 1 以上 10以下であれば 　if (txt_num >= 1 && txt_num <= 10) { 　　　//四角を描画 　　　my_shape.graphics.drawRect(xy,100,100); 　　　//もし「my_txt」の数値が 11以上 20以下であれば 　} else if (txt_num >= 11 && txt_num <= 20) { 　　　//丸を描画 　　　my_shape.graphics.drawCircle(50+xy, 50+xy, 50); 　} 「&&」については，【図】↓をご参考に。 あと， 座標は別に動かさなくて良いです。 　//四角を描画 　my_shape.graphics.drawRect(xy,xy,100,100); や 　//丸を描画 　my_shape.graphics.drawCircle(50+xy, 50+xy, 50); この↑部分は こう↓でも良いです。 　//四角を描画 　my_shape.graphics.drawRect(0,0,100,100); や 　//丸を描画 　my_shape.graphics.drawCircle(50, 50, 50); しかしこれだと「Enter」する度に同じ場所に図形が重なって 新たに描画されたかどうかがわからないため 動作検証用に5pxずつ座標をずらしているだけです。 　
> object1(グラフィック)を配置 ここがよくわかりません。 「object1」とは何でしょうか？ インスタンス名ですか？ 変数名ですか？ また「グラフィック」とは何でしょうか？ 普通に解釈するなら「グラフィックシンボルに変換したステージ上のグラフィックインスタンス」となりますが その意味のグラフィックならインスタンス名は付けられないと思います。 また普通，ActionScriptで直接グラフィックインスタンスの操作をすることははできません。 上記の「グラフィック」という意味のものではなく ActionScriptで作成した何某かのグラフィックでしたら そのグラフィックを生成したスクリプトなどを書いてもらわないとグラフィックの指す物が何かわかりません。 もし上記の「グラフィック」という意味のものでしたら まずグラフィックインスタンスを用意するのはやめるべきです。 グラフィックインスタンスではなく，インスタンス名を付けることができて ActionScriptで直接操作できるムービークリップ(またはボタン)を用意すべきです。 シーン１(root)にインスタンス名mcopというムービークリップを手動で配置し そのmcopの中にインスタンス名mcというムービークリップを手動で配置し そのmcの中にインスタンス名object1というムービークリップを手動で配置したとします。 ※「手動で」というのは「ActionScriptではなく」という意味です。 　root 　　└mcop(ムービークリップ) 　　　　└mc(ムービークリップ) 　　　　　└object1(ムービークリップ) そして ムービークリップmc 内のフレームにスクリプトを書いて ムービークリップobject1 を非表示にするとします。 その場合は次のようなスクリプトになります。 MovieClip(root).mcop.mc.object1.visible = false; 上記のは root を基準とした絶対パスでの書き方です。 相対パスで書くと次のようにもっと単純になります。 object1.visible = false; または this.object1.visible = false; 「1.5 rootとstage (ActionScript3.0入門ノート)」 http://oshige.com/flash/as3note/2007/04/14_rootstage.html
＃１ですが。。。 > 今回はwonderflで作ったコンテンツがありまして 　…中略… > 逆ならいけますでしょうか？ > flash8でアニメーションを作成。→swfをwonderflで読み込み再生→ > その後wonderflで作成したメインコンテンツを挿入。 結局，＃２の方のおっしゃることを参考にするならば wonderfl のコンテンツというのはやはり ActionScript 3.0 のみなのでしょう？ それだと無理です。 ActionScript 3.0 コンテンツは Flash Player 9 以上用にパブリッシュされた SWF でしか動作しません。 そもそもエンジンが違いますし Flash Player 9 以上用にパブリッシュされた SWF は Flash Player 8 用 SWF に表示させるのは基本的に無理です。 (アナログのLPレコードプレイヤーに，CDを乗せて再生させようとするようなもの。) 「AVM1Movie - ActionScript 3.0 コンポーネントリファレンスガイド」 http://livedocs.adobe.com/flash/9.0_jp/ActionScriptLangRefV3/flash/display/AVM1Movie.html 　 逆に Flash Player 9 以上用にパブリッシュされた SWF 内に Flash Player 8 用 SWF を表示させることは無理ではないですが。。。。 しかししかし... それも根本的に邪道であって， かなりな障壁はつきまといます(それなりの覚悟と知識がないと制御不可能)。 「LocalConnection - ActionScript 3.0 コンポーネントリファレンスガイド」 http://livedocs.adobe.com/flash/9.0_jp/ActionScriptLangRefV3/flash/net/LocalConnection.html
＃１です。 すみません一部訂正というか，１行書き忘れです。 関数 finishSpeedUp 内の最後に //「stage」上でマウスアップ時に 関数 ｆｉｎｉｓｈSpeedUp を実行するのをやめる stage.removeEventListener(MouseEvent.MOUSE_UP,finishSpeedUp); を入れるのを忘れていました。 スクリプトの書き始めでは(構想段階では) 上の１行を入れるつもりだったのですが 実際にコードを書いているうちに入れることをすっかり忘れ去っていました。 訂正はそこだけですが 再びスクリプトの全文を書いておきます。 //------------------------------------------------ //「speed_up_btn」押下時に 関数 speedUp を実行 speed_up_btn.addEventListener(MouseEvent.MOUSE_DOWN,speedUp); //関数 speedUp の定義 function speedUp(evt:MouseEvent):void { //１フレーム進む時間毎に 関数 playHighSpeed を実行 mc.addEventListener(Event.ENTER_FRAME,playHighSpeed); //「stage」上でマウスアップ時に 関数 ｆｉｎｉｓｈSpeedUp を実行 stage.addEventListener(MouseEvent.MOUSE_UP,finishSpeedUp); } //関数 playHighSpeed の定義 function playHighSpeed(evt:Event):void { //「mc」の再生フレームが最終フレームでなければ if (evt.target.currentFrame!=evt.target.totalFrames) { //「mc」の再生フレームを2フレーム先に進めて停止 evt.target.gotoAndStop(evt.target.currentFrame + 2); } else { //それ以外は「mc」の再生フレームをフレーム2に戻して停止 evt.target.gotoAndStop(2); } } //関数 finishSpeedUp の定義 function finishSpeedUp(evt:MouseEvent):void { //１フレーム進む時間毎に 関数 playHighSpeed を実行するのをやめる mc.removeEventListener(Event.ENTER_FRAME,playHighSpeed); //「mc」を普通に再生させる mc.play(); //「stage」上でマウスアップ時に 関数 ｆｉｎｉｓｈSpeedUp を実行するのをやめる stage.removeEventListener(MouseEvent.MOUSE_UP,finishSpeedUp); } //------------------------------------------------ 　
> アクションスクリプトにどのように書き込めばよいのでしょうか。 > ｃｓ５にはコードスニペットというのができて > これを使えば簡単かと思ったのですができません。 具体的な「何をどうするのか」という方針(ストーリー)がなければコードも何もないと思います。 (人間が考えた方針(ストーリー)をソフト上で実行させるのがコードです。) > 小のボタンを、ステージ上でクリックしたら大の写真が出てくるようにしたい この「大の写真を出す方法」など， 細かなバリエーションも合わせると無数にあります。 例えば 「大の写真をステージ外のとんでもない場所(x=10000000とか)に配置しておいて，ボタンクリックでステージ表示内に移動させる。」 という方針もありますし 「大の写真を透明にしておいて，ボタンクリックで不透明にする。」 という方針もありますし 「大の写真を非表示(visible=false)にしておいて，ボタンクリックで表示(visible=true)する。」 という方針もありますし 「ボタンクリックで大の写真のシンボルをライブラリからステージ上に出す。」 という方針もありますし 「ボタンクリックで大の写真のJPEGファイルを外部からロードして表示する。」 という方針もありますし 　…　etc.　etc. … ただ， 大の写真をライブラリから呼び出したり， 大の写真のJPEGファイルを外部からロードする場合， 大の写真を出したは良いけど，深度(表示順序の上下関係)はどうするの？ とか 大の写真を出したは良いけど，引っ込めるのはどうするの？ などという問題も発生する可能性も出てきます。 ですから "私は勝手に" ， 「大の写真を非表示(visible=false)にしておいて，ボタンクリックで表示(visible=true)する。」 という方針で行くのが良いのではないかと思います(あくまでも私が思うだけ)。 以下では， その「私の勝手な方針(ストーリー)」を実現する方法を書きます。 ActionScript 3.0 設定 のドキュメントを作成してあるものとします。 そのドキュメントのステージ上の，小の写真ボタンを選択した状態で「プロパティ」パネルを表示させ， そのボタンにインスタンス名を付けます。 ここでは「small_btn」というインスタンス名を付けることにします。 またステージ上の大の写真を選択してムービークリップに変換し， このムービークリップにもインスタンス名を付けます。 ここでは「big_mc」というインスタンス名を付けることにします。 その「small_btn」や「big_mc」があるレイヤーとは別に ActionScript を書くためのレイヤーを作成し そのレイヤーの「small_btn」や「big_mc」が存在するフレーム上のキーフレームに 次のようなスクリプトを書きます。 //----------------------------------------------- //「big_mc」を非表示にする big_mc.visible=false; //「small_btn」をクリックしたとき 関数appearBigMC を実行 small_btn.addEventListener(MouseEvent.CLICK,appearBigMC); //関数appearBigMC の定義 function appearBigMC(evt:MouseEvent):void { //「big_mc」を表示する big_mc.visible=true; } //----------------------------------------------- これで，ムービープレビュー や パブリッシュ してもらうと結果が見えると思います。 人間側に何の方針もなく，PCに向かって「方針も考えろ」というのは酷ですよね。 また逆に， 人間側には方針があるのに，PCが勝手に考えた方針で進んで行くのも困りものですよね。 どっちにしても コードスニペットですべての事が運ばれていくのはおかしい(無理または困る)と思います。
papervision3DをFLEX４-SDKで使用していますが特にパージョンを意識したことはありません。 参考のサイトは（私のブックマークに登録されているところです） PV3D の立体が試せる Primitive Generator 　http://clockmaker.jp/labs/090419_primitive_generator/bin/index.html 　http://troi.kbc-ehime.ac.jp/kj/?p=516 Papervision3Dいろいろ その1 　http://sakef.jp/blog/2010/10/pv3d_samples_01/ Papervision3D で円形とかリングとか表示してみる 　http://www.nilab.info/zurazure2/000678.html Papervision3DTM 2.1 日本語 リファレンスガイド 　http://papervision3d-jp.googlecode.com/svn/trunk/docs/index.html あとpapervision3Dだけでないですがここも参考になると思います 　http://wonderfl.net/ 　　私の作品も入れてあります（http://wonderfl.net/user/hi.kurosawa）
if文 の条件の書き方とかいう問題ではなくて もっと根本的なことで if文 が実行されるタイミングの問題ではないでしょうか？ 書かれていらっしゃる内容だと ルートの3フレーム が表示されたとたんに if文 が実行されます。 そうではないのでは？ if文 が実行されるのは 少なくとも指定秒に達した後でなければなりませんよね？ 例えば テキスト入力変数lmt に 5 と入れた場合は， 少なくとも 5 秒たってから if文 が実行される必要があるでしょう？ そしたらそのようになるようにしなければ...。 ムービークリップ「c_mc」の中はどうなっているのかわかりませんが， 例えば「c_mc」内の 10フレーム に /:cnt++; などと書いてルートの変数cntの値を1ずつ加算していたとします。 そうでしたら その後に if文 を入れるべきでしょう。 例↓ --------------------------------- /:cnt++; if (Number(/:lmt) == /:cnt) { tellTarget ("/") { gotoAndPlay("tokutei"); } } --------------------------------- ※Number(/:lmt) の部分は /:lmt だけでも良いと思いますが 　テキストフィールドの入力値は 　基本的に文字列として扱われてしまうことが多いので 　念のため Number() で数値化しています。 ムービーの構造全体が把握できていないため これで良いかどうかはわかりませんが 路線としてはこのような感じにすべきだと思います。
もうすでに自力で解決されていらっしゃるとは思いますが念のため。。。 このご質問の後にされている質問 「ムービークリップを１コマ飛しで再生」 (OKWave系の代表3サイト) http://okwave.jp/qa/q6787543.html or http://oshiete.goo.ne.jp/qa/6787543.html or http://oshiete1.nifty.com/qa6787543.html などなどなど... ここ↑で書かれていらっしゃる内容(仕様)に従うこととしてよろしいでしょうか？ その場合，次のような感じになると思います。 ステージ上に用意するインスタンスは次の５つであるとします。 「mc」：再生/逆再生などをさせるムービークリップ 「back2_btn」：mc内を高速逆再生させるボタン 「back1_btn」：mc内を逆再生させるボタン 「stop_btn」：mc内の再生を止めるボタン 「next1_btn」：mc内を普通に再生させるボタン 「next2_btn」：mc内を高速再生させるボタン これらが存在するフレームに書くスクリプト例です。 //================================== //早送り時のスピードを設定 (★可変) var high_spd:int = 3; //特殊再生時のスピードの変数の宣言 var spd:int; //---↓back2_btn↓------ //「back2_btn」押下時に 関数onBack2Press を実行 back2_btn.addEventListener(MouseEvent.MOUSE_DOWN,onBack2Press); //関数onBack2Press の定義 function onBack2Press(e:MouseEvent):void { //特殊再生時のスピードを -high_spd にする spd = - high_spd; //共通で使用する関数 commonFunc を実行 commonFunc(); } //---↓back1_btn↓------ //「back1_btn」押下時に 関数onBack1Press を実行 back1_btn.addEventListener(MouseEvent.MOUSE_DOWN,onBack1Press); //関数onBack1Press の定義 function onBack1Press(e:MouseEvent):void { //特殊再生時のスピードを -1 にする spd = -1; //共通で使用する関数 commonFunc を実行 commonFunc(); } //---↓stop_btn↓------ //「stop_btn」押下時に 関数onStopPress を実行 stop_btn.addEventListener(MouseEvent.MOUSE_DOWN,onStopPress); //関数onStopPress の定義 function onStopPress(e:MouseEvent):void { mc.stop(); } //---↓next1_btn↓------ //「next1_btn」押下時に 関数onNext1Press を実行 next1_btn.addEventListener(MouseEvent.MOUSE_DOWN,onNext1Press); //関数onNext1Press の定義 function onNext1Press(e:MouseEvent):void { mc.play(); } //---↓next2_btn↓------ //「next2_btn」押下時に 関数onNext2Press を実行 next2_btn.addEventListener(MouseEvent.MOUSE_DOWN,onNext2Press); //関数onNext2Press の定義 function onNext2Press(e:MouseEvent):void { //特殊再生時のスピードを high_spd にする spd = high_spd; //共通で使用する関数 commonFunc を実行 commonFunc(); } //---↓特殊再生用の関数群↓------ //共通で使用する関数 commonFunc の定義 function commonFunc():void { //毎フレーム 関数specialPlay を実行 mc.addEventListener(Event.ENTER_FRAME,specialPlay); //stageからマウスアップ時に 関数onStageUp を実行 stage.addEventListener(MouseEvent.MOUSE_UP,onStageUp); } //関数specialPlay の定義 function specialPlay(e:Event):void { //spdが正の数で mc内のフレームが最終フレームに達したとき if (spd >= 0 && mc.currentFrame == mc.totalFrames) { //mc内フレームをフレーム1に戻す mc.gotoAndStop(1); //spdが負の数で mc内のフレームがフレーム1に達したとき } else if (spd < 0 && mc.currentFrame == 1) { //mc内フレームを最終フレームに進める mc.gotoAndStop(mc.totalFrames); } //mc内のフレームを spdフレーム 進めて停止 mc.gotoAndStop(mc.currentFrame + spd); } //関数onStageUp の定義 function onStageUp(e:MouseEvent):void { //毎フレーム 関数specialPlay を実行するのをやめる mc.removeEventListener(Event.ENTER_FRAME,specialPlay); //stageからマウスアップ時に 関数onStageUp を実行するのをやめる stage.removeEventListener(MouseEvent.MOUSE_UP,onStageUp); //「mc」内タイムラインの再生を開始 (★要る？) mc.play(); } //================================== 特殊再生である 「高速逆再生」と「逆再生」と「高速再生」は結局どれも同じことをさせています。 メインは関数 specialPlay(エッチなプレーや変態プレーではありません) です。 同じことをさせるのですが， それぞれのボタンによって 関数specialPlay を実行させるときの変数spd(スピード)の値を変えています。 この spd の値だけが違う部分です。 こうしておけば，ほとんど同じ関数を何度も定義する必要がなくなりますよね。
普通に this["sub_base"+i]=new SubTitleBase(); mainBoard_mc.addChild(this["sub_base"+i]); this["sub_base"+i].gotoAndStop(1); ではうまく行かないのでしょうか？ this["sub_base"+i] とは このタイムラインに置いた sub_base0 や sub_base1 など… という変数ですよ。 その sub_base0 や sub_base1 など… という変数に new な SubTitleBase インスタンスの参照を入れるということです。 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html ↑じっくり読んで良く理解しないとわからないと思いますが。。。 というか ActionScript 3.0 になって Flash を始めた方には 何の抵抗も錯覚もないと思いますが それ以前に(ActionScript 2.0 以前に) Flash をしていると その経験や知識が逆に足をひっぱることになって混乱するのかもしれません。
ご提示のスクリプトですと、「停止」ボタン操作で停止した場合は、StopClick 関数内で「変数 soundCh の値を null にする」処理が行われます。 ですから、その後で再度「再生」ボタンをクリックすると、PlayClick 関数内の if 文の条件である「 soundCh の値が null の時」が成立して、サウンドが再生されます。 しかし、曲の最後に達して再生が終了した場合は、soundCh には再生に使用されたチャンネルを操作するための情報が入っています。 この状態で「再生」ボタンをクリックしても、soundCh の値が null ではないために PlayClick 関数内の if 文の条件が成立せず、再生されないのですが、「停止」ボタンをクリックすると soundCh が null に書き換えられて再生できるようになる、というわけです。 最後まで再生された後も再生できるようにするには、曲の最後に達した時にも soundCh の値を null に戻す処理が必要です。 曲の最後に達したかどうかは、SOUND_COMPLETE というイベントを使って検出できます。 soundCh の値を操作して再生中かどうかを判断することも可能ではあるのですが、稼働しているオブジェクトの参照を持っている soundCh の値を null に書き換えてしまうのは、少々乱暴だと思います。 代わりに、再生中かどうかの情報を持つ変数を作り、こちらで判断してはいかがでしょう。 次のように考えます。 再生しているかどうかの情報を管理する変数を１つ、用意します。ここでは仮に、play_flg という名前だとします。 この変数の値を、再生している時 true 、それ以外の時は false と決めます。今回は扱いたい情報が２種類しかないので、Boolean というデータ型にします。 「再生」ボタンがクリックされた時は、この変数の値を見て、false の時だけ再生します。 再生した場合は、再生中の印として true を入れます。すると、再生中に連続してクリックされても再生の条件が不成立になり、重複再生を防ぐことができます。 「停止」ボタンをクリックした時と曲の最後に達した時は、false に書き換えます。 スクリプトの一例です。 ライブラリにリンケージでクラス名”BGM”を設定したサウンドシンボル、ステージにインスタンス名”play_btn”と”stop_btn”と付けたインスタンスがあるものとします。 （↓　各行頭に全角のスペースが入っています。コピーする際は、全て半角のスペースかタブに置き換えてください） //＊＊＊ 　import flash.media.*; 　//再生状況を保持するフラグ 　//再生時true、それ以外はfalse 　var play_flg:Boolean = false; 　//チャンネルとSoundオブジェクトの作成 　var soundCh:SoundChannel; 　var snd:BGM = new BGM(); 　//「再生」ボタンによる再生処理 　function PlayClick( evt:MouseEvent ):void 　{ 　　//停止している場合のみ、再生する 　　if( play_flg == false ) 　　{ 　　　//サウンドを再生 　　　soundCh = snd.play( 0 , 1 ); 　　　//再生が終了した時のイベント処理を登録 　　　soundCh.addEventListener( Event.SOUND_COMPLETE , PlayEnd ); 　　　//再生中であることを記録する 　　　play_flg = true; 　　} 　} 　//「停止」ボタンによる停止処理 　function StopClick( evt:MouseEvent ):void 　{ 　　//再生中であれば停止する 　　if( play_flg == true ) 　　{ 　　　//サウンドを停止 　　　soundCh.stop(); 　　　//再生終了時のイベント処理を削除しておく 　　　soundCh.removeEventListener( Event.SOUND_COMPLETE , PlayEnd ); 　　　//停止したことを記録する 　　　play_flg = false; 　　} 　} 　//再生が終了した時の処理 　function PlayEnd( evt:Event ):void 　{ 　　//フラグをリセット 　　play_flg = false; 　} 　//各ボタンのイベント処理を登録 　play_btn.addEventListener( MouseEvent.CLICK , PlayClick ); 　stop_btn.addEventListener( MouseEvent.CLICK , StopClick ); //＊＊＊
そもそも書かれていらっしゃるサイトのスライドショーは Suzuka とも Flash とも関係なくて JavaScript の jQuery を使用したものですがそこのところはよろしいのでしょうか？？？ 【jQuery を使用参考サイト例】 「画像をフェードインさせるスライドショーを作ってみた」 http://likearpeggio.blog63.fc2.com/blog-entry-197.html 以下では jQuery を使わず Suzuka を使って似たような Flash を作成する方法を回答します。 ＝＝＝ ＝＝＝ ＝＝＝ まずファイル構造が次のようになっているとします。 　任意のフォルダ 　　　├○○.html (○○.swf を貼り付ける) 　　　├○○.swf (作成する Flash ファイル) 　　　└image (フォルダ) 　　　　　├pic1.jpg 　　　　　├pic2.jpg 　　　　　├pic3.jpg 　　　　　├pic4.jpg 　　　　　└pic5.jpg 外部JPEG(pic1.jpg～pic5.jpg) は同じ縦横サイズであるとします。 Suzuka を起動させ、 [ファイル]→[プロジェクトのプロパティ]で「プロジェクトのプロパティ」パネルを表示させて 「基本設定」で「幅」と「高さ」をJPEGと同じ大きさにします。 また 同じパネルの「SWFバージョン」で「SWF8」を選択します。 そして[ファイル]→[名前を付けて保存]で上記の「任意のフォルダ」に任意の名前でプロジェクトファイル(.csf)を保存します。 Suzukaの編集画面のタイムライン(レイヤー名称の部分)を選択し [右クリック]→[アクションレイヤーを挿入]より、ActionScript を記述用のレイヤーを挿入します。 そのアクションレイヤーのフレーム1を選択して Suzukaの編集画面の右下の方にある [スクリプトを編集] ボタンをクリックし 出てくるスクリプトエディタパネルに次のようなスクリプトを書きます(コピペ可)。 //================================= //JPEGの枚数の設定 var max_n = 5; //JPEGフェードインのスピードを設定 var spd = 4; //JPEGフェードイン後の完全表示時間(秒)を設定 var sec = 2.5; //---以上が適当に変える設定--- //空のMC(ムービークリップ)mc0と1を 深度0と1に作成 this.createEmptyMovieClip("mc0", 0); this.createEmptyMovieClip("mc1", 1); //MovieClipLoaderを作成 var mcl = new MovieClipLoader(); //ロード監視用にするObjectを作成 var obj = new Object(); //JPEGロード完了時に実行するメソッドを定義 obj.onLoadInit = function(target_mc) { // //JPEGをロードしたMCを透明にする target_mc._alpha = 0; //JPEGをロードしたMCの深度を1(上側)にする target_mc.swapDepths(1); // //JPEGをロードしたMCに毎フレーム実行するメソッドを定義 target_mc.onEnterFrame = function() { //MCをspdずつ不透明にして行く this._alpha += spd; //MCが完全不透明になったら if (this._alpha>=100) { //指定秒後に関数loadJPEGを実行 setTimeout(loadJPEG, sec*1000); //この毎フレーム実行するメソッドを削除 delete this.onEnterFrame; } }; }; //objをmclのリスナー(監視人)として登録 mcl.addListener(obj); //カウント用変数の初期化 var j_num = 0; var m_num = 0; //関数loadJPEGの定義 function loadJPEG() { //各カウント用変数のカウントアップ j_num = (j_num<max_n) ? j_num+1 : 1; m_num = (m_num == 0) ? 1 : 0; //外部JPEGをロード mcl.loadClip("image/pic"+j_num+".jpg", "mc"+m_num); } //関数loadJPEGを初回実行 loadJPEG(); //================================= あとは [ウィンドウ]→[プレビュー]してみるとか または [ファイル]→[SWFファイル生成]でSWFを上記の「任意のフォルダ」に書き出してもらうと出来上がりです。 なお、 [ツール]→[オプション]で出てくる「オプション」パネルの「全般」タブにある「パブリッシュ設定」の項目の欄で 　□ HTMLファイルも保存する にチェックを入れておいて [SWFファイル生成] をすると、 上記の「任意のフォルダ」にはSWFファイルとともに、それが貼り付いたHTMLが書き出されます。 全体的には SWF6 以上で使用可なスクリプトばかりですが MovieClipLoader が SWF7 以上、setTimeout が SWF8 以上でのみ使用可であるため 結局 SWF8 のFlashファイルを書き出す必要があります。 （SWF8 ＝ Flash Player 8 以上用の SWF） また SWF8 にした場合、 外部画像ファイルは普通の JPEG 以外にも、プログレッシブJPEG や 静止GIF や PNG のロードが可能になります。 写真(JPEG)の枚数を変える方法はわかると思いますが、 例えば、写真(JPEG)を100枚にしたい場合は imageフォルダ内に pic1.jpg～pic.100jpg を用意した上で 上記スクリプトの最初の var max_n = 5; の部分を var max_n = 100; に変えると写真の枚数を変更できます。 ※※※注意※※※ //外部JPEGをロード mcl.loadClip("image/pic"+j_num+".jpg", "mc"+m_num); この部分で "image/pic"+j_num+".jpg" のように指定しているJPEGへのファイルパスは SWFからではなくHTMLからのパスです。 ファイル構造変更の際には注意してください。 ---変更例--- 　任意のフォルダ 　　　├○○.html (○○.swf を貼り付ける) 　　　└image (フォルダ) 　　　　　├○○.swf (作成する Flash ファイル) 　　　　　├pic1.jpg 　　　　　├pic2.jpg 　　　　　├pic3.jpg 　　　　　├pic4.jpg 　　　　　└pic5.jpg 上のように変更した場合も JPEGへのファイルパスの部分は "image/pic"+j_num+".jpg" このままで変更なしです。 (HTMLから見たJPEGの位置は変更していないため)
次の２つのうちどちらかでできると思います。 ２つの違いは，最初のデータをどのように用意するかの違いです。 ---------------------------------------------------------- //とりあえず文字列を 変数str1 と str2 に分けて用意する(?) var str1:String='<font color="#cc0033">Laid off</font> a lot of workers.'; var str2:String='They <font color="#cc0033">laid</font> us <font color="#cc0033">off</font> for a month.'; //関数getStrの定義(引数s：文字列) function getStr(s:String):void { // //引数 sを 「</font>」で区切った配列1を作成する var arr1:Array=s.split('</font>'); // //配列2を作成する var arr2:Array = new Array(); // //配列 arr1 の要素数-1 ループさせる for (var i:int = 0; i < arr1.length-1; i++) { //配列arr1の各要素を「>」で区切った配列3を作成する var arr3:Array=arr1[i].split(">"); //配列3の最後の要素をつなげた配列2にする arr2.push(arr3[arr3.length-1]); } // //arr2を出力させてみる trace(arr2); } //関数getStrを実行(引数ｓｔｒ１) getStr(str1); //関数getStrを実行(引数ｓｔｒ１) getStr(str2); ---------------------------------------------------------- ---------------------------------------------- //とりあえず分けない文字列全文を用意する(?) var str:String='<font color="#cc0033">Laid off</font> a lot of workers.They <font color="#cc0033">laid</font> us <font color="#cc0033">off</font> for a month.'; //strを「.」で区切った配列arrを作成 var arr:Array=str.split('.'); //arrの要素数分ループ for (var i:int = 0; i<arr.length; i++) { //関数getStrを実行(引数arr[i]) getStr(arr[i]); } //関数getStrの定義(引数s：文字列) function getStr(s:String):void { // //引数 sを 「</font>」で区切った配列1を作成する var arr1:Array=s.split('</font>'); // //配列2を作成する var arr2:Array = new Array(); // //配列 arr1 の要素数-1 ループさせる for (var i:int = 0; i < arr1.length-1; i++) { //配列arr1の各要素を「>」で区切った配列3を作成する var arr3:Array=arr1[i].split(">"); //配列3の最後の要素をつなげた配列2にする arr2.push(arr3[arr3.length-1]); } // //arr2を出力させてみる trace(arr2); } ----------------------------------------------
＞ローカルでは正常でも、アップするとおかしくなることってあるのでしょうか ローカルでエラーになっても、サーバーにアップすると、正常稼働する事例 http://oshiete.goo.ne.jp/qa/5561564.html ローカル環境上では相対パスで静的ファイルが取得できるのに対し、サーバ上では相対パスでの***による静的ファイルの取得は不可
確かに分かりずらいご質問ですね...。 なぜかと言うと 「A.b.addEventListener...を b.addEventListener...に変更」 「オブジェクトの重なり順を変更する」 「Aの中にあるbをAのBOXから出す」 この３つは，基本的には全く別のことだからです。 ３つとも全てに回答すれば そのうちのどれかが求めていらっしゃることに当たるかもしれません。 以下ではすべて， はじめに次のようなタイムライン階層になっているものとします。 　スクリプトを書く階層(＝this) 　　　└A(ムービークリップ) 　　　　　　└b(ムービークリップ) ※ A 内の c は登場しないようなので略します。 ＝＝＝ ＝＝＝ ＝＝＝ (1)A.b.addEventListener...を b.addEventListener...に変更 ActionScript 3.0 では， ムービークリップにインスタンス名を付けると言っても 結局のところインスタンスは「変数」で管理するようになっています↓。 ・[AS3] MovieClipインスタンスとインスタンス名 http://f-site.org/articles/2008/04/19014939.html したがって > A.b.addEventListener.....とアクセスするのを、 > b.addEventListener....で、アクセス出来るように変更 これは簡単なことで 次の１行のスクリプトを書けば良いだけです。 ------------------------------- //変数「b」に 「A」内の「b」の参照を代入 var b:MovieClip = A.b; ------------------------------- これで本当にできているのか， 「制御」→「ムービープレビュー」で検証する用のスクリプトも書いておきます。 ------------------------------- //変数「b」に 「A」内の「b」の参照を代入 var b:MovieClip = A.b; //「b」クリック時に 関数bClick を実行 b.addEventListener(MouseEvent.CLICK,bClick); //関数bClick の定義 function bClick(e:Event):void { //「b」のインスタンス名でも出力させてみる trace(e.currentTarget.name); } ------------------------------- (2) オブジェクトの重なり順を変更する 重なり順とはZ軸の表示順序で， ActionScript 1.0/2.0 時代の名残かもしれませんが深度とも言われます。 ・ActionScript 3.0「深度」 http://www.yosukesugahara.com/diary/actionscript-30/actionscript-30-15.html ・AS3.0リンケージ深度やレイヤー階層 http://d.hatena.ne.jp/jedisystemer/20100113/1263398269 上記ページなどに書いてあるように， 重なり順は setChildIndex や swapChildren などで変えます。 「A」内の「b」を，「A」の箱から出したように見せるには 次のようにして「A」内での「b」の重なり順を一番上にしても良いでしょう。 ------------------------------- //「A」内の最高深度を取得 var h_depth:int = A.numChildren - 1; //「A」内の「b」を「A」内の最高深度にする A.setChildIndex(A.b, h_depth); ------------------------------- 下の添付図↓は， 上記スクリプトを実際に確かめてみた様子です。 添付図のようなものを作成した場合， 「A」内の「b」が，「A」内に描いた箱の外(上)に表示されるようになります。 (3) Aの中にあるbをAのBOXから出す つまりインスタンス自体のタイムライン階層を 次のように↓変更するということですね。 　スクリプトを書く階層(＝this) 　　　├b(ムービークリップ) 　　　└A(ムービークリップ) これは ActionScript 2.0 まではできなかったことなのですが ActionScript 3.0 では概念が変わったため簡単にできます。 たった１行です↓。 ------------------------------- //この階層に「A」内の「b」を配置 this.addChild(A.b); ------------------------------- (1)～(3) の３通りの回答をしてみました。 ここまで書いて思うのですが， 仮に (3) の「Aの中にあるbをAのから出す」が求めていらっしゃることだったとします。 しかし (3) をしても (1) の「A.b.addEventListener...を b.addEventListener...に変更」 をしたことにはなりません。 次のように試してみるとわかります。 「bなど存在しないよ！」という内容のエラーが出ると思います。 ------------------------------- //この階層に「A」内の「b」を配置 this.addChild(A.b); //「b」クリック時に 関数bClick を実行 b.addEventListener(MouseEvent.CLICK,bClick); //関数bClick の定義 function bClick(e:Event):void { //「b」のインスタンス名でも出力させてみる trace(e.currentTarget.name); } ------------------------------- なぜエラーが出るのかという理由は (1) で書いたURLページの説明にある通りで 「b」という変数がスクリプトを書いた階層に存在しないからです。 したがって (1) と (3) の両方をする場合は (1) のことも (3) のことも両方ともしなければならないということになります。 (1) と (3) とは全く別のことですから。↓ ------------------------------- //変数「b」に「A」内の「b」の参照を代入 var b:MovieClip = A.b; //この階層に変数「b」が参照するMCを配置 this.addChild(b); //「b」クリック時に 関数bClick を実行 b.addEventListener(MouseEvent.CLICK,bClick); //関数bClick の定義 function bClick(e:Event):void { //「b」のインスタンス名でも出力させてみる trace(e.currentTarget.name); } ------------------------------- 長くなりましたが以上です。
次のページを良く読んでしっかり理解してみてください。 「FN0205002 - gotoAndPlay-gotoAndStopでシーンの移動ができない」 http://www.fumiononaka.com/TechNotes/Flash/FN0205002.html
Flash Player 10あたりからセキュリティが厳しくなって外部サーバにアクセスする事が出来なくなりました。 外部サーバにアクセスするためには、外部サーバに「crossdomain.xml」ファイルをおかなくてはいけません。 「crossdomain.xml」についてはここで下手に書くより検索したほうが分かりやすいので検索してください。 ただ注意として「crossdomain.xml」の仕様も途中で変更になって（？） 外部サーバのディレクトリ指定を開放したいときは、開放ディレクトリと外部サーバのWEBルートの2箇所に置くと書いてあるほうが新しいようです。
まず最初の， ブロックのMCをステージ上に並べるスクリプトの方も あまりよろしくないですね。 ActionScript 3.0 では， インスタンスのインスタンス名はどうでも良くて， インスタンスはそれを参照する変数で管理するのが普通です。 なぜそうなのか， 次のページを良く読んで内容を理解してみてください↓。 「F-site [AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html それと， eval は ActionScript 2.0 時代にはすでに普通は使われていませんでしたよ。。。 使っていたのは Flash 5 時代くらいだけで， MXの頃からAdobe(当時Macromedia)も eval の使用はあまり推奨していなかったこともあり， 使えたとしても使わないのが普通でした(使えない場合もあるので使わない)。 eval の代わりに「配列アクセス演算子」を使うのが普通でした。 「FN0507001 - ドット演算子と配列アクセス演算子 - Flash 」 http://www.fumiononaka.com/TechNotes/Flash/FN0507001.html 以上の２点のことより， ブロックのMCをステージ上に並べるスクリプトは 次のようにするのが良い(手間が少ない）と思います。 (メインのタイムラインのフレームに書く場合) ------------------------------ for (var i:int = 0; i<32; i++) { this["block" + i] = new block_class(); this["block" + i].x = i % 4 * 40 + 40; this["block" + i].y = Math.floor(i / 4) * 15 + 25; this.addChild(this["block"+i]); } ------------------------------ これで 上記スクリプトをメインのフレームに書いた場合 this(この場合root) には 変数「block0」～「block32」が作成されるのと同時に それら各変数には呼び出された各ブロックMCへの参照が代入されます。 ちなみに addChild するのは(インスタンス本体を配置するのは)， stage ではなく，上記のように this(root) の方が都合が良いように思います。 ActionScript 3.0 では this(root) は stage の 子 です。 上記スクリプトをメインのフレームに書いた場合， そのスクリプトの居場所も this(root) になります。 スクリプトの居場所 this(root) よりも上位階層にインスタンスを配置するのは， それなりの理由と，それなりの意識(そのことを忘れずに意識をしておくこと)が必要だと思います。 　 　 次に，当たり判定→MC削除 の部分です。 上のスクリプトでブロックのMCを呼び出した場合， ご質問のスクリプトのように 「ボールがブロックに当たったら消える(=非表示にする)」 ということをする場合は， 次のようにすれば消えます。 ------------------------------ for (var i = 0; i<32; i++) { if (ball_mc.hitTestObject(this["block" + i])) { this["block" + i].visible = false; } } ------------------------------ そうではなくて 「ボールがブロックに当たったら消える(=ステージ上から削除する)」 という場合は次のようになります。 ------------------------------ for (var i = 0; i<32; i++) { if (this["block" + i] != null) { if (ball_mc.hitTestObject(this["block" + i])) { this.removeChild(this["block" + i]); this["block" + i] = null; } } } ------------------------------ ちなみに... ついでなので，この回答に際して動作検証するために私が作ったサンプルのスクリプト全文を書いておきます。 一応，FLAのメインのタイムラインのフレーム1に書いたスクリプト例です。 ステージ上の右下の方には 直径 20px ほどの円い塗り入りのムービークリップ「ball_mc」を置いています。 「ball_mc」を自力ドラッグしてブロックを消してみるという，単なる検証用だけのためのスクリプトです。 ------------------------------ for (var i:int = 0; i<32; i++) { this["block" + i] = new block_class(); this["block" + i].x = i % 4 * 40 + 40; this["block" + i].y = Math.floor(i / 4) * 15 + 25; this.addChild(this["block"+i]); } //「ball_mc」をマウスで押したとき 関数onBallPressを実行 ball_mc.addEventListener(MouseEvent.MOUSE_DOWN,onBallPress); //関数onBallPressの定義 function onBallPress(e:MouseEvent):void { //「ball_mc」のドラッグを開始 e.currentTarget.startDrag(); } //マウスをアップしたとき 関数onBallReleaseを実行 stage.addEventListener(MouseEvent.MOUSE_UP,onBallRelease); //関数onBallReleaseの定義 function onBallRelease(e:MouseEvent):void { //「ball_mc」のドラッグを停止 ball_mc.stopDrag(); } //マウスが動くごとに 関数removeBallを実行 this.addEventListener(MouseEvent.MOUSE_MOVE,removeBall); //関数removeBallの定義 function removeBall(e:MouseEvent):void { for (var i = 0; i<32; i++) { if (this["block" + i] != null) { if (ball_mc.hitTestObject(this["block" + i])) { this.removeChild(this["block" + i]); this["block" + i] = null; } } } } ------------------------------ 　
Timerクラス や setInterval や setTimeout や ENTER_FRAME は， 「だいたい○秒間隔で△を実行する」 というような感じで 何かのイベントをだいたいの時間で定期的に行うものであって， そもそも時間を測るものではありません。 本業は "時間計測" ではなく "イベント実行" です。 時間の間隔を測るのでしたら普通は getTimer を使います。 数時間とか数日間とかすごく長い時間間隔を測る場合は Date の getTime を使う方が正確です。 (実際にはそんなに長時間同じSWFを表示させ続けることはないと思いますが。) ENTER_FRAME で getTimer や Date.getTime を実行しさせて時間を取得します。 上にも書きましたが， ENTER_FRAME 自体はすごくイイカゲンですよ。 でも ENTER_FRAME はイイカゲンでも良いのです。 実行間隔はイイカゲンでも，その実行時の正確な時間を取得出来れば良いのですから。 ※仮にフレームレートを 30fps に設定していたとして 　 処理が重くなって 10fps になったとしても 　 それは実行間隔が間延びするというだけの話で 　 それと実際の時間とは全く関係がないのですから 　 正確な時間さえ取得できれば 　 相対誤差は１秒未満で納まるでしょう？ 　 という意味です。 ※パソコンの時計でも１秒の刻み(表示間隔)は 　 すごくゆらいでいてイイカゲンです。 　 １秒の刻み(表示間隔)はイイカゲンでも 　 そのときに取得する時刻が正確であれば 　 時計として使えます(現に使っています)。 AS3の新規ドキュメントを作成して メインのタイムラインのフレーム1に書くスクリプト例です↓。 //==================================== //---以下動作検証のための下ごしらえ----- var my_txt:TextField = new TextField(); my_txt.x = my_txt.y = 10; my_txt.width = 100; my_txt.height = 20; my_txt.background = true; my_txt.border = true; my_txt.text = "スタート"; // var my_ｆmt:TextFormat = new TextFormat(); my_ｆmt.align = TextFormatAlign.RIGHT; my_ｆmt.font = "_等幅"; my_txt.setTextFormat(my_ｆmt); // addChild(my_txt); //---以上動作検証のための下ごしらえ----- //クリック時の時間を代入する変数を宣言 var old_time:Number; //my_txtプレス時に関数startTimerを実行 my_txt.addEventListener(MouseEvent.MOUSE_DOWN,startTimer); //関数startTimerを定義 function startTimer(e:MouseEvent):void { //クリック時の時間を保存 old_time = getTimer(); //毎フレーム時間ごとに関数getTimeを実行 this.addEventListener(Event.ENTER_FRAME,getTime); } //関数getTimeの定義 function getTime(e:Event):void { //今現在の時間を取得 var new_time:Number = getTimer(); //クリック時～今現在の経過時間を取得 var past_time:Number = new_time - old_time; //経過分数の取得 var past_min:Number = Math.floor(past_time/(60*1000)); //経過秒数の取得 var past_sec:Number = Math.floor((past_time- past_min*(60*1000))/1000); //経過百分の1秒数の取得 var past_csec:String = (("0" + new_time).substr(-3,3)).substr(0,2); // ～分○○秒○○ の表示 my_txt.text = past_min + "分" + ("0" + past_sec).substr(-2,2) + "秒" + past_csec; } //==================================== SWFを表示させて [　スタート] をクリック(プレス)してもらうとタイマーがスタートします。 家の時計などで正確さを調べてみてください。 私の環境だと， 色々他の作業をしながら30分間測ってみて 誤差は１秒以内でした(小さすぎて正確な誤差がわからない。) 数時間以上計測するとおそらく数秒ほど誤差が出てくると思います(かなり昔に実験したことがあるだけで，今のFlashPlayerでも出るかどうかはわかりませんが)。 もし誤差が出てその誤差も取りたい場合は スクリプト中の //クリック時の時間を保存 old_time = getTimer(); や //今現在の時間を取得 var new_time:Number = getTimer(); の部分を //クリック時の時刻を保存 var old_date:Date = new Date() old_time = old_date.getTime(); や //今現在の時刻を取得 var new_date:Date = new Date() var new_time:Number = new_date.getTime(); に変えてもらうと， 長時間でも正確なタイマーになります。 (大袈裟なのでこちらはあまり使われませんが。。。) 実際にはテキストフィールドに経過時間を表示させるのではなくて， 例えば 「past_time が 1800000ミリ秒(30分) 以上になれば○○を実行」 のような感じになるようにすれば良いということになります。
＃１です。 > （なおかつずっと回転しておいてほしいです。） ここを読ませてもらって ただ単にずっと回転しているだけでしたら簡単(回答しやすい)と思い， 以下を考えてみました。 設定が ActionScript 3.0 の Flash CS3 ドキュメントのステージ上に 絵または写真が7枚あったとします。 絵または写真の大きさは適当で良いですが， 一応，横：120px 縦：180px 辺りを想定しています。 その7枚の絵または写真を，個別に７つのMC(ムービークリップ)に変換します。 MCに変換するときに，基準点が中央になるように設定してMCに変換します。 変換した７つのMCにはそれぞれ 「card0」「card1」「card2」「card3」「card4」「card5」「card6」 というインスタンス名を付けます。 それらMCのあるレイヤーとは別にスクリプトを記述する用のレイヤーでも挿入します。 ※参考【図】↓ そのスクリプト用のレイヤーのフレーム1に書く(コピペする)， ActionScript 3.0 のスクリプト例です↓。 //================================= //カードの枚数の設定 var crd_n:int = 7; //回転の中心座標の設定 var cnt_x:Number = 250; var cnt_y:Number = 150; //回転半径の設定 var rtt_r:Number = 180; //偏平率の設定 var rat_y:Number = 4 / 10; //回転スピードの設定(例：100分の1周ずつ) var spd:Number = 1 / 100; //遠くのカードのボケ度合いを設定 var blr = 15; //---以上が変更する設定--------- //回転する周数の初期化 var rtt_s:Number = 0; for (var i:int=0; i<crd_n; i++) { this["filter" + i] = new BlurFilter(10,10,BitmapFilterQuality.MEDIUM); } //毎フレーム時間で関数rotateCardを実行 this.addEventListener(Event.ENTER_FRAME, rotateCard); //関数rotateCardの定義 function rotateCard(e:Event=null):void { //各カードの位置と大きさを算出 for (var i:int=0; i<crd_n; i++) { this["card" + i].x = Math.cos((2*Math.PI/crd_n)*i+rtt_s*Math.PI)*rtt_r+cnt_x; this["card" + i].y = Math.sin((2*Math.PI/crd_n)*i+rtt_s*Math.PI)*rtt_r*rat_y+cnt_y; var rdc:Number = (Math.sin((2*Math.PI/crd_n)*i+rtt_s*Math.PI)+4)/5; this["card" + i].scaleX = this["card" + i].scaleY = rdc; this["filter" + i] .blurX =this["filter" + i] .blurY = (1-rdc)*blr; this["card" + i].filters = [this["filter" + i]]; } //表示順序を変えるための配列を作成 var dps_arr:Array = new Array(); //配列の各要素に オブジェクト{MC，MCのｙ座標} を代入 for (i=0; i<crd_n; i++) { dps_arr[i] = {mc:this["card" + i],mc_y:this["card" + i].y}; } //MCのｙ座標 をキーにして配列の要素をソート dps_arr.sortOn("mc_y",Array.NUMERIC); //各カードの表示順を指定 for (i=0; i<crd_n; i++) { this.setChildIndex(dps_arr[i].mc, i); } // //回転周数にspdの値を加算 rtt_s += spd; } //関数rotateCardを即実行 rotateCard(); //================================= 一旦，何も考えずパブリッシュしてみます。 そして 配置場所やその他色々なものが変であれば(作りたいものは人によって違うので普通は変だと思う)， //---以上が変更する設定--- よりも上の数値を変更してもらうと， ある程度のことがカスタマイズできると思います。 Math.PI(パイ(π)) は，中学数学(小学算数？)くらいで出てくる円周率です。 sin(サイン)，cos(コサイン)は，高校の数学で出てくる三角関数です。 また Math.sin() や Math.cos() の () 内に入れる引数は，弧度(radian)です。 この辺も高校数学で習うはずです。 少なくともこの辺の数学を理解していないと， ActionScript をいくら説明しても内容の理解は不可能だと思います。 一応， ActionScript や 数学の理解は不可能でも //---以上が変更する設定--- より上を変えることによって使えるようにしたつもりです。 ちなみに関係ありませんが スクリプト中に出てくる「BlurFilter(ぼかしフィルター)」は， 私の名(BlurFiltan)の由来となっています。 Flash 8 で 「BlurFilterクラス」 が登場して感動したのでこれを捩った名にしました。 (今まで薄っペラだった Flash で空気感が表現できるようになったー！！ と感動した。) (情緒 とか 風情 とかも表現しやすくなった。)
そもそもそういうページは見ないと思いますが。。。 確認ですが，フルスクリーンというのは， ActionScript 3.0(Flash Player 9.0)になってできるようになった stage.displayState = StageDisplayState.FULL_SCREEN; を使うフルスクリーンのことですよね？ Stage - ActionScript 3.0 言語およびコンポーネントリファレンス →「displayState」 http://help.adobe.com/ja_JP/AS3LCR/Flash_10.0/flash/display/Stage.html#displayState 　～↓引用↓～ > フルスクリーンモードは、マウスクリックまたは > キー操作に対応して開始されます。 > ムービーでは、ユーザー入力なしに > Stage.displayState を変更できません。 「AS3で画面いっぱい（フルスクリーン）で表示させる方法」 http://hisasann.com/housetect/2008/07/as3.html 　～↓引用↓～ > ただし > フルスクリーン表示の切り替えは、セキュリティの都合上 > ユーザーが意図せずに行われるべきではないという事で、 > 必ずマウスイベント中か、キーボードイベント中に > 記述する必要があります。操作していないときに > プロパティを変更しても何も起こりません。 というわけですから， "ネット上のSWFを閲覧する場合" は， プレーヤーに表示されるフルスクリーンボタンを押すこと無く ページもしくはSWFをフルスクリーン状態で開くことはできません。 代替案としては， ご質問で書かれていらっしゃるHTMLコードの width="1920" height="1080" の部分(２箇所)を width="100%" height="100%" に変更した上で JavaScript によってウィンドウのサイズをモニターのサイズにリサイズすることくらいが考え付く案です。 「ウィンドウのサイズをモニターのサイズに合わせる - JavaScript」 http://javascript.eweb-design.com/0505_mnt.html ===ちなみに================== ネット上ではなく "ローカルのプロジェクタファイル(EXEなど)を閲覧する場合" なら， 表示されるフルスクリーンボタンを押すこと無く最初からフルスクリーン状態で開くことはできますよ。 Flash( SWF を作成する FLA)の メインのタイムラインのフレーム1の最初の行辺りに fscommand("fullscreen", "true"); と書いて プロジェクタファイル(EXEなど)をパブリッシュすれば良いだけです。 プロジェクタファイル(EXEなど)は 「ファイル」→「パブリッシュ設定」で「形式」タブを選択し， 　□ Windows プロジェクタ(exe) や 　□ Macintosh プロジェクタ にチェックを入れてパブリッシュすれば書き出されます。
状況がよくわかりませんが...前置きとして。 例えば テキスト入力 の テキストフィールド に A～Z の文字しか入力させないようにするのでしたら簡単なことで 仮にテキストフィールドに「my_txt」というインスタンス名を付けた場合 その 「my_txt」 が存在するフレームに my_txt.restrict = "A-Z"; と書けば良いだけですが， こういう状況であるとか， もしくはこの方法を何らかの形で使えるような状況ではないということですね？ ＝＝＝ ＝＝＝ ＝＝＝ あとよくわからない状況としては， > 動作が遅くなるのではないかと思ったのですが、 > onClipEvent(enterFrame)に記述してみました。 と書かれていらっしゃいますが，この結果を書かれていません。 onClipEvent(enterFrame)に記述をした結果 日本語入力オフ の件だけはクリアできたのではないでしょうか？ 日本語入力オフ の件もクリアできなかったのでしょうか？ 動作が遅くなるなどの副作用を除けば，基本的にその方法で問題点はクリアされると思いますが。。。 それと ActionScript2.0，Flash8 でしたら 普通， onClipEvent(keyDown) などは使いません。 Flash 5 (ActionScript 1.0 の初期) くらいのみで使われていたものです。 そもそも 「キーの監視に何の関係もないムービークリップを作成する」 というのが変(不自然)ですよね。 Flash 5 のときはムービークリップ以外にインスタンスらしいインスタンスが存在しなかったため， 何でもかんでもムービークリップにさせていたという変なものです。 なぜこのようなことを書くのかというと onClipEvent(enterFrame) には， それを書いたムービークリップがステージ上から消えるまで解除できないという欠点があるからです。 私としては， まず onClipEvent(enterFrame) を消したいのですが それだけだと統一感がなくなるため， 同時に onClipEvent(keyDown) も消したいわけです。 onClipEvent(enterFrame) を解除することができれば， 動作が遅くなるなど無駄なCPUの使用は防げますよね。 というわけで 次のスクリプトが考えてみた解決策案です。 例えば_rootのフレーム1などのフレームに書くスクリプト例です。 新規ドキュメントを作成した場合は フレーム1にコピペして即パブリッシュやムービープレビューするだけですぐ動作検証できます。 //====================================== //---検証用テキストフィールドの作成------ var my_txt:TextField = createTextField("txt", 0, 10, 10, 20, 20); my_txt.border = true; my_txt.background = true; my_txt.selectable = false; //---↑質問本題とは直接関係なし↑----- //キー監視用にするインスタンス「key_obj」を作成 var key_obj:Object = new Object(); //キーを押したときに実行する動作を定義 key_obj.onKeyDown = function():Void { //キーコードを取得 var key_cd:Number = Key.getCode(); // //キーコードが65以上90以下である場合 if (key_cd>=65 && key_cd<=90) { //そのキーの文字を検証用テキストフィールドに表示 my_txt.text = String.fromCharCode(key_cd); } else { //それ以外は検証用テキストフィールドを空にする my_txt.text = ""; } // //毎フレーム実行する動作を定義 _root.onEnterFrame = function():Void { //もしシステム IME が有効であれば if (System.IME.getEnabled()) { //システム IME を無効にする System.IME.setEnabled(false); } //毎フレーム実行する動作を削除 delete _root.onEnterFrame; }; }; //Keyクラスのリスナーとして「key_obj」を登録 Key.addListener(key_obj); //====================================== 　◎仕様 　 スクリプト：ActionScript 2.0 　 プレーヤー：Flash Player 8 以上 　 (System.IME.* が Flash Player 8 以上でしか 　 使えないため。 　 これを除けば Flash Player 6 以上で動作する。) CapsLock状態になっても，半角/全角キーを押されても， テキストフィールドには「A」～「Z」しか表示されないと思います。 「○○.onEnterFrame = function(){}」 内で 即 「delete ○○.onEnterFrame」 をするのは このご質問の場合に限らずスクリプトの実行を １フレーム時間 遅延させるときに良く使われる手法です。 使用例(参考まで)↓ 「MovieClip.attachMovieで配置したMovieClipのfunctionが実行されない」 http://www.fumiononaka.com/TechNotes/Flash/FN0307006.html 　～引用～ > 'function'の呼出しを1フレーム待たせるために、処理を > 'MovieClip.onEnterFrame'イベントハンドラメソッドに > 設定しています。 　…中略… > 配置から1フレーム遅れた処理になります。 その他 「イベントハンドラメソッドはdeleteで消せ!」 http://f-site.org/articles/2004/05/22140833.html
＃１で回答した者です。 ＃１の回答では > if( loop_cnt == undefined || loop_cnt>mcimg._totalframes) > {loop_cnt = 1;} これがご質問の本題に関係があるものとして そこからムービーの構造やしくみを私が勝手に想像した上での回答です。 仮にご質問中の > if( loop_cnt == undefined || loop_cnt>mcimg._totalframes) > {loop_cnt = 1;} これはなかったものとします。 そして > （flashを途中から再生させる→ループで頭に戻る > →その後はそのまま全てのタイムラインをループ） だけにシンプルに答えるとします。 その場合はスクリプトを次のようにすれば良いと思います。 再生させるタイムラインのフレーム1に書くスクリプトです。 (_rootを再生させるなら_rootのタイムラインのフレーム1に書くスクリプトです。) (ムービークリップ内を再生させるならムービークリップ内のタイムラインのフレーム1に書くスクリプトです。) ----------------------------------- //再生開始フレームを設定(4は例えばの例) var start_frm = 4; //もし変数 play_flag が未定義であれば if (play_flag == undefined) { //変数 play_flag を true と定義 var play_flag = true; //このタイムラインをこのフレームで停止 this.stop(); //---ロード待ち処理------ //毎フレーム実行するメソッドを定義 this.onEnterFrame = function() { //このタイムラインが指定フレームまでロードされたら if (this._framesloaded>=start_frm) { //指定フレームより再生開始 this.gotoAndPlay(start_frm); //毎フレーム実行するメソッドを削除 delete this.onEnterFrame; } }; } ----------------------------------- ＃１ と同じく，一応 Flash MX 以上(MX，MX2004，8，CS3，CS4，CS5，CS5.5 のいずれか)をお持ちで ActionScript 1.0 (または 2.0) を使う設定で Flash Player 6 以上用の SWF をパブリッシュするものと想定しています。
肝腎なバージョンを書いてくださらないと 回答不可能か困難になる場合が多いですよ...。 ガサゴソと探してみましたが 既存のもので「SteelExternalAll」というスキンは ActionScript 3.0 用コンポーネントには存在しないようです。 ということは Flash 8 とか Flash MX 2004 で ActionScript 2.0 用コンポーネントを使用しようとされているということでしょうか？？？ よくわからないので勝手にそういうこととします。 パスを相対パスで指定する場合 親SWFにロードする子SWFやJPEGなどのパスは 親SWFを起点としたパスではなくHTMLを起点としたパスになります。 これはFLVとは関係なくて動画以外のファイルはいつもそうです。 つまり loadMovie() や LoadVars.load() や MovieClipLoader.loadClip() や loadVariables() や getURL() などで書くパスは 全て HTML を起点としたパスになります。 なぜそうなのかと言うと loadMovie() などなどの命令文は ブラウザに対するリクエストだからです。 ブラウザはHTMLを表示しているので(ブラウザの居場所はHTMLの場所なので)，HTMLからのパスになります。 FLVなどの動画だけが例外(すごく特殊なもの)だと思った方が良いです。 FLVなどの動画だけはSWFを起点としたパスを指定します。 したがって以下のようになります。 FLVを表示させる 親SWF が仮に 「Main.swf」 という名であるものとします。 その 「Main.swf」 を貼り付ける HTML が仮に 「Main.html」 という名であるものとします。 また 「Main.swf」 に写し出される FLV が仮に 「Movie.flv」 という名であるものとします。 そしてそれらのファイル構造が次のようになっているとします。 　　任意のフォルダ 　　　　├Main.html 　　　　└img(フォルダ) 　　　　　　├Main.swf 　　　　　　├SteelExternalAll.swf 　　　　　　└Movie.flv この場合， 「Main.swf」をパブリッシュする際に指定する「SteelExternalAll.swf」の相対パスは 「img/SteelExternalAll.swf」 になります。 ※ 【図】 (Flash 8 での操作画面例)↓ ※当然ですが，「Main.swf」を直接開いても 　 「SteelExternalAll.swf」のスキンは表示されなくなります。 　 SWFの上階層の 「Main.html」 をブラウザで開けば 　 「SteelExternalAll.swf」のスキンが表示されるはずです。
#1のコードはフレームアクションじゃないですよ ASファイルのコードです CircleTransition.asって名前で保存して flaファイルと同階層に置いて使う事を想定してます 仮にトランジションしたいムービーをmyMCとして ３秒後に２秒かけて一個半径50pxの円でトランジションしたいなら 上記の通りCircleTrasition.asって名前で#1のコードを保存 flaファイルのアクションに書くのは CircleTransition.transOut(ムービーの名前,3,950,286,2,50) だけです flaのフレームアクションのコードはなるべく少ない方がいいカンジ
> 順に１～２０とラベルされており ラベルとは...??? フレームに1～20というラベル名を付けたのですか？ まずそれがダメでしょう。 "ラベル名" なら "ラベル名" らしく，ちゃんと文字列にしないと。 例えば フレームに「label1」～「label20」というラベル名を付けたとします。 その場合， ボタンに書くスクリプトは次のようになります。 ---------------------------- on (keyPress "*") { gotoAndPlay("label" add nb); } ---------------------------- gotoAndPlay() または gotoAndStop() の引数が１つの場合 その引数は 「フレームラベル名」 または 「フレーム番号」 として Flash Player に受けとられます。 gotoAndPlay("文字列") の場合「フレームラベル名」として受けとられ gotoAndPlay(整数値) の場合「フレーム番号」として受けとられます。 また， Flash Lite 1.x では 数値加算演算子 と 文字列加算演算子 が区別されています。 「+」が数値加算演算子で，「add」が文字列加算演算子です。 (例： 1+1→2 ， 1 add 1→11) なお Flash Player 5 以降は 数値加算演算子 と 文字列加算演算子 の区別はなくなり， どちらであっても 「+」 を使います。 (例： 1+1→2 ，Number(String(1)+String(1))→11) あと， eval は インスタンス や 変数 を文字列で呼ぶときに使うものです。 今回の場合は全く関係しないでしょう。 ---一般的なevalの使用例------------ for (i=1; i<=10; i++) { eval("Hensuu" add i) = i; } trace(Hensuu5); -------------------------------- ---あえて今回のものに使用すると------- on (keyPress "*") { gotoAndPlay("label" add eval("nb")); } -------------------------------- ↑回りくどくてややこしくなっただけです。 　 evalを使う必要は全くありません。 なお Flash Player 5 以降， eval の使用は非推奨(半使用禁止)になりました。 代わりに 「配列アクセス演算子」 を使います。 動作検証時の作成物画面例↓
そんな感じでいいと思います。 事前にコンパイルしておいたものをflashplayerが実行しているだけです。
よく見たらback_mcとかって どこにも変数宣言ありませんね もしかしてアレですか BgSetクラスって シンボルの基本クラスで使ってるんですか？ ってことはシンボル化のときにAS用に書き出しチェックつけて クラス名つけてそれをnewしてaddChildしてるんですよね？ back_mcとかmenu_mcってのがオーサリングでつくったものってことなら ADDED_TO_STAGE待たないとアクセスできないです スクリプトのコードで変数宣言されたものと違って プロパティウインドでつけられた名前は基本的にステージからのパスです そのタイムラインが再生された状態で初めて有効になります そのムービー内のアクセスしたい対象が登場するフレーム以降に 書かれたコードならADDED_TO_STAGEを 待つ事なくアクセスすることができるんですが 外からアクセスする場合はADDED_TO_STAGE待たないとダメです こういう事はあんまりしないので、詳しくわかんないですが 多分back_mcとかmenu_mcのADDED_TO_STAGEを知る為に そのBgSetを継承したシンボルのクラスに 何らかのイベントをdispatchEventさせて そのイベントを待ってアクセスしないと いけないんじゃないかと思います 多分そんな面倒なことしなくても もっとスマートな方法がある気がしますが とりあえずアクセスできるタイミングとか 単純に考えるとそんなカンジです
たぶん、Main.asで1フレーム目にないオブジェクトを扱っているためです。 1フレーム目で見せたくないものはalpha=0やvisible=falseで見えないようにしておいて、 配置自体は1フレーム目からにしてみてください。 タイムラインとスクリプトを合わせて使用する際はいろいろ癖があるので気をつけた方がいいですよ。
＃２です。 今私が ＃２ で書いたURLを今見ると > GACは2011年５月を持ちましてサービスを終了しました。 > 長くご愛顧ありがとうございました。 となってしまいますね。 回答したときはそうなってなかったのに...(困)。 Google の キャッシュ でしたら かろうじて残っています。 http://webcache.googleusercontent.com/search?q=cache:zuIqeFpZUcAJ:gac.kir.jp/19/22402+http://gac.kir.jp/19/22402&cd=1&hl=ja&ct=clnk&gl=jp&source=www.google.co.jp あと 百度 のキャッシュにも かろうじて残っています。 http://cache.baidu.jp/jp?word=http%3B%3A%2Cgac%3B%2E%3Bkir%3B%2E%3Bjp%2C19%2C22402&url=http%3A//gac%2Ekir%2Ejp/19/22402&p=9d36cc0c86cc42aa01f7c7710e05&user=baidujp
Mac OS 10.4 の標準日本語入力システム「ことえり」のヘルプからの抜粋です。 －－－　引用ここから ソフトウェアのなかには、日本語を入力する場合に、書類のウインドウ上で日本語の入力・変換ができるものと、画面の下に表示される小さなウインドウ内で日本語の入力・変換ができるものがあります。書類のウインドウ上で日本語の入力・変換をする方式を「インライン入力」と呼びます。 「ことえり」を使って文字を入力する場合、文字の入力場所でインライン入力ができないときは、「変換ウインドウ」が画面に表示されます。 －－－　引用ここまで ↑　変換ウィンドウが出るということは、Flash Player はインライン入力（直打ち）に対応していないのではないでしょうか。 ちなみに ActionScript 3.0 ・ Flash Player 9 のテキスト入力も試してみましたが、変換ウィンドウが表示されてしまいました。 当方の環境では Flash Player 10 でパブリッシュした swf 作品の動作確認ができないのですが、少なくとも９までは対応していないようです。 しかし、これはあくまでも Mac の Flash Player の事情ですので、閲覧者が WIndows やその他直打ちできるＯＳを使っているのであれば、問題はありません。
ボタン自体にクリックなどのマウスイベントを付けることはできますが ボタンの内部の何かに，クリックなどのマウスイベントを付けることはできません。 ですから 仮に ボタン「オーバー」時に 「アップ」フレームに戻ることなく リンク付テキスト が無事に表示されたとしても，そのリンクは効きません。 (「アップ」フレーム にも リンク付テキスト を置けばわかるはずです。) したがって リンク付テキスト を使う(テキストのリンク機能を使う)という方法自体をやめた方が良いと思います。 ActionScript のバージョン や Flash のバージョンを書かれていらっしゃらないため回答しにくいですが ActionScript 3.0 の場合 基本的な操作方法は次のようにします。 まず 普通通りに「アップ」～「ヒット」フレームまでちゃんと作成したリンクテキストを用いないボタンをステージ上に配置します。 そのボタンを選択した状態で「プロパティ」パネルを表示させて その「プロパティ」パネルよりインスタンス名を付けます。 ここでは仮の例として 「A_btn」というインスタンス名を付けるとします(【図】(CS4での画面例)↓) その「A_btn」が存在するタイムラインに スクリプト記入用にするレイヤーでも追加して その「A_btn」が存在するフレーム(例えば フレーム1 なら フレーム1)のキーフレームを選択した状態で 「アクション」パネルに次のようなスクリプトを書きます。 //-------------------------------- //「A_btn」クリック時に 関数AClickを実行 A_btn.addEventListener(MouseEvent.CLICK,AClick); //関数AClickの定義(引数：イベント)：戻り値無し function AClick(e:MouseEvent):void { //例えば「aaa.html」というリクエストを作成 var myReq:URLRequest = new URLRequest("aaa.html"); //そのリクエストページを同窓で開く navigateToURL(myReq,"_self"); } //-------------------------------- ActionScript 2.0 の場合， フレームに書くスクリプトは次のようになります。 //-------------------------------- //「A_btn」クリック時に実行するメソッドを定義 A_btn.onRelease = function():Void { //「aaa.html」というページを同窓で開く getURL("aaa.html", "_self"); }; //-------------------------------- もし ActionScript 1.0 や 2.0 で スクリプトをフレームに書くのではなくボタン自体に書くのでしたら次のようになります。 //-------------------------------- //このボタンクリック時に実行 on (release) { //「aaa.html」というページを同窓で開く getURL("aaa.html", "_self"); } //--------------------------------
1以外の条件でスルーしてしまうからてしょう。 elseつけるなり、最後にreturnをおくなりしてください。
たしか Sound か SoundChannel のどちらかが使いまわし出来なかったと思うので、 新しくインスタンスを作り直す必要がある覚えがあります。 その為、ちゃんとクリアの後処理を入れておかないとメモリリークの原因になります。 （単一ならそうでもないと思いますが） あと、現状のソースだとmp3ファイルの読み込みが完了しないと再生されないと思うので、 サイズが大きくて再生までに時間がかかるのを回避するためにストリーミング再生出来るようにしたらどうでしょう？ 具体的なやり方ですが、Adobeのヘルプに「Podcast Player」のサンプルがあります。 http://help.adobe.com/ja_JP/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d15.html サンプルファイルは以下からDLできます。(色んなサンプルの詰め合わせで ZIP, 42 MB) http://livedocs.adobe.com/flash/9.0/main/samples/Programming_ActionScript3.0_samples.zip 基本的には、SoundPlayer.as と SoundFacade.as の動きをみればだいたい分かると思います。 今後拡張したいと言う時に参考になる良いサンプルだと思いますよ。
＞フラッシュとして作成しないといけないと思っています（間違っているでしょうか。。） そーです、合っています。 Adobe　FLASH買ってください Elementsじゃできませんから 買ったら質問してくださいね。
フォルダ名の後の連番が微妙ですね。 以下では，仮に 「img10/3.jpg」 まであるものとします。 つまり フォルダ名の後の連番が ２桁に繰り上がる "可能性がある" ものとします(別に繰り上がらなくても良いですが)。 以下ではメインのタイムラインに書く２通りのスクリプト例を書きます。 ◎ファイルパスを計算で用意する方法例 //------------------------ //Loaderを作成＆配置 var loader1:Loader = new Loader(); addChild(loader1); //ランダムな1～10のフォルダ番号を取得 var folder_num:int = Math.floor(Math.random() * 10) + 1; //番号を２桁の文字列に変換 var folder_str:String = ("0"+folder_num).substr(-2,2); //ランダムな1～3のファイル番号を取得 var file_num:int = Math.floor(Math.random() * 3) + 1; //ファイルをロード loader1.load(new URLRequest("img" + folder_str + "/" + file_num + ".jpg")); //------------------------ ◎ファイルパスをデータで用意する方法例 //------------------------ //ファイル登録用の配列を作成 var file_arr:Array = new Array(); //ロードするファイルを全て登録 file_arr.push("img01/1.jpg"); file_arr.push("img01/2.jpg"); file_arr.push("img01/3.jpg"); //　　～略～ file_arr.push("img10/1.jpg"); file_arr.push("img10/2.jpg"); file_arr.push("img10/3.jpg"); //Loaderを作成＆配置 var loader1:Loader = new Loader(); addChild(loader1); //配列の要素数分のランダムな整数を取得 var rnd_num:int = Math.floor(Math.random() * file_arr.length); //ファイルをロード loader1.load(new URLRequest(file_arr[rnd_num])); //------------------------ ※乱数について Math.random() で 0以上1未満のランダムな数(小数)が得られます。 Math.random()*10 で その範囲が10倍に拡大されて0以上10未満の数(小数)が得られます。 Math.floor(Math.random()*10) で 0以上10未満(9以下)の整数が得られます。 Math.floor(Math.random()*10)+1 で 1以上11未満(10以下)の整数が得られます。 ※２桁の文字列に変換について 文字列＋数 は 文字列 になります。 ("0"+folder_num) で 例えば folder_num が 5 であれば "05" という文字列が得られます。 例えば folder_num が 10 であれば "010" という文字列が得られます。 ("0"+folder_num).substr(-2,2) で 文字列 ("0"+folder_num) の最後(右)から２文字目より２文字が得られます。 例えば "05" という文字列であれば "05" が得られます。 例えば "010" という文字列であれば "10" が得られます。 つまり Excel で言えば RIGHT関数 を使ったようなもので あるセルに =RIGHT("0" & 5, 2) や =RIGHT("0" & 10, 2) と書いたのと同じようなことです。
「どの階層にどういったインスタンスがあってスクリプトはどこに書いたものなのか」 という状況説明が全くないため，よくわかりませんが， ステージ上に「btn_0」というインスタンス名(または変数名)を付けたボタンインスタンスがあって その「btn_0」がある階層のフレームにスクリプトを書く場合でしたら， 次のようにすればできませんか？ var Pagecount:Number = 0; this["btn_" + Pagecount].visible = true; Google検索「配列アクセス演算子」 http://www.google.co.jp/search?sourceid=navclient&hl=ja&q=%e9%85%8d%e5%88%97%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e6%bc%94%e7%ae%97%e5%ad%90
インスタンスフィールドとかスタティックフィールドで検索してみてください。 たとえばこんな感じ？ http://www40.atwiki.jp/spellbound/pages/193.html
スクリプトは「どういう動作をさせるか」という考え方によって全く変わります。 また ActionScript のバージョンによっても全く変わります。 CS5 ということは 最初のSWFも次のSWFも ActionScript 3.0 設定でパブリッシュしたのでしょうか？ 仮にそう(ActionScript 3.0)であるとして， 最初に表示されるSWFが「aaa.swf」というファイル名で それを表示させるHLMLと同じ階層(ディレクトリ)にあり 「aaa.swf」の次に再生されるSWFも同じ階層にある 「bbb.swf」というファイルであったとします↓。 　任意のディレクトリ 　　　├○○.html(最初に「aaa.swf」を貼り付けてある) 　　　├aaa.swf(最初に再生される) 　　　└bbb.swf(次に再生される) その場合， 「aaa.swf」を作成するためのFLAファイル(aaa.fla)のメインのタイムラインの最終フレームをキーフレームにして そのキーフレームに次のように書くのが１つの手段です。 ------------------------------------------------------- //次に再生するSWFのURLリクエストを作成 var myRequest:URLRequest = new URLRequest("bbb.swf"); //Loaderインスタンス「myLoader」を作成 var myLoader:Loader = new Loader(); //次に再生するSWFをロード myLoader.load(myRequest); //stageにLoaderを配置 stage.addChild(myLoader); //このタイムライン(root)を削除 stage.removeChild(stage.getChildAt(0)); -------------------------------------------------------- もし ActionScript 2.0(1.0でも同じく) で同様のことをするならば 最終フレームをに書くスクリプトは次のようになります。 （というか たった１行でできます。） -------------------------------------------- //このタイムライン_rootに次のSWFをロード _root.loadMovie("bbb.swf"); --------------------------------------------
＃１ですが。。。 > 助言をいただければ幸いです。 ですからですね 仮に(あくまでも仮に) 私が「Flash 8」が良いと思ったとしましょう(思いませんが)。 それを言ってどうなるんでしょうか？ という話です。 良いですか？ 書かれていらっしゃる Flash MX ～ Flash CS4 は全て過去のバージョンなんです！ 過去のバージョンは，正規のルートでは普通は手に入りませんし 仮に入るとしても手に入れるメリットなどあるのでしょうか？ ということですよ。。。 こんな(「OKWave」や「教えて！goo」のような)明るい場所で いわゆる「シリワレ」や「割れソフト」を買うことを薦めろとおっしゃるのですか？ ということです。 http://www.google.co.jp/search?hl=ja&source=hp&biw=&bih=&q=%E5%89%B2%E3%82%8C Flash Lite 1.1 開発に限定するなら Flash 8 以降は大して変わりません。 それ以外はかなり変わります。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 見てどうなるものか知りませんが， Flash MX 以降の差分 ということで私のネタ帳より一部を抜粋↓。 2004年12月５日 Flash MX 2004(58,000円)，Flash MX Professional 2004(84,000円) 発売。 対応プラグイン：Flash Player 7 ECMA-262改訂4版に準拠 ActionScript2.0 を採用。 MovieClipLoaderクラスなどをサポート。 外部ASファイルにクラスを定義したクラスファイルの配置が可能となる。 データ型のチェックによりエラーが発見できるようになる。 FlashLite 対応に差がある程度で MX 2004 と MX Professional 2004 の機能の差はほとんどない。 2005年 10月12日 Flash Basic 8(25,000円)，Flash Professional 8 (84,000円) 発売。 対応プラグイン：Flash Player 8 DisplacementMapFilterクラス，BlurFilterクラス，BitmapData クラスなどをサポート。 最大 16 色を追加可能なグラデーション機能の拡張。オブジェクトの描画モデル機能の追加。ActionScriptエディタにスクリプトアシストモード(MXではノーマルモード)復活。 モーショントゥイーンのカスタムイージングコントロール(Professionalのみ)機能の追加。グラフィック効果フィルタ ，ブレンドモードの追加。 その後(CS3以降)はここ↓にまとめてあります。 「購入ガイド バージョン別機能比較表 Adobe Flash Professional CS5.5」 http://www.adobe.com/jp/products/flash/buying-guide.html 同じ場所にありますが CS5への アップグレード 対象は Flash 8 以降ですよ↓。 http://www.adobe.com/jp/products/flash/buying-guide.displayTab3.html ＃１でも書きましたが， Flash 8 未満，つまり Flash MX 2004 以下は， アップグレードの対象になっていませんからね。 「割れ」でないちゃんとした(？) 中古を買うにしても，１円でも払ったら損ですよ。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 繰り返しますが 正規ルートで買うなら迷う必要なしで CS5 または CS5.5 で決まりです。 (なんで CS4 以下が出てくるのか意味ワカラン。。。)
こんにちは 参考になるか分かりませんが、ＡＳ３について色々書かれていますので、一応ＵＲＬを貼ります。
表示が出来ないということですが、選択ツールでそのラインを選択し、そのラインの太さはどのようになっていいるのかを確認して下さい。太さが設定した値であれば、正しく表示されているはずです。 もしかして、プレビュー等の表示した際の太さを言われているのであれば、拡大表示をして確認して下さい。
コンストラクタ名またはクラス名のTypoではないでしょうか？ クラス名がTimeViewなのに対し コンストラクタ名がTimeとなっています。 コンストラクタ名を間違た場合警告などは発生せず、 それはただのメソッドとして扱われてしまいます。
navigateToURL()はブラウザに「そのURLに行け」と命令するだけのものです。 そのswfの場所がhttp://hogehoge.com/fuga.swfと仮定した場合、 「http://hogehoge.com/data/top1.docへ行け」、とブラウザに命令している だけにすぎません。ブラウザとtop1.docとの通信は完全にFlashの外で行われて いるため、Flashサイドだけではファイル名を変更することはできません。 もしどうしても変更したい場合、top1.docとの間にCGIなど Flashとは別にサーバサイドのプログラムをかませて、 HTTPレスポンスヘッダを捏造してあげる必要があります。
この辺りは参考になりませんか？ http://flashrave.org/anima/fade_in/index.html http://www.flash-jp.com/modules/newbb/viewtopic.php?topic_id=1999&forum=8 http://hfm-kenchan.com/Lesson/log_qa/D0503074.htm
その式ですと、乱数の範囲が、配列変数のインデックス（管理番号）の最大値よりも 1 だけ広くなってしまいます。 RandomInt 関数内の乱数を求める式を 　Math.floor( Math.random() * ( maxN - j ) ); に、変更してみてください。 　 たった 1 の違いが、何が問題なのかと言いますと。 ご提示の式ですと、0 ～ 配列変数の要素の総数、の範囲で乱数を求めることになります。 例えば int_a が 10 個の要素を持っている時、0 ～ 10 までの乱数を求めてランダムに要素を１つ取るとすると、最大の 10 が出た時には int_a[ 10 ] を取ることになります。 しかし、配列変数のインデックスは 0 から始まるので int_a は 0 から 9 番までしかなく、10 番を指定したのでは値の取得に失敗してしまいます。 関数内で、乱数で選んだインデックス（変数 int_r ）と int_a の要素の総数を表す a_length の値を監視してみると分かるのですが、値の取得に失敗して「 ,, 」と歯抜けになるのは乱数（＝ int_r ）と a_length が同じになった場合で、運よく１度も同じにならなかった時はこの問題は起こりません。 － － － － － Math.random で任意の範囲の乱数を発生させる式が、Adobe 社のホームページで紹介されています。 　・Math.random() でランダムな整数を取得する方法 　　http://kb2.adobe.com/jp/cps/228/228622.html ご参考になさった作例では、この式を利用して配列変数 int_a のインデックスの範囲内で乱数を決めて任意の要素を１つ抜き取り、それを別の配列変数 int_b の先頭から順に詰めていく、といった方法をとっていると思われます。 int_a の要素は最初は変数 maxN と同じ数、ご提示のスクリプトですと 10 個あるのですが、配列変数のインデックスは 0 から始まるので、最後の要素は int_a[ 9 ] です。 ですから、抜き取る要素を決める乱数は 0 ～ 9 の範囲で求めます。最大値の 9 とは、maxN - 1 のことです。 すると、先の式に当てはめますと、 　Math.floor( Math.random() * ( ( maxN - 1 ) - 0 + 1 ) ) + 0 これを整理しますと、 　Math.floor( Math.random() * maxN ); になります。 int_a から splice メソッドで要素を抜き取ると配列変数の要素が少なくなっていきますから、要素が減った分だけ乱数の範囲も狭めていかなければなりません。 抜き取ってなくなった数は、値を抜き取った時にカウントを取っている変数 j を見ると分かります。 合わせますと、int_a の 0 ～最大インデックスの間で乱数を求める式は 　Math.floor( Math.random() * ( maxN - j ) ); 　 となります。 ＊ ＊ ＊ 今回の件での変数 maxN とは、初期状態の int_a の要素の総数と同じ意味です。 配列変数の要素の総数は length プロパティに記録されており、要素を削除・追加した時には length プロパティは自動的に修正されます。 この点を利用して、 （↓　各行頭に全角のスペースが入っています。コピーする際はご注意ください） //＊＊＊ 　//抜き取った値をint_bに詰める時のインデックス 　var j:Number = 0; 　//int_aの要素が尽きるまでループ 　while( int_a.length ) 　{ 　　//抜き取る要素をランダムに選ぶ 　　var int_r:Number = Math.floor( Math.random() * int_a.length ); 　　//int_aの要素を抜き取り、int_bの先頭から詰めていく 　　int_b[ j ] = int_a.splice( int_r , 1 ); 　　//値を詰めるインデックスを更新 　　j++; 　} //＊＊＊ と、書くこともできます。 なお、繰り返しますが、配列変数のインデックスは”0 から”始まり、最後は”要素の総数 - 1 ”です。 配列変数 int_b の値を for ループで全部取り出す時は、 　for( i = 0 ; i < int_b.length ; i++ ) というように書きます。 先頭は１番ではありませんので、ご注意ください。
Flashのバージョンや ActionScriptのバージョンなどのバージョンを一切書かれていませんが... その辺にあまり当たり障りないヒントとして Google検索「モーショントゥイーン」 http://www.google.co.jp/search?hl=ja&q=%E3%83%A2%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%88%E3%82%A5%E3%82%A4%E3%83%BC%E3%83%B3 Google検索「Flash フェードイン」 http://www.google.co.jp/search?hl=ja&q=Flash+%E3%83%95%E3%82%A7%E3%83%BC%E3%83%89%E3%82%A4%E3%83%B3 Google検索「Flash アルファ 変化」 http://www.google.co.jp/search?hl=ja&q=Flash+%E3%82%A2%E3%83%AB%E3%83%95%E3%82%A1+%E5%A4%89%E5%8C%96
インスタンスは 独立したMC(ムービークリップ) として管理やプロパティ変更などをする必要があります。 以下は簡易版(簡易閲覧検証用)スクリプトです。 //------------------------------------------------------- //例えば「back_mc」というインスタンス名のMCを作成します createEmptyMovieClip("back_mc", 0); //その「back_mc」をbackgroundで塗りつぶします bmp = flash.display.BitmapData.loadBitmap("background"); mat = new flash.geom.Matrix(); back_mc.beginBitmapFill(bmp, mat, true, true); back_mc.moveTo(0, 0); back_mc.lineTo(Stage.width, 0); back_mc.lineTo(Stage.width, Stage.height); back_mc.lineTo(0, Stage.height); back_mc.endFill(); //その「back_mc」の初期不透明度を 0 にします back_mc._alpha = 0; //その「back_mc」に1フレーム進む時間ごとに //毎回実行するメソッドを定義します back_mc.onEnterFrame = function():Void { //このMCの不透明度に5を加算 this._alpha += 5; //もしこのMCの不透明度が100以上になれば if (this._alpha>=100) { //このMCの不透明度を100にする this._alpha = 100; //1フレーム進む時間ごとに毎回実行するメソッドを削除 delete this.onEnterFrame; } }; //------------------------------------------------------- 書かれていらっしゃるスクリプトを 上記スクリプトに書き替えてみてください。 パブリッシュまたはムービープレビューしてみて これでちゃんとフェードインするようでしたら １行目の createEmptyMovieClip("back_mc", 0); を削除して 作成されているムービーの最下レイヤーのステージ左上のコーナーに 中身が空の「back_mc」というインスタンス名の MC(ムービークリップ) を手動で作成し 再度パブリッシュまたはムービープレビューしてみてみてください。
私は 「Swift 3D」 ではないかと思いました・ Google検索「Swift 3D」 http://www.google.co.jp/search?hl=ja&q=Swift+3D&aq=f&aqi=g8g-r1&aql=&oq= しかし， どうやらそうではないみたいなことが書いてありました。 「FlasherDotOrg Article Giant Steps - an animated short film's trip around the world (Michal Levy)」 http://www.flasherdot.org/Articles/GiantSteps.htm > What software programme was used to create it? >　I used Maya. But the real breakthrough of this film on the net was >　only after I rendered it into vectors, >　and made it into a Flash film. http://translate.google.co.jp/translate?hl=ja&sl=en&tl=ja&u=http%3A%2F%2Fwww.flasherdot.org%2FArticles%2FGiantSteps.htm > どのようなソフトウェアプログラムがそれを作成するために使用された？ >　私はMayaを使用。しかし、ネット上でこの映画の本当のブレークスルーは、 >　唯一の私はベクトルにそれをレンダリング後だったとFlash映画にそれを作った。
配列の扱い方ですか？ ご質問で書かれていらっしゃるコードには 「配列」など登場してませんよ。 「配列アクセス演算子」が登場しているだけです。 配列を作るのでしたら 次のようにすべきでしょう。 --------------------------------- var cou = new Array(); for (n=0; n<10; n++) { cou[n] = n; trace("cou["+n+"] = "+cou[n]); } --------------------------------- もっともこのままのスクリプトでは ActionScript 2.0 というよりも 1.0 そのものです。 ActionScript 2.0 らしくするには さらに型指定を入れるべきでしょう。 --------------------------------- var cou:Array = new Array(); for (var n:Number=0; n<10; n++) { cou[n] = n; trace("cou["+n+"] = "+cou[n]); } --------------------------------- ＝＝＝＝＝＝ 元のスクリプトであると どちらかと言うと配列よりは ハッシュ風のもののように見えなくもありません。 ハッシュ風なものとするなら(ハッシュでもないですが)， 次のような感じでも良いと思います。 --------------------------------- var cou:Object = new Object(); for (var n:Number=0; n<10; n++) { cou[n] = n; trace("cou["+n+"] = "+cou[n]); } ---------------------------------
for文 で一気にループさせるからおかしくなるのではないでしょうか？ まずは「いつ」，「何をするのか」をちゃんと考えなければならないと思います。 次のような感じで ご質問で書かれていらっしゃる日本語文のような感じに動きませんでしょうか。 ------------------------------------------ //カウンタとなる変数 cntA を定義 var cntA:int = 0; //A_positiveを動かす 関数「moveA」 を定義 function moveA(e):void { //A_positive の x座標を line_○ の x座標 に移動 A_positive.x = this["line_" + cntA].x; //もし cnt_A が 2 未満 であれば cnt_A に 1 を加算 //それ以外(2以上)であれば 0 に戻す cntA = (cntA < 2) ? cntA+1 : 0; } //関数「moveA」を即実行 moveA(null); //Timerインスタンス tmerA を作成(1秒間隔 , 無限回) var tmerA:Timer = new Timer(1000,0); //指定秒間隔で 関数「moveA」 を実行 tmerA.addEventListener(TimerEvent.TIMER, moveA); //タイマースタート tmerA.start(); //---↓勝手な付け加え↓--- //A_positive をクリックしたときも 関数「moveA」 を実行 A_positive.addEventListener(MouseEvent.CLICK,moveA); ------------------------------------------ Google検索「配列アクセス演算子」 http://www.google.co.jp/webhp?hl=ja#hl=ja&q=%E9%85%8D%E5%88%97%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90 Google検索「ActionScript 三項演算子」 http://www.google.co.jp/webhp?hl=ja#hl=ja&q=ActionScript+%E4%B8%89%E9%A0%85%E6%BC%94%E7%AE%97%E5%AD%90 ※上記スクリプトでは 　 カウンタのアップに三項演算子を使っていますが 　 これは使わず普通に if文 でも良いです。
次のような感じで良いのではないかと思います。 var mc:Fukidashi = new Fukidashi(); //初期値がtrueのフラグでも用意しておく var flag:Boolean = true; A_btn.addEventListener(MouseEvent.CLICK,xClick); function xClick(evt:MouseEvent):void { //もしflagがtrueであれば if (flag) { mc.alpha = 0; addChild(mc); mc.x = 0; mc.y = 0; mc.addEventListener(Event.ENTER_FRAME,imgAlpha); function imgAlpha(event:Event):void { mc.alpha += 0.05; if (mc.alpha>1) { mc.removeEventListener(Event.ENTER_FRAME,imgAlpha); } } //フラグをfalseにする flag=false; //もしフラグがfalseであれば } else { removeChild(mc); //フラグをtrueにする flag=true; } }
実際に動作検証はしていませんが こんな感じでできませんでしょうか。 for (var i:int=1; i<=100; i++) { Tweener.addTween(list["a" + i], {alpha:1, time:1}); } http://www.google.co.jp/search?hl=ja&q=%E9%85%8D%E5%88%97%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90
親元のページが 真っ白画面で[object] 状態になるのは、 window.open の実行で戻り値 「Wondowオブジェクト」 が返ってくるからだと思います。 戻り値表示を回避するには link_mc をクリックしたときの動作を以下のようにすれば良いと思います。 組み合わせによって数通りの書き方ができますが 一応、３～４例書いてみます。 ※「AAA.html」 は、仮リンク先URL です。 ※getURL の ( ) 内が改行しているように 　 見えるかもしれませんが改行ナシの１行です。 --------------------------- // link_mc をクリックしたときの動作を定義 link_mc.onRelease = function() { // リンク先 を 別窓で開く getURL("javascript:if(window.confirm('外部ページを開きます')){window.open('AAA.html');void(0)}"); }; --------------------------- 　　↑または↓ --------------------------- // link_mc をクリックしたときの動作を定義 link_mc.onRelease = function() { // リンク先 を 別窓で開く getURL("javascript:if(window.confirm('外部ページを開きます')){void(window.open('AAA.html'))}"); }; --------------------------- 　　↑または↓ --------------------------- // link_mc をクリックしたときの動作を定義 link_mc.onRelease = function() { // リンク先 を 別窓で開く getURL("javascript:window.confirm('外部ページを開きます') ? void(window.open('AAA.html')) : void(0)"); }; --------------------------- あと、 「ものは試し」と思ってやってみましたら これでもできました↓。 --------------------------- // link_mc をクリックしたときの動作を定義 link_mc.onRelease = function() { // リンク先 を 別窓で開く getURL("javascript:if(window.confirm('外部ページを開きます')){window.open('AAA.html')};this.href"); }; --------------------------- 以上では 一応 ActionScript の修正案を書いていますが 内容的には ActionScript は全く関係なくて、 全て JavaScript の仕様に対する対処法ですよ。 (HTML から a href を実行するときの対処法でも同様の事項が出てきます。) 　 　 ＝/＝/＝/＝/＝/＝/＝/＝/＝/＝/＝ その他 Suzuka で [SWF8] を生成する設定にしている場合は ExternalInterface クラスが使えますから これを使ってみても良いかもしれません。 ※同じく 「AAA.html」 は、仮リンク先URL です。 ※同じく ExternalInterface.call の ( ) 内が 　 改行しているように見えるかもしれませんが 　 改行ナシの１行です。 --------------------------- // link_mc をクリックしたときの動作を定義 link_mc.onRelease = function() { // リンク先 を 別窓で開く flash.external.ExternalInterface.call("function(){if(window.confirm('外部ページを開きます')){window.open('AAA.html')}}"); }; --------------------------- 　
＃１です。 > 今回のケースはA_mcの起点がトップレフトにあり… 起点？ 起点ではなくてそこが "基準点" なのではないですか？ 「インスタンスの基準点」 http://homepage3.nifty.com/ginga-b/MX/inst_refpoint.html そうでしたら， 次のようにすれば良いでしょう。 A_mc.x = stage.stageWidth*0.5 - A_mc.width*0.5;
No1の者です。 すいません＞＜ 記述に間違いがありました。 ▼HTML例） <div id="eveimg0"> <object type="application/x-shockwave-flash" data="動画.swf" style="width:570px;height:317px"> <param name="movie" value="動画.swf" valuetype="ref" type="application/x-shockwave-flash"> <param name="bgcolor" value="#ffffff"> <param name="loop" value="false"> <param name="quality" value="high"> </object> </div> <div id="eveimg1"><img src="画像.jpg" /></div> ...(省略 文字数制限で書ききれない)... <div id="eveimg8"><img src="画像.jpg" /></div> <ul id="imgmenu"> <li><img src="切替ボタン1" onclick="changeImg(1);" /></li> ...(省略 文字数制限で書ききれない)... <li><img src="切替ボタン8" onclick="changeImg(8);" /></li> <!-- ←ここ「1」じゃなくて「8」です --> </ul> えっと、ボタンを押すと全部消えちゃうって事ですが、 ----- <div id="eveimg0">ブロック</div> <div id="eveimg1">ブロック</div> <div id="eveimg2">ブロック</div> <div id="eveimg3">ブロック</div> <div id="eveimg4">ブロック</div> <div id="eveimg5">ブロック</div> <div id="eveimg6">ブロック</div> <div id="eveimg7">ブロック</div> <div id="eveimg8">ブロック</div> ----- <ul id="imgmenu"> <li>切替ボタン1</li> <li>切替ボタン2</li> <li>切替ボタン3</li> <li>切替ボタン4</li> <li>切替ボタン5</li> <li>切替ボタン6</li> <li>切替ボタン7</li> <li>切替ボタン8</li> </ul> 細かい指定はともかく、上記のようになってますか？^-^; <div id="eveimg0"> <div id="eveimg1">ブロック</div> </div> のように、divの中にdivが入ってたりしてませんか？ 次のものが原因かわかりませんが、 Flashのparamの以下を追加してみて下さい。 <param name="wmode" value="transparent">
別の "TOP" シーン にジャンプした後も， addEventListener(Event.ENTER_FRAME, updateDate2); が有効になり続けるため 各針への参照が切れてしまうのが原因ではないかと思います。 フレーム1 のスクリプトを 次のように変更すると(1行付け加えると) 無事にパブリッシュできるような気がします。 top2nd_btn.addEventListener(MouseEvent.CLICK, fl_top22); function fl_top22(event:MouseEvent):void { //１フレーム進む時間ごとに毎回 //updateDate2 を実行させるのを取り消す↓ removeEventListener(Event.ENTER_FRAME, updateDate2); gotoAndPlay(1,"TOP"); }
答え自体は簡単に書けるのですが， 少し模索する方向がずれていらっしゃるように思うので その点を書きます。 とりあえずは 次のページを良く読んで理解してみてください。 「[AS3] MovieClipインスタンスとインスタンス名」 http://f-site.org/articles/2008/04/19014939.html 　 ============================= 今回のご質問に ただ単に回答するだけでしたら 次のスクリプト↓で終わりです。 ------------------ bot1.addEventListener(MouseEvent.CLICK, onClick); function onClick(e:MouseEvent):void { trace(e.target.name); } ------------------ または上記の trace(e.target.name); の部分を trace(e.currentTarget.name); のようにしても良いです。 　 ============================= しかし... 　「そのインスタンス名を取得して何かメリットがありますか？」 というのが 最初に書いた「[AS3] MovieClipインスタンスとインスタンス名」のページに書かれてあることです。 インスタンス名を取得する必要など普通はないと思います。 たとえば 　「bot1 をクリックしたときに bot1 を右に 20px 移動させる」 とします。 その場合は次のようにすれば良いだけです。 ------------------ bot1.addEventListener(MouseEvent.CLICK, onClick); function onClick(e:MouseEvent):void { e.target.x += 20; } ------------------ インスタンス名など出てきません。 でも確かにインスタンス名のような名前が必要な場合も出てきますよね。 しかし，その場合も次のようにすれば良いだけです。 ------------------ bot1.addEventListener(MouseEvent.CLICK, onClick); function onClick(e:MouseEvent):void { var my_mc:MovieClip = MovieClip(e.target); my_mc.x +=20; } ------------------ これは 　インスタンスを名指しで呼びたいときには 　インスタンス名や最初の変数名など関係なく 　勝手にインスタンスを参照する変数を作って 　その名で呼べば良いでしょう ということです。 最初に書いたページに書かれてある 「変数によりインスタンスを参照するというのが、ActionScript 3.0の基本だといえます。」 の具体的な一例にもなっています。 　 　 話が前後しますが bot1.addEventListener(MouseEvent.CLICK, onClick); ここで使っていらっしゃる 「bot1」 も， この時点ではすでに 「インスタンス名」 ではありません。 この 「bot1」 は インスタンス名 と同名で自動命名されたそのインスタンスを参照する 「変数名」 なのです【図】↓。 その他 URL 「Adobe ActionScript 3.0* 変数と定数」 http://help.adobe.com/ja_JP/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7fc7.html 　
＃１ ＆ ＃２ です。 > 実際には、 > > function abcdOver(e:MouseEvent):void > { > var c:ColorTransform = new ColorTransform(); > c.color = (0xCCCCCC); > e.target.transform.colorTransform = c; > } > > にしたかったのですが、これは駄目でした。 駄目とはどういう状態なのでしょうか？ (駄目じゃないとはどういう状態なのでしょうか？) 他のものを除くと スクリプトは次のようにするということですよね？ -------------------------------- var btn_arr:Array = [aboutA_mc,aboutB_mc,aboutC_mc,aboutD_mc]; for (var i:int = 0; i<btn_arr.length; i++) { btn_arr[i].buttonMode = true; btn_arr[i].addEventListener(MouseEvent.ROLL_OVER,abcdOver); } function abcdOver(e:MouseEvent):void { var c:ColorTransform = new ColorTransform(); c.color = (0xCCCCCC); e.target.transform.colorTransform = c; } -------------------------------- もっとも c.color = (0xCCCCCC); ではなく c.color = 0xCCCCCC; だとは思いますが この場合は ( ) があっても意味は変わりませんからこのままでも良いです。 うまく行っていると思いますが【添付図】↓ 　 　 と言いますか，【添付図】の場合は ただ単に var c:ColorTransform = new ColorTransform(); c.color = (0xCCCCCC); aboutB_mc.transform.colorTransform = c; と書いたときと変わらないということです。 (for文 や 配列 などを使おうが使わまいが同じ結果になる。)＝(問題ない。)
ActionScriptですか？ 使っても良いですが使わなくても良いでしょう。 と言うか ActionScriptを使わない方法ができてから 気が向いたら使ってみても良いかもしれません(？)。 要するにどう見ても "単なるボタン" です。 ロールオーバー(マウスオーバー)で オーバーフレームに遷移するだけの超単純なボタンで， アップ・オーバー・ダウン・ヒット フレームのうち アップとオーバーフレームに塗りや字を置けば良いだけです。 　 　 ～作り方～ ステージ上に矩形ツールで濃いグレーの透明な塗りの四角を描きます。 (例：色が #333333 で アルファ が 0％ の塗り) その四角を選択して「修正」→「シンボルに変換」をします。 このとき「シンボルに変換」ダイアログで，タイプを「ボタン」にして「OK」します。 シンボルに変換されたステージ上のボタンインスタンスをダブルクリックして，ボタン内のタイムラインの編集に入ります。 ボタン内のタイムライン には 「アップ」「オーバー」「ダウン」「ヒット」というフレームがあって 「アップ」フレームだけに塗りがある状態だと思いますから 「オーバー」フレームを選択して右クリックなどから「キーフレームに変換」を選択します。 すると「オーバー」フレームにも同じ塗りができるので その「オーバー」フレームの塗りだけを半透明にします。 (例：色が #333333 で アルファ が 50％ の塗り) 参考【図】↓(CS4 での操作画面例) ステージ上の何もないところをダブルクリックするなどして メインのタイムラインの編集に戻り 「制御」→「ムービープレビュー」で確かめればボタンの動きがわかると思います。 それだけのことです。 ボタンの下レイヤーでスライドショー的なアニメーションを作れば良いだけですね。 　 参考URL 「ボタンを理解しよう！」 http://1art.jp/flash/le/lesson8/lesson8.htm 　 ちなみに 色が #000000 でなく，#333333 という妙に落ちつかない色を書いたのは，CS3 や CS4 辺りに変なバグがあるためです。 http://level0.kayac.com/2009/11/black_transparent_shape.php --- --- --- 別にActionScriptを使っても良いとは思います↓。 「ActionScript 3.0に対応したMovieClipのボタンをつくる」 http://fumiononaka.com/TechNotes/Flash/FN0706001.html しかし， 今回のものの場合は手間をかけても同じ物ができるだけですから ActionScript を使っても面倒が増えるだけだと思います。 　 --- --- --- なお ボタンクリック時(書かれているFlashの場合はボタンプレス時)に 別ページに行きますが，それにはスクリプトが要りますよ。 ActionScript 1.0 や 2.0 なら getURL， ActionScript 3.0 なら navigateToURL とそれにまつわる諸々。 でも 「それはそれ」 です。 今回の質問内容とは何の関係もしません。 　
それは基本的にブラウザに細かい命令をするわけですから ActionScript(SWF内部的なこと) ではありません。 そういう仕事を直接するのは JavaScript です。 Flash でできることは， そういうブラウザ制御の JavaScript を呼び出すくらいです。 このようなこと↓を Flash のボタンなどから実行させます。 ■同じサブウィンドウで表示するページを切り替えよう http://www.d3.dion.ne.jp/~tiyoko01/java/subwin/subwin4.html ↑上のJavaScriptをそのまま使わせてもらうことにします。 ◎ファイル構造例 　任意のフォルダ 　　　├AAA.html(AAA.SWFを貼り付ける) 　　　├AAA.swf 　　　├TEST1.html 　　　├TEST3.html 　　　└TEST3.html 　 　 ◎AAA.html の HTMLソース 例 --------------------------- <html> <head> <title>AAA</title> <script type="text/javascript"> <!-- function subWins(pages) { w=window.open(pages,"mado","width=300,height=300,left=350"); w.focus(); } //--> </script> </head> <body> <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=10,0,0,0" width="550" height="400" id="AAA" align="middle"> <param name="allowScriptAccess" value="always" /> <param name="movie" value="AAA.swf" /> <param name="quality" value="high" /> <embed src="AAA.swf" quality="high" width="550" height="400" name="AAA" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash" /> </body> </html> --------------------------- 　 　 ◎AAA.swf AAA.swf のステージ上には 「btn1」，「btn2」，「btn3」 というインスタンス名を付けたボタンがあるとします。 それらのボタンがあるフレームに書くスクリプト例↓ --------------------------- btn1.addEventListener(MouseEvent.CLICK,btn1Click); function btn1Click(e:MouseEvent):void { ExternalInterface.call("subWins", "TEST1.html"); } btn2.addEventListener(MouseEvent.CLICK,btn2Click); function btn2Click(e:MouseEvent):void { ExternalInterface.call("subWins", "TEST2.html"); } btn3.addEventListener(MouseEvent.CLICK,btn3Click); function btn3Click(e:MouseEvent):void { ExternalInterface.call("subWins", "TEST3.html"); } --------------------------- 　
> もし、お時間があれば、コードの解説もお願いしたいのですが。。。 字数の制限もありますし ＃１ の 第二案 の方がご質問の元に近いので そちらの方をメインに書きます。 　 ◎第二案(コメント入り) ------------------------ //各ボタンMCへの参照を配列「btn_arr」に登録 var btn_arr:Array=[btnA_mc,btnB_mc,btnC_mc]; //文字列 A と B と C を配列「lbl_arr」に登録 var lbl_arr:Array=["A","B","C"]; //変数 i を 「0」 ～「配列btn_arrの要素数未満」 まで //1ずつ加算しながらループ for (var i:int = 0; i<btn_arr.length; i++) { //各ボタンMC内の変数nに現在の変数iの値を固定する btn_arr[i].n = i; //各ボタンMCのボタンモードを有効にする btn_arr[i].buttonMode=true; //各ボタンMCクリック時に関数abcClickを実行 btn_arr[i].addEventListener(MouseEvent.CLICK,abcClick); } //関数abcClickの定義 function abcClick(e:MouseEvent):void { //このタイムラインを 配列lbl_arrの //自分自身（クリックしたMC）内に固定した //n要素のラベルに行かせて再生 this.gotoAndPlay(lbl_arr[e.currentTarget.n]); // //変数 i を 「0」 ～「配列btn_arrの要素数未満」 まで //1ずつ加算しながらループ for (var i:int = 0; i<btn_arr.length; i++) { //各ボタンMCクリック時に関数abcClickを実行 btn_arr[i].addEventListener(MouseEvent.CLICK,abcClick); } //ただし自分自身（クリックしたMC）自体をクリックした時に //関数abcClickを実行するのを削除 e.currentTarget.removeEventListener(MouseEvent.CLICK,abcClick); } ------------------------ 最初に出てくる 配列「btn_arr」 の各要素には ３つあるボタンMCの参照を代入しています。 最初の１行をバラバラに書くと次のように書き替えられます。 var btn_arr:Array = new Arry(); btn_arr[0] = btnA_mc; btn_arr[1] = btnB_mc; btn_arr[2] = btnC_mc; これで，要素数(Array.length)が 3 の配列ができます。 ですから下に出てくる for文 は for (var i:int = 0; i<3; i++) のようにループされることになります。 つまり i=0 状態で １回目ループ i=1 状態で ２回目ループ i=2 状態で ３回目ループ i=3 状態になると 3 未満という条件が成立しないのでループせずに for文 を抜けます。 その for文 内で 各ボタンMC 内の変数 に i の値を代入したり クリック時のイベントリスナーを登録しています。 そんな感じです。 第一案 の方も第二案 とほとんど同じですが， 「クロージャ」というもの(関数)を使っているところが大きく違います。 Google などで 「クロージャ」 を軸に(例「クロージャ+ActionScript」などと) 検索してみてください。
firefoxからflashのプラグインは、入れていないのでしょうか？ プラグインが入っていなければ、 firefoxのブラウザから、flashのプラグインのダウンロードサイトより firefox用のflashプラグインを入れれば動きます。
レイヤをもう1こ作って、 フレーム1ではレイヤ1にシンボル1、レイヤ2にシンボル2、 フレーム2ではレイヤ1にシンボル2、レイヤ2にシンボル1、 とすれば良いでしょう。
フレームレートの設定はいくつになっていますか？ これが1とかになっているといくら軽くてもカクカクします。 PCに積んでるメモリが少ない場合も同様です。 タスクマネージャとにらめっこして、FlashPlayer(またはIExplorerなど)の CPU使用率が異様に上がる場合、Flashムービー自体が重いのでしょう。 再生したままウィンドウを最小化すると計算だけして描画はされないため、 描画が重いか、計算が重いか判別できます。
(‥ )ン? 反映されてます。 マスクのサイズを 小さくしてみて 確認してみて。 環境 CS 5
noris02さんもおっしゃられている変数に格納するのがいいと思います。 var arraya = [2,22,44];//配列でフレームを指定 var f = 0;//フレーム番号を入れる変数 var k = 0;//クリックされた回数を入れる変数 button_1.addEventListener(MouseEvent.CLICK, fl_ClickToGoToAndPlayFromFrame); function fl_ClickToGoToAndPlayFromFrame(event:MouseEvent):void { f = arraya[k];//配列arrayaの0番目つまり2をfに代入　※配列は0から数えます gotoAndPlay(ｆ);//代入されたf番目のフレームに飛ぶ ｋ++;//クリックされた回数を1増やす。（arrayaの次を呼び出すため） } ASは久しぶり＋未検証なのでこのままだと動かないかもしれませんが 参考になれば幸いです。
ライブラリ内に「test_mc」というクラス名を付けた 200×100pxのムービークリップを用意して観察してみましたが 伸びたり縮んだり現象は起きないように見えましたよ(Windows環境)。 ちなみに，関数 testEF 内を次のようにして ムービープレビュー状態でしばらく放置してみました。 function testEF(evt:Event):void { mc.y += testNum; if (mc.y<=0||mc.y>=400) { testNum*=-1; trace(getTimer()/1000 + "秒経過，height…" + mc.height); trace(getTimer()/1000 + "秒経過，scaleY…" + mc.scaleY); } } 結果↓ 14.962秒経過，height…100 14.962秒経過，scaleY…1 34.962秒経過，height…100 34.962秒経過，scaleY…1 54.962秒経過，height…100 54.962秒経過，scaleY…1 　～ 略 ～ 602.928秒経過，height…100 602.928秒経過，scaleY…1 624.301秒経過，height…100 624.301秒経過，scaleY…1 645.403秒経過，height…100 645.403秒経過，scaleY…1 　～ 略 ～ 1013.313秒経過，height…100 1013.313秒経過，scaleY…1 1033.313秒経過，height…100 1033.313秒経過，scaleY…1 1053.313秒経過，height…100 1053.313秒経過，scaleY…1 数値で見てみてもやはり伸びたり縮んだり現象は起きていないようです。 　 　 作るときに何か妙なことをしていなければ なんとなく Mac の スタンドアローン版(デバッグ版) Flash Player のバグではないかと思います。 ブラウザ用 Flash Player で見たときも同じように伸びたり縮んだり現象が起きますか？ もし起きなければ， オーサリング環境だけで起きることなので気にすることはないのではないかと思います。。。(多分) かつて Flash Player 4 (Flash Lite 1.x) でも似たようなバグがありました。 MC の rotation を随時変えて MC を回転させ続けると MC が拡大したり縮小したりするという現象です。 (例：Flash Lite 1.1 用のアナログ時計を作ると，針が伸び続けたり縮み続けたりする。) このときは MC の scaleX と scaleY を定期的に 1 にするというような方法でみなさん対処されていたようです。 (実際には ActionScript 1.0 なので，MC の _xscale と _yscale を 定期的に 100 にしていたのですが。) もし ブラウザ用 Flash Player で見たときにも伸びたり縮んだり現象が起きるのでしたら 上のように対処してみても良いかもしれません。 つまり mc の scaleY を Event.ENTER_FRAME で 1 にし続けるというようなことをしてみても良いかもしれません。
Selection は import するしないの問題でなく ActionScript 2.0 まで存在していたクラスです。 import の必要があるのはそれではなく MovieClipクラス と コンポーネントの TextInput クラスです。 ----------------- package { import flash.display.MovieClip; import fl.controls.TextInput; public class hoge extends MovieClip { public var ipt:TextInput; public function hoge() { ipt.setFocus(); } } } ----------------- ただ...， ブラウザでページを開いたときにフォーカスが当たっているのはブラウザの部分のどこかで つまり，Flash(SWF)以外の部分ですから， 上のようにコンストラクタ内 にスクリプトで 表示されたとたん TextInput にフォーカスを与えるようにしても すぐには入力できないので，やっていることは無意味に近いですよ。 パブリッシュしたSWFをスタンドアローンの Flash Player で開くのであれば意味があるのかも？ (↑もちろん一般的閲覧者は普通そんなことしませんが。) ご質問されているスクリプトはあくまでも単なるサンプル例であって 実際には使わず，どこか他の場所(他のタイミング)で使うのであれば問題ないと思います。
？？？？？？？？？？？？？？？？？？？？ Flash の バージョン や ActionScript のバージョンも書かれていらっしゃらない上， (最低限すべきこと↑) なおかつ！ 状況説明 も全くされていない上， なおかつ！ 何をどのようにしたら 「二度目を押すと次に進まず、スタート時のアニメになってしまいます。」 状態になったのか，そのスクリプトさえ記述されていません。 したがって，まともな回答を望む方がおかしいですよ。 > どうしたら押す度に進みますか？ もし， 何かをされた部分に(何をされたか私は知りません。とにかく何かをされた部分に，) gotoAndPlay(1); というスクリプトがありましたら その部分を play(); に書き替えればうまく行く可能性があります。 その部分が例えば ABC.CDF.gotoAndPlay(1); かもしれません。 その場合は ABC.CDF.play(); にしてみると言うことです。 なぜ，回答者が具体例までを，わざわざ作成しなければならないのだか。。。 (「質問に手を抜くにもほどがある！」と思います。)
> そもそもこのswfにはタイムラインという概念が存在しないので 私は After Effects を持っていないので何とも言えませんが 普通，動画作成＆編集ソフトで作成した動画は タイムラインという概念 "しか" 持たないと思いますよ。 つまり， 普通の動画は スクリプト や 座標 や様々なプロパティ という概念が存在せず， タイムラインだけがあると思います。 (もしくは タイムライン を格納したオブジェクト(MC)があるかです。) あと，私の勝手な推測ですが， After Effects で生成される SWF は ActionScript 2.0 (AVM1エンジン規格)設定で作成された SWF ではないかと思います。 その辺は After Effects のバージョンや設定に依存すると思うので SWF ファイルを見てみないと何とも言えません。 何とも言えないので ActionScript 3.0 設定(AVM2エンジン規格) の場合と合わせて ActionScript 2.0 の場合のスクリプト例も書いておきます。 ◎もし After Effects で生成された SWF が 　 ActionScript 3.0 設定の SWF であった場合 ----------------------------- var loader:Loader = new Loader(); var newSWFRequest:URLRequest = new URLRequest("swfs/" + "test" + ".swf"); loader.load(newSWFRequest); addChild(loader); //loaderにSWFの最初のフレームがロードされたとき関数 onInit を実行 loader.contentLoaderInfo.addEventListener(Event.INIT,onInit); //関数 onInit の定義 function onInit(e:Event):void { //loader内のコンテンツの再生を停止 MovieClip(loader.content).stop(); } ----------------------------- ◎もし After Effects で生成された SWF が 　 ActionScript 2.0 設定の SWF であった場合 この場合 そのSWFをロードする 親SWF もActionScript 2.0 設定で作成する必要があります。 その場合のスクリプト例↓ ----------------------------- //ムービークリップ「loader」を最高深度に作成 var loader:MovieClip = createEmptyMovieClip("ld",getNextHighestDepth()); //MovieClipLoader「mcl」を作成 var mcl:MovieClipLoader = new MovieClipLoader(); //リスナー用オブジェクト「obj」を作成 var obj:Object = new Object(); //「mcl」のリスナーとして「obj」を登録 mcl.addListener(obj); //SWFをロード mcl.loadClip("swfs/" + "test" + ".swf",loader); //loaderにSWFの最初のフレームがロードされたときに実行 obj.onLoadInit = function():Void{ //loader内の再生を停止 loader.stop(); } ----------------------------- 最低ラインこの辺までやってみて その結果からこの先の対策を検討し その後， この件とは別に「逆再生」などの方法を思考・模索し もしわからなければその方法を問うべきでしょう。 （段階を跳び越えすぎですよ。）
ActionScript 1.0＆2.0 の場合 MC(ムービークリップ)に外部SWFをロードすると その外部SWFはそのMC自体と同じ存在になります。 ですからロードするしないは関係なく， 「ターゲットパス」さえ理解していれば MCプ内にボタンを置いたと思って考えるだけで 普通の場合と変わらずできると思います。 「ターゲットパス」 http://homepage3.nifty.com/ginga-b/MX/targetpath.html > ムービークリップ（loadいう名にしています） そういう紛らわしいネーミングは混乱や誤作動の原因になるだけです。 「index.swf」内にある「content.swf」をロードするMCには 「load_mc」というインスタンス名を付けてあるものと変えます。 また 「content.swf」内のボタンには 「cnt_btn」というインスタンス名を付けてあるものとします。 ◎階層構造 　index.swfの_root 　　└load_mc(MC) 　content.swfの_root 　　└cnt_btn(ボタン) ◎スクリプト例 ○場合1-1 　 cnt_btn自体に書くスクリプト例(絶対パス) on (release) { _root.gotoAndStop("move"); } ○場合1-2 　 cnt_btn自体に書くスクリプト例(相対パス) on (release) { this._parent.gotoAndStop("move"); } ○場合2-1 　 cnt_btnを置いたフレームに書くスクリプト例(絶対パス) cnt_btn.onRelease = function():Void { _root.gotoAndStop("move"); }; ○場合2-2 　 cnt_btnを置いたフレームに書くスクリプト例(相対パス) cnt_btn.onRelease = function():Void { this._parent._parent.gotoAndStop("move"); }; ※cnt_btnを置いたフレームとはつまり， 　 content.swf 内のメインタイムラインのフレームのことです。 ※場合1-2 と 場合1-2 は 　 ActionScript 1.0 の範囲内のスクリプトです。 　 (パブリッシュ設定 は ActionScript 1.0 にしていても 　 2.0 にしていても どちらでもかまいません。) 　 一方 　 場合2-1 と 場合2-2 は Voidキーワード を含むため 　 ActionScript 2.0 の範囲内のスクリプトです。 　 (パブリッシュ設定 を ActionScript 2.0 にしてないと 　　エラーが出ます。)
とりあえずコレくらいは出来るようになって↓ 「フリーのFlash作成ソフトSuzukaによる、スライドショー作成チュートリアル」 http://www.towofu.net/blog/2006/08/flashsuzuka.html そしてこんな感じも出来れば↓ 「小技１（ものをトゥイ～ンで動かす） 」 http://ciel.ari-jigoku.com/kowaza1.html ( http://ciel.ari-jigoku.com/ より) あとは適当にバリエーションを考えるだけで その辺のものはできると思いますよ。 その他リンク http://wikiwiki.jp/suzuka/?%A5%EA%A5%F3%A5%AF
単に ボタンをクリックする度に， Loader インスタンスを作成し続けるから変になるのだと思います。 外部 SWF は Loader にロードされるのですよ。 ムービークリップ ではなく ムービークリップ内 の Loader にロードされるのです。 そのイメージをしっかり持ってください。 変更例↓ ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ //↓Loaderは１つで良い var ld:Loader = new Loader(); MovieClip(parent).main_mc.mc1.addChild(ld); btn1.addEventListener(MouseEvent.CLICK,link1); function link1(event:MouseEvent):void { var req:URLRequest=new URLRequest("movie.swf"); ld.load(req); } //---同階層にbtn2があってmovie2.swfをロードする例--- btn2.addEventListener(MouseEvent.CLICK,link2); function link2(event:MouseEvent):void { var req:URLRequest=new URLRequest("movie2.swf"); ld.load(req); } ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
＃２です。 ついうっかり書き間違いです。失礼しました。 > 例えば _root ある変数 「hensuu」 に 　　↓修正変更↓ 例えば root にある変数 「hensuu」 に です。 _root ではなく root です。 ActionScript 3.0 流に言うなら 『例えば MovieClip(root).hensuu に』　です。
検証のため 関数 makeTriangle をちょっと変更して ムービープレビューしてみました【図↓】。 Windows ですが 線の太さは特に変わらないように見えますが。。。？ ちなみに 上の図は stage.quality = StageQuality.HIGH; 下の図は stage.quality = StageQuality.LOW; を書いています。 さらにちなみに 関数 makeTriangle の 検証のための変更↓ //関数 makeTriangle の定義 function makeTriangle(e:Event):void { //(前のフレーム時間で)描画したものを消す //(↓修正した上でコメントアウト) //spriteAP.graphics.clear(); spriteAP.graphics.lineStyle(1,0x000000); //(↓重複しているためコメントアウト) //spriteAP.graphics.lineStyle(1,0x000000,1,false,"normal","round"); spriteAP.graphics.moveTo(A_mc.x,A_mc.y); spriteAP.graphics.lineTo(P_mc.x,P_mc.y); } 　
FlashVars は Flash Player 6 以上でできるようになった機能ですから Suzuka の場合は SWF4以外(SWF6以上) の SWF を生成する設定にしていれば普通にできると思いますよ。 FlashVars で SWF 内に送りこまれる変数名とその値は SWF の フレーム1 開始前に _root(_level0) に送り込まれますからそれを取ってくれば良いだけです。 ロード待ちをする必要もないので ActionScript 的には LoadVars (外部テキスト読み込み) より はるかに簡単です。 ◎ ファイル構造例 　任意のフォルダ 　　　├AAA.html 　　　└AAA.swf (例：横400px 縦300px) 　 　 ◎ AAA.swf のスクリプト例 メインタイムラインにアクションレイヤーを挿入して そのレイヤーのフレーム1に次のように書き【図↓】、 SWFの生成をします。 ------------------------------ //「txt0」と「txt1」というインスタンス名の //テキストフィールドを適当に作成 this.createTextField("txt0",0,10,10,100,20); txt0.border = true; this.createTextField("txt1",1,10,40,100,20); txt1.border = true; //「txt0」 に _root の変数 myVar0 の値を表示 txt0.text = _root.myVar0; //「txt1」 に _root の変数 myVar1 の値を表示 txt1.text = _root.myVar1; ------------------------------ 　 　 ◎ AAA.html のコード全文例 ------------------------------ <html xml:lang="ja" lang="ja"> <head> <title>AAA</title> </head> <body> <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" width="400" height="300" id="AAA"> <param name="movie" value="AAA.swf" /> <param name="FlashVars" value="myVar0=test0&myVar1=test1" /> <embed src="AAA.swf" FlashVars="myVar0=test0&myVar1=test1" width="400" height="300" name="AAA" type="application/x-shockwave-flash" /> </object> </body> </html> ------------------------------ これで AAA.html をブラウザで開けば検証できると思います。 　 　 テキストフィールド「txt0」と「txt1」は 値を人間が目で見るためだけに作ったもので、基本的には本題の FlashVars とは全く関係しません。 結局 _root.myVar0 と _root.myVar1 の値を取ってきて何かに使えば良いというだけです。 あと、_root は "あえて明示" しているだけです。 上記の場合は _root に書くスクリプト例ですから 別に _root など無くても良いです↓。 ---変更例--------------------- //「txt0」 に変数 myVar0 の値を表示 txt0.text = myVar0; //「txt1」 に変数 myVar1 の値を表示 txt1.text = myVar1; ------------------------------ 　
for や while でループの終了条件が成立せずループから抜け出せなくなった場合、システムのフリーズなど最悪の事態を避けるために、Flash Player は警告を出してスクリプトの実行を中断するかどうかを尋ねてきます。 その警告もこれと同様の措置です。一箇所で処理が延々と繰り返されるだけで先に進めなくなった時、システムを守るために強制的にスクリプトが中断されます。 例えば、関数内で自分自身を呼び出す”再帰呼び出し”において、再帰を終了する条件に不備があるとその警告が出ます。 //＊＊＊ //呼び出した回数 times = 0; //自分自身を呼び出す関数 function Self_Call() { //呼び出した回数を数える times++; trace( times ); //自分自身を再度呼び出す Self_Call(); } Self_Call(); //＊＊＊ 関数を呼び出すと、一旦もとの流れから外れて関数で定義された処理を行い、関数が終了すると、もとの流れに戻ってきて続きのスクリプトが実行されます。 ActionScript では関数内で自分と同じ名前の関数を呼び出すこともできますが、その際は、ある条件になったら呼び出しをやめるように設計しなければなりません。 しかし、上記のスクリプトでは呼び出しの終了条件を定めていないため、一度関数が呼び出されると延々と自分自身を呼び出し続け、もとの流れを遠く離れてどんどん支流に逸れていく一方です。 結局、いつまでも最初の Self_Call(); を終了することができないために、もとの流れには二度と戻れません。これはつまり、スクリプトの実行がこの一箇所で滞ってしまってここから先に進めないということなので、再帰呼び出しを 256 回繰り返した時点でスクリプトの実行そのものが強制的に打ち切られます。 ご質問の件は、何が原因で先に進めなくなっているのか分かりませんが、「特定の条件が成立するまで同様の作業を繰り返す」というような再帰的な特性を持つ処理に何か問題があるのではないでしょうか。 再帰呼び出しでは、終了条件を入れたつもりでも実は誤りがあって条件が成立せず、終了できなくなっていることがよくあります。 SharedObject に書き込むデータを収集する・ SharedObject から取り出したデータを解析して利用する処理あたりに、再帰的な特性があるように思います。 データが複雑すぎる入れ子構造になっていないかどうか、解析する時に終了条件がきちんと成立するかどうかなどを、確認してみてはいかがでしょう。
バージョンを書かれていらっしらないので回答するのに困るのですが， Flash MX 以上(Flash MX，MX 2004，8，CS3，CS4，CS5)をお持ちで Flash Player 6 以上用 SWF をパブリッシュ する(Flash Lite 1.1 は除く) ということで， ActionScript 1.0 (2.0 でも可) を使用するという条件で回答します。 また _root に配置した ムービークリップ「mc1」 内は １フレームまでしかない という条件で回答します。 > ２フレーム目から表示したい これを言い換えると 1フレーム目は表示させてはならない ということになりますよね。 その辺も考え合わせて スクリプトを例えば次のようにします。 ----------------------------------- //_root にある MC「mc1」に SWF をロード _root.mc1.loadMovie("＊＊.swf"); //その「mc1」の不透明度を 0(透明) にしておく _root.mc1._alpha = 0; //1フレーム進む時間ごとに毎回実行 _root.onEnterFrame = function() { //もし 「mc1」 のロードされたフレームが 2 フレーム 以上になれば if (_root.mc1._framesloaded>=2) { //「mc1」の不透明度を 100(全く不透明) にする _root.mc1._alpha = 100; //「mc1」を フレーム2 から再生 _root.mc1.gotoAndPlay(2); //この1フレーム進む時間ごとに毎回実行するメソッドを削除 delete _root.onEnterFrame; } }; ----------------------------------- フレーム2 に進ませる，つまり フレーム○ に進ませる ということは 少なくとも その フレーム○ が PC のメモリ上にロードされている必要があります。 ですから 少なくとも フレーム○ がロードされるまでは gotoAndPlay(○) の実行を待つ必要があります。 それで上のようなスクリプトになります。
exe の利点は ＃１ の方の書かれていらっしゃる通りだと思います。 ですから逆に exe の欠点を書きます。 第一の欠点は「Windowsでしか動かない」ということです。 第二の欠点(というか最大の欠点？)は，「何某か別のソフト内で動かせない」ということです。 Windows であっても IE の中では動かせません。 また PowerPoint 内や，その他 C# でプログラミングされたアプリケーションなどの中では普通は動作させることができません。 第三の欠点は Player込みの容量なので「ファイル容量が大きい」ということです。 ちなみに... Adobe や Macromedia の Flash 作成ツールを使っていらっしゃる場合 SWF を普通にダブルクリックなどで見ることができてしまいますが， これは Adobe や Macromedia の Flash 作成ツールを使っていらっしゃるからですよ。 Adobe や Macromedia の Flash 作成ツールをインストールされていない方は スタンドアローン版 Flash Player が 入っていないので SWF の単独起動はできません。 その点 ダブルクリック などで Flash のみを直接開ける exe は魅力的かもしれません(Windowsに限って)。 そんなこんなはありますが， exe を作って配布して良いことなどは，今はほとんどありませんよ。 （昔はありましたが...） 昔の機能を消すに消せなかった遺物のようなものだと思った方が良いです。 （今は AIR が主流ですし...）
点Aや点Bや点Cは それぞれ「A_mc」「B_mc」「C_mc」というインスタンス名を付けたムービークリップであったとします。 その場合の "フレームに" 書くスクリプト例です↓。 ============================== import flash.display.Shape; //---Shapeは先に作成＆配置--- var shape:Shape=new Shape(); //(↓状況が不明ですが一応元のままで) shape.x=200; shape.y=100; addChild(shape); //毎フレーム時間 関数 makeTriangle を実行 addEventListener(Event.ENTER_FRAME,makeTriangle); //関数 makeTriangle の定義 function makeTriangle(e:Event):void { //(前のフレーム時間で)描画したものを消す shape.graphics.clear(); //頂点の座標 var vertices:Vector.<Number> = Vector.<Number>([A_mc.x,A_mc.y,B_mc.x,B_mc.y,C_mc.x,C_mc.y]); //三角形の赤い塗りを描画 shape.graphics.beginFill(0xFF0000); shape.graphics.drawTriangles(vertices); shape.graphics.endFill(); } ============================== Event.ENTER_FRAME の箇所で 「毎フレーム時間」 と書いていますが これは 「１フレーム進む時間ごとに毎回」 という意味です。 　 　 　 なお， スクリプトを書いたタイムラインを "ループ再生させる" 場合 上記のスクリプトが何度も実行されると Shape が重複出没して変になります。 また 何度も同じスクリプトを実行させるのは無駄ですから 仮にフレーム1に上のスクリプトを書いた場合， 最終フレームなどには ============================== //１フレーム分タイミングを後にずらして //gotoAndPlay(2) を実行 addEventListener(Event.ENTER_FRAME, function():void { gotoAndPlay(2); removeEventListener(Event.ENTER_FRAME, arguments.callee); } ); ============================== のようなことを書いて， フレーム1が何度も表示されないようにする必要があります【図↓】。 (スクリプトを フレーム1 に書くのではなく ドキュメントクラスを使った場合は この辺の気配りや細工は要りませんが。) 　 　 　 逆に， タイムラインを最終フレームなどで止めて "ループ再生させない" 場合 三角形の描画が継続したままだと無駄(CPUなどの無駄遣いになるだけ)ですから 再生を停止させるフレームに次のように書いて ENTER_FRAME イベントでの関数実行を停止させるようにした方が良いです。 =========================== stop(); //毎フレーム時間 makeTriangle が実行されるのを取消 removeEventListener(Event.ENTER_FRAME,makeTriangle); =========================== 　
三角形の頂点全てにシェイプヒントを付けてみてはいかがでしょう。 動かす頂点にだけシェイプヒントを付けると、一時的に三角形ではなくなるなど中間の形状が正しくないアニメになりますが、全ての頂点にヒントを付けて１つの頂点を動かすと、その角だけが動くシェイプトゥイーンが作成されます。 ヒントを付けているにも関わらず他の頂点も動いてしまう場合は、動かさない頂点の位置が最初と最後のキーフレームでズレていないかどうかを確認してみてください。 また、いろいろと触っているうちにヒントがズレたり増えたりして、おかしなことになる場合があります。 ズレた時は、ヒントを一旦全て削除して付け直してみてください。
左右には動くということは、キャラクターを動かすことはできるんですよね。 ということは、ジャンプして落下させるという動きを、 プログラムでどう表現するかがわかれば簡単に実装できるはずです。 それは、次の二つので表現できます。 1. 上を押したときにキャラクタに毎フレーム上方に移動する「速度」をつけます。 2. しかし、「重力」があるため、その「速度」は毎フレームごとに減少していきます。 以下に、簡単な実装コードを記述します。 var acc:Number = -10; // 「速度」 var gravity:Number = 1; // 「重力」 addEventListener(Event.ENTER_FRAME, function(evt:Event):void { 　　// 「速度」の分だけ、y 方向を移動させる 　　obj.y += acc; 　　// 「重力」の分だけ「速度」を減少させる 　　acc += gravity; }); 落下の動きにのみ着目しているので、着地や x 方向の動きは考慮していません。 また、acc や gravity の値は、実際に動かしてみて適当な値を探してみてください。
全体的な感想ですが スクリプトやインスタンス１つ１つについて もう少しヘルプを見直された方が良いように思います。 まず ご質問の最初の方の説明には次のように書いてあります。 > ans → ダイナミックテキスト　変数：ans しかし その後の説明やスクリプトにはこの ans が一切出てきません。 ここで「？？？」状態になります。 またヘルプにも書いてありますが Flash Player 6 以上用の SWF をパブリッシュするときには テキストフィールド に 変数名 を付けることは「非推奨」事項になっています。 (ヘルプで「非推奨」と検索。) ですから 答えを出力するダイナミックテキストの変数名は削除しましょう。 混乱の元になるだけです。 そして 答えを出力するダイナミックテキストには 「ans01」というインスタンス名のみを付けます。 したがってこの時点で関数 hikizan 内の ans01=aaa_num-bbb_num; は， ans01.text = aaa_num - bbb_num; のように変更する必要があります。 次に， これもヘルプに書いてあることですが， TextField クラスの onChanged ハンドラは， ユーザーの操作によってTextField の値が変更された場合にのみ発動します。 スクリプトで変更されたときには発動しません。 もしこのときに発動するとイベントが無限連鎖する場合もあり得てしまいます。 またスクリプトで変更するタイミングは把握済みで ボタン「btn01」をクリックしたときに「ans01」を変更するのですから そのときに保存すれば良いだけです。 わざわざ 『ボタン「btn01」をクリックしたときに変化する「ans01」の変化をonChangedで感知して保存する』 みたいなすごい遠回りなことは考えなくて良いです。 あと... SharedObject.getLoval("flashcookie"); ではなくて SharedObject.getLocal("flashcookie"); ですよね。 というわけでフレームのスクリプト書き直し例↓ =========================== myLocalSO = SharedObject.getLocal("flashcookie"); //---aaa--- if (myLocalSO.data.aaa != null) { aaa.text = myLocalSO.data.aaa; } aaa.onChanged = function() { myLocalSO.data.aaa = aaa.text; }; //---bbb--- if (myLocalSO.data.bbb != null) { bbb.text = myLocalSO.data.bbb; } bbb.onChanged = function() { myLocalSO.data.bbb = bbb.text; }; //---ans01--- if (myLocalSO.data.ans01 != null) { ans01.text = myLocalSO.data.ans01; } //---関数hikizanの定義--- function hikizan() { aaa_num = Number(aaa.text); bbb_num = Number(bbb.text); //↓変更 ans01.text = aaa_num - bbb_num; //↓ココで保存 myLocalSO.data.ans01 = ans01.text; } =========================== 結局 SharedObject "以外" の部分に問題があるように思います。 　
ロード待ち処理を入れていないからでしょうね。 修正変更例↓ --------------- package { //↓☆追加(本題とは無関係) import flash.display.Sprite; import flash.display.MovieClip; //↓☆追加 import flash.events.*; import flash.text.TextField; import flash.text.Font; import flash.text.TextFieldAutoSize; import flash.text.TextFormat; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.URLVariables; public class timeLoad extends Sprite { private var tf:TextField; public function timeLoad():void { var myRequest:URLRequest = new URLRequest("time.php"); var myLoader:URLLoader = new URLLoader(); //↓☆追加 myLoader.addEventListener(Event.COMPLETE, completeHandler); myLoader.load(myRequest); tf = new TextField(); tf.defaultTextFormat = new TextFormat("Helvetica",10,0x000000); tf.x = 0; tf.y = 0; //↓★削除(表示命令早すぎ。無理。) //tf.text = myLoader.data; addChild(tf); } //↓☆追加 private function completeHandler(evt:Event):void { tf.text = evt.target.data; } } } --------------- ロードされていないデータは表示できません。 もしできたならばPCは予知能力を持つ超能力者(機)です。 これ↓は単に「ロードしなさい」と命令しているだけです。 myLoader.load(myRequest); SWF(Flash)はクライアントのメモリ上にあります。 「ロードしなさい」命令でサーバのPHPに挨拶しに行って そのPHPから返事をもらい サーバから様々な回線を通じてそのデータが流れてきて やっとクライアントPCのSWFにデータが届きます。 ですから 「ロードしなさい」→即「返事を表示」 など無理です。 ※PHPを使わなくても同じです。 　 単なるサーバ上にあるテキストデータでも 　 ロードには時間がかかりますから 　 即「データを表示」など無理です。 ※クライアントPC上のデータでも同じです。 　 PC上の一般的なテキストデータでも 　 ハードディスク上記録データの取得＆メモリへのロード 　 には時間がかかりますから 　 即「データを表示」など普通は無理です。 そもそもクライアント環境だけ(=サーバやPHPなし)での検証が足りてないのでしょう。 (問題の切り分けが肝腎です。) ===別件=== > tfの内容が2011.1.1などになるのが目的です。 PHP作成データは「2011/01/01」のような文字列だと思います。 これを「2011.1.1」という形にするのでしたら tf.text = event.target.data; 　↓変更例↓ tf.text = event.target.data.split("/").join(".").split(".0").join("."); などのようにする必要があると思います。 　
getURL() は ActionScript 2.0 以下で動作するスクリプトです。 そのスクリプトをそのまま使いたいのでしたら 「ファイル」→「パブリッシュ設定」で出てくる「パブリッシュ設定」パネルから， 「Flash」 タブ を選択し， 「スクリプト」 の部分を 「ActionScript 1.0」 または 「ActionScript 2.0」 に変更すべきです。 例えば ムービークリップ に z軸 座標を使っているとか 他に ActionScript 3.0 しか通用しないスクリプトをすでに使っていらっしゃる場合は 変更が不可能になるため ActionScript 3.0 設定でなければならないかもしれません。 その場合は 次のように書き替えます。 ------------------------------------- //このタイムラインをこのフレームで再生停止 stop(); //リクエストする URL を設定 var my_url:URLRequest=new URLRequest("http://www.google.co.jp/"); //リクエストに設定したURL を同窓で開く navigateToURL(my_url,"_self"); ------------------------------------- とにかく ActionScript 2.0 以下と 3.0 とは 共存できません。
「数値の最大値」と書いていらっしゃるからには 例えば 3桁 とか 4桁 という 「桁数制限(=文字数制限)」 ではなくて 例えば 123(百二十五) とか 123.4 という 「数値の最大値制限」ですよね？ それでしたら 色々な場合が考えられるのですから 単純な "設定" と言うよりは その場合場合に応じたプログラムを考えるべきだと思います。 例えば 入力可能な値が 正の数も負の数も アリで，なおかつ 小数 も アリ だとします。 そして 最大値 が 123.4 であったとします。 その場合のフレームに書くスクリプト例です↓。 =================================================== //---↓適当に入力TextField「my_txt」を作成＆配置↓--- var my_txt:TextField = new TextField(); my_txt.type = TextFieldType.INPUT; //↓「0～9」 と 「-」 と 「.(小数点)」 のみ入力可 my_txt.restrict = "0-9\\-."; my_txt.border = true; my_txt.x = my_txt.y = 20; my_txt.width = 100; my_txt.height = 24; addChild(my_txt); //---↓本題の動作↓--- //最大値を設定 var max_num:Number = 123.4; //「my_txt」テキスト変更時に関数 onTextChange を実行 my_txt.addEventListener(Event.CHANGE,onTextChange); //関数 onTextChange の定義 function onTextChange(e:Event):void{ //もし入力値が max_num より大きい場合 if(Number(e.target.text) > max_num){ //入力値を max_num にする e.target.text = String(max_num); //その時の文字数をカウント var text_len:int = e.target.text.length; //カーソルの位置を最終位置にする e.target.setSelection(text_len,text_len); } } =================================================== 上記スクリプト中に 　//その時の文字数をカウント 　var text_len:int = e.target.text.length; 　//カーソルの位置を最終位置にする 　e.target.setSelection(text_len,text_len); という部分がありますが これは たとえば 567 という値を入力したとき 強制的に 123.4 という値にすれば 元のカーソルの位置が 567 の 7(３文字目) の後のままそれが維持されるため 何だか不自然だと感じたため 文字列の最終文字の後に カーソル を移動させるためだけのものです。 小数が元から入らなければあまり考える必要はありません。 以上のように１例を挙げてみましたが その他色々な場合が考えられるのですから 単純な "設定" と言うよりは その場合場合に応じたプログラムを考えるべきだと思います。 プログラミング "しなければならない" と考えると面倒かもしれませんが その場に応じたプログラミングが "できる" と考えれば それが Flash の長所であると言えます。
＃１です。 ＃１の回答後色々考え直してみたのですが ひょっとして「あらかじめ３行のASを登録しておくようなAS」とは 関数(function文) のことでしょうか？ 例えば Suzuka のキャンバス上のフレーム1に３つのスプライトを用意して そのスプライト(スプライトを配置したレイヤー)に 「mc_1」「mc_2」「mc_3」 というインスタンス名を付けたとします。 その状態でアクションスクリプトレイヤーを挿入して【図↓】 そのアクションスクリプトレイヤーのフレーム1に次のスクリプトを書いたとします。 ------------------------------------------- //関数 moveMC の定義(引数:スプライトインスタンス) function moveMC(MC){ //引数で送られて来たスプライトのx座標を10加算 MC._x += 20; } //変数 i を 1～3 で 1 ずつ加算しながらループ for(var i = 1; i<=3; i++){ //mc_(1～3) クリック時の動作定義 this["mc_" + i].onRelease = function(){ //関数 moveMC を実行(引数:自分自身のスプライト) moveMC(this); }; } ------------------------------------------- そうすると どのスプライトをクリックしても右に10pxずつ動きます。 クリックされたスプライトが 関数 moveMC 内のスクリプト MC._x += 20; これを例えば MC._x += 50; のように書き換えれば 全てのスプライトクリック時の動作が 右に50pxずつ動くようになります。 そういう意味でなら 「あらかじめ３行のASを登録しておくようなAS」として function文 を使います。 Suzuka のための参考サイトではありませんが↓ 「ActionScriptのオブジェクト化(function)　FLASHRAVE - FLASH 講座 -」 http://flashrave.org/as/function/index.html
＃１の回答者です。 > 実際途中をどんな形でつなげばいいか見本の動きがほしいのです。 意味がわからんです。 ご質問で提示された画像の下には５つの変形途中経過画像がありますよね？ それで良いのでは？ ５つの変形途中経過画像 を適当にトレースして シェイプトゥイーン させてみたのが下の動画ですが。。。 （シェイプヒントは使っていません。） つまりご質問そのものが 回答そのものになっている気が...？？？
結局，キャラクターを左から右に移動させるのか 右から左に移動させるのかがわからない文章ですね。 たまたまスクリプトも短く字数制限を超えないので どっちとも書いておきます。 ステージ上にキャラクターはMC(ムービークリップ)として作成してあり， 「chara_mc」というインスタンス名を付けてあるものとします。 またこのMCの基準点は「中央」に設定してあるものとします。 その場合「chara_mc」が存在するタイムライン(_rootなど)の フレームに書くスクリプト例です↓。 ===左から右に移動させる場合============= //Flash Player 内 ムービーの拡大/縮小なし Stage.scaleMode = "noScale"; //左上を基準に整列 Stage.align = "TL"; //キャラのx座標をステージの左端から //キャラの幅の半分だけ左に配置 chara_mc._x = 0 - chara_mc._width / 2; //キャラに毎フレーム時間で実行するメソッドを定義 chara_mc.onEnterFrame = function():Void { //このMC(キャラ)のx座標を右に例えば10pxずつ移動 this._x += 10; //このMCのx座標がステージの右端から //MCの幅の半分右になったら if (this._x > Stage.width + this._width / 2) { //このMCのx座標をキャラの幅の半分左に配置 chara_mc._x = 0 - chara_mc._width / 2; } }; ==================================== ===右から左に移動させる場合============= //Flash Player 内 ムービーの拡大/縮小なし Stage.scaleMode = "noScale"; //左上を基準に整列 Stage.align = "TL"; //キャラのx座標をステージの右端から //キャラの幅の半分だけ右に配置 chara_mc._x = Stage.width + chara_mc._width / 2; //キャラに毎フレーム時間で実行するメソッドを定義 chara_mc.onEnterFrame = function():Void { //このMC(キャラ)のx座標を左に例えば10pxずつ移動 this._x -= 10; //このMCのx座標がステージの左端から //MCの幅の半分左になったら if (this._x < 0 - this._width / 2) { //キャラのx座標をステージの右端から //キャラの幅の半分だけ右に配置 chara_mc._x = Stage.width + chara_mc._width / 2; } }; ==================================== 例えばコレ↓などがありますが //キャラのx座標をステージの左端から //キャラの幅の半分だけ左に配置 chara_mc._x = 0 - chara_mc._width / 2; これは説明上でそう書いているだけですから 当然 0 など取って 次のように書いてもかまいません(普通は次のように書きます)。 //キャラのx座標をキャラの幅の半分左に配置 chara_mc._x = -chara_mc._width / 2;
とりあえず、表示モードを最低レベルのアウトライン表示にしてみてはいかがでしょう。 「表示」メニューの中に「プレビューモード」という項目があり、”アウトライン表示”から”フル”までのレベルが選べます。 （↑　CS5 では表現・名称が変わっているかもしれません。要するに、編集中の表示モードの設定です。詳しくはヘルプをご参考になさってください） ”フル”に近いほど書き出す swf ファイルに近い状態で表示されるため、当然ながら CPU のパワーを消費します。 最も低いレベルの”アウトライン表示”は表示がかなり簡略化されるものの、CPU の負担は軽くなります。 これは編集中にだけ有効な表示方式ですから、アウトライン表示で作業しても、実際には画像や描画したオブジェクトはきちんと書き出されます。 他には、編集しないレイヤーを表示しない・常駐ソフトや余計なアプリケーションを停止するなどして CPU の余力を捻出する、あたりでしょうか。 クイックタイム形式の複数のファイルをつなげる方法については詳しくありませんが、「 QuickTime 結合」で検索してみたらいろいろと出てきました。 フリーの結合ツールもあるそうなので、短く作って後でつなぎ合わせることも可能かもしれません。
通常は１年に１件見かけるか見かけないかというような内容のご質問ですが 最近なぜが立て続けに近い内容の質問があります。 「グラデーションを動かす方法」 （02/14） http://okwave.jp/qa/q6522774.html 「Flashでの質問です。」 （02/18 ） http://okwave.jp/qa/q6531277.html 「flash　CS5でのループ画面の作成について」 （02/19） http://okwave.jp/qa/q6533655.html スクリプトは違いますが 考え方(大まかな原理)は上の３件と同じで行きます。 すみませんが字数制限も超えるため 以下では考え方(大まかな原理)は省略します。 というわけで作り方ですが まずステージ上に 1260×237px の画像を配置しますよね。 その画像をムービークリップに変換するわけですが そのときに「基準点」を「左上」に設定してムービークリップ(MC)に変換します【図↓】。 そのムービークリップに 例えば 「ko_mc」(意味:子MC) というインスタンス名を付けます。 その「ko_mc」を再び「基準点」を「左上」にしたムービークリップに変換します。 そのムービークリップに 例えば 「oya_mc」(意味:親MC) というインスタンス名を付けます。 その「oya_mc」があるレイヤーとは別に スクリプト用にするレイヤーを作成し そのレイヤーのキーフレームに次のスクリプトを書き(コピペし)ます。 ============================== //最初のスピードを設定 var spd1 = 150; //最終的スピードを設定 var spd2 = 10; //スピードダウンする度合を設定 var down_spd = 2.5; //フェードインする度合を設定 var up_alpha = 2; //---↑以上が設定↑------ //「ko_mc」を複製(場合によっては i<=1 の1を2や3に変更) for (var i = 1; i <=1; i++) { oya_mc.ko_mc.duplicateMovieClip("ko_mc"+i, i, {_x:oya_mc.ko_mc._width*i}); } //「oya_mc」のアルファを0にする oya_mc._alpha = 0; //「oya_mc」に毎フレーム時間実行するメソッドを定義 oya_mc.onEnterFrame = function() { // //---↓移動に関して↓------ //spd1 の値が spd2 より大きいとき if (spd1 > spd2) { //spd1 の値を down_spd だけ減算 spd1 -= down_spd; } else { //それ以外は spd1 の値を spd2 の値で固定 spd1 = spd2; } //「oya_mc」を spd1 の値だけ右に移動 this._x += spd1; //もし 「oya_mc」 の座標が 0 以上であれば //(場合によっては 0 を -200 などに変更) if (this._x > 0) { //「ko_mc」の横幅分左に移動 this._x -= this.ko_mc._width; } // //---↓アルファに関して↓------ //「oya_mc」のアルファが100未満であれば if (this._alpha < 100) { //「oya_mc」のアルファを up_aipha だけ加算 this._alpha += up_alpha; } else { //それ以外はアルファを100 で固定 this._alpha = 100; } }; ============================== 　
　 グラフィックインスタンスのループ指定は そのインスタンス内のタイムラインを複数フレームにしてアニメーションを作ったときに インスタンス内タイムラインをループ再生させるかどうかという設定ですからご質問とは関係がありません。 「FLASH学習・技法　シンボル」 http://www17.ocn.ne.jp/~wolves/SCHOOL/lecG/lecG2_3.html =/=/=/=/=/=/=/=/=/=/=/=/=/= ご質問本題のループですが 昨日私が偶然他の方に回答した＃２の回答に似ています。 Q「Flashでの質問です。」 http://okwave.jp/qa/q6531277.html これをこのご質問に則した形で書き直します。 仮に写真(写真入りボタン)が「A」「B」「C」「D」「E」という５枚あって ステージ上に配置してあるものとします。 またその写真を引っ付けて横に並べたときにステージの横幅を超えるものとします。 この場合， その５枚の写真をコピペで２倍の10枚に増やし ABCDEABCDE のように引っ付けて横に並べます。 その10枚全てを選択して 「修正」→「シンボルに変換」で １つのムービークリップ(以下 MC と略) に変換します。 そのときに "基準点" を左上にして変換します。 MCを配置する場所は適当で良いです。 【図】↓参照のこと。 その作成したMCを選択して 「プロパティ」パネルを表示させ <インスタンス名>欄でそのMCにインスタンス名を付けます。 ここでは「photo_mc」というインスタンス名を付けたとしておきます。 その「photo_mc」があるレイヤーとは別に 新規レイヤーを追加し そのレイヤーの空白キーフレームに次のようなスクリプトを書きます(コピペ可)。 ------------------------ //動く速さを設定(適当に変える) var speed:Number = 10; //photo_mcに毎フレーム時間でmoveMCを実行する //イベントリスナーを登録 photo_mc.addEventListener(Event.ENTER_FRAME,moveMC); //関数 moveMC の定義 function moveMC(e:Event):void{ //photo_mcのx座標をspeedだけ右に移動 e.target.x += speed; // //もしphoto_mcのx座標が 0 より大きくなれば if (e.target.x > 0) { //photo_mcの横幅の半分だけ左に移動 e.target.x -= e.target.width / 2; } } ------------------------ 他にもループさせる手法(原理/考え方)はありますが いずれにしてもループしているように見せかける何らかの手品です。 この 写真をあらかじめ ２倍(または ３倍，４倍…) に複製しておいて それら全体を動かすという方法が スクリプトも複雑にならず簡単だと思います。 もし 最初の５枚の写真を引っ付けて横に並べたときにステージの横幅を超えない場合は ３倍 や ４倍… にしてステージに並べてMCに変換し その MC の x座標が 0 より大きくなれば MCの横幅の 1/3 や 1/4 … だけ左に移動させるようにスクリプトを変更します。 　
おそらく正規表現を使えばできると思います。 新規ドキュメントを作成し フレームに記述(コピペ)するスクリプト例です↓。 -------------------------- //文章を設定 var str1:String = 'He <font color ="#00FFFF">gose</font> to library.'; //置換するパターン var pattern:RegExp = /<font color ="#00FFFF">.*?<\/font>/g; //置換後の文章を取得(複数ある場合は最短一致) var str2:String = str1.replace(pattern, '<font color ="#00FFFF">_______<\/font>'); //置換後の文章を出力窓に出力 trace(str2); -------------------------- または -------------------------- //文章を設定 var str1:String = 'He <font color ="#00FFFF">gose</font> to library.'; //置換するパターン(複数ある場合は最短一致) var pattern:RegExp = /<font color ="#00FFFF">.*?<\/font>/g; //置換後の文章を取得 var str2:String = str1.replace(pattern, "_______"); //置換後の文章を出力窓に出力 trace(str2); -------------------------- 「制御」→「ムービープレビュー」で出力窓を確認してみてください。 もし， タグに 「font color ="#00FFFF"」 が入っている入っていないに関わらず他の場合でも， 例えば文章が 「He <font size="4">goes</font> to library.」 の場合でも 「He <u>gose</u> to library.」 の場合でも 同様のことをする場合は次のようになります(？？？) (色々な場合でうまく行くかどうかはわかりません...) -------------------------- //文章を設定 var str1:String = 'I <font size="4">love</font> you. You <u>like</u> me.'; //置換するパターン var pattern:RegExp = />[^<]*<\//g; //置換後の文章を取得 var str2:String = str1.replace(pattern, '>_______</'); //置換後の文章を出力窓に出力 trace(str2); -------------------------- または -------------------------- //文章を設定 var str1:String = 'I <font size="4">love</font> you. You <u>like</u> me.'; //置換するパターン var pattern:RegExp = /<[^>]*>.*?<[^>]*>/g; //置換後の文章を取得 var str2:String = str1.replace(pattern, '_______'); //置換後の文章を出力窓に出力 trace(str2); -------------------------- この辺↓前後のページが参考になると思います。 「Adobe ActionScript 3.0 繰り返し制御文字」 http://help.adobe.com/ja_JP/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7eab.html 私は上記ページからリンクされている PDF ファイルをダウンロードして ７章と10章を熟読した上でなんとか考えて上記スクリプトを書きました。 結構アセアセにややこしいです(特に下のスクリプト２つ)。
１、 ＭＣの名前についてプロパティパレットでつけたインスタンス名は 基本的にstageからのパスであり、ＭＣがaddChildされた後じゃないと機能しない ２、 １フレーム目のスクリプトはＭＣクラスインスタンスが 生成された直後、addChildされる前に実行される 以上から１フレーム目でインスタンス名によってＭＣを参照する場合は Event.ADD_TO_STAGEイベントを待つとかします ちなみにタイムラグ出来ちゃいますけど ２フレーム目にスクリプトを書くようにしても 動くかもしんないです
個人的なおすすめはフォトライブラリみたいなものでしょうかね ファイル読み込みとかのイベント処理、動的なレイアウトとか 最低限クリアしなければいけない基本がありつつ デザインや機能に凝れば際限がないところもあり ローカルアプリとかサーバサイドとの連動にも発展していきやすい 「ここはもっとこうしたい！」って思いがでやすく 結構モチベーションをキープできる題材だと思います
HugFlashのプログラム（たぶんお化けっぽいアイコン）をダブルクリックして、出た画面でSoundとVideoをチェックします。 その右側の歯車のボタンでconfigの画面が現れ、videoのタブでoutputを映像+音声出力にすることにより音つきの動画として抽出できるかと思います。 出力形式もvideoのタブでmp4形式あるいはavi形式が選べます。
「インポート後にインスタンスを作る」とは？ インポートする必要もなければインスタンスを作る必要もありませんよ。 スクリプトをコピペされたのか「Download」ボタンからダウンロードされたのかわかりませんが どちらにしても任意のフォルダに「Main.as」という名でクラススクリプトファイルを保存します。 ダウンロードされた場合は「tVmM.as」というファイル名を「Main.as」に変えるということです。 その「Main.as」を保存したフォルダに 新規で作成したドキュメントファイル「○○.fla」を保存します。 ドキュメントのステージを選んだ状態で プロパティインスペクタ(プロパティパネル)を表示させて 　クラス：[　　　　　　] のようになっているテキスト入力部分にクラス名「Main」を記入します。 そしてパブリッシュまたは，「制御」→「ムービープレビュー」です。 インポートするスクリプトも書きませんし ステージ上には何のインスタンスも用意しません。 ※これはつまり「ヘルプ」にある「例」のスクリプトと同じ 　 「ドキュメントクラス」のクラスファイルです。 　 一般的なインポートするカスタムクラスとは違います。
＃１です。 ですから... 「contentLoader」に対してリンクを付けるんです。 言い換えると 「contentLoader」に対して，クリック時に別ページを開く関数を実行するイベントリスナーを追加するんです。 ※もしくは「contentLoader」にではなく 　 親の「contentMC」にリンクを付けても良いと思います。 　 その場合 buttonMode が true にできます。 回答字数制限で全文は書けないため 「～略～」の部分を省略しています。 ★付きの箇所が追加部分です。 ～～～～～～～～～ package { ～略～ import flash.net.navigateToURL; public class Main extends Sprite { private var contentMC:MovieClip; private var contentLoader:Loader; //コンストラクタ public function Main() { //外部ファイルを配置するムービークリップの生成 contentMC = new MovieClip ; ～略～ //Loaderオブジェクトを生成 contentLoader = new Loader ; contentMC.addChild(contentLoader); //ボタン処理 my1_btn.addEventListener(MouseEvent.CLICK,my1Handler); my2_btn.addEventListener(MouseEvent.CLICK,my2Handler); my3_btn.addEventListener(MouseEvent.CLICK,my3Handler); } //各ボタンをクリックしたときに外部ファイルを読み込む private function my1Handler(evt:MouseEvent):void { var url = "img/flashimg01.jpg"; loadContent(url); //★Loaderクリック時の動作 contentLoader.addEventListener(MouseEvent.CLICK,LD1Handler); } private function my2Handler(evt:MouseEvent):void { var url = "img/flashimg02.jpg"; loadContent(url); //★　〃 contentLoader.addEventListener(MouseEvent.CLICK,LD2Handler); } private function my3Handler(evt:MouseEvent):void { var url = "img/flashimg03.jpg"; loadContent(url); //★　〃 contentLoader.addEventListener(MouseEvent.CLICK,LD3Handler); } //★Loaderクリック時に別ページを開く関数 private function LD1Handler(evt:MouseEvent):void { var link:URLRequest = new URLRequest("http://www.yahoo.co.jp/"); navigateToURL(link,"_blank"); } private function LD2Handler(evt:MouseEvent):void { var link:URLRequest = new URLRequest("http://www.google.co.jp/"); navigateToURL(link,"_blank"); } private function LD3Handler(evt:MouseEvent):void { var link:URLRequest = new URLRequest("http://www.baidu.jp/"); navigateToURL(link,"_blank"); } //外部ファイル読込 private function loadContent(url) { var req:URLRequest = new URLRequest(url); contentLoader.load(req); } } } 　
> スクリプトに関するエラーは出ていません。 そうですか？ 私は出ましたよ。 navigateTOURL(url); このようなメソッドはありません。 navigateToURL(url); です。大文字小文字を間違えています。 ・その他 > プレビューして見たとき、クリックしても何の反応もありません。 プレビュー と書かれただけではどのプレビューかわかりませんが， 「ファイル」→「パブリッシュプレビュー」でHTMLを選んだ場合のプレビューでは その SWF(閲覧用Flashファイル) が存在するドライブやフォルダなどを グローバルセキュリティパネルで許可しておかなければ外部サイトにはアクセスできません。 ここ↓で設定です。 「グローバルセキュリティ設定パネル」 http://www.macromedia.com/support/documentation/jp/flashplayer/help/settings_manager04.html また，私の環境では， 「制御」→「ムービープレビュー」で表示されるプレビュー画面から， つまり スタンドアローン版 Flash Player での閲覧状態から， navigateToURL などで ブラウザ(IE) を起動させて目的のサイトを表示させることは可能ですが， 他の環境であれば， そのようなこと(危険をはらむこと)はセキュリティの関係でできない可能性も十分考えられます。 あと，「image」という名は， ちゃんとクリックするものに インスタンス名や変数名として付けていますか？
２０年ばかり前に、Basio言語で作ったことがありますが、考えかたのみ紹介すると、 (1)配列Aを１６個を用意する（２５個、３６個、４９個のレベルも選べるようにしました。） (2)それぞれの配列に、配列変数と同じ数字を割り当てる。１６番目には０を割り当てる。 (3)ランダムに１～４の数字Xを出し、空白のパネル（０が割り当てられている配列）がどちらに進むか決める。 (4)(3)で決めた方向が、適切でないとき（枠外にはみ出る）、(3)をやり直す。 (5)進む方向の配列変数にある数字と、空白のマスの数字（つまりは０）を置き換える。 (6)(3)～(5)を何回か繰り返す。繰り返す回数（置き換える回数）も選べるようにしました。 (7)Play中は、カーソルキーにより進む方向を決め、(3)～(5)を繰り返す。 というものです。つまりは、マスはそのままにし、そこに入る数字だけを入れ替えるというものです。 大体の方針はつかんでらっしゃるみたいですね。(4)は、X＝１のとき上のマスと交換としたなら、空白のマスが１～４だったら上はないのでやり直し、というif文書けばいい。(5)は上と交換なら、配列変数－４と交換。 ランダムに選ぶには、宣言が必要ですよ。そうしなければ、いつも同じ数字が出てくることになり、同じ結果になる。 表示は別のObjectで、A(1)～A(16)まで表示すればいい。 とまあ、こんなものです。できあがったら、私のやったみたいに、レベルを変えられるようにしたら、面白いですよ。
まず on (press) は， 「ボタンをクリックしたとき」 ではなくて 「ボタンをプレスした(押した)とき」 です。 ボタンをクリックしたときに何かをさせたいのでしたら， on (release) です。 次に getURL() は，Flash 内のことに携わるスクリプトではなくて 「ブラウザでページを開く」 など Flash 外 のことをするときに使うものです。 （getURL の引数は ブラウザへのリクエストになります。） Flash 内の，つまり SWFムービー内のタイムラインを操作するのでしたら， stop() や play() や gotoAndStop() や gotoAndPlay() を使います。 ご質問の場合は おそらくメインのライムライン（_rootのタイムライン）の再生フレームを1フレームに戻して再生させたいのだろうと推測されますから， ボタンがボタンインスタンスである場合(ムービークリップ製のボタンでない場合)， on (release) { gotoAndPlay(1); } または on (release) { _root.gotoAndPlay(1); } または on (release) { this.gotoAndPlay(1); } のようにする必要があります。 なおご存じだとは思いますが， on (press) や on (release) などが ボタン や ムービークリップ 自体に書けるのは ActionScript 1.0 または 2.0 設定のときだけです。 Flash CS3 のデフォルトのパブリッシュ設定などでは ActionScript 3.0 を使うようになっていますから この設定を あえて(意識して) ActionScript 2.0 以下に変更するか あえて(意識して) ActionScript 2.0 以下のドキュメントを作成する必要があります。
「ウィンドウ」メニューの中の「他のパネル」にカーソルを合わせ、「シーン」の項目を選択してください。 「シーン」パネルが開き、現在、存在しているシーンの一覧が表示されます。 パネル内のシーンの名前をドラッグすると、紙のアイコンが表示されます。この状態で他のシーンの名前の上下に移動すると、再生する順序を変更することができます。 シーン２をシーン１の前に再生したい場合は、シーン１の名前の上にドラッグします。 ドラッグしている間は移動できる先が線で表示されますから、参考にしてください。 シーンを作ると通し番号の名前が付きますが、この番号と再生順序は全く関係がありません。シーンの再生順序は、この一覧に並んでいる順番通りになります。 「シーン」パネルでは、再生順序の変更のほかに、シーンの複製・新規作成・削除・名前の変更もできます。 通し番号は仮のものなので、分かりやすい名前に変更しておくといいでしょう。 シーン名をダブルクリックすると、名前を入力できるようになります。
今回の例では <Files ~ "\.wav$"> SetEnvIf Referer "^http://www\.xxx\.jp/" ref SetEnvIf Referer "^$" ref Order Deny,Allow Deny from all Allow from env=ref </Files> となるかと思います。（１行目の ~ が抜けている） ただ、この例でもブラウザのアドレス欄にwavのURLを直接入力した場合はwavを開けます。 補足をいただいて改めて調べてみましたが、Flashからのアクセスはブラウザでアクセスするのと基本的に区別がつかないようです。 つまりFlashでアクセスできるようにすると、ブラウザでもアクセスできる、ということになります。 もしFlash側でRefererやUser-Agentを書き換えるとか、ActionScriptにaddRequestHeaderというのがあるようなのでこれで独自のヘッダを追加するとかして、ブラウザのアクセスと区別できればもう少し制限できると思います。
配置する10個のMC(ムービークリップ)は 例えば違う絵柄や違うアニメーションが入っているような別物であるものとします。 つまり10個のMCはシンボルとしても別物であるとします。 （各MCの "基準点" の位置はご自身でしっかり把握しておいてください。） MCを用意した後のさらに下準備として 作成した10個のMCシンボルに別々のクラス名を付けます。 クラス名を付けることや その先のことも含めて次のページのようなことをして行きます。 「[AS3] クラスを文字列で参照したい」 http://f-site.org/articles/2008/01/17051234.html 上記ページではMCシンボルに「Pen」というクラス名を付けていますが ここでは「MC0」「MC1」「MC2」…「MC9」という 10個のクラス名を付けるとしておきます【添付図↓】。 そしてフレームに次のようなスクリプトを書きます。 --------------------------- //「MC0」を配置するx座標を設定 var start_x:Number = 80; //「MC0」を配置するy座標を設定 var start_y:Number = 40; //ランダム配置するMCの個数を設定 var haiti_n:int = 8; //横に並べる個数を設定 var yoko_n:int = 4; //MCを配置する横間隔を設定 var kankaku_x:Number = 100; //MCを配置する縦間隔を設定 var kankaku_y:Number = 60; //クラス名を入れる配列 var name_arr:Array = new Array(); //「MC0」～「MC9」を配列の要素に代入 for (var i:int = 0; i<=9; i++) { name_arr[i] = "MC" + i; } for (i = 0; i<haiti_n; i++) { //配列の要素分の乱数を取得 var rand_n:int = Math.floor(Math.random() * name_arr.length); //その要素を抜きとり取得 var name_str:String = name_arr.splice(rand_n,1); //文字列のクラス化 var myClass:Class = Class(getDefinitionByName(name_str)); //そのクラスを呼び出して配置 this["mc" + i] = new myClass(); this["mc" + i].x = i % yoko_n * kankaku_x + start_x; this["mc" + i].y = Math.floor(i / yoko_n) * kankaku_y + start_y; addChild(this["mc" + i]); } //(※後の使用方法例) this.mc2.rotation = 30; --------------------------- これでパブリッシュします。 上のスクリプトでは このMCの重複出没を防ぐために Arrayクラスの splice() メソッドを使っています。 このメソッドを使わずに 配列の中身をあらかじめランダムシャッフルしておいた上で 要素0から順に8つの要素を取り出しても良いと思います。 ※人間的にはこちらの方が難しいですが 　 PC的には多分こちらの方が処理が速いと思います。 「配列を偏りなくランダムに並替える」 http://fumiononaka.com/TechNotes/Flash/FN0212003.html それと「%」は剰余演算子です。 その他 Google検索「配列アクセス演算子」 http://www.google.co.jp/search?q=%94z%97%F1%83A%83N%83Z%83X%89%89%8EZ%8Eq
う～～ん...， わかりませんね。 私の持っているバージョンは Flash CS5 ではなく CS4 なのですが それで書かれていらっしゃる通りのものを作成してみましたが child.swf 中の 「読めた！！」 も出ましたし 再生も停止しました。 ↓【添付図】↓ ひょっとして child.swf のパブリッシュ設定が ActionScript 2.0 になってるのだろうか？ などと思い，色々バージョンを変えた実験してみましたが そういう変なことをしたときに出るエラーはご質問のエラーとは違っていました。 　TypeError: Error #1009: 　　 null のオブジェクト参照のプロパティまたは 　　 メソッドにアクセスすることはできません。 　　 at parent_fla::MainTimeline/completeSwf() ですから こういったバージョン違いのミスでもないのだろうと思います。 細かいことを言えば var mc:MovieClip=new MovieClip(); の部分はおそらく var mc:MovieClip; のようにするべき （new MovieClip() を取るべき） だとは思いますが こうしても しなくても どちらにしても 「読めた！！」 は出ましたし 再生も停止しました。 以上， 「どうしてそうなる(ご質問のようにうまく行かない現象が起きる)のかわからない。」という報告まで。
外部XML とか 外部SWF とかは関係なくて navigateToURL を 複数回 連続で 実行しているところが問題なのではないでしょうか。 メインのSWF 「main.swf」 と 外部SWF 「gaibu.swf」 が同じフォルダにあるとします。 「gaibu.swf」 内には 「btn」 というインスタンス名のボタンが用意してあって， そのボタンが存在するフレームに ----------------------- btn.addEventListener(MouseEvent.CLICK,clickHandler); function clickHandler(e):void { var url:URLRequest = new URLRequest("http://goo.ne.jp/"); navigateToURL( url, "_blank"); } ----------------------- と書かれていらっしゃるわけですよね。 また単独で 「gaibu.swf」 を開いた場合は ボタンをクリックすると 「goo」サイト が別窓で開かれるのですよね。 そこまでは問題ありませんよね？ そこまで問題がなければ その 「gaibu.swf」 をロードする 「main.swf」 のフレームには 次のようなスクリプトを書きます。 ---------------------------------- //ローダーの作成と外部SWFのロードと配置 var my_req:URLRequest=new URLRequest("gaibu.swf"); var my_ld:Loader = new Loader(); my_ld.load(my_req); this.addChild(my_ld); //ローダーをクリック時に clickHandler を実行 my_ld.addEventListener(MouseEvent.CLICK,clickHandler); //clickHandler の定義 function clickHandler(e:MouseEvent):void { //タイマーインスタンスを作成(1000ミリ秒後に1回実行) var myTimer:Timer = new Timer(1000, 1); // timerHandler を指定ミリ秒後に実行 myTimer.addEventListener(TimerEvent.TIMER, timerHandler); //タイマースタート myTimer.start(); } //timerHandler の定義 function timerHandler(e:TimerEvent):void { //OKWaveをリクエストとするURLRequestを作成 var url:URLRequest=new URLRequest("http://okwave.jp/"); //そのURLを別窓で開く navigateToURL( url, "_blank"); } ---------------------------------- これでパブリッシュして 表示された「main.swf」 内の「gaibu.swf」内のボタンをクリックすると 「goo」と「OKWave」が開くと思います（多分）。 navigateToURL の連続実行は失敗します。 そもそも複数ページが同時表示されるようにリンクを張ること自体がナンセンスですよ。 いわゆる「ブラクラ」行為です。 AS2 の getURL の頃は 複数窓を同時に開くことはできたと言っても そういう質の悪いこと（質の悪い行動に結びつくこと）は ブラウザのセキュリティによってはばまれていた可能性が大きかったと思います（確かMacとかでは通用しなかったような？）。 上の例では一応１秒の実行間隔をとっていますが これでも一般的には良い行為だとは決して言えません。
まず、 魔女は「スプライト」で作成して(魔女の絵をスプライトの中に入れて)、 そのスプライトを動かすようにします。 （理由：スプライトにはインスタンス名が付けられるため） そのスプライトをシンボルリストに追加作成するときの話ですが 魔女の絵と同じサイズか、魔女の大きさよりも小さいサイズ(例：10×10px)のスプライトを作成し その小さなスプライト内のレイヤーに 魔女の絵 を追加して 「魔女入りスプライト」を作成します。 （小さなスプライトにする理由：基準点の操作がしやすいため） その「魔女入りスプライト」をメインのタイムラインのレイヤーに追加して そのレイヤーに例えば「majyo」というインスタンス名を付けて そのスプライト「majyo」をキャンバス上で動かします【添付図】↓。 そして スクリプトを次のように書き替えます。 (追加ではなく書き換えです。) ------------------------------- // カウント用の変数 cnt の初期化 cnt = 0; // １フレーム進む時間毎に実行する動作をmajyoに定義 majyo.onEnterFrame = function() { //↓星の数の調節(3という数値を変えて調節) for(var i = 1; i<=3; i++){ // 識別子「star_mc」を深度 cnt に呼びだす var Star = _root.attachMovie("star_mc"、 "star"+cnt、 cnt); // 呼びだしたインスタンスをこの(majoの)座標に移動 Star._x = this._x; Star._y = this._y; // 呼びだしたインスタンスを -180～180°でランダムに回転 Star._rotation = Math.random()*360-180; // cnt が 10000未満であれば (10000は適当) if (cnt<10000) { // cnt の値を 1 加算 cnt++; } else { // 10000以上であれば cnt を 0 に戻す cnt = 0; } } }; --------------------------------
> 元の画像もライブラリ内に残ったままになり それで何か不具合がありますでしょうか？ 普通は不具合は起きないと思うので残ったままで良いと思います。 ＝＝＝＝＝＝＝＝ この場を借りて，すみません！ 以下は前回のご質問「景品パネルの作り方」の続きの回答です。 ＝＝＝＝＝＝＝＝ ＃１のお礼で要求されている内容は 「本番用のActionScript3.0のスクリプト」でしたね。 スクリプトだけ書いても伝わるかどうかはわかりませんが 私が勝手に作ってみたも物の例【添付図↓】の場合は(この場合に限っては) 次のようなスクリプトで動作しました。 ------------------------------ //9つの景品クラス名の配列を作成 //最後の Z を "特定の景品" のクラス名とする var arr:Array = new Array("A","B","C","D","E","F","G","H","Z"); //クリック数カウント用変数を用意 var cnt:uint = 0; for (var i:uint = 0; i <= 8; i++) { //9個のMCのボタンモードを有効にする this["panel" + i].buttonMode = true; //9個のMCクリック時に関数 mcClick を実行 this["panel" + i].addEventListener(MouseEvent.CLICK,mcClick); } //関数 mcClick を定義 function mcClick(e:MouseEvent):void { // //カウントを1加算 cnt++; // //乱数を入れる変数の宣言 var rnd:uint; // //もしカウント数が6以下であれば if (cnt <= 6) { //0～配列の最終要素-1までの乱数を取得 rnd = Math.floor(Math.random() * (arr.length - 1)); //カウント数が6以上であれば(最後の方であれば) } else { //0～配列の最終要素までの乱数を取得 rnd = Math.floor(Math.random() * arr.length); } // //その乱数要素を配列から削除して取得 var name_str:String = arr.splice(rnd,1); // //その要素名のクラスのインスタンスを呼び出す var myClass:Class = Class(getDefinitionByName(name_str)); var myInstance:MovieClip = new myClass(); // //そのインスタンスの座標をクリックしたパネルと同じにする myInstance.x = e.currentTarget.x; myInstance.y = e.currentTarget.y; // //そのインスタンスを配置 addChild(myInstance); // //クリック動作を削除 e.currentTarget.removeEventListener(MouseEvent.CLICK,mcClick); // //クリックしたパネルを非表示 e.currentTarget.visible = false; } ------------------------------ スクリプト以前の話としては まずステージ上に "基準点" を中央にした 「panel0」～「panel8」 というインスタンス名を付けたクリック用のMC(ムービークリップ)を用意しています。 これはクリック用のパネルです。 それら９個のMC が存在するフレームに，上のスクリプトを書いています。 それとは別に "内部に" 「パネルが裏返るアニメーション」 を入れた "基準点" を中央にした９個の MC を作成して それらシンボルには「A」「B」「C」「D」「E」「F」「G」「H」「Z」というクラス名を付けています。 そういう状況でのみ無事に動作するスクリプト例です。 状況や作る内容が変われば当然スクリプトも変わります。
ツッコミどころ満載ですね。。。 CS3，CS4 の問題ではないと思います。 書かれていらっしゃるスクリプトでは CS4 でもエラーは出ますし無事に動作しないと思います。 無事に動作するしないは置いておいて まずエラーに関してですが これはイベントの型が違っているからだと思います。 function jump_10(event:MotionEvent):void 　　↓変更↓ function jump_10(event:MouseEvent):void function jump_20(event:MotionEvent):void 　　↓変更↓ function jump_20(event:MouseEvent):void さて以上でエラーは出なくなるとは思いますが これでも無事に動作しないと思います。 ボタンなどのインスタンスにイベントリスナーを登録する場合や 何かのインスタンスに対してそのプロパティを設定したり 何かのインスタンスにメソッドを実行させるためには 「.」(ドット) を使います。 「,」(カンマ) ではありません。 btn01,addEventListener(MouseEvent.CLICK,jump_10); 　　↓変更↓ btn01.addEventListener(MouseEvent.CLICK,jump_10); btn02,addEventListener(MouseEvent.CLICK,jump_20); 　　↓変更↓ btn02.addEventListener(MouseEvent.CLICK,jump_20); btn03,addEventListener(MouseEvent.CLICK,jump_30); 　　↓変更↓ btn03.addEventListener(MouseEvent.CLICK,jump_30); さらに　gotoAndStop(○○)　についてですが， ○○ の部分に数値を入れると その番号のフレームに行って停止します。 ---例--- //フレーム30に行って停止 gotoAndStop(30); ○○ の部分に文字列を入れると そのフレームラベル名の付いたフレームに行って停止します。 ---例--- //ラベル名 content1 のフレームに行って停止 gotoAndStop("content1"); ご質問のスクリプトの場合はこの引数部分が 「"」(ダブルクォーテーション)でくくられていますから文字列です。 つまり　gotoAndStop("フレームラベル名")　という意味になります。 しかし フレームラベル名 に "10" や "20" や "30" などというような 数値そのものを文字列にしたものは使えません。 このフレームラベル指定の「"」は取るべきたと思います。 つまり CS3 ，CS4 の問題ではなく 書かれていらっしゃるスクリプト全般がそもそもおかしいということになります。 全文書き換え↓ stop(); btn01.addEventListener(MouseEvent.CLICK,jump_10); function jump_10(event:MouseEvent):void { gotoAndStop(10); } btn02.addEventListener(MouseEvent.CLICK,jump_20); function jump_20(event:MouseEvent):void { gotoAndStop(20); } btn03.addEventListener(MouseEvent.CLICK,jump_30); function jump_30(event:MouseEvent):void { gotoAndStop(30); }
おみくじみたいに１回のみ１枚をランダム表示をさせるだけでしたら スクリプトを改造するというほどのことでもないと思います。 単に var myTimer:Timer = new Timer(3000); この行↑を含む それ以下の行を全て消せば良いだけだと思います。 つまりわざわざ 「タイマーを使って 3000 ミリ秒間隔で randomShowMC() を実行する」 ということをしなければ良いだけでしょう。 この件に関しましては以上です。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ > 又は、 > ムービーインスタンス「mc0」から「mc4」の画像をランダムで > 表示させ、最初に表示された、 > その画像で停止させるスクリプト 　　↓それは少々頭を使いますね↓ -------------------------------- //[0,1,2,3,4] という要素の配列 n_arr を作成 var n_arr:Array = new Array(0,1,2,3,4); //最初のMCを入れる変数の宣言 var first_mc:MovieClip; //関数 randomShowMC の定義 function randomShowMC(e:TimerEvent):void { //一旦 全MCを非表示にする for (var i:int=0; i<5; i++) { this["mc" + i].visible = false; } //もし配列の要素数が0でなければ if (n_arr.length != 0) { //配列の要素分の乱数を求める var rnd:int = Math.floor(Math.random() * n_arr.length); //配列から乱数要素を抜きとりその要素を取得 var n:int = n_arr.splice(rnd,1); //first_mc が未登録であれば if (first_mc == null) { //ランダムなMCを first_mc に登録 first_mc = this["mc" + n]; } //ランダムなMCを表示 this["mc" +n].visible = true; //もし配列の要素数が0であれば } else { //最初のMCを表示 first_mc.visible = true; //タイマーイベントを削除 myTimer.removeEventListener(TimerEvent.TIMER ,randomShowMC); } } //関数 randomShowMC を実行:初回実行 randomShowMC(null); //タイマーインスタンスを作成 var myTimer:Timer = new Timer(3000); //タイマーイベントをセット myTimer.addEventListener(TimerEvent.TIMER ,randomShowMC); //タイマースタート myTimer.start(); -------------------------------- 　
IEは採用ブラウザの少ないobjectタグでコンテンツを 埋め込むことを推奨としていて、元々ブラウザシェアのライバル だったNetScape向けのタグであるembedタグを意図的に 排除しようとしていた向きもあり、embedタグに対しての対応が 特に最近のIEでは十分ではありません。 ですから、ブラウザ判定を行って処理を分岐させ、各ブラウザ用の 対策を行わないとそのままでどうにかすることは無理です。 いずれにしてもFlashコンテンツを絶対に印刷させないことは 無理なので、どこまでで妥協するかということになりますね。
javascriptでの flash再生停止 http://www.openspc2.org/reibun/FlashMX2004/ActionScript/LiveConnect/001/index.html というようなページならば あったのですが、(たぶんサンプルで点在してる) 作り方が丁寧に書かれてるサイトはわかりません。 ボタンをシーン1のタイムライン1において、2 にASで gotoAndPlay(1); ボタンを押したら それ以降のムービー(シーン2　もしくは タイムライン3以降)に飛ぶように 設定すればできると思います。
＃１です CS5 をお使いでしたら パネルがめくれるアニメーションを作る際に ムービークリップを「3D 回転」させると よりリアルな表現ができると思います【添付図↓】 しかしこの機能を使うには ActionScript 3.0 のパブリッシュ設定にする必要があります。 そうなると ＃１ のスクリプトは使えません。 またお礼に ActionSctipt 3.0 をご希望と書いていらっしゃるので 3.0 に書き換えました。 ActionScript 3.0 設定の 新規ドキュメント を作成し フレーム1にコピペ→「制御」→「ムービープレビュー」する例です。 --------------- //適当に9個のMCを作成(本当は手動で作成) for (var i:uint = 0; i <= 8; i++) { this["panel" + i] = new MovieClip(); this["panel" + i].x = i % 3 * 60 + 40; this["panel" + i].y = Math.floor(i / 3) * 40 + 20; this["panel" + i].buttonMode = true; this["panel" + i].mouseChildren = false; this["panel" + i].txt = new TextField(); this["panel" + i].txt.autoSize = TextFieldAutoSize.CENTER; this["panel" + i].txt.border = true; this["panel" + i].txt.text = "panel" + i; this["panel" + i].addChild(this["panel" + i].txt); this.addChild(this["panel" + i]); } //9つの要素の配列を作成 //最後の Z を "特定の景品" 対象文字とする var arr:Array = new Array("A","B","C","D","E","F","G","H","Z"); //クリック数カウント用変数を用意 var cnt:uint = 0; for (i = 0; i <= 8; i++) { //9個のMCクリック時に関数 mcClick を実行 this["panel" + i].addEventListener(MouseEvent.CLICK,mcClick); } //関数 mcClick を定義 function mcClick(e:MouseEvent):void { //カウントを1加算 cnt++; //乱数を入れる変数の宣言 var rnd:uint; //もしカウント数が6以下であれば if (cnt <= 6) { //0～配列の最終要素-1までの乱数を取得 rnd = Math.floor(Math.random() * (arr.length - 1)); //カウント数が6以上であれば(最後の方であれば) } else { //0～配列の最終要素までの乱数を取得 rnd = Math.floor(Math.random() * arr.length); } //その乱数要素を配列から削除して取得表示 e.currentTarget.txt.text = "景品" + arr.splice(rnd,1); //クリック動作を削除(重複クリック防止) e.currentTarget.removeEventListener(MouseEvent.CLICK,mcClick); e.currentTarget.buttonMode = false; } --------------- なお ActionScript 3.0 ではシンボルに識別子を付けられません。 もしライブラリからシンボルを呼び出す場合は クラス名を付けて new ○○ で呼び出します。 その場合はこの辺をご参考に↓。 「F-site [AS3] クラスを文字列で参照したい」 http://f-site.org/articles/2008/01/17051234.html あと＃１も２も字数制限ほぼいっぱいで これ以上詳細な説明はココでは難しいです。 　
問題を単純化しましょう。 （＝ちゃんと問題を切り分けましょう。） ロードするしない以前の問題です。 （ロードが頭にあるので問題点が切り分けられてないのでは？） これ↓では白い枠自体が描けないでしょう？ ------------------------ createEmptyMovieClip("mc", getNextHighestDepth()); mc.lineStyle(1,0xffffff,100,true,"none","none","miter",90); mc.beginFill(0xffffff,100); mc.moveTo(0,0); mc.moveTo(0,55); mc.moveTo(120,55); mc.moveTo(120,0); mc.endFill(); ------------------------- 白い背景付きの枠を書くのであれば こう↓です。 ------------------------- createEmptyMovieClip("mc", getNextHighestDepth()); mc.lineStyle(1, 0xffffff, 100, true, "none", "none", "miter", 90); mc.beginFill(0xffffff, 100); mc.moveTo(0, 0); mc.lineTo(0, 55); mc.lineTo(120, 55); mc.lineTo(120, 0); mc.endFill(); ------------------------- 以上。 と終わりたいところですが せっかく MovieClipLoader を用意されているようなので MovieClipLoader を使う ならでは のスクリプトを以下に書きます。 ------------------------------------------ //ロード監視用のインスタンスloadListenerを作成 var loadListener:Object = new Object(); //MovieClipLoader インスタンスmcLoaderを作成 var mcLoader:MovieClipLoader = new MovieClipLoader(); //この階層にムービークリップmcを作成 createEmptyMovieClip("mc", getNextHighestDepth()); //JPEGロード完了時の動作を定義 loadListener.onLoadInit = function(target:MovieClip):Void { //ロードしたMCの幅と高さを取得 var w = target._width; var h = target._height; // target.lineStyle(2, 0xffffff, 100, true, "none", "none", "miter", 90); target.beginFill(0xffffff, 100); target.moveTo(0, 0); target.lineTo(0, h); target.lineTo(w, h); target.lineTo(w, 0); target.endFill(); }; //mcLoader の監視役として loadListener を登録 mcLoader.addListener(loadListener); //img/test.jpg をロード mcLoader.loadClip("img/test.jpg", mc); ------------------------------------------ ↑外部JPEGのサイズは任意で（固定でなくて）プログラミングできるという意味です。
書かれていらっしゃるスクリプト中の 　// メソッド 　private function init():void { } この function init 内で var 宣言した変数は このメソッド内でしか通用しません。 つまり この function init 内で作成した ボタン(SimpleButton)インスタンスを参照する変数 fullscreenBtn1 や normalBtn1 は そこでしか通用しない名前ですから 　//ボタンの切り替え 　private function stageFullScreenHandler():void { } 内で呼んでもそのときには存在しないのでどうしようもないのです。 new FullscreenBtn() や new NormalBtn() で作成した "ボタンインスタンス自体" は function init 実行後も存在しますよ。 それらの "インスタンス自体" ではなくて var 宣言で作成した それらのインスタンスを呼ぶための(それらのインスタンス参照用の) fullscreenBtn1 や normalBtn1 という "変数" が function init 実行後に即消えてしまうのです。 「ステートメント、キーワード、ディレクティブ」 http://livedocs.adobe.com/flash/9.0_jp/ActionScriptLangRefV3/statements.html#var 　～引用～ > var 定義キーワード > > 変数を指定します。関数内で変数を宣言した場合、 > その変数はローカルです。 > 変数はその関数用に定義され、 > 関数呼び出しの終了時にスコープから外れます。 というわけで 変更部分の周辺と関係部分のみを書くと 次のような感じになります↓。 --------------------------- package { //インポート //～略～ 　　//↓この２行付け加え(抜け？) import flash.display.StageAlign; import flash.display.StageScaleMode; //～略～ public class Main extends Sprite { //プロパティ　※ここですでに宣言されてますよ(無変更) private var fullscreenBtn:Sprite; private var fullscreenBtn1:SimpleButton; private var normalBtn1:SimpleButton; //～略～ // メソッド　※この function 内の var を削除 private function init():void { fullscreenBtn = new Sprite(); addChild(fullscreenBtn); fullscreenBtn.y = 6; fullscreenBtn1 = new FullscreenBtn(); normalBtn1 = new NormalBtn(); fullscreenBtn.addChild(fullscreenBtn1); fullscreenBtn.addEventListener(MouseEvent.CLICK,btChangeClicHandler); stage.addEventListener(FullScreenEvent.FULL_SCREEN,stageFullScreenHandler); updatePos(null); } //～略～ } } --------------------------- 　
考え方自体は私がかつてココで他の方に回答した このような感じ↓で行くとします。 「QNo.4071675 ローディングバーをゆっくりみせる方法」 http://okwave.jp/qa/q4071675.html 今回ご質問の場合に 上の考え方を当てはめると スクリプトは次のようになります↓。 ------------------------------- var loaded:int; var loadtotal:int; //↓本物のロード％ var percent_A:int; //↓偽物のロード％ var percent_B:int = 0; var loader:Loader = new Loader(); var rec:URLRequest = new URLRequest("komorebiTown.swf"); loader.addEventListener(Event.ENTER_FRAME,enterFrameHandler); loader.load(rec); addChild(loader); function enterFrameHandler(ev:Event):void { loaded = ev.target.contentLoaderInfo.bytesLoaded; loadtotal = ev.target.contentLoaderInfo.bytesTotal; //↓本物のロード％を算出 percent_A = Math.floor(loaded / loadtotal * 100); //↓偽物のロード％を算出(例：2ずつ加算) percent_B += 2; //↓本物と偽物のうち小さい方をテキストフィールドに表示 txt.text=String(Math.min(percent_A,percent_B)); //↓本物と偽物のうち小さい方が100に達すれば if (Math.min(percent_A,percent_B)>=100) { //↓関数onLoadedを実行 onLoaded(); } } //↓関数onLoadedの定義 function onLoaded():void { loader.removeEventListener(Event.ENTER_FRAME,enterFrameHandler); } ------------------------------- なお「ダウンロードのシミュレート」機能を すでに使っていらっしゃれば以下に書くことは無視してください。 こういったものをローカルで動作検証する場合は 「ダウンロードのシミュレート」機能を使うと大変簡単に検証できます。 「ダウンロードのシミュレート」は 「制御」→「ムービープレビュー」 で一旦ムービープレビュー画面を出し その画面から 「表示」→「ダウンロードの設定」で適当な回線速度を選び 「表示」→「ダウンロードのシミュレート」で色んな速度での表示のされかたを検証します。 上で書いたようなスクリプトに変更しなくて 元のままでも ネット上に実際にアップすれば（または「ダウンロードのシミュレート」の設定次第では）， カウントアップする速さは，ある程度遅くなると思いますよ。 ただし元のままと言っても function proHandler 内で addEventListener(Event.ENTER_FRAME,loop); をし続ける部分は間違いだとは言い切れませんが変だとは思います。 （そんなにしょっちゅう何度も同じ addEventListener をしなくても良いでしょう。）
> サーバによってデータの読み込みに、 > こうまで差が出るものなのでしょうか。 普通に出ると思いますよ。 極端な話，例えば 普通の自宅サーバ などは 自分用(個人がインターネットを楽しめるくらい)の回線しかないでしょう？ もしそんな回線で公開して 複数クライアントから同時アクセスがあるととんでもなく遅くなります。 また，細い回線部分を経由すると， その細い部分で頭が押さえられてしまいます。 要するにサーバのスペックもありますが それ以上に回線の問題の方が大きいのではないかと思います。 > データのサイズは1.3MBほどなので、決して重くはないと 普通は十分重いですよ。 タイムラインを使った10分以上のアニメのようなものであれば または しばらく流れる動画入りムービーのようなものであれば そんなに重くはないと言えるのかもしれません。 （ロードと再生が並行で行われるので1.3Mでも苦にはなりにくい。） しかしフレームが少ししかない いわゆるアプリケーション的なものであれば （一瞬で 1.3M 近くのものが表示される必要があるものであれば） かなり重い部類に入ると思います。 もしそのようなものであれば 誤作動を起こす可能性もあるので ちゃんと Now Loading ... のようなロード待ち処理を付けた方が良いと思います。 （また 「ムービープレビュー」 の 「ダウンロードのシミュレート」 機能も使って検証してみてください。）
＃１です。 「画面いっぱいに拡大できない」と書かれていらっしゃったので モニタいっぱいくらいなのかと思ってましたら，なんと15000pxでしたか。 それはすごい数字ですね。 なるほど，おっしゃる通り限界があって，なかなか簡単には拡大できませんね。 > スクリーン外のグレーのエリアからも飛び出してしまい、 > 拡大する四つ角の矢印が見えなくなってしまい、 > 出来ませんでした。 そのグレーエリア内の大きさの限度ですが これはステージの（白い部分の）大きさによって変わるんですよ。 550×450px のものを作るとしても 作成中だけは 2880×2880px にすれば ある程度ワークスペースも大きくできますよ。 「修正」→「ドキュメント」でサイズを 2880px×2880px にしておいて ムービークリップを選択し 「修正」→「変形」→「伸縮」で出てくるハンドルをドラッグすれば 私の場合は ムービークリップ をなんとか 26000×18500px くらいまでは拡大できました。 その辺りが限界でしょうかね。
前回 No.6436822 と同じ並べ替えの仕様で、名前の通し番号だけムービークリップの並び順に変更する、とのことでよろしいでしょうか？ _name プロパティを直接書き換えてしまうと、様々な誤動作の原因になります。 ですから、これは触らずに、配列変数を用意してリネーム後の名前を記録してはいかがでしょう。 No.6436822 でご紹介したスクリプトの初期設定の部分に （↓　各行頭に全角のスペースが入っています。コピーする際はご注意ください） 　//リネーム後の管理番号を記録する配列変数 　//フィールド名 　//　clip：ＭＣの参照（Photo0～番号順） 　//　rename_no：リネーム後の番号 　//記録位置はインスタンス名の番号の順 　var list:Array = new Array(); ↑　このスクリプトを追加し、並べ替えを行う Clip_Align 関数を次のように変更してみてください。 字数の都合上、位置を決める処理を省略させていただきました。 //＊＊＊ 　//整列とリネームを行う関数 　function Clip_Align():Void 　{ 　　var px:Number , num:Number; 　　var i:Number , j:Number; 　　var ref:MovieClip; 　　//表示フレームを順に調べ、表示しているＭＣがあれば横に並べる 　　for( i = 5 , num = 0 ; i >= 1 ; i-- ) 　　{ 　　　//全てのＭＣをチェック 　　　for( j = 0 , px = 0 ; j <= 23 ; j++ ) 　　　{ 　　　　//操作するＭＣの参照を作成 　　　　ref = clip_addr[ "Photo" + j ]; 　　　　//該当するＭＣがあった場合、横に並べていく 　　　　if( ref._currentframe == i ) 　　　　{ 　　　　　/*ここに、位置を決める処理を書く*/ 　　　　　//リストにリネーム後の管理番号を参照と一緒に記録 　　　　　list[ j ] = { clip : ref , rename_no : num }; 　　　　　//次のためにpxとnumを更新 　　　　　px++; 　　　　　num++; 　　　　} 　　　} 　　} 　　//デバッグ 　　trace( "－－－－－" ); 　　for( i = 0 ; i < type_max ; i++ ) 　　{ 　　　trace( "元：" + list[ i ].clip._name + "　リネーム後：" + "Photo" + list[ i ].rename_no ); 　　} 　} //＊＊＊ プレビューで確認すると、元の名前とリネーム後の名前が出力されます。 配列変数にはリネーム後の番号だけが入っています。名前はこの番号に "Photo" を追加して作成してください。 trace 文で分かりにくい場合は、ムービークリップに名前を出力するテキストフィールドを作り、そちらにそれぞれの名前を出力すると確認すると分かりやすくなります。 ActionScript の配列変数では、同じ要素の中に仕切り（フィールドといいます）を作って複数の情報を管理することができます。 今回は clip と rename_no という２つの仕切りを作り、clip にムービークリップの参照を、rename_no にリネーム後の番号を記録しています。 リネーム後の番号を持っているムービークリップを判別できるので、何かありましたら利用してみてください。 ムービークリップの並び順に通し番号を振り直すカラクリは、num という変数で取るカウントです。 この変数をまず、外側 i のループの最初で 0 に初期化しておきます。 内側 j のループで、並べるムービークリップが見つかるたびにこの値を記録し、次のために更新します。 上の段に並べるものから探しますから、つまり、先に見つかったものから順に番号が割り当てられます。 j は元のインスタンス名の番号を表します。 従って、配列変数の j 番目に記録すると、元のインスタンス名の並び順で参照とリネーム後の番号を一緒に管理することができます。 なお、 　list.sortOn( "rename_no" , Array.NUMERIC ); で、リネーム後の順番に注目して並べ替えることもできます。 何かに使えそうでしたら利用してみてください。
横から失礼します。 ＃１の回答者の方が書かれていらっしゃる方法の通りで良いと思います。 ＃１の方の書かれている図（矢印表記の図）は 「タイムラインのレイヤーのようす」 なのです。 ご質問の状況についてですが， まず 「Ａ」のアルファを 100→0 と変化させると その下レイヤーに配置してある「Ｂ」がだんだん現れるのですよね？ そして 「Ｂ」のアルファを 100→0 と変化させると その下レイヤーに配置してある「Ｃ」がだんだん現れるのでしょう？ だとすれば 後は 「Ｃ」の下レイヤーに「Ａ」を配置して 「Ｃ」のアルファを 100→0 と変化させれば 「Ａ」が徐々に現れるものができるはずです【添付図↓】。 PC用 Flash の場合は メインのタイムラインは自動でループ再生しますから ほっておけば勝手に最初のフレームに戻って 「A」→「Ｂ」→「C」(→「A」) が繰り返されるはずです。 ActionScript など不要です。 ※注 PCではなく携帯での閲覧では 自動でループ再生しないので 携帯用SWFを作成する時には 最終フレームにをキーフレームを作成して そのキーフレームに -------------------- //フレーム1に戻って再生 gotoAndPlay(1); -------------------- のようなことを書く必要があります。 　 > Actionscriptは使っていないのですが、 > やはり使わないと不可能なのでしょうか？ 捉え方がちょっとズレているかも(？)です。 Actionscript は「使えば動く」 というものではありません。 (適当な願い事をとなえれば動きだす魔法の呪文ではありません。) 「具体的に何をどう動かすのか」 を考えることが最も肝腎なことです。 プログラムのコーディングとは 「コンピュータが狙い通りに動くように命令文を書くこと」です。 今回の場合 ActionScript を書くとしても いったい何をどう動かすのでしょうか？ 「動かない」と決め付けていると動かせませんから 頭を柔らかくして 「いかにして動かしてやるか」 を考えることが大切です。 「鳴かぬなら鳴かせてみせよう ホトトギス！」 です。 　 > Ａｃｔｉｏｎｓｃｒｉｐｔなどのプログラム言語は、 > みなさんどうやって勉強されたのでしょうか？ 上でも少し書きましたが言語自体はどうでも良いものです。 ホトトギスを鳴かせる具体的な策略を考えるのが第一です。 具体的な策略がなければコードは１行(１文字)たりとも書けません。 具体的な策略が煉り上がればそれが成功するように ActionScript の場合はヘルプや本やネットでスクリプトやその使い方を調べたり 場合によっては過去の記憶などをたどったり試行錯誤をして 狙い通り動くようにキッチリとコーディングして行きます。 上達はこの行為の積み重ねです。 （また，この積み重ねで身につくものを世間ではスキルと言います。） 例えば本を読んで言語だけを大量に暗記しも何にもなりません。 　
まず書かれていらっしゃるページの内容ですが， そのページの通りのことをしても 結局 「CGIページが開いてしまう」 という事態は回避できません。 LoadVars.send メソッド は getURL と同じく 新しいページを開くときに値を送信するメソッドです。 また LoadVars.load メソッド は 単にデータ（ファイル）をロードするだけです。 「データさえ送信できれば、CGIページは開かなくていい」 という場合は，LoadVars.send メソッドではなく LoadVars.send メソッド を使います。 書かれていらっしゃるページと同じサイトで言うなら こちら↓のページです。 「loadVars.sendAndLoad()メソッド。データ送受信」 http://1art.jp/flash2/chapter/49/49.htm ダミーの「ロード用 LoadVars インスタンス」でも用意して 結局 その 「ロード用 LoadVars インスタンス」 ロード時に何もさせなければ 単に 「送信するだけ」 のものができます。 > このやり方だとこのように >　my_lv.name1 = name1_txt.text; > として、my_lv.○○と > いちいち変数を定義し直さなければならないのかな？ 書き方はどうであれ（ループ文などで短くすることはできますが），する内容はその通りです。 基本的に 　LoadVars.変数A=値A; 　LoadVars.変数B=値B; 　LoadVars.変数C=値C; 　　　…　　　　　　　　… のように 送信するデータを指定します（指定できます）。 上に （指定できます） とカッコ付きで書いていますが， 本当はカッコではなくて，こちらがメリットなんです。 getURL だと そのタイムラインにある変数が全て送信されてしまうでしょう？ つまり CGI などに送信する変数の大半は ゴミ になることもあり得るのです。 （というか普通に作っているとゴミだらけになる。） getURL でゴミを送信しないようにするためには getURL 設定用の ムービークリップ をわざわざ作成して， 　そのムービークリップ.gerURL(○○); のようなことをしなければならないのです。 ※この場合↑の gerURL は 　 MovieClip クラス の getURL メソッドです。 LoadVars が誕生するまでは みなさんそうしていたのですがこれって変でしょう？ データを送信するために なんで関係のない ムービークリップ を作成しなければならないのでしょうか？ そこが変なのと機能が少ないのとでLoadVars が誕生したのです。
CD-Rってあのディスクを一から作るんですか？ この文面では、そう受け取られても仕方ないものです。 文面からはなぜFlashで作ろうと思ったのかも見えてきません。 お客さんからはもっと具体的な要望が出されているのではないですか？ 何を作ろうとしているのかが全く見えないので皆さん、回答のつけようがないのだと思います。 より具体的に補足しないと私のような頓珍漢な回答しかつかないのでは？
>>・メインとなるクラスからしかstageにはアクセスできないのでしょうか？ stageはDisplayObjectを継承しているクラスからしか参照ができません。 また、そのDisplayObjectを継承しているクラスも、stageにaddChildされた後でなければstageを参照することはできません。 そのため通常はEvent.ADDED_TO_STAGEをリスナ登録後にstageを参照します。 >>・また、このクラス内でaddChilde()するときもエラー（1180: 未定義である可能性が高いメソッド addChild の呼び出しです。）をはいてしまうのですが、これはこのクラスのインスタンスを生成するときに、addChildするための場所（？）を引数として持ってこないといけないのでしょうか？ addChildはDisplayObjectContainerクラスを継承しているクラスでしか使用することができません。 記述されているクラスはDisplayObjectContainerクラスを継承されていないようですのでエラーがでるのでしょう。 通常はSpriteやMovieClipを継承することが多いです。
＃１です。 > ボタンタイプのシンボルにして、 > オーバーのフレームにだけ音源ファイルをおいてあります。 そういう状況でしたら次のようにするのが１つの方法だと思います。 （その状況だと案は以下の１つくらいしか思い浮かばない。） ステージ上には５つのボタンがあったとします。 　[■sound] 　[■top]　[■mail]　[■blog]　[■link] ボタンにはそれぞれ 「sound_btn」「top_btn」「mail_btn」「blog_btn」「link_btn」 というインスタンス名を付けていたとします。 ※ インスタンス名は， 　　各ボタンを１つずつ選択した状態で 　　ステージ右の「プロパティ」パネルの 　　上の方にある 　　　[＜インスタンス名＞ ] 　　となっている入力ボックスで設定できます。 そのようになっている状態で それらボタンが存在するフレーム(キーフレーム)に次のスクリプトを書きます。 --------------------------------- //音 オン・オフ のフラグを用意（初期値：オン） var sound_flg:Boolean = true; //「sound_btn」クリック時の動作を定義 sound_btn.onRelease = function():Void { //もしフラグの値が true であれば if (sound_flg) { //フラグの値を false にする sound_flg = false; //(目印にこのボタンを半透明にする) this._alpha = 50; //もしフラグの値が false であれば } else { //フラグの値を true にする sound_flg = true; //(目印にこのボタンを不透明にする) this._alpha = 100; } }; //関数 deleteSound の定義 function deleteSound():Void { //もしフラグの値が false であれば if (!sound_flg) { //全ての音オブジェクトを削除 stopAllSounds(); } } //「top_btn」～「link_btn」ロールオーバー時に //関数 deleteSound を実行 top_btn.onRollOver = deleteSound; mail_btn.onRollOver = deleteSound; blog_btn.onRollOver = deleteSound; link_btn.onRollOver = deleteSound; --------------------------------- 要するに「音制御ボタン」を１回クリックしたときに 用意したフラグ用変数の値を false にするわけです。 そして４つの「メニューボタン」にロールオーバーしたときに そのフラグ用変数の値が false である場合に限って出てくる音を全て消すというしくみです。 音(Soundオブジェクト) にインスタンス名などを付けて その音をボタンのロールオーバー時に呼び出すような仕組みにしてあると その音を呼び出さなければ良いというだけのことになります。 そうではなく ボタン内タイムラインに配置した無名の音が勝手に鳴るしくみを作っているわけですから 勝手に鳴り出す全ての音をその都度消してしまうしか方法はないということになります。 ちなみに私が作成してみたものの参考図↓
text1 が配列変数であるにも関わらず、添字を忘れているからではないでしょうか。 　trace( text1[ 0 ].indexOf( "講談社" , 0 ) ); に、変更してみてください。 例えば、 （↓　各行頭に全角のスペースが入っています。コピーする際はご注意ください） //*** 　var test:Array = [ "講談社" ]; 　trace( test ); 　trace( test.indexOf( "社" , 0 ) ); //*** trace 文では確かに”講談社”と出力されますが、”社”を検索すると -1 （見つからない）と出ます。 上記の test は要素が１つしかありませんが、１つしかなくてもれっきとした配列変数です。 ですから、要素の番号を指定して //*** 　var test:Array = [ "講談社" ]; 　trace( test[ 0 ] ); 　trace( test[ 0 ].indexOf( "社" , 0 ) ); //*** ↑　このようにすると、”社”の位置である 2 が出力されます。 要素が１つしかないと分かりにくいのですが、配列変数の添字を省略した場合は配列変数の中身を全てまとめた形で扱われています。 //*** 　var test:Array = [ "講談社" , "集英社" , "小学館" ]; 　for( var i:int = 0 ; i < test.length ; i++ ) 　{ 　　trace( test ); 　　trace( test.indexOf( "社" , 0 ) ); 　} //*** ↑　ループなので「講談社,集英社,小学館」と３回表示され、検索の結果はいずれも -1 です。 この場合も添字を指定して //*** 　var test:Array = [ "講談社" , "集英社" , "小学館" ]; 　for( var i:int = 0 ; i < test.length ; i++ ) 　{ 　　trace( test[ i ] ); 　　trace( test[ i ].indexOf( "社" , 0 ) ); 　} //*** ・・・とすると、要素ごとの値が個別に出力され、検索も正常に行われます。 － － － － － ところで、読み込んだデータを格納する text1 が、jsonLoaderComplete 関数のローカル変数になっているようですが。 ローカル変数は関数が終了すると消えてしまうため、関数の外では参照できなくなります。 関数の外で定義しておくと、そのタイムラインが存在している間は変数も存在しているので、関数の外でも参照できます。
おそらく素材のプレイヤーはflaを編集できないかと思いますのでご自分で作成された方がいいかと思います。 DBに保存する場合はflash → php → mysql という感じでしょうか。 ランキングを表示する際はphpでDBの情報を取得後、テキストかxml等でflashに返してあげればいいんではないでしょうか。
関数はメモリのどこかに存在していて、呼び出す時はその所在地が必要になります。 メモリ内での所在地を表す情報を”参照”といい、関数の名前はその関数のメモリ内での所在地を表す参照になっています。 関数を定義する function キーワードでは、名前を定めない関数（匿名関数といいます）を作ることもできます。 匿名関数を作った時は、作られた関数の参照（＝メモリ内での所在地）が返されます。 返された参照を変数に保存しておけば、この変数を関数の名前の代わりに使うことができます。 ループを利用して匿名関数と連番の名前の付いた変数を作ると、連番の関数のようにすることができます。 合わせますと、関数 on0 ～ on2 を定義し、これらをボタン btn0 ～ btn2 のイベント処理関数に指定するスクリプトは次のようになります。 （↓　各行頭に全角のスペースが入っています。コピーする際は、全て半角のスペースかタブに置き換えてください） //*** 　//btn0～btn2のイベントリスナーを登録 　for( var i:int = 0 ; i < 3 ; i++ ) 　{ 　　//匿名関数を作り、連番の変数に参照を保存する 　　this[ "on" + i ] = function( e:MouseEvent ):void 　　{ 　　　trace( e.target.name ); 　　}; 　　//イベントリスナーを登録 　　this[ "btn" + i ].addEventListener( MouseEvent.MOUSE_DOWN , this[ "on" + i ] ); 　} //*** ↑　この場合は関数が３つ作られ、on0 ～ on1 という名前で呼び出せます。 ただし、全く同じ内容の関数が３つ存在することになり、メモリを無駄に占有してしまいます。 － － － － － ActionScript 3.0 では、イベントが発生した時に呼び出される関数に、イベントに関する様々な情報を１つにまとめたものが渡されるようになりました。 渡される情報の１つに、イベントを検出した対象を表す情報があります。上記の例では仮引数 e を介して参照している e.target の部分がそれで、対象がどんなインスタンス名であっても対応できるようになっています。 動作は全く同じで対象だけが異なる場合は、この e.target という表現を利用すると、関数は１つだけで済みます。 //*** 　//イベント処理関数 　function onButton( e:MouseEvent ):void 　{ 　　//ボタンの名前を出力 　　trace( e.target.name ); 　} 　//btn0～btn2のイベントリスナーを登録 　for( var i:int = 0 ; i < 3 ; i++ ) 　{ 　　this[ "btn" + i ].addEventListener( MouseEvent.MOUSE_DOWN , onButton ); 　} //*** ↑　このスクリプトでは、どのボタンが押されても omButton 関数が呼び出されます。 omButton 関数内の e.target は、btn0 でイベントが検出された時には btn0 を、btn1 で検出された時には btn1 を表しますので、同じ関数を登録していてもボタンに応じた名前が出力されます。
＞私が書いたものは ＞条件の、 ＞★ _mcの移動幅を5～10もしくは-10～-5の範囲になるようにします。 ＞の、 ＞ ＞「_mcの移動幅を5～10」というのをスタート時には設定しているけれど、 ＞「-10～-5の範囲になるように」は設定していないという解釈で大丈夫でしょうか？ 半分不正確、ですかね？ 「『_mcの移動幅を5～10』というのをスタート時には設定していて、 『5～10もしくは-10～-5の範囲になるように』は設定していない」 というほうが正確だと思います。 この問題の場合、正方向と負方向のどちらか一方に向かうのが正しいということはなく、正方向に向かうのと負方向に向かうのとが半々の確率になるようにするのが正しい仕様です。 問題の本文だけだとちょっと分かりづらいですが、ヒントに書いてある式を使うことを考えるとそうなります。 まあ、これはあくまでこの問題に限っての事で、あなたのコードのほうが正しい仕様というのもあります（出発点がステージの隅で、外に出ないように飛び出す方向を正方向-正方向に限定したい）。
ファイル構造がどうなっていて どういうスクリプトを書いたなどが書かれていないため 何とも言えませんが 　「Flash での 指定ファイルパス が 　 Flash(SWFファイル) からの 相対パス になっていて 　 Flash(SWFファイル) が貼り付けてある HTML からの 　 相対パス になっていていないから。」 というのが原因ではないでしょうか？ getURL (←ActionScript 2.0 以下) や navigateToURL (←ActionScript 3.0) で指定するファイルパスは 単純に言えば 「ブラウザへのリクエスト」 です。 URLRequest （←つまり リクエスト） インスタンスを作成する ActionScript 3.0 の方が 明示的 ですからその点はわかりやすいです。 ActionScript 2.0 では リクエストインスタンス を作成しないのでわかりにくいかもしれませんが どちらにしても ブラウザ に対して ページを開く リクエスト を送信します。 ブラウザ は 通常 SWF は直接表示していなくて HTML などを表示していると思います。 SWF は HTML に貼り付いているだけのことで ブラウザ自体は SWF ではなく HTML を表示しています。 （＝ブラウザ自体は HTML の場所を訪問している状態です。） ですから SWF からのは HTML を基準としたパスを書くべきだということになります。 ・例 　任意のフォルダ 　　├ index.html (index.swf が貼り付いている) 　　├ content.html 　　└ flash(フォルダ) 　　　　　└index.swf 「index.html」から「content.html」を相対パスで表示させたい場合 「index.swf」からリクエストするページは 「../content.html」 ではなく 「./content.html」 または 「content.html」 になります。 ---以上，勝手な推測と，勝手に作った例です------------------
replaceMaterialByName関数はCubeオブジェクトに使うものですね。 marker.material = new BitmapFileMaterial(url); でいけるんじゃないでしょうか。 変更前のBitmapDateを再利用しない場合はdisposeしてあげるといいですね。 ではでは:)
＃１、２です。 SetUp 関数内の 　ref = clip_addr.attachMovie(name_str, name_str, i); の後に 　trace( ref ); と入れて、「ムービープレビュー」で確認してみてください。 _level0.a ～ _level0.e のターゲットパスが出力されれば、ムービークリップ a ～ e は存在しています。 存在しているにもかかわらず表示されない場合は、ステージから外れた位置に配置されてしまったのだと思います。 変数 org_x と org_y 、特に org_y の値を小さくして試してみてください。 整列した時は、番号が大きいものほど上に並びます。 最初は全て１なので、一番下である５段目（スクリプトでは０から数えているので４段目）に全部並ぶことになります。 つまり、それぞれの初期座標は 　Ｘ： org_x で指定された位置から、20 px 空けて横並び 　Ｙ：（ムービークリップの高さ＋ 20 ）×４＋ org_y で、org_y を 0 にしてもＹ＝ 400 の座標になります。 ＃１のスクリプトは、org_x と org_y の場所に、一番上に並ぶ５番のムービークリップの左上が来る配置になっています。 この点を考慮して、位置やステージの大きさ・ボタンの配置等を決めてみてください。 trace 文でターゲットパスが表示されない場合は、何らかの原因でムービークリップの挿入が失敗しています。 よくあるミスはリンケージ名の誤りです。 文字コード 97 の代わりに 98 や 99 などを入れて、b 以降のムービークリップが表示されるかどうか、確認してみてください。 リンケージ名は”半角”の”小文字”で付けます。 － － － － － 例えば、 　for( i = 0 ; i < type_max ; i++ ) 　{ 　　for( j = 1 ; j <= pic_max ; j++ ) 　　{ 　　　name_str = String.fromCharCode( 97 + i ) + j; 　　　trace( name_str ); 　　} 　} ↑　このようなループにすると、a1 ～ e5 までの文字列を取得できます。 文字列ができれば、attachMovie で挿入したり、[　] 演算子で参照に変換してムービークリップを参照することができます。 しかし、ムービークリップが全部独立していると、”次の番号の”ムービークリップに切り替える部分が面倒です。 アルファベットや番号がつながっていて名前に関連性はあっても、あくまでも独立したムービークリップ同士になるのですから、それぞれのアルファベットで今表示している番号がいくつであるかを取得する仕組みを作らないと難しいと思います。 また、今表示するもの以外は表示されない（もしくは重ねるなどして見えなくする）ようにする工夫も必要です。 一番手っ取り早いのは、a のムービークリップの１フレームに１つずつ、a1 ～ a5 のムービークリップを入れてしまうことです。 これなら、スクリプトも変更せずに済みます。
ActionScript 以前に Flash のベース的なことなので どこから説明すべきか困りますが 思いつくところから順に書きます。 ・テキスト（テキストフィールド）を傾ける話 動的にテキストを変える場合， 普通はダイナミックテキストフィールドを使用して， フォントには 「_ゴシック」とか「_等幅」などのような "デバイスフォント" を使用します。 このデバイスフォントとは Flash(SWFファイル)内にフォントを埋め込まず， 「あ」なら「あ」という文字情報だけをテキストフィールドに指定し， 「あ」という形（フォントのアウトライン情報）はデバイス(PCや携帯)にあるものを表示させるものです。 今見ているこのページの文字もそうですよ。 ページに「あ」という形が埋め込まれているのではなくて 「あ」を表示しろという命令だけがHTMLに書いてあって 実際の「あ」はPC内のフォントが表示されています。 このような表示方法の文字は回転できないのです。 回転させたい場合はどうするのかと言うと 普通は デバイス のフォントを参照表示させるのではなく Flash(SWFファイル)内に「あ」なら「あ」という形を埋め込んで それを表示させる方法を使います。 ・日本語フォントを埋め込む話 フォントをFlash内に埋め込むと その文字の回転などができるようになります。 英語圏の Flash では フォント が埋め込まれてある Flash を見かけることが良くあります。 ところが 日本語 の場合はものすごく沢山の文字があります。 例えば「MS明朝」１つを全て埋め込んでも それだけで数MBのファイル容量になってしまい実用的なものではなくなります。 ですから 日本語フォントはダイナミックテキストフィールドには埋め込まないのが普通です。 ・(2)フォントの指定： に関連する話 ですから（以上のことから）， フォントを部分的に変更するにしてもしないにしても 日本語部分は固定ですから「静止テキスト」にすべきだということになります。 静止テキストは通常埋め込みフォントになります。 そして 『「○○」に入る数字の部分』 のみを ダイナミックテキスト にして 「日・時・分・秒」各４つの 「○○」 のテキストフィールドに それぞれの数字を表示させるようにした上で， 「日・時・分・秒」各４つの 「○○」 のテキストフィールドに 0～9 までの数字フォントを埋め込む。 ということをする必要が出てきます。 ・簡単な例 ステージ上に5°傾けたダイナミックテキストフィールドを用意し そのテキストフィールドに例えば 「my_txt」 というインスタンス名を付け フォントファミリーをデバイスフォント以外の普通のフォントに設定し 「文字の埋め込み...」ボタンより 数字[0..9](11文字) を指定します【図↓】 フレームに次のスクリプトを書きます。 my_txt.text = "123.4"; パブリッシュすれば 123.4 が表示されると思います。
> 例：var→variableのこと変数という意味 > など。 > 意味と例文が載った分かりやすい本はないでしょうか？ その辺はヘルプに書いてますよ。 「ステートメント、キーワード、ディレクティブ」 http://help.adobe.com/ja_JP/AS3LCR/Flash_10.0/statements.html →「var」 http://help.adobe.com/ja_JP/AS3LCR/Flash_10.0/statements.html#var 意味も使用例も載ってますよね？ そういうことを書き出したらキリがないんです。 （それだけで膨大な情報量になって結局何の解説もできない本になる。） だからそういう本はないと思います。 （そもそもヘルプにあるのでそんな本を作成する必要もないですし。） それにそんなことわかっても実際には使えないので そういうことは飛ばした本ばかりがあるのです。 > そんなの丸暗記だとおっしゃられるかもしれませんが、 > どうも理屈っぽくて、それから先に進めません。 ...それが良いことか悪いことかは知りませんが そもそもそのように考えるところが 少なくとも私とはかなりズレてると思います。。。 丸暗記も何もですね... そもそも覚える必要はほとんどないんです。 単純に言えば 「『暗記』は人間のする作業ではない。」 です。 もちろん var とか function とかくらいは丸暗記で覚えていますが， それ以外は調べれば出てくるでしょう？ 人間のする作業は， 「見ること」「考えること」「調べること」です。 見たものを「良い」とか「悪い」とか判断することはPCや本には無理です。 「何をしたいか」，「どのようにすべきか」を考えることもPCや本には無理です。 「何を調べれば良いか」「どう調べれば良いか」を判断することもPCや本には無理です。 つまり人間は人間でしかできないことを担当すべきです。 辞書的な記憶力なんてPCや本には絶対勝てないわけですし， そもそもPCや本に勝つ必要もないのです。 引き出しの取っ手部分くらいを記憶しておけば良いのです。 例えば 　「接尾辞 というものがあって 変数の値にそれを入れると 　あとは コードヒント が出てくるので便利だ」 とか，そういう引き出しの取っ手部分(この場合は「接尾辞」というもの)を記憶をしていれば良いのです。 「FN0303002 - コードヒントの活用 - Flash テクニカルノート」 http://fumiononaka.com/TechNotes/Flash/FN0303002.html ちなみに CS4 のヘルプは， デフォルトではネット上のページを参照してしまいます。 これでは非常に使いにくいです。 私は次のページの方法でローカルのヘルプをオフラインで利用しています。 「F-site Flash CS4のヘルプ」 http://f-site.org/articles/2009/01/16130620.html ※実はこの↑ページ 　 私が CS4 のヘルプについて 　 「ローカル で使えないから困る」 と 野中先生 に言ったとき 　 「なるほどそうだ」ということになって 　 野中先生が作ってくれたページです。 上記ページの 「この記事へのコメント」にある 5.オッキー さんのコメントが非常に参考になります。 > 5.オッキー（2009年02月03日 11:38） > オフラインでヘルプを確認する方法 > [ウィンドウ]-[エクステンション]-[サービス接続] > -右上のフライアウトメニュー(▼)-[オフライン設定] > -[オフラインのままにします]をチェック > だそうです（via Adobe N村さん）。 簡単なことでも調べることは大切です。 わかりきっているようなことでもどんどん調べてみてください。
ロードしたJPEGに名前(インスタンス名)を付けるのでしたら そのJPEGをロードするムービークリップに名前を付ければ良いだけです。 つまり簡単なことです。 問題はそうではなくて JPEGをロードするムービークリップに onRelease=function(){} のような イベントハンドラメソッド が設定できないということではないでしょうか？ ムービークリップにJPEGなどをロードすると そのムービークリップはJPEGに乗っ取られてしまいますが そのとき すでに設定してある イベントハンドラメソッド も消えてしまうのです。 解決方法は大きく分けて２つあります。 １つ目は イベントハンドラメソッドを設定するムービークリップ（＝親MC）内に JPEGをロードするムービークリップ（＝子MC）を作成して その 子MC に JPEG をロードする方法です。 ２つ目は JPEGをロードするムービークリップにJPEGをロードし， 完全にロードされた状態になってから(ロード待ちをしてから) そのムービークリップに イベントハンドラメソッド を設定する方法です。 上記１つ目の方法は 入れ子状態のムービークリップを作れば良いだけですから簡単です。 ２つ目の方法は 実際にスクリプトを書かなければわかりにくいと思うのでこの方法について書きます。 ◎ ファイル構造 　任意のフォルダ 　　　├任意のフォルダ 　　　│　　├○○.html 　　　│　　└○○.swf（○○.fla） 　　　└images(フォルダ) 　　　　　　 └image1.jpg ◎ ○○.fla _root のステージ上には 「targetlargeMC」というインスタンス名を付けたムービークリップを すでに用意してあるものとします。 その他 本題とは関係ない雑多な物（handMC など）は存在しないものとします。 (問題解決には問題の切り分けが大切です。問題をシンプルに！) (本来，雑多なものは質問者が削除しておくべきです。) (そういう肝腎な作業をしていないことが問題解決できない最大の原因ですよ。) ◎ ○○.fla の _root のフレームに書くスクリプト ------------------------------ //ロードを監視するオブジェクトを作成 var obj:Object = new Object(); //MovieClipLoaderインスタンスを作成 var mcl:MovieClipLoader = new MovieClipLoader(); //JPEGロード完了時の動作を定義 obj.onLoadInit = function(target:MovieClip):Void { target.onPress = function():Void { this.startDrag(); }; target.onRelease = target.onReleaseOutside = function ():Void { this.stopDrag(); }; }; //mclのリスナーとしてobjを登録 mcl.addListener(obj); //targetlargeMCをターゲットにJPEGをロード mcl.loadClip("../images/image1.jpg", targetlargeMC); ------------------------------ ActionScript 2.0 要 Flash Player 7 以上
ややこしければ無理をせずに 変数の中にURLを入れて そのURLを window.open すれば良いのではないかと思います。 ---例----------------------- Btn.onRelease = function() { my_url = "test.php?name=" + escape(mozi) + "&tokuten=" + suuti; getURL("javascript:void(window.open('" + my_url + "','subWin','width=320,height=240'))"); }; ---------------------------- ちなみに 変数を利用しない場合は 次のようになると思います。 ---------------------------- Btn.onRelease = function() { getURL("javascript:void(window.open('test.php?name=" + escape(mozi) + "&tokuten=" + suuti + "','subWin','width=320,height=240'))"); }; ---------------------------- ※ 私の環境で 　　ローカルファイルを IE で閲覧した場合では動作しませんが 　　他のブラウザや ネットにアップした場合は 　　上記スクリプトで動作します。
その動作は、IE 6/7/8における「EORAS SCREEN」というクソな仕様の結果で、UIの理念とは何の関係もありません。 何でも、Microsoftが、Webページ内にプラグインを埋込む仕様について、EORASという企業の特許を侵害したとかで、自主的に「１クリックしないとインタラクティブ動作できない」ふうにブラウザを設計したようです。 Microsoft以外のブラウザにはこの特許問題がなく、そもそも本当に特許侵害問題があったのかなど、詳しいことは全く謎ですが、<object>タグを使ってIE用プラグイン（いわゆるActiveXというやつ）を直打ちした場合には、必ずこの問題が発生します。 また、Flashに限らず、ShockwaveやAcrobatなどのプラグインでも発生します。 回避方法は単純で、外部JavaScriptから、document.write等を用いて<object>タグ以降を生成すればよく、普通はFlash埋込み用の各種JavaScriptライブラリが存在しますので、それを使います。 有名なライブラリでは、swfObjectというものがあり、これを使えば問題は発生しません。 Dreamweaverでも最近のバージョンではこれを使ってFlashをページに埋め込むようになっています。
> スタートボタンにタイムの設定とタイムが0になったときに > ジャンプするフレームを設定した場合、 > スコアはどこにどのように設定したら表示されるのでしょうか？ この質問で、質問者さんがどの程度理解されているかは、なんとなく分かりました。 「インスタンスへのパス指定方法が分からない」という理解でよろしいでしょうか？ スクリプトをそのまま読み取るのであれば、スコア表示に指定されているscore_txtをrootに配置してください。簡単な回答ですが、これ以上の表現が思い浮かびません。具体的なパスの指定方法は参考URL(「flash 相対パス　絶対パス」でのgoogle検索結果の先頭)が参考になります。 もしくは、 ・scoreに0は表示される(1フレーム目のscore初期化は動いている) ・scoreの加算、減算の部分に不具合があるっぽい(puraScore()やmaiScore()が怪しい) ・変数(score)への指定はあるが、インスタンスscore_txtへの指定が見当たらない。 以上のことから、もしかしたら、puraScore()やmaiScore()に以下を追加すると動くかもいしれませんね。 もちろん、加算、減算のあとに追加してくださいね。 _root.score_txt.text=score;
確認ですがムービー内の階層構造を書くと次のようになっているということですよね？ 　_root 　　　└c_sprite(スプライトインスタンス) 　　　　　　└c_text(テキストフィールド) まず理解しておくべきことは 「TextFormat」 を適用させるのは 「TextFieldインスタンス」 なんです。 （インスタンスに対してテキストフォーマットを適用するという意味） ですからまず、 スプライトインスタンス「c_sprite」 内の テキストフィールド には （「c_sprite」 内のレイヤーに配置した テキストフィールド の レイヤーには） 「c_text」というインスタンス名を付ける必要があります。 "変数名" ではなく "インスタンス名" です。 (もし 変数名 を付けていたらその変数名は削除した方が良いです。) そして 書かれていらっしゃるスクリプトを次のように変更します。 var c_text_tf = new TextFormat(); c_text_tf.color = 0x0000FF; _root.c_sprite.c_text.setNewTextFormat(c_text_tf); _root.c_sprite.c_text.text = "■"; 最後の４行目だけを変えただけです。
やっぱり肝腎な点（コピペでさえ動作しないという点）を無視して 先へ先へ進むのが間違っていたと思います。 良いですか。 「問題を切り分ける」が最も大切なことです。 元の質問自体が「問題を切り分け」ができていないのです。 今の現状の詳細説明が必要なのではありません。 「バージョン」と「できない点」が必要なのです。 良いですか。 「マウスアイコン」も何も元の問題解決には関係がないのです。 まず ＃１ で回答したスクリプトが実行できないのでしょう？ これは避けて通れない重要問題ですよ。 私は何年もココで回答していますが， 私自身の回答でそういう意見が返って来たことはありません。 初めてのことです。 -------------------- OKWave 連携サイトによっては コピペで何か不都合が生じる場合があるかもしれません。 ですからまず OKWave から このご質問のページを見てみてください。 ＃１の該当ページは "今現在" はおそらく次のURLでアクセスできると思います。 http://okwave.jp/qa/q6408118_2.html 上記ページのスクリプトがコピペしにくい場合は 「印刷」ページからの方がコピペしやすいかもしれません。 http://okwave.jp/print/qa/q6408118_2.html?order=DESC&by=datetime コピペしにくい場合は その 「印刷」 ページからコピペするようにしてください。 Flash を全く起動させていない状態から Flash CS4 を起動させます。 するとデフォルトの設定では この回答に添付した 【図↓】 のような画面になると思いますから すかざず 「Flash ファイル （AS 2.0）」 を選択してください。 そうしますと ステージ が現れて， デフォルト設定ではステージの下に 「タイムライン」 と書かれたタブが出てくると思いますから その 「タイムライン」タブ を選択します。 その タイムライン の フレーム1 を選択して 「ウィンドウ」→「アクション」 で 「アクション-フレーム」 と書かれたタブを出します。 その 「アクション-フレーム」 内の白いスクリプトを書くスペースに ＃１ で書いたスクリプト の 「---」 と 「---」 との間のコードをコピペします。 その状態で すかさず 「制御」→「ムービープレビュー」 です。 そうしますと ムービープレビュー画面が出てくると思いますから そのムービープレビュー画面の中の 　[スタートボタン] をクリックします。 そうすれば 60 から 59→58→57→ とカウントダウンが始まり カウントが 0 になると 出力窓に 　　得点は10点 　　適当にどこかのフレームにジャンプする という内容の文字列が表示されると思います。 この原理を理解して 今作成されているものに使ってください。
ムービークリップの中に雪を降らせて そのムービークリップにマスクをかければいいでしょう。 マスクにする星型のムービークリップに「star_mc」というインスタンス名を付けたとします。 そしてスクリプトの最初の部分 ---------------------------- width = 550; height = 400; total = 200; for (var t = 0; t != total; t++) { var mc = _root.attachMovie("snowflake", "snowflake"+t, _root.getNextHighestDepth()); 　～略～ ---------------------------- この部分を次のように変更します。 ---------------------------- width = 550; height = 400; total = 200; //例えば「sky_mc」というムービークリップを作成して _root.createEmptyMovieClip("sky_mc",0); //その「sky_mc」に「star_mc」のマスクをかけて _root.sky_mc.setMask(star_mc); for (var t = 0; t != total; t++) { //その「sky_mc」の中にsnowflakeを呼び出す var mc = _root.sky_mc.attachMovie("snowflake", "snowflake"+t, _root.sky_mc.getNextHighestDepth()); 　～略～ ---------------------------- なお上記スクリプトでは 雪を降らせる「sky_mc」 をスクリプトで作成していますが スクリプトで作らず手でムービークリップを作成して そのムービークリップをステージの左上コーナーに手動で配置しても良いです。 （そのムービークリップの基準点がステージ左上のコーナーに来るように配置しても良いです。） 手動で配置した場合のメリットは「レイヤーを選ぶことができる」ということです。 雪の上に（雪の手前に）何かを描くことも 雪の下に（雪の背景に）何かを描くことも簡単にできます。
？？？ その「コンパイラ」という言葉を使われている状況によって変わると思いますが 私が 「Flash で コンパイラ」 という言葉を聞いたときに パッ と思いつくのは 文字通り 「SWF を コンパイル する ソフト」 です。 Adobe(Macromedia) Flash 作成ソフト 限定用語で言うなら， 「SWF を パブリッシュ する ソフト」 です。 つまり Flash オーサリングツール のことです。 つまり Flash MX とか Flash 8 とか Flash CS3 とか Flash CS5 とかが 王道の Flash コンパイラ です。 そして その派生の Flex もしくは Flash Builder 系列も Flash コンパイラ ですし， Flash Catalyst もFlash コンパイラ です。 さらには Flash と同じ ローカルマシーンで SWF を作成する ParaFla! や Suzuka など 日本製 SWF 作成フリーソフトもそうですし， その他 FREEMOTION とか MotionMaker もそれに該当します。 また サーバ 上 で動的に SWF を生成する Ming などもそれに該当すると思います。 私は 「Flash で コンパイラ」 という言葉を聞いて それだけでは 以上のように解釈しますが。
すみません ＃１ です。 > 開催日時を > new Date(2011,4,1,0,0,0);//2011年4月1日 午前0時0分0秒 > と書き換えてみたのですが、 > 表示値の日付が「マイナス17日」となってしまいました。 本当ですね。検証不足で失礼しました。 変数の型指定 の unint や int がまずかったです。 限界値を振り切れてました。。。 そういう大きな数の型指定は ActionScript 2.0 同様 Number が良いです。 その他，妙な雑念も少し追い払って次のような感じで良いのではないかと思います。 ------------------------------------ //---テキストフィールド「cd_txt」を用意--- //(手動で用意しても良いですよ。) var cd_txt:TextField = new TextField(); //適当に設定 cd_txt.border = true; cd_txt.background = true; cd_txt.autoSize = "left"; //適当に座標を指定 cd_txt.x = 20; cd_txt.y = 10; addChild(cd_txt); //---開催の日時を設定--- //例：2011年4月1日 午前0時0分0秒 var open_date:Date = new Date(2011,3,1,0,0,0); //開催日時の1970年1月1日からの経過ミリ秒数を取得 var open_time:Number = open_date.getTime(); //今の日時オブジェクトの宣言 var now_date:Date; //1フレーム進む時間毎に関数countDownを実行するイベントリスナーを登録 this.addEventListener(Event.ENTER_FRAME,countDown); //関数countDownの定義 function countDown(evt:Event):void { //今の日時を取得 now_date = new Date(); //今の1970年1月1日からの経過ミリ秒数を取得 var now_time:Number = now_date.getTime(); //開催日と今の差分ミリ秒数を算出 var diff_time:Number = open_time - now_time; //カウントダウンする日数を取得 var cd_days:Number = Math.floor(diff_time/(24*60*60*1000)); //余りのミリ秒を取得 var remain_ms:Number = diff_time-cd_days*24*60*60*1000; //カウントダウンする時数を取得 var cd_hours:int = Math.floor(remain_ms/(60*60*1000)); //余りのミリ秒を取得 remain_ms -= cd_hours*60*60*1000; //カウントダウンする分数を取得 var cd_minutes:int = Math.floor(remain_ms/(60*1000)); //余りのミリ秒を取得 remain_ms -= cd_minutes*60*1000; //カウントダウンする秒数を取得 var cd_seconds:int = Math.floor(remain_ms/1000); cd_txt.text = "開催まであと" + cd_days + "日" + cd_hours + "時間" + cd_minutes + "分" + cd_seconds + "秒です。"; } -------------------------------- なお ActionScript に関わらず 月の数（１月 ２月…）は，日本人の感性とは１箇月ずれます。 日本人の 1月 は プログラミング言語では 0の月 です。 日本人の 2月 は プログラミング言語では 1の月 です。 日本人の 12月 は プログラミング言語では 11の月 です。 ですから ＃１ の場合は //例：2010年12月30日 午前7：30分 0秒 var open_date:Date = new Date(2010,11,30,7,30,0); のままで良いですし上の例も //例：2011年4月1日 午前0時0分0秒 var open_date:Date = new Date(2011,3,1,0,0,0); で良いのです。
こういうことでしょうか↓？ 教えて！goo より 「wonderflのコードをCS4で再現」 http://oshiete.goo.ne.jp/qa/5141080.html
chromeはキャッシュが微妙なのでその影響じゃないでしょうか。 もう解決されたとのことなので確認は出来ませんが、不具合が出たときはシークレットウィンドウを開いてそっちで確認して動けば大抵はキャッシュが原因ですね。拡張とかでも別管理になっているようで、通常ウィンドウでクラッシュしてもシークレットウィンドウでは平気とかよくあります。 それにしてもchromeのフラッシュページのクラッシュ率は異常ですね。
おそらくこの点↓が問題でしょう。 > 次に スプライトAでボタンを作って、以下のように記述しました。 Suzuka や Parafla! の スプライト というものは Adobe (Macromedia) Flash で言うところの ムービークリップ(MovieClip) なんです。 で、 そのムービークリップというのはムービーの中のムービーであって「階層」を持つんです。 「ターゲットパス」 http://homepage3.nifty.com/ginga-b/MX/targetpath.html 「Suzuka 基礎・基本 ★ ターゲットパス(&階層)」 http://suzupara.iinaa.net/kiso_target.html ボタン と スプライト とは、階層を持つ持たないが大きな違いです。 （ボタン＝階層を持たない ・ スプライト＝階層を持つ） > タイムライン上にアクションレイヤーで > n = 10 ; > として 変数n に１０を代入しました。 おそらくこの タイムライン上 とは メインのタイムライン， ActionScript的に言えば _root のタイムラインだと考えられます。 一方 > on(Press){ > n = n - 1; > } と書かれたのは スプライトA ですから つまり スプライトA の中の変数 n から -1 をしようとしているということになります。 階層図で表すと次のようになります。 　_root ← n=10 　　　└スプライトA ←nから1を引く したがって、 _root の変数 n の値を -1 したい場合は、 スプライトAに書くスクリプトを on(press){ _root.n = _root.n - 1; } または on(press){ _root.n -= 1; } または on(press){ _root.n--; } もしくは on(press){ _parent.n = _parent.n - 1; } または on(press){ _parent.n -= 1; } または on(press){ _parent.n--; } もしくは on(press){ this._parent.n = this._parent.n - 1; } または on(press){ this._parent.n -= 1; } または on(press){ this._parent.n--; } のように書く必要があります。 ＝＝＝＝＝＝＝＝＝＝＝＝ なお on(release) や on(press) など onハンドラ の () 内の最初の文字は小文字です。 Flash Player 7 以上(SWF7 以上)用の SWF では 大文字小文字が厳格に区別されますから 大文字小文字を間違えると正常に動作しない現象が発生するおそれがあります。
以下の条件を全て満たさない場合、この回答は役に立たたないので回れ右。 *FlashDevelopを使用している。 *問題が発生しているのはOutputパネル *コロンの左側の数字によっては出力内容に色が付く。 結論からいうと、ActionScriptもFlashも質問者も悪くなく、FlashDevelopが余計なことをしているのが原因。 「二文字目がセミコロンである場合、最初の数値の値によってstatusを変える。 その上で、その2文字を本来のメッセージから取り除く」とかいう処理。なんで余計なことすんねん。 http://code.google.com/p/flashdevelop/source/browse/trunk/FD3/External/Plugins/OutputPanel/PluginUI.cs?r=1623#307 回避策は、該当箇所(307-316)までをコメントアウトするなり削除した上で、ソースコードをビルドしなおしてOutputPanel.dllと入れ替える。 ============================================= *さんじゅっぷんくっきんぐ！面倒臭がりの俺のレシピ、書き方が非常にイイカゲンだ！ 0. FlashDevelopを終了する。 1.MonoDevelop, SharpDevelop, Visual C# Express等の開発環境と、必要があればコンパイラ等を用意 #俺はMonoDevelop + Monoを使うようにしているが、他の人には使いにくいかと(ぉ 2.ここ以下のファイルを階層構造保ったまんますべてダウンロード。まぁ俺がSubversionに慣れてないだけですが。 http://flashdevelop.googlecode.com/svn/trunk/FD3/External/Plugins/OutputPanel/ 3.開発環境上で、ソリューションを新規作成し…ウィザードの都合上、C#プロジェクトを新規追加するハメになるだろう。 名前は何でもいいや。実質どうせ使わないし。 4.ソリューションエクスプローラ上のソリューションを選択して多分コンテキストメニューとかから出来るんで、ダウンロードしたcsprojファイルを指定してプロジェクトを追加しておこう。 5. 何か参照のSystem.Deployment使ってないっぽいから削除 6. 今回面倒くさくてダウンロードしてないので、参照できなくなっているPluginCoreプロジェクトを削除する代わり、 すでにインストールしているFlashDevelopの方からPluginCore.dllを追加 7. ビルドしたバイナリの出力先が、このソフトの開発者の環境に合わせた位置にあって結構アレなので適当に修正。 8. ビルド 9.もとのOutputPanel.dllのバックアップとった上で、できあがったOutputPanel.dllを既にあるOutputPanel.dllと入れ替える。 10. FlashDevelopを起動し、現象が再現していたソースコードをビルド・実行してみて、現象が再現しないことを確認する。 ================================ 一度自分でビルドしてみてね。一応デバッグビルド済みの奴置いとくけど。 https://cid-b89cb784f5346675.office.live.com/browse.aspx/TestCase/Q6389424?uc=1 #MITライセンスって著作権者名書くらしいけど、プロジェクト(FlashDevelop.org)なのか作者(Mika Palumさん)なのかわからん。 #一応「リンクするだけでOK?」っぽい雰囲気がコメントにあるのでそのまんま放置http://www.opensource.org/licenses/mit-license.php #問題があったら差し替えるかも
どちらの方法も結構簡単ですよ。 ↓flash勉強用サイト http://flashmovie.client.jp/02-tech.html ↓おすすめ書籍 Webデザイン＆スタイルシート逆引き実践ガイドブック　境　祐司 2008年初版で少し古いのですが、Webデザインの勉強の仕方や、デザインの基本なんかも載せられていて面白かったです。 まるまるこのサイトをコピーして作ってみたりしたらいいと思います。
lis.onLoadInit には、function キーワードで作った匿名関数の参照が入っています。 lis が startLoad 関数の終了とともに消え、それに伴い lis.onLoadInit も無効になっても、この匿名関数そのものは削除されません。 同様に、変数 mcLoader には、new MovieClipLoader(); で作成した MovieClipLoader オブジェクトの参照が入っています。 mcLoader は startLoad 関数が終了した時に消えてしまいますが、メモリ内のどこかに作られた MovieClipLoader オブジェクトの本体は消えません。 startLoad 関数内では、lis.onLoadInit や mcLoader に記録されている参照を使って、”MovieClipLoader オブジェクトの本体に”「読み込みが完了したら、指定の関数を呼び出すように」と指示を出します。 MovieClipLoader オブジェクトの本体と匿名関数は startLoad 関数が終了してもメモリのどこかに存在しており、オブジェクトは指示に従って活動を続けます。 ですから、startLoad 関数が終了して lis や mcLoader が削除されても、読み込みやイベント処理関数は問題なく実行されるというわけです。 ポイントは、lis と mcLoader 自身がイベント発生時に呼び出される関数と読み込みを実行するオブジェクトなのではない、という点です。 イベントハンドラに登録する関数と MovieClipLoader オブジェクトの本体はメモリのどこかに作られており、lis や mcLoader はただ、その所在を知っていて取次ぎをしているだけなのです。 匿名関数が startLoad 関数終了後も存在していることは、次のようにすると確認できます。 （↓ 各行頭に全角のスペースが入っています。コピーする際は、全て半角のスペースかタブに置き換えてください） //＊＊＊ 　//関数の参照を保持する変数 　var test:Function; 　function startLoad():Void 　{ 　　var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth()); 　　var mcLoader:MovieClipLoader = new MovieClipLoader(); 　　var lis = new Object(); 　　//リスナーと変数に匿名関数の参照を記録する 　　lis.onLoadInit = test = function() 　　{ 　　　trace(1); 　　}; 　　mcLoader.addListener(lis); 　} 　startLoad(); 　//変数testに格納されている関数を呼び出してみる 　test(); ＊＊＊// 「ムービープレビュー」で確認してみてください。 loadClip を省略しているため読み込みは行われず、lis.onLoadInit に記録されている匿名関数は MovieClipLoader のイベントハンドラからは呼び出されません。 匿名関数は１度だけ、最後の test(); により呼び出されます。 －－－－－ new MovieClipLoader(); で作ったオブジェクトや lis.onLoadInit に記録された匿名関数は startLoad 関数が終了した後でも存在はしていますが、その所在を知っていたのは、ローカル変数の mcLoader と lis.onLoadInit だけです。 従って、この所在を誰か他の者にも伝えておかない限り、startLoad 関数の終了とともにオブジェクトと匿名関数の所在を知る者がいなくなり、２度とアクセスできなくなってしまいます。 上記のスクリプトでは、匿名関数の場所をタイムラインが持っている変数である test にも記録しているので、startLoad 関数の外でも呼び出すことができます。
http://www.macromedia.com/support/documentation/jp/flashplayer/help/settings_manager04.html ここにアクセスしていただき、swfが置いてあるドライブを選択して追加してください。 編集 ↓ 追加 ↓ フォルダーを参照 ↓ swfの置いてあるドライブ 普通はc:¥です。
まずは簡単なところから始めるようにしましょう。 初心者でしたらなおさら基本的な文法や処理の意味を理解しないとやりたいと思ってらっしゃることは実現不可能かと思います。 ヒントを求めるというかおっしゃっていることは誰かに作ってもらいたいような感じを受けますので自由課題とのことでしたらなおさら、ご自分で理解しながら作っていくのが大切かと思いますがいかがでしょうか？ 「こういう実行をしたいんだけど」「こういうコードを書いて」「こういうエラーが出て」「ここがわからない」上での助言を求めるようにしないと回答もしずらいかと思います。 まずは、大重さんや野中さんなどがASの基本について書かれている本が沢山出ていますのでそこから勉強した上でやりたいことを実現させていくのが 一番の近道かと思います。
次のページに書かれてあることがそのまま答えに近いものではないでしょうか？ 「F-site [AS3] クラスを文字列で参照したい」 http://f-site.org/articles/2008/01/17051234.html
その書かれていらっしゃるページが良く理解できますね。 私は理解できませんでしたが。。。 というかですね， 思ったまま(考えついたまま)を脈略無くメモしただけのページなのではないでしょうか？ 説明のしかたが悪いのではなく， 元から説明などする気などなくて， 単なる私的構想メモ日記を書いたページのように見えますが。 > 「1180:未定義である可能性が高いメソッド > flagStateの呼び出しです。」 > のエラーが出てしまいます。 ムービークリップクラスを継承するflagStatクラスを用意していないからではないでしょうか？ つまり 内部が３フレーム（３つのキーフレーム）からできていて 各フレームのステージ上には 「　(空白)」 や 「■」 や 「×」 の絵を配置し 各キーフレームには 「off」 や 「on」 や 「erase」 というようなフレームラベルを付けたムービークリップを用意しておいて ライブラリ からそのムービークリップを選択して リンケージ より flagStat というクラス名を付けるんです。 その作業が抜けているのではないでしょうか？ という意味です。 リンケージでクラス名を付ける部分や それを呼び出す部分などが参考になるかと↓。 「第３回 表示リスト」 http://saitos-web.com/interactive2/lec_3.html
画像を使いたいと書かれましても その画像がどこにあるどんな画像かがわからないため 具体的な方法やスクリプトは回答できませんね。 例えば ・その beginFill～ で描いた四角や三角なども画像と言えば画像です(ベクタ画像)。 ・ステージ上に描いた絵も画像です(シェイプ，ベクタ画像)。 ・スクリプトでビットマップ画像を描くことも可能です。 ・ライブラリの中に読み込んだJPEGなどの写真も画像です(ビットマップ画像)。 ・外部JPEGファイル(ビットマップ画像ファイル)をロードする場合もあるでしょう。 ・外部SWFでも静止画であれば一般的にそれは画像になります。 何処にある何を表示させるのかによって その方法も考え方自体も変える必要があることがわかると思います。 もし， ライブラリにあらかじめ読み込んであるビットマップ画像を ステージ上に呼び出すのでしたら この辺が参考になると思います↓。 「F-site [AS3] ビットマップをダイナミックに配置する」 http://f-site.org/articles/2006/08/10205003.html もし， 外部ビットマップファイル(JPEG/静止GIF/PNG)を 作成中のSWFにロードするのでしたら この辺が参考になると思います↓。 「ADD CHILD = AS3 - Loaderクラスで外部ファイルから画像を複数読み込む[3-5]」 http://www.addchild.net/as3-beginner/ls3/337.html その他，もし，もし，… と書いていたらきりがありませんのでこの辺で終わります。 ＝＝＝＝＝＝＝＝＝＝ あと ご質問で書かれているスクリプトの > var ball:MovieClip=new MovieClip(); の部分や， 私が上で書いた２つ目のページの > //Loaderオブジェクト生成 > var myLoader:Loader = new Loader(); の部分のように， for文の中で，同じ参照変数名を持つインスタンスを複数作ると， 後々の管理ができなくなるので， 「配列アクセス演算子」などを使って，違う参照変数名を付けた方が良いように思います。 （単に「並べて終わり」でしたらそのままでも良いと思います。）
＃１です。 > なぜfunctionのあとだとi=11になるのでしょうか？ Flash の ActionScript に限らず for 文で i を変えれば普通はそうなります。 それがルール（言語仕様）です。 ActionScript 限定で話をすると 例えば次の文をフレームに書いたとします。 --------------------- for (i=1; i<=10; i++) { trace(i); } trace(i); --------------------- 上の文はパブリッシュ時に 次のように変換されて処理されます。 --------------------- i = 1; while(i<=10){ trace(i); i++; } trace(i); --------------------- ※ HugFlash の HugDimension モードでの 自作SWF 解析結果 for文 を使って書いても， 結局内部マシン語的には while文 と同値のものとして扱われるということです。 またその while文 には上のように変換されるので i は 11 となって for文 から抜けます(while文 から抜けます)。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ > onRelease時に > > _global.hensuu=i > //iはクリックしたmcの番号 > > などとしたい場合はどうすれば可能なのでしょうか？ それは ＃１ の回答自体がヒントになっていると思いますが， 各 MC 内に i を固定してしまえば良いでしょう。 ---＃１のスクリプトを変更---------------- for (i=1; i<=10; i++) { _root["mc"+i].num = i; _root["mc"+i].onRelease = function() { this.kai_mc.nextFrame(); trace(this.num); }; } ------------------------------------- 「制御」→「ムービープレビュー」で 各 MC クリックをすれば動作検証できると思います。 その他，私の最近の回答より 「スクリプトをまとめて書くには」 http://okwave.jp/qa/q6341073.html
＃１です。 前回のとき（つまりカスタムカーサーを入れる前）は， 「twolargeMC」をドラッグできていて ＃１で回答したものを入れた後（つまり＃１のカスタムカーサーを入れた後）， 「twolargeMC」をドラッグできなくなったということですか？ それは謎ですね。 カーソル（カーサー）のスクリプトとドラッグのスクリプトは あえて全く無関係にしていますから干渉し合うことはないと思いますが。 また， 実際に作成してみましたがそんなことにはなりませんでしたよ。 原因は他の部分にあるのでしょうね。 つまり 今回も前回も書かれていない箇所が原因でしょう。 以下は単に思いつくまま書くだけですが。 例えば カーサームービークリップ「handMC」自体に on(release){…} や on(press){…} や on(rollOve){…} などというような ボタン由来の onイベントハンドラ を書いているとか。 もしくは ムービークリップ「handMC」が存在するフレームに handMC.onRelease=function(){…} や handMC.onPress=function(){…} や onRollOve=function(){…} などというような ボタン由来の onイベントハンドラメソッド を書いているとか。 また例えば ムービークリップで作っていたカーサー「handMC」を ボタンで作り替えたとか。 また例えば ドラッグする twolargeMC の上のレイヤーに 透明のボタンでも用意してしまったとか。 　
　 まず alpha の値ですが この alpha はすごくアナログ的なものなのです。 例えばフラグ的に使うことはできません。 例：「alphaが0だったら1にする 1だったら0にする」 　　というようなことをするときに alpha の値は使えません。 雰囲気で言えば 「alpha=1」 は 「水１リットル」 みたいなものです。 実体として「正確に 水１リットル を汲み取れる人や装置」はこの世に存在しません。 日常生活での 水１リットル は必ず誤差を含みます。 正確な 水１リットル は数学的な概念として存在するだけです(理科的には存在しません)。 というわけで， alpha の値がキッチリと 0 になることなどまずないので if (img_mc.alpha == 0){ img_mc.removeEventListener(Event.ENTER_FRAME,imgAlpha2); } この 　 if(img_mc.alpha == 0) がダメです。 その上に書かれていらっしゃる 　 if (img_mc.alpha > 1) と同じように 　 if(img_mc.alpha <= 0) または 　 if (img_mc.alpha < 0) のようにする必要があります。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ あと img_mc の alpha が 0→1 や 1→0 と "変化している最中" に _btn から マウスオーバー したり マウスアウト された場合の処理が抜けていますね。 それと function の定義場所がおかしかったりもします。 その辺りのことも入れると スクリプトは次のようになります。 ----------------------- var img_mc:MovieClip; img_mc.alpha = 0; _btn.addEventListener(MouseEvent.MOUSE_OVER,xClick0); function xClick0(evt) { img_mc.removeEventListener(Event.ENTER_FRAME,imgAlpha2); img_mc.addEventListener(Event.ENTER_FRAME,imgAlpha); } function imgAlpha(event:Event) { img_mc.alpha += 0.05;//スピード if (img_mc.alpha>1) { img_mc.removeEventListener(Event.ENTER_FRAME,imgAlpha); } } _btn.addEventListener(MouseEvent.MOUSE_OUT,xClick); function xClick(evt) { img_mc.removeEventListener(Event.ENTER_FRAME,imgAlpha); img_mc.addEventListener(Event.ENTER_FRAME,imgAlpha2); } function imgAlpha2(event:Event) { img_mc.alpha-=0.05;//スピード if (img_mc.alpha==0) { img_mc.removeEventListener(Event.ENTER_FRAME,imgAlpha2); } } ----------------------- 　 　
>>1さん来ないみたいなので代わりに補足レス >未定義stage Haneクラスのインスタンスが stageにaddChildされてないと Haneインスタンスのstageはnullです もう少しいうとこのHaneクラス自体は MovieClipの拡張クラスである必要性が あんまりないように思います hane_mcにリスニングさせればいいかと思います public function moveHane(mou:Point):void{ distance = Point.distance(ballPt,mou); addEventListener(Event.ENTER_FRAME, kaitenHandler); } public function kaitenHandler(ev:Event):void{ if(distance<200){ hane_mc.rotation+=2000/Math.max(50,distance); } ↓ public function moveHane():void{ hane_mc.addEventListener(Event.ENTER_FRAME, kaitenHandler); } public function stopHane():void{ hane_mc.removeEventListener(Event.ENTER_FRAME, kaitenHandler); } private function get dst():Number{ return new Point(hane_mc.mouseX,hane_mc.mouseY).length } public function kaitenHandler(ev:Event):void{ if(dst<200){ hane_mc.rotation+=2000/Math.max(50,dst); } 片づけ用にstopHane()を用意 distanceをｄｓｔとしてgetter実装 これでdistanceとballPtプロパティは不要になってます
次のページで書かれてある要領で 牛のスライドショーを作れば良いのではないでしょうか。 「フリーのFlash作成ソフトSuzukaによる、スライドショー作成チュートリアル - ダイズバタケ」 http://www.towofu.net/blog/2006/08/flashsuzuka.html 「ドライバー」→「はさみ」→「メガネ」 とアルファを使って切り替えるのではなくて 「牛１」→「牛2」→「牛3」→「牛4」→「牛5」 のようにアルファを使って切り替えるという意味です。
外部SWFをムービークリップの中に直接はロードできませんよ。 　ローダーとなるインスタンスにSWFをロードして 　そのローダーをムービークリップの中に配置する という流れになります。 ---------------------------- mc.loadMovie("test.swf"); ---------------------------- 　↓変更↓ ------------------------------------------ //「test.swf」をリクエストとするインスタンス req を用意 var req:URLRequest = new URLRequest("test.swf"); //外部SWFをロードするローダーインスタンス ld を作成 var ld:Loader = new Loader(); // ld に 「test.swf」 をロード ld.load(req); //mc内に ld を配置 mc.addChild(ld); -------------------------------------------
Flash'(SWF) 内に ビットマップ画像(JPEG や GIF や BMP や PNG など) を表示させる方法はたくさんあります。 その方法を書かれていらっしゃらないので決定的な解決策は書けませんが， 結局，ビットマップ画像 に スムージング をかけているかどうかという部分がネックだと思います。 もし，書かれていらっしゃる画像（ビットマップ画像ですよね）が， Flash CS5 の ライブラリ に存在するシンボルでしたら， ライブラリ で その ビットマップシンボル を選択して その プロパティ より スムージング にチェックを入れておくのが改善策になると思います。 http://help.adobe.com/ja_JP/Flash/10.0_UsingFlash/WSd60f23110762d6b883b18f10cb1fe1af6-7e9ca.html#WSd60f23110762d6b883b18f10cb1fe1af6-7e96a 上に書いた状況とは別の状況の場合は 次のような検索ワードを起点に検索してみてください。 http://www.google.co.jp/search?hl=ja&q=%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0+Flash& ※ Flash Player は画像処理ソフト(Photoshop など)ではないので 　Flash Player のスムージングに大きな期待をするのは間違いです。 　ある程度の改善策になるだけです。
> ムービープレビューの不可解な動きは… ですよね。 それでしたら最新の Flash Player による仕様変更などは全く関係しないはずです。 ムービープレビュー時の動作は その オーサリングツール (ご質問の場合は Flash MX) と， それに付随する スタンドアローン版(デバッグ版)の Flash Player と， OS のバージョン（Windows Me から XP にアップグレードしたなど） だけに依存します。 つまり，極々個人的な問題に集約されます。 OS を バージョンアップ しているなどのことをしていないのであれば Flash MX の アンインストール ＆ 再インストール をするのが第一手段だと思います。 もし OS が変わったから不具合が起きるなどの場合は その責任は誰も負えません(Macromedia も Adobe も)。 「互換モード」を XP 未満 にするとか？ （XP なら十分動作すると思うので関係ないと思いますが） そのくらいができることでしょうか。 Google検索「互換モード Flash MX」 http://www.google.co.jp/search?hl=ja&q=%E4%BA%92%E6%8F%9B%E3%83%A2%E3%83%BC%E3%83%89+Flash+MX
1) リファラーで認証する 2) クッキーやフォームから認証キーを渡して認証する 3) JavaScriptとワンタイムパスワードを使って認証する すぐに思い浮かぶのはこのくらいですかね。 1番は簡単で、多くの場合に十分だと思います。 ただしリファラーを切っていたり、サーバー移転時などで問題が生じると思います。
私の環境(Windows Vista / IE 8)ではURLエンコードすれば成功しましたよ。 例えば 検索窓である テキスト入力 の テキストフィールド に 「_txt」 というインスタンス名を付けていたとします。 その場合は次のようになります。 var _str:String = encodeURI(_txt.text); var url:URLRequest = new URLRequest("http://www.youtube.com/results?search_query=" + _str + "&aq=f"); navigateToURL(url);
Security.allowDomain()の問題じゃないでしょうか フラッシュは通常同一ドメインのコンテンツしか 読み込めないようになってます あと、リダイレクトしてるだけで実質のドメインが 違う場合の問題もあるかもしれません
ご質問のポイントが何なのかが見えませんが。 > 一度ブラウザでそのテキストを読み込むと、テキスト自体を編集しても、 > 編集前のテキストがいつまでも読み込まれ続けてしまいます。 あの... それは 「テキスト」 をキャッシュから参照する問題であって 「SWF(つまり Flash)」 をキャッシュから参照する問題とは関係がないのではないでしょうか？ 問題を切り分けましょう。 SWF(Flash) から ロードする テキストファイル のキャッシュ参照を防止するのでしたら， ロードするテキストファイルのファイル名の後に 随時変わる URLクエリ でも引っ付けてロードするのが一般的な方法かと思います。 ActionScript のバージョンも何も書かれていらっしゃらないので具体的な回答はできませんが， 例えば 「○○○.txt」 というファイルをロードするのでしたら 「○○○.txt?△△△=□□」 というファイルをロードするようにします。 そして □□ の部分を毎回変えるようにします。 例えば ランダムの数を出して 「○○○.txt?△△△=82645931468」 のようなものを読み込むとか， 今現在の時刻を出して 「○○○.txt?△△△=2010_12_03_21_48_10」 のようなものを読み込むとか。 http://www.google.co.jp/search?hl=ja&source=hp&q=%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E5%8F%82%E7%85%A7+%E9%98%B2%E6%AD%A2+Flash+%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88
書かれていらっしゃるスクリプト中の 「mc」(MovieClip) は private var mc:MovieClip = new MovieClip(); で作成されたムービークリップなのですから "単フレーム" ですよね。 つまり フレーム1 しか存在しないはずですから 当然，再生 も 停止 もないと思います。 再生 や停止 をさせたいのは 「mc」 ではなくて， 「mc」 に配置した 「l」(Loader) 内にロードした 「animation.swf」 ではないのでしょうか？ （↓【図】 参照） もしそうであれば 書かれていらっしゃる private function Stop(e:Event):void{ mc.stop(); } の部分を， private function Stop(e:Event):void{ MovieClip(l.content).stop(); } または， private function Stop(e:Event):void{ var cnt_mc:MovieClip = l.content as MovieClip; cnt_mc.stop(); } などのように変更する必要があります。 --- 補足：階層の話 --- --- --- --- なお書かれていらっしゃる 「l」 は そのドキュメントクラス内で宣言された Loader を参照する変数 「l」 です。 つまり 変数 「l」 はドキュメントクラス階層内直下に存在します。 したがって ムービークリップ「mc」の中に「l」を配置してはいますが MovieClip(mc.l.content).stop(); にはなりません。 もし上記のように書いた場合 『「mc」内の変数「l」が参照するLoader内のコンテンツよ，止まれ。』 という意味になってしまいます。 MovieClip(l.content).stop(); これで 『ここに定義された変数「l」が参照するLoader内のコンテンツよ，止まれ。』 という意味になり，無事に動作します。
元の Appleショップ サイトのJSで動くものが 私の環境では(だけ？)ドラッグできないので したいことが今ひとつ理解しにくいです。。。 (何だか出来の悪いJS...。無理をゴリ押ししてみっともないことになってるApple。) 良くはわかりませんが， 「ドラッグを 『した』か 『していない』か というフラグとなる変数」を作って それの変数の値を使って判断すれば良いのではないでしょうか。 --- Frame25 のアクション--------------- //ドラッグ 『した』『していない』のフラグをfalseにしておく var drag_flg:Boolean = false; //twolargeMCを押したときに実行するメソッドを定義 twolargeMC.onPress = function() { //twolargeMCをドラッグ開始 startDrag(this); // //マウスが動いたときに実行するメソッドを定義 this.onMouseMove = function() { //ドラッグ 『した』『していない』のフラグをtrueにする drag_flg = true; //即 このマウスが動いたときに実行するメソッドを削除 delete this.onMouseMove; }; }; //twolargeMCを放したときと //外で放したときに実行するメソッドを定義 twolargeMC.onRelease = twolargeMC.onReleaseOutside = function () { //もしドラッグ 『した』『していない』のフラグがfalseの場合 if (!drag_flg) { gotoAndStop(20); } else { //ドラッグ終了 stopDrag(); //ドラッグ 『した』『していない』のフラグをfalseに戻す drag_flg = false; } }; --------------------------------- 　
最初は「オーバーレイ」かと思いました。 「二行でFlashをオーバーレイ表示 - PHP,MySQL,Flexな日々＋イラストとか」 http://d.hatena.ne.jp/haru-komugi/20080809/1218212390 「F-site レイヤーを使用したFull Flash」 http://f-site.org/articles/2006/09/09042615.html -------------------------- しかしよく見ると書かれていらっしゃる物はこれとは違いますね。 背景を YAHOO っぽくした 単なる全画面Flash（フルスクリーン / リキッドデザインのFlash）ですね。 「リキッドデザイン Flash」 http://www.google.co.jp/search?hl=ja&q=%E3%83%AA%E3%82%AD%E3%83%83%E3%83%89%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3+Flash&aq=f
foo="正解数：" add score; の add 部について。 文字列の加算については foo="Stirng" + score; ですね。 addは flash lite1.1という mobile（携帯用）でした。 「flash つくり方」等で 検索をかけると、 情報けっこうあります。
あれ、できるのかな？とおもい　調べてみました。 .loadMovieを使っての 質問・解答のなかにヒントらしきものを見つけたので 記入しておきます。既に見られていたり、いや、できるよということでしたら私の無知です。 すみません。 http://okwave.jp/qa/q5339620.html
ちょっと乱暴なやり方ですが // クリック時の処理 peat[i].sp.addEventListener( MouseEvent.CLICK , function(event:MouseEvent):void{ test(event, arguments.callee, peat[i]); } ); } ↓ peat[i].sp.addEventListener( MouseEvent.CLICK, function(ind){return function(event:MouseEvent){test(event, arguments.callee, peat[ind])}}(i) ); 簡単に言うと関数を作る関数をその場で実行してる感じです
地道に（普通に？），次のような感じになると思います。 --------------------------------------- var bn01:MovieClip = new fr_bn01(); var bn02:MovieClip; var bn03:MovieClip; bn01.addEventListener(Event.ENTER_FRAME,func01); addChild(bn01); function func01(evt:Event):void { var mc:MovieClip = MovieClip(evt.target); if (mc.currentFrame == mc.totalFrames) { mc.stop(); mc.removeEventListener(Event.ENTER_FRAME,func01); removeChild(mc); bn02 = new fr_bn02(); bn02.addEventListener(Event.ENTER_FRAME,func02); addChild(bn02); } } function func02(evt:Event):void { var mc:MovieClip = MovieClip(evt.target); if (mc.currentFrame == mc.totalFrames) { mc.stop(); mc.removeEventListener(Event.ENTER_FRAME,func02); removeChild(mc); bn03 = new fr_bn03(); bn03.addEventListener(Event.ENTER_FRAME,func03); addChild(bn03); } } function func03(evt:Event):void { var mc:MovieClip = MovieClip(evt.target); if (mc.currentFrame == mc.totalFrames) { mc.stop(); mc.removeEventListener(Event.ENTER_FRAME,func03); } } -----------------------------------
知っている限りでは例えば「http://okwave.jp/」にアクセスした時に最初にアクセスするファイルを「http://okwave.jp/index.html」ではなく「http://okwave.jp/top.html」にするにはサーバーの「htaccess」を指定変更すれば出来ると思います。 http://www.shtml.jp/htaccess/directoryindex.html こちらのページを参考にする事で変更は出来ます。 ただ、ここの部分を変更すると今後もずっと同じ仕様になってしまいますので、本当はあまりおすすめ出来ないかもなんですよね～。質問主が「今の状況を理解している人がいない」という状況を、仮に質問主様が運用管理から外れた場合助長する事になるんじゃないかと（普通は滅多にhtaccessなんて触らないし） もしこちらで設定変更されるなら、ちゃんと仕様書等作って運用管理する体制整えた方がいいですよ？まぁこれやるやらないに限らず本当は整えるべきなんですが。 ブラウザの戻るボタンでムービー再生されないようにするにはクッキーの読み込みで「一度表示されたページは表示されない」という方法があったような気がしますが、ちょっと調べきれなかったのでhtacessを使った上でまだ必要だと感じられたら、ご自分で調べてみて下さい（以前にそういうシステム作った気がしますが、かなり面倒だった記憶があります。）
> 自分が思い浮かぶのは、 > サイズ意外のところに背景色をおいて隠す。。くらいです。　 それでも良いのではないでしょうか。 ActionScript 3.0 設定 でしたら root(シーン1 など のメインタイムライン)全体にマスクをかけても良いとは思います。 //--- root の フレーム1 に書く------------------ //適当なスプライトでも用意して var mask_sp:Sprite = new Sprite(); //そのスプライトにステージと同じサイズの四角を用意し mask_sp.graphics.beginFill(0xffffff); mask_sp.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight); mask_sp.graphics.endFill(); //そのスプライトを配置 addChild(mask_sp); //root に スプライトのマスクをかける root.mask = mask_sp; //---------------------------------------- ActionScript 2.0 以下では 同じことはできないと思います(多分)。
例えば、ステージ外に画像を残して作成していませんか？
以前に全く同じ質問をされていますよね？ 「actionscript3.0 データ型について」 http://okwave.jp/qa/q6309057.html 元から「何が疑問なのか」がつかみにくいご質問なのですが 上では理解できたようなことを書かれていらっしゃるので さらに「何が疑問なのか」がわかりにくいです。。。 > 下記の場合のデータ型はどれを指すのでしょうか？ これに ズバッ と答えるなら void です。 それだけです。 ＝＝＝ しかし今回の質問に際して 「何が疑問なのか」をもっと考えてご質問を何度も読ませてもらったところ 私なりに（あくまでも "私なり" に）「疑問の原因」がわかったような気がします。 疑問の発生原因は 引用されている次の文章↓ではないかと思います。 > メソッドのデータ型は省略可能ですが、 > 省略しない場合には必ずvoidを指定します。 良く読むと この文章↑は変です。 誰もがそう書いているのではなく 出所はおそらく１人の方です↓。 Google検索「省略しない場合には必ずvoidを指定」 http://www.google.co.jp/search?hl=ja&q=%22%E7%9C%81%E7%95%A5%E3%81%97%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%81%AB%E3%81%AF%E5%BF%85%E3%81%9Avoid%E3%82%92%E6%8C%87%E5%AE%9A%22 出所の著者の方のお名前を出すのは控えますが その方の入力ミスや誤植のようなものだと思います。 つまり，著者の方の理解が不十分なのではなく「単なるミス」でしょう。 私が校正するとしたら次のように書き直します。 　「メソッドのデータ型は省略可能ですが、 　 戻り値が存在しない場合には 　 必ず void を指定するようにします。」 つまり元の文だと 「データ型を省略しない場合にはどんなときもvoidを指定する」 ととれますがそれは間違いで 「戻り値が存在しない場合にはvoidを指定する」のです。 またこの場合の void がデータ型です。 これで理解できますか？ ◎ご質問で書かれている関数（メソッド）の例 function moveX():void{ my_mc.x = my_mc.x + 200; } これには戻り値（return で返される値）が存在しません。 ですから この関数の型は void (英語で「空」「無」) になります。 ◎他の例１ 整数とは限らない何かの数を戻り値として返す場合 その関数の型は Number になります。 function moveX():Number { return 200+10.5; } trace("戻り値…" + moveX()); trace("戻り値の型…" + typeof(moveX())); ◎他の例２ true または false のどちらかの値しか返さない場合 その関数の型は Boolean になります。 function moveX():Boolean { return false; } trace("戻り値…" + moveX()); trace("戻り値の型…" + typeof(moveX())); ◎他の例３ 次の場合も戻り値を返しませんから型は void です。 function moveX():void { var num:Number = 200+10.5; } trace("戻り値…" + moveX()); trace("戻り値の型…" + typeof(moveX())); 　
前置きとして... eval は古い関数で昨今はほとんど使いません。 配列アクセス演算子 [] を使うのが一般的です。 「ドット演算子と配列アクセス演算子」 http://fumiononaka.com/TechNotes/Flash/FN0507001.html まず クリックイベントを設定する各「aaa○」 内に固有の i を保存しておいて その固有の数を参照する方法があります↓。 for (i=1; i<=10; i++) { //「aaa○」内の変数 num に i を保存 this["aaa"+i].num = i; //「aaa○」クリック時 this["aaa"+i].onRelease = function() { //この「aaa○」内をフレーム2から再生 this.gotoAndPlay(2); //この「aaa○」の親にある「bbb○」をフレーム2から再生 this._parent["bbb"+this.num].gotoAndPlay(2); }; } 推奨はしませんが 上のスクリプトを eval を使って書き直すと次のようになります。 for (i=1; i<=10; i++) { //「aaa○」内の変数 num に i を保存 eval("this.aaa"+i).num = i; //「aaa○」クリック時 eval("this.aaa"+i).onRelease = function() { //この「aaa○」内をフレーム2から再生 this.gotoAndPlay(2); //この「aaa○」の親にある「bbb○」をフレーム2から再生 eval("this._parent.bbb"+this.num).gotoAndPlay(2); }; } また 「クロージャ」というものを使っても良いと思います↓。 for (i=1; i<=10; i++) { //「aaa○」クリック時の動作として //関数 abGotoPlay の戻り値を代入 _root["aaa"+i].onRelease = abGotoPlay(i); } //関数 abGotoPlay の定義 function abGotoPlay(num) { //関数を戻り値として返す return function () { //「aaa○」と「bbb○」をフレーム2から再生 _root["aaa"+num].gotoAndPlay(2); _root["bbb"+num].gotoAndPlay(2); }; } これまた推奨はしませんが 上のスクリプトを eval を使って書き直すと次のようになります。 for (i=1; i<=10; i++) { //「aaa○」クリック時の動作として //関数 abGotoPlay の戻り値を代入 eval("_root.aaa"+i).onRelease = abGotoPlay(i); } //関数 abGotoPlay の定義 function abGotoPlay(num) { //関数を戻り値として返す return function () { //「aaa○」と「bbb○」をフレーム2から再生 eval("aaa"+num).gotoAndPlay(2); eval("bbb"+num).gotoAndPlay(2); }; }
確かにFLASHを作成するにはAdobeFLASH等の製品が必要ですが、 フリーウェアでも作成可能です。 http://allabout.co.jp/gm/gc/66769/ ただ、「完全互換」とか、本家Adobe製品で行える全ての事を、 こういったフリーウェアで実現できるとは思わない方が良いでしょうね。
> 0⇒1⇒2と現在フォーカスが当たっているものだけ > 別の色にするというもの ↑この部分の意味が全くわかりません。 （フォーカスが当たっているものって普通は１つでは？？？） とりあえず上で書いた部分は無かったことにします。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 上のことは無いものとして さらにもっともっと問題をシンプルにしませんか？ 書かれたスクリプトを次のようにするとどうなりますでしょう？ -------------------------- for (var i = 0; i < 3; i++) { var icon = new Icon(); icon.x = i * 20; icon.num.text = i; addChild(icon); } icon.x = 200; -------------------------- 別の３つの Icon クラスのインスタンスに 同じ名前（同じ参照変数名）を付けたら ３つ全てを管理できなくなるでしょう？ 「文字の色」とか「Timer」とか そういう問題以前のことだと思います。 上のスクリプトを次のように変えれば問題(解決策)が見えてきませんか？ ------------------------------- for (var i = 0; i < 3; i++) { this["icon" + i] = new Icon(); this["icon" + i].x = i * 20; this["icon" + i].num.text = i; addChild(this["icon" + i] ); } this.icon0.x = 0; this.icon1.x = 100; this.icon2.x = 200; ------------------------------- または，次のように変えてみましょう。 ------------------------------- for (var i = 0; i < 3; i++) { this["icon" + i] = new Icon(); this["icon" + i].x = i * 20; this["icon" + i].num.text = i; addChild(this["icon" + i] ); } for (i = 0; i < 3; i++) { this["icon" + i].x = i * 100; } ------------------------------- Google検索「配列アクセス演算子」 http://www.google.co.jp/search?hl=ja&q=%E9%85%8D%E5%88%97%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90
CSV→XML変換は独自にスクリプトを書く必要はあると思いますが、可能です。 SWF内でデータができあがっているのなら、表示ももちろん可能です。
＃１＆２です。 > 「〇〇年〇〇月〇〇日〇〇時〇〇分〇〇秒」を > ターゲットに、現在の時間からカウントダウン そういうことですね。 それでしたら次のような感じになるのではないでしょうか。 以下は ＃１ の補足で書かれたものをベースに変更しています。 HTML --------------------------- <html> <head> <title>test</title> <script type="text/javascript"> function sayTime() { //2010年12月1日0時をターゲットとする var targetDate = new Date(2010,11,1,0,0,0); var targetTime = targetDate.getTime(); return targetTime; } </script> </head> <body> <!--Flashを貼り付けるタグなど--> </object> </body> </html> --------------------------- swfファイルActionScript --------------------------- //externalクラスのインポート import flash.external.*; //1フレームで停止 stop(); //JavaScriptからターゲットのミリ秒数を取得 var jsTime:Number = Number(ExternalInterface.call("sayTime")); this.onEnterFrame = function() { // //現在のローカル日付オブジェクトを作成 var today:Date = new Date(); // //1971年1月1日から現在のミリ秒数を取得 var myTime:Number = today.getTime(); // //JavaScriptで得たミリ秒数から現在のミリ秒数を引いた残り var timeLeft:Number = jsTime - myTime; //その 残り を 秒 にしておく var secLeft = Math.ceil(timeLeft / 1000); // //残り時間のそれぞれ 日・時・分・秒 を割り出す var days:Number = Math.floor(secLeft / (24 * 60 * 60)); secLeft -= days * 24 * 60 * 60; var hrs:Number = Math.floor(secLeft / (60 * 60)); secLeft -= hrs * 60 * 60; var min:Number = Math.floor(secLeft / 60); secLeft -= min * 60; var sec:Number = secLeft; // //日を文字列に変換 var counter_days:String = String(days); //時を2桁文字列に変換 var counter_hrs:String = ("0" + hrs).substr(-2, 2); //分を2桁文字列に変換 var counter_mins:String = ("0" + min).substr(-2, 2); //秒を2桁文字列に変換 var counter_secs:String = ("0" + sec).substr(-2, 2); // //各テキストフィールドに 日・時・分・秒 を表示 _root.time_days.text = counter_days; _root.time_hrs.text = counter_hrs; _root.time_mins.text = counter_mins; _root.time_secs.text = counter_secs; // //カウントダウン終了時2フレームへ if (timeLeft <= 0) { delete this.onEnterFrame; gotoAndStop(2); } }; --------------------------- ※次の図は 日・時・分・秒 を求めるイメージ図です。 ※＃２の下に substr() についての図も追加しました。 　
HTMLのほうのFLASH領域は100%に広がっていますか？ もしくわ、FLASHに // 100%表示 stage.scaleMode = StageScaleMode.NO_SCALE; // 左上指定 stage.align = StageAlign.TOP_LEFT; をいれてみてはどうでしょうか？
こんな感じでしょうか var loader_obj : Loader = new Loader(); var url : URLRequest = new URLRequest("./loader_obj.swf"); loader_obj.load(url); loader_obj.contentLoaderInfo.addEventListener(Event.COMPLETE ,compHandler); addChild(loader_obj); function compHandler(evt:Event):void{ //ロード完了後にcontentのサイズを変えてあげる //とりあえず、幅を基準に広げてます。 var wp:Number = stage.stageWidth / loader_obj.contentLoaderInfo.width; loader_obj.scaleX = wp; loader_obj.scaleY = wp; }
mc.x0 は ムービークリップ「mc」 の中の 変数 x0 です。 mc.x は ムービークリップ「mc」 の x座標です。 したがって次の２行 　　mc.x0 = mc.x; 　　mc.x = 100; に注釈を加えると次のようになります。 　　//ムービークリップ「mc」 の中の変数 x0 に 　　//ムービークリップ「mc」 の現在の座標を保存 　　mc.x0 = mc.x; 　　//そしてムービークリップ「mc」 の x座標 を 100 にする 　　mc.x = 100; 作成しているものが見えないので何とも言えませんが ムービークリップ「mc」 の最初の配置位置が大切なんじゃないでしょうか？ ムービークリップの最初の配置位置は変数に記録しておいて そのムービークリップのx座標を100にするなど色々動かしてまた元の位置に戻すときに ムービークリップ「mc」内に保存した個々の元の座標にする。 だいたいそんな内容ですよ。 例えば たくさんのムービークリップを ☆ 型に配置する場合， 手でムービークリップの位置を決めるのは簡単なことです。 ActionScriptで配置しようと思えば， 各座標などを計算したりあらかじめデータを調べておいて そうなるように配置しなければなりません。 それは大変で手間です。 それで最初の座標は作者の置いた場所（つまりどこでも良い）ということにしているのではないかと思います。 靴をぬいで上がる飲み屋さんの下駄箱とか 銭湯のロッカーのようなものです。 Aさんのロッカーは139で Bさんのロッカーは26で Cさんのロッカーは231で… などのような管理台帳や一覧表を用意して銭湯のロッカーを管理することもできますが それだと，銭湯屋さんも客もみんなが手間です。 それで普通客にはロッカーの番号札の付いたキーを持って歩かせますよね。 帰るときは自分の番号札を見れば 「調べる」とか「考える」とか「思い出す」という作業をせずに簡単に自分のロッカーのところに戻れるじゃないですか。 そんなようなシステムです。
「動きがカクカクする」 という現象自体が どういうカクカク状態なのかがわからないため返答が難しいです。 「Suzuka で SWF8 を選択したら滑らかになる」 という現象は 私の経験上からだけで言えば 「JPEG などのビットマップ画像を 拡大/縮小/回転 などをさせるときに画像がギザギザになったりカクカクと動いたりしなくなる」 くらいです。 つまり JPEG や PNG や GIF などのビットマップ画像限定の話になります。 同様の現象はここにも書いてありますが↓。 「クリックポイント拡大 サンプル＆作成方法解説」 http://suzupara.iinaa.net/magnification.html 　～引用～ > Suzuka の場合，ビットマップを拡大縮小させたとき > SWF8 で書き出せば > なぜか自動的にスムージングがかかって > ある程度カクカク・メラメラが押さえられるようです。 こういう ビットマップ カクカク現象 でしょうか？ この カクカク現象 限定でしたら Flash の 「ライブラリ」 で読み込んだビットマップ画像を選択して 右クリック→プロパティ などから「ビットマップのプロパティ」パネルを表示させ 　□ スムージング にチェックを入れると ある程度カクカク・メラメラが押さえられます。 　↓【添付図】 参考↓ 　 　 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ また、 ご質問でも書かれていらっしゃいますが 「動きがカクカクする」 という現象はフレームレートが低いことによっても起こります。 でも 30fps だと普通の場合は大丈夫ではないかと思います。 しかし、 画像にフィルタやアルファなどをかけすぎると（特にぼかし系入りのフィルタ） 画像描画（描画計算処理）のために PC の CPU(GPU) がアップアップ状態になって処理が遅くなり 設定のフレームレートに達することができずにカクカクする場合も多々多々多々多々あります。 または かなり凝った ActionScript で 3D などを表現しようとした場合も PC の CPU がアップアップ状態になってカクカクすることがあります。 この場合のカクカクはどうしようもありません。 フィルタやアルファなどをかけないようにするとか 凝った ActionScript で CPU を疲れさせるのをやめにするとかしか対処法はありません。 または 動く部分の描画スペースを減らすというのも１つの方法です。 (例：800×600px のSWFを 200×150px で HTML に貼り付ける。 など)
> 各ボタンon (release)で > 各ムービークリップの再生をしたい と書かれていらっしゃいますが， まず on(release) が使えるのは ActionScript 1.0 または 2.0 です。 その点は問題ないでしょうか？ つまり Flash 8 以下 (Flash 8，MX 2004，MX，5) をお使いの場合は特に気にすることはありません。 しかし Flash CS3 以上(Flash CS3，CS4，CS5) をお使いの場合は 「ファイル」→「パブリッシュ設定」で Flash タブを選択し， ActionScript のバージョン を ActionScript 2.0 か 1.0 にしておく必要があるということです。 Flash CS3 以上で使える ActionScript 3.0 では on(release) が使えないどころか ボタンやムービークリップ自体にActionScriptを何も書くことはできないので 「うまくかない」 どころか 「記入不可能」 ということになります。 以上が on(release) を使う最低条件です。 　 　 　 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 以下はそういう条件での作成方法です。 上でも少し書きましたが on(release) は ボタン自体またはムービークリップ自体に書くスクリプトです。 ボタンA をクリックしたとき その ボタンA が存在するタイムラインのフレームをフレーム2 に進めて停止させたい という場合は， アクションパネル を表示させて， ボタンA を選択した状態でアクションパネル に次のように書きます。 on (release) { gotoAndStop(2); } または on (release) { this.gotoAndStop(2); } ※参考【図】↓ 上の２つのスクリプトは ボタンA が ボタンインスタンス で作られたものである場合です。 もし ボタンA を ムービークリップ で作られた場合は ムービークリップはそれ自体に階層を持つため ムービークリップ自体には 次のように書く必要があります。 on (release) { _parent.gotoAndStop(2); } または on (release) { _root.gotoAndStop(2); } もし （あくまでも 仮に の話です）， ボタンA が自作したボタンではなく コンポーネント の Buttonコンポーネント を使用されている場合は Buttonコンポーネント自体に 次のように書く必要があります。 on (click) { _parent.gotoAndStop(2); } または on (click) { _root.gotoAndStop(2); } 　 他のボタンも同様に ボタンB でしたら gotoAndStop(2) の部分を gotoAndStop(3) のように変えて書きます。 ボタンC でしたら gotoAndStop(2) の部分を gotoAndStop(4) のように変えて書きます。 　 　 　 ※以上は on(release) を軸として書いたものです。 　 on(release) ではなく 　 ActionScript 3.0 を軸にする場合 や 　 onReleaseイベントハンドラメソッドを軸にする場合， 　 内容は根底から全面的に変わります。
他にもありますが例えば次のようなソフトを使えば 完全ではありませんがある程度見ることができますよ↓。 「frimo 3 - 高性能Flash作成ソフト」 http://www.ah-soft.com/fm/ （↑Adobe Flash 不要） 「Motion Decompiler 3 - 高性能Flash解析ソフト」 http://www.ah-soft.com/mdw/index.html （↑ 要 Adobe Flash） でも... たいてい他人が作成したものを見てもわからないと思います。 （特に説明用のサンプルではないわけですし。） 他の作成者が作成したものを見てその内容がわかる人は その作成者よりもかなりレベルが高い人だと思います。。。
Flash は 基本的にその時点で存在するものにしか命令できません。 メインタイムラインの「mc1」と「mc2」は同時に存在しないため お互いに命令しあうことは基本的にできません。 あえてするなら次のような感じです↓ //---「mc1」フレーム "sub2" のスクリプト--- //「mc1」の再生を停止 stop(); //「btn2」にクリック時に実行するイベントリスナーを登録 btn2.addEventListener(MouseEvent.CLICK,Click2); //関数 Click2 の定義 function Click2(evt:MouseEvent):void { //親階層に毎フレーム時間実行するイベントリスナーを登録 MovieClip(parent).addEventListener(Event.ENTER_FRAME,gotoPart2); //親階層をフレーム "main2" に進めて停止 MovieClip(parent).gotoAndStop("main2"); } //関数 gotoPart2 の定義 function gotoPart2(evt:Event):void { //親階層の「mc2」をフレーム "part2" に進めて停止 evt.target.mc2.gotoAndStop("part2"); //親階層の毎フレーム時間実行するイベントリスナーを削除 evt.target.removeEventListener(Event.ENTER_FRAME,gotoPart2); } //-------------------------------- ただし Flash Player 10 以上用SWFをパブリッシュする必要があります。 （Flash Player 9 にはこれらができないバグ(仕様？)がある） （同様のことは Flash Player 8 以下でもできるのでおそらく 9 だけのバグ） 「mc1」とその「parent」＝「root」は同時に存在しているので 「mc1」から「root」にイベントリスナーを登録することはできます。 また 「root」は「mc2」と同時に存在しているので 「root」から「mc2」にgotoAndStop命令をすることはできます。 ～～～日常生活での類似例～～～ 私は 今日 家にいるが 明日 はいない。 弟は 明日 家にいるが 今日 はいない。 これでは明日 弟に対して 「犬の散歩をしろ」 と命令することができないので 今日も明日も家にいる母に 明日 弟に対して 「犬の散歩をしろ」 と命令してもらうことにした。 ～～～～～～～～～～～～～～～ 上の方法は Flash Player 10 ではできると言っても 不確実で危ない橋を渡るようなものですから 普通はあまりしないと思います。 　 　 　 スクリプトがバラバラになるのでわかりにくいかもしれませんが 以下のようにする方がもう少し確実だと思います。 「root」の フレーム "main1" 辺りに次のような変数を用意し， var flag:Boolean = false; 「mc1」の フレーム "sub2" の Click2 を次のように変更し， //関数 Click2 の定義 function Click2(evt:MouseEvent):void { //親階層の flag の値を true にする MovieClip(parent).flag = true; //親階層をフレーム "main2" に進めて停止 MovieClip(parent).gotoAndStop("main2"); } 「root」フレーム "main2" に次のように書く。 //flagの値がtrueだったら if (flag) { mc2.gotoAndStop("part2"); }
バージョンも何も書かれていませんが。。。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ActionScript 2.0 (1.0も含む) でしたら LoadVarsクラスの loadメソッド 辺りで PHPなどで作成したカウンタを動かして 動かした結果から算出された数値を Flash で受け取るのが一般的かと思います。 Google検索例「LoadVars load」 http://www.google.co.jp/search?hl=ja&q=LoadVars+load だいたい次のページのような感じで行けるかと思います↓。 「にゃあプロジェクト - ウェブログ - LoadVars.loadでPHPと連携」 http://www.project-nya.jp/modules/weblog/details.php?blog_id=517 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ActionScript 3.0 でしたらURLLoader でしょうか。 Google検索例「URLLoader URLRequest」 http://www.google.co.jp/search?hl=ja&q=URLLoader+URLRequest やっている内容は違いますがここがすごくわかりやすかったです↓。 「ヤッチマイナシコ » URLVariables でPHPと通信 – AS3」 http://nashiko.net/blog/1069
状況もバージョンも書かれていませんので具体的回答はできませんが。 考え方だけでよろしいですか？ 「だんだん増えるダミーの数値量」を用意して 「本当のローディング数値量」と比べ 小さい方(大きくなるのが遅い方)の数値量をローディング数値量とすれば良いのではないでしょうか。 【例】 「ローディングバーをゆっくりみせる方法」 http://okwave.jp/qa/q4071675.html ↑で書いたスクリプトの使用及び動作環境 　 ・スクリプトのバージョン：ActionScript 1.0 　 ・オーサリングツールのバージョン：Flash 5 以上 　　　(Flash 5，MX，MX 2004，8，CS3，CS4，CS5) 　 ・プレイヤーのバージョン： Flash Player 5 以上 また ローディングが終わった後も 例えばローディングバーがだんだん消えていくという演出を入れても良いかもしれませんね。
ご質問内容そのままの回答を書くと 書かれているページの フレーム2 のスクリプトの次の部分を ----------- // JPEG ロード完了時 myObj.onLoadInit = function(target_mc) { // load_mc にリンクを設定 target_mc.onRelease = function() { getURL(myXML.childNodes[0].childNodes[cnt].attributes.linkURL, "_blank"); }; // 再生開始 _root.play(); }; ----------- 次のように変えれば良いと思います。 ----------- //JPEGロード完了時 myObj.onLoadInit = function(target_mc) { //ロールオーバー時の動作 target_mc.onRollOver = function() { //再生フレームが11以上26以下であれば if (_currentframe >= 11 && _currentframe <= 26) { //再生停止 stop(); } }; //ロールアウト＆外で放した時の動作 target_mc.onRollOut = target_mc.onReleaseOutside = function () { //再生フレームが11以上26以下であれば if (_currentframe >= 11 && _currentframe <= 26) { //再生開始 play(); } }; //load_mcにリンクを設定 target_mc.onRelease = function() { getURL(myXML.childNodes[0].childNodes[cnt].attributes.linkURL, "_blank"); }; //再生開始 _root.play(); }; ----------- しかし 実際にやってみるとこれは変なんです。 フレーム11未満でオンマウスすると そのままフェードインして勝手にフェードアウトしてしまいます。 （そうなるように書いているので当たり前ですが。。。） 上のような感じではなくて したいことは次のような感じではないでしょうか？ ----------- //JPEGロード完了時 myObj.onLoadInit = function(target_mc) { //ロールオーバー時の動作 target_mc.onRollOver = function() { //再生フレームが11未満の時 if (_currentframe < 11) { //毎フレーム時間実行するメソッドを定義 target_mc.onEnterFrame = function() { //再生フレームが11の時 if (_currentframe == 11) { //再生停止 stop(); //毎フレーム時間実行するメソッドを削除 delete target_mc.onEnterFrame; } }; //それ以外で再生フレームが 26以下の時 }else if (_currentframe <= 26) { //再生を停止 stop(); } }; //ロールアウト＆外で放した時の動作 target_mc.onRollOut = target_mc.onReleaseOutside = function () { //毎フレーム時間実行するメソッドを削除 delete target_mc.onEnterFrame; //再生開始 play(); }; // load_mc にリンクを設定 target_mc.onRelease = function() { getURL(myXML.childNodes[0].childNodes[cnt].attributes.linkURL, "_blank"); }; // 再生開始 _root.play(); }; ----------- 　
> 画像をボードのちょうど中央に ボードとは何でしょうか？ よくわかりませんが， 「ウィンドウ」→「整列」にチェックを入れて「整列パネルを表示させ， その 画像 と ボード？ とやらを一緒に選択するなどして， [整列]と[分布]を中央にするとかすれば 何かそれらしいことはできませんでしょうか？ > サイズも”ちょうど1.5倍”にしたいと思うのですが、 これは知りません。 ActionScript でインスタンスの大きさを倍数で設定することならできますが， オーサリングの操作上は無いような気がします。 (Suzuka は逆に倍数しかありませんよね？ 確か...。)
そうですね。 ＃１ の方も書いていらっしゃいますが， Flash で文字を回転させたりするのには あらかじめ文字を Flash の SWF中に埋め込んでおくか画像にしておくような必要があるのです。 知識や技を駆使すれば 絶対に埋め込んだり画像にする必要があるというわけではありませんが 普通は埋め込んだり画像にしておきます。 アルファベットの大文字/小文字や，数字だけの場合， 数は知れているので 埋め込んだり画像にするのもそんなに手間ではありませんし， 容量も大きくなりません。 しかし タイトルなどをユーザーが日本語文字で指定する場合， ユーザーがどんな文字を指定してくるかはあらかじめわからないため， 全ての日本語フォント(当然漢字も含む)を 埋め込んだり画像にしておく必要が出てくるのです。 画像にするには ものすごい労力が要りますし， 埋め込むにしても画像にするにしても，膨大なファイル容量になります。 また著作権の絡みも出てきます。 それで 文字がかなり面白く動かすためには 字数の知れた アルファベット くらいしか指定できないのです。 作成環境が Windows 限定ですが， フリーの Flash を作成するソフトに Parafla! http://www.geocities.jp/coa9999/ というものがあります。 このソフトは結構高度な Flash も作れますが， それ以外に テキストエフェクト という面白い機能があって充実しています。 http://www.geocities.jp/coa9999/parafla.html#parafla6 　↑ココだけ見ても面白いでしょう。 これを使うと比較的簡単にタイトルのエフェクトを作成できます。 日本語も使えます。 本家 Adobe の Flash 作成ソフトにはこれに及ぶ機能はありません。 このエフェクトの場合は フォントを埋め込むということになるのですが（作れば自動的に埋め込まれる） 作者が使う分だけのフォントが埋め込まれるだけなので大したファイル容量にはなりません。 またこの ParaFla! のテキストエフェクトのファンが多いらしく サイトなどの情報も充実しています。 「ParaFla!でFlash作成 - テキストエフェクト」 http://www.geocities.jp/para_core/kouza/texteffect.html 「テキストエフェクト - ParaFla! Wiki」 http://www.wikihouse.com/ParaFla/index.php?%A5%C6%A5%AD%A5%B9%A5%C8%A5%A8%A5%D5%A5%A7%A5%AF%A5%C8 「◆ParaFla用テキストエフェクト◆ 」 http://nuko.info/tool/txtefct/ などなどなど。
メソッドの（戻り値の）データ型は省略可能 ってことですね moveX():void の:voidが型指定 たとえばこのメソッドだったら my_mcが存在するかどうかわからなくて ちゃんとmy_mcは存在して 200右に移動する処理は 実行されたのか？を知りたかったりすると思います そういうときに function move();Boolean{ try{ my_mc.x = my_mc.x + 200; return true;}catch(e){ return false } } というような感じでBoodean（真偽値）を 戻り値の型として指定して retunさせるようにしたりしますが 実は:Booleanは指定しなくてもいいってことです でも型指定しといたほうがメモリに優しいというお話
myenterframeはmymcの名前空間にいるので mymc.removeEventListener(Event.ENTER_FRAME, mymc.myenterframe); とやれば動くんじゃないですかね ちなみに僕はこういうことするときはmymc側に リスナーを全てremoveする為の destroyメソッドとか用意するようにしてます そういうふうにしておけばmymcにremoveしたいリスナーが増えたり 親のclick以外からもmymcのリスナーをremoveしたいとなったときも 書き換えが楽になるのでオススメ
＃１です > ある日の午前0時に発売開始する商品があるとして、 > その日の時間までをフラッシュで表示したい なるほど。そういうことですか。 その「ある日の午前0時」(仮) は， サーバでもクライアントでも同じ時点を指しますよね。 今の時刻が2000年10月であっても2010年11月であっても「ある日の午前0時」は同じ時点を指します。 ですから，これは固定でFlash(クライアントサイド) でも求められます。 「今」は， どこから見るか，いつから見るかによって変わりますから， この「今」をサーバで決めた今にするということですよね。 ActionScript 3.0 で Flash フレーム1 のスクリプトだと こんな感じでできると思います↓ ---------------------- //テキストフィールドを作成 var time_txt:TextField = new TextField(); time_txt.autoSize = TextFieldAutoSize.LEFT; addChild(time_txt); //ゴール時刻を2010年11月20日13時とする var goal_date:Date = new Date(2010,10,20,13,0,0); //今のクライアント時刻を入れる変数 var now_date:Date; //キャッシュ参照対策用 now_date = new Date(); var now_time:Number = now_date.getTime(); //サーバ時刻との差を入れる変数 var dif_time:Number; //PHPへのパス(キャッシュ参照対策入り) var php_url:URLRequest = new URLRequest("time.php" + "?t=" + now_time); //PHPのローダー var php_ld:URLLoader = new URLLoader(); //PHPロード時に関数onLoadCompを実行 php_ld.addEventListener(Event.COMPLETE, onLoadComp); //PHPをロード php_ld.load(php_url); //関数onLoadCompの定義 function onLoadComp(evt:Event):void { //今のクライアント時刻 now_date = new Date(); //サーバとクライアントの1970/1/1からの経過ミリ秒の差 dif_time = Number(evt.target.data) - now_date.getTime(); //毎フレーム関数countDownを実行 addEventListener(Event.ENTER_FRAME,countDown); } //関数onLoadCompの定義 function countDown(evt:Event):void { //今のクライアント時刻 now_date = new Date(); var sec:Number = (goal_date.getTime() - now_date.getTime() - dif_time)/1000; time_txt.text = "あと " + String(Math.round(sec)) + "秒"; } ---------------------- キャッシュ参照対策を入れていますから このままではムービープレビューでは動作しないと思います。 SWF と HTML をパブリッシュした上で 「time.php」 が 1970年1月1日からのミリ秒を出すようにして HTML をブラウザで見たら「あと○○秒」が表示されると思います。 「ある日の午前0時」(仮) は Flash 内で固定的にしていますが， サーバで変えてその変えたデータもロードするようにしても良いと思います。 ※それと 　 他プログラム言語でも同じですが 　 月の数 は 日本人的数え方 とは １ ずれます。 　 日本人の１月はプログラムでは0の月になります。 　 12月は11の月です。 　
slide.swf内には 「_root」 が使われているようです。 slide.swf 単独の場合の _root は slide.swf のメインタイムラインになりますが slide.swf が main.swf にロードされたとき，この _root は main.swf のメインタイムラインに移動してしまいます。 この辺が動作しない原因ではいかと思います。 Flash Player 7 以上の SWF を作成する場合は _lockroot が使えます。 slide.swf内のフレーム1の最初辺りにでも this._lockroot = true; と書くと _root が slide.swf内 で固定されるのでちゃんと動作するようになるかもしれません。 （時間の都合上 未検証です。） 「Flash CS4 Professional ActionScript 2.0 _lockroot (MovieClip._lockroot プロパティ)」 http://help.adobe.com/ja_JP/AS2LCR/Flash_10.0/help.html?content=00001326.html
＃１です。 ＃１の「おまけ」のSuzukaでの方法です。 『Suzuka での方法』 ◎外部ファイルを使う件 > 添付画像のようなテキストを外部からインポートしたり イラストレーターなど そういう文字画像が作れるソフトで画像を作ってアルファ入りのPNGなどに保存し そのPNG画像を Suzuka のシンボルリストに追加して そのシンボルをレイヤーに追加して使えば良いだけだと思います。 ごく普通のSuzukaの使い方です。 　 　 ◎Suzuka で作成して使う件 > suzukaで作成して使う方法はありませんでしょうか？ まず 「ファイル」→「プロジェクトのプロパティ」で 「SWFバージョン」 を 「SWF8」 にしておきます。 　　　　　　　　　　　~~~~~~~~~~~~ そして シンボルリストに 「あい」 というテキストを追加して その 「あい」 をレイヤーに追加してキャンバスに配置します。 その右側の テキスト:[あい] のプロパティパネルで 「カラー」タブを選択し「フィルタ」をクリックします。 すると「フィルタ」パネルが出てきますから そこで 　□ ドロップシャドウ にチェックを入れ ハイライト を 黒色(#000000) にし 「ぼかし」に適当な数値を入れ 　□ オブジェクトを表示 　□ ノックアウト効果 にチェックを入れると それらしいものができると思います【下図↓】。 (ドロップシャドウ ではなく グロー でも良いかも) 　 　 どの方法にしても 「特殊文字を使う」 という感覚ではなく 「文字などに特殊効果を付ける」 という感覚だと思います。
AIRはたしかにFlexもJavaScriptも扱えますが、現状ではAIR APIはブラウザ上では動かないんじゃないでしょうか。 Flex or JavaScript → AIRはほぼ100%いけると思いますが、AIR → ブラウザはAIR APIを使用しない範疇で書かれているもののみ動作するということになると思います。 ですが、わざわざAIRを使って開発するのにAIR APIを使わないのではメリットはほぼ無いようなものなので、AIR → ブラウザにできるようなものは少ないはずです。
まず細かい所から <?xml varsion="1.0" encoding="UTF-8"?> 　↓変更↓ <?xml version="1.0" encoding="UTF-8"?> ですね(varsion → version)。 そのXMLがSWFなどと同じフォルダに 「list.xml」というファイル名で存在するとします。 その場合のフレームに書くスクリプト例↓ ＝＝＝＝＝＝＝＝＝＝＝＝＝＝ //---XML部--- //Flash内のXMLインスタンスを宣言 var my_xml:XML; //XMLファイルロード用インスタンスを作成 var xml_ld:URLLoader = new URLLoader(); //XMLファイルのリクエストインスタンスを作成 var xml_rq:URLRequest = new URLRequest("list.xml"); //XMLファイルロード完了時に xmlOnLoad を実行 xml_ld.addEventListener(Event.COMPLETE, xmlOnLoad); //関数 xmlOnLoad の定義 function xmlOnLoad(evt:Event):void { //XMLインスタンスを作成 my_xml = new XML(xml_ld.data); //swfLoad を実行 swfLoad(); } //XMLファイルをロード xml_ld.load(xml_rq); //---SWF部--- //カウント用変数 cnt を用意 var cnt:uint = 0; //外部SWFファイルロード用インスタンスを作成 var swf_ld:Loader = new Loader(); //外部SWFファイルロード用インスタンスを配置 swf_ld.x = 20; swf_ld.y = 10; this.addChild(swf_ld); //外部SWFファイルロード時swfOnLoadを実行 swf_ld.contentLoaderInfo.addEventListener(Event.COMPLETE, swfOnLoad); //関数 swfOnLoad の定義 function swfOnLoad(evt:Event):void { //毎フレームwatchSWFを実行 swf_ld.addEventListener(Event.ENTER_FRAME,watchSWF); } //関数 watchSWF の定義 function watchSWF(evt:Event):void { var all_frm:uint = MovieClip(swf_ld.content).totalFrames; var now_frm:uint = MovieClip(swf_ld.content).currentFrame; //再生フレームが全フレーム数になれば if (now_frm == all_frm) { //毎フレームwatchSWFを実行するリスナーを削除 swf_ld.removeEventListener(Event.ENTER_FRAME,watchSWF); //cntが XMLのノード数-1 未満であれば if (cnt < my_xml.children().length() - 1) { //cntに1を加算 cnt++; } else { //それ以外はcntを0に戻す cnt = 0; } //swfLoad を実行 swfLoad(); } } //関数 swfLoad の定義 function swfLoad():void { //XMLからcnt番のfilenameの値を取り出す var swf_str:String = my_xml.children()[cnt].filename; //SWFファイルのリクエストインスタンスを作成 var swf_rq:URLRequest = new URLRequest(swf_str); //SWFファイルをロード swf_ld.load(swf_rq); } ＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 　
> //曜日を取得 > WD = fscommand2("GetDateWeekday"); ということは 携帯用 Flash の SWF4 を生成するということですよね。 Flash Lite 1.1 つまり Flash Player 4 レベルの SWF。 そのバージョンにテキストの色を変えるスクリプトなどありません。 そちらの方向で考えるのはやめた方が良いです。 でも決して「出来ない」というわけではありません。 あらかじめ最初から 　黒字の「MON」 　黒字の「TUE」 　黒字の「WED」 　黒字の「THU」 　黒字の「FRI」 　青字の「SAT」 　赤字の「ＳＵＮ」 を書いたテキストを用意しておいて 曜日によってその「すでに書いてあるテキスト」を表示させれば良いと思います。 例えば 「youbi」 というインスタンス名のスプライトを用意しておいて その スプライト 内の 　フレーム1には黒字の「MON」を 　フレーム2には黒字の「TUE」を 　フレーム3には黒字の「WED」を 　フレーム4には黒字の「THU」を 　フレーム5には黒字の「FRI」を 　フレーム6には青字の「SAT」を 　フレーム7には赤字の「ＳＵＮ」を 配置すれば if 分も不要になり tellTarget("/youbi"){ gotoAndStop(fscommand2("GetDateWeekday")); }; のような感じでそれぞれの色の文字列が表示されると思います。 上に書いたのはほんの一例です。 文字の色を変えられなくても 同じような効果を見せる方法はたくさんあります。 例えば次のページは SWF4 ではないので スクリプトの参考にはなりませんが↓ 「万年カレンダー サンプル＆作成方法解説」 http://suzupara.iinaa.net/calendar.html 上のページのスクリプト自体は参考になりませんが 黒い塗りを各数字の文字の形でくり抜いて くり抜いた文字の背景色を変えることによって 表示される文字の色を変えるという考え方は使えるかもしれませんよね。 「▲ SWF4のスクリプト書式」 http://nuko.info/memo/#pf02
「A」 が addChild されている状態とは 「A」 がどこかの階層の表示リストに存在するということです。 そたがってこの辺↓が使えると思います。 「ActionScript 3.0のイベント処理について デベロッパーセンター」 http://www.adobe.com/jp/devnet/actionscript/articles/event_handling_as3_08.html > 表示オブジェクトがこのような表示リストに含まれていない場合、 > そのstageプロパティはNullです。 ◎新規ドキュメントのフレーム1などに書くスクリプト例↓ ---------------------- var A:Sprite = new Sprite(); A.graphics.beginFill(0xFF0000); A.graphics.drawRect(0, 0, 50, 50); trace(A.stage); this.addChild(A); trace(A.stage); this.removeChild(A); trace(A.stage); ---------------------- 「制御」→「ムービープレビュー」 での出力結果↓ 　 null 　 [object Stage] 　 null ◎if文を使った判定例↓ ---------------------- var A:Sprite = new Sprite(); A.graphics.beginFill(0xFF0000); A.graphics.drawRect(0, 0, 50, 50); this.addChild(A); //↓ 「//」 を付けたり取ったりして検証 //this.removeChild(A); if(A.stage == null){ trace("Aはありません"); } if(A.stage != null){ trace("Aはあります"); } ---------------------- 　 　 ～～～ 別法 ～～～～～～～～～～～～ getChildByName() を使っても調べられます。 「FlashゲームPG講座 For AS3.0」 より「インスタンスが表示リストに存在するか調べる」 http://hakuhin.jp/as3/container.html#CONTAINER_04 ◎新規ドキュメントのフレーム1などに書くスクリプト例↓ ---------------------- var A:Sprite = new Sprite(); A.graphics.beginFill(0xFF0000); A.graphics.drawRect(0, 0, 50, 50); A.name = "A"; trace(this.getChildByName("A")); this.addChild(A); trace(this.getChildByName("A")); this.removeChild(A); trace(this.getChildByName("A")); ---------------------- 「制御」→「ムービープレビュー」 での出力結果↓ 　 null 　 [object Sprite] 　 null ◎if文を使った判定例↓ ---------------------- var A:Sprite = new Sprite(); A.graphics.beginFill(0xFF0000); A.graphics.drawRect(0, 0, 50, 50); A.name = "A"; this.addChild(A); //↓ 「//」 を付けたり取ったりして検証 //this.removeChild(A); if(this.getChildByName("A") == null){ trace("Aはありません"); } if(this.getChildByName("A") != null){ trace("Aはあります"); } ----------------------
Tweenerだったら var n=2//最終のスケール var mtx=new Matirx()//transformは直接いじれないので別にMatrixを作る Tweener.addTween(mtx,{a:n,d:n,time:5,onUpdate:function(){mc.transform.matrix=mtx}})//アップデートの度にそのMatrixをmc.transformに反映 みたいなカンジでしょうかね まあなにせtransformの中身はgetter、setter実装なので 直接そのオブジェクトのプロパティはいじれないんで アップデートのたびにtransform.matrix=… ってやらなきゃいけないってことだけ抑えてれば 大丈夫なんじゃないでしょうか
「CS5での使用方法」ではなく 「(CS5の)ActionScript 3.0 設定での使用方法」 ですよね？ （CS5 でも ActionScript 2.0 にすれば，書かれていらっしゃるページと同じ方法でできると思います。） （ActionScript 3.0 設定の場合 識別子 は付けられません。） とにかく，ステージ上に絵を描くか写真を配置し， その絵や写真をムービークリップシンボルに変換しますよね。 そのときに 基準点 を 左上 にしてムービークリップに変換します。 　　　　　　~~~~~~~~~~~~~~~~~~~ この操作で「ライブラリ」にそのムービークリップシンボルが入りますからそれを確認します。 次にその「ライブラリ」の中のそのムービークリップシンボルを選択して 右クリックなどから「プロパティ」を表示させます。 出てきた「シンボルプロパティ」パネルで 　□ ActionScript 用に書き出し 　と 　□１フレームに書き出し にチェックを入れます。 そうしますと， 　クラス：［　　　　　　］ の部分が記入可能になりますから その[　　]の欄で適当に決めたクラス名を付けます。 たとえば 「GazouMC」 というクラス名を付けます。 　　　　　~~~~~~~~~~~~~ そして「シンボルプロパティ」パネルをOKで閉じます。 最初に作成したステージ上のムービークリップはもう必要ないので削除します。 （画像入りムービークリップはライブラリに残っているのでステージから削除しても大丈夫です。） 次に「コンポーネント」パネルから 「ScrollPane」コンポーネントを選択し ドラッグ＆ドロップ でステージ上に「ScrollPane」を引きずり出します。 その引きずり出したステージ上の「ScrollPane」を選択し 今度は「コンポーネントインスペクタ」で「パラメータ」タブを選択し 「source」となっている欄の値に 上で命名したクラス名「GazouMC」を記入します。 これでパブリッシュ または ムービープレビュー などをすれば ステージ上の 「ScrollPane」 内に 「GazouMC」 が表示されます。
>FLASHはjava言語で構成されていると思うのですが、 Javaに似ているところもありますが、Javaではありません。 ActionScriptという専用の言語です。 >HTMLのようにメモ帳などを使って専用のソフトがない状態でも作成できないのでしょうか？ 最低限、SWFへのコンパイラは必要でしょう。
書き直した方のスクリプトってよく見ると Tweenをstart()してないんじゃないですか？
ナノサウンドが好きです
フラッシュのビットマップ補完は荒いからなぁ とか一瞬おもったんですが fps（フレーム／秒）８か９ってのは低すぎやしませんか？ そりゃカクカクもしますよって数値ですよ スムーズに見せたいならとりあえず２４fpsくらいじゃないでしょうか
参考URLの下の方にありませんか？なければ下記URL(古いバージョン） http://kb2.adobe.com/jp/cps/228/228683.html （ダウンロード時） 現在導入されているものをアンインストール、再起動 Windowsファイアーウォールを無効、セキュリティソフトのパーソナルファイアーウォールの遮断があれば例外許可（または一時的に無効） セキュリティ対策ソフトを一時的「無効」 ブラウザのセキュリティ設定でブロックを設定変更 例：「ツール」「インターネットオプション」「セキュリティ」「レベルのカスタマイズ」「セキュリティの設定」ActivXコントロールとスクリプトを有効 例：「レベルのカスタマイズ」「セキュリティの設定」「ダウンロード」「ファイルのダウンロード」を有効 （インストール時） アドミ権限でログインし実行（XP) 右クリック「管理者として実行」(Vista）
TouchEvent って... そもそも Flash Player 10.1 以上対応 すなわち Flash CS5 以上でないと使えないと思いますよ。 CS4じゃ無理でしょう。 また仮に CS5 を使っても 実際の検証は普通のPCでは無理だとは思いますが。 さらにその上ですね，，， 例のいわく付きの iPhone アプリ 関連をターゲットとして開発されたようなものだと思うので 今後の発展もあるやなしや。。。？？？
極々 基礎的なコース(？) で考えると、 「何でも良いので勝手に 変数 でも作って ボタンクリック時にその 変数 に適当な 値 を代入すると同時にアニメーションを開始させ アニメーション終了後に 変数 の値によって navigateToURL する。」 という路線で行けば良いだけではないでしょうか。 次のページは ActionScript 1.0 用のサイトのようですが ActionScript 3.0 でも考え方は同じでできます↓。 「Suzuka 基礎・基本 if文 ＆ else if 文」 http://suzupara.iinaa.net/kiso051.html ボタンで決めた変数の値によって 最終フレームで navigateToURL する ＵＲＬ を変えれば良いだけでしょう？
オートリロードの場合、その都度通信費が掛かりますよね。 パケット定額に入っていない人が、そのページを寝る前に閲覧 終了させずに放置して6時間経過しました・・・・さてどうなるでしょうと考えると そういうトラブルを招く機能は持たせられないはずです パケット通信は利用者の許可を得て始めて通信して発生させるのが常例になってますので
＃１＆＃２です。 > タグ付きのテキストを繁栄する方法がありましたらご指導ください。 書かれていらっしゃる範囲内のHTMLタグでしたら Flash Player も理解してくれますので簡単にできますよ。 テキストフィールドに文字を表示させるときに 　テキストフィールドインスタンス.text = "○○"; と書くと そのテキストフィールドには ○○ が単なる文字列として表示されますが そうではなくて 　テキストフィールドインスタンス.htmlText = "○○"; と書くと そのテキストフィールドには ○○ がHTML装飾入りの文字列として表示されます。 具体的には ＃２で回答したスクリプトの後半部分の次の箇所↓ //関数setTextの定義 function setText(evt:Event):void { //data_txtにランダムな１行データを表示 data_txt.text = data_arr[Math.floor(Math.random() * data_arr.length)]; ～略～ } この↑部分を 次のように書き換えます↓。 //関数setTextの定義 function setText(evt:Event):void { //data_txtにランダムな１行データを表示 data_txt.htmlText = data_arr[Math.floor(Math.random() * data_arr.length)]; ～略～ } つまり data_txt.text →変更→ data_txt.htmlText です。 スクリプト修正はこれだけで終わりです。 ===補足(どうでも良いことかも)========= なお外部テキストは たとえば次のように変えてみると 表示のされ方の違いがわかりやすくなると思います。 <a href="http://www.yahoo.co.jp"><font color="#0000ff"><u>検索ページはyahoo</u></font></a> <a href="http://www.google.co.jp/">検索ページはgoogle</a> <a href="http://www.goo.ne.jp/"><font color="#00ff00">検索ページはgoo</font></a> <font size="24">あなたは検索ページを</font> <font size="36"><i>使いますか</i></font> （↑自動改行が入ってしまうと思いますが実際は５行です） 上の外部テキスト例は， 　「<a>リンクをかけただけでは 　 文字にアンダーラインなどが入らないので 　 場合や必要に応じて 　 <u>でアンダーラインを付けたり 　 文字色もあえてリンク色にする 　 必要があるかもしれない。」 という説明(意味)も含んでいます。
オシャレな画面遷移を（簡単に）実現したいのであれば、「Progression」を使われるのが最も簡単で手っ取り早いと思います。 タイムラインがトゥイーンだらけになったり、スクリプトが山のようになる心配はありません。 考え方だけを真似るのもアリなので、勉強されたらいいと思います。少なくとも自分の場合はムダではなかったです。 Progression4：Framework for Flash（フリー） http://progression.jp/ この中に、「コンポーネントスタイル」というものがありますが、その要点は ・画面遷移ボタン以外の画面（シーン）をまるごとMovieClipにする ・画面（シーン）自身の登場と退出を、すべてMovieClip中のアニメーションとして作る。 ・あらかじめ用意した「アニメーション・トランジション定義コンポーネント」を、MovieClip中に配置してアニメーションを自動制御する。 というもので、慣れればアニメーションつき画面遷移をすばやく作成できます。 「アニメーション・トランジション定義コンポーネント」は、Progressionにもついていますし、もっと派手なものは「FlashEff」など有料の海外製品も入手できます。 外していたらすいません。
そもそも「深度」というものは 「タイムラインごと」( ＝階層ごと＝MC(ムービークリップ)ごと )にあるもので， なおかつ swapDepths で動かせる深度は その動かすMCが存在する「タイムライン内」(＝階層内＝MC内)だけです。 また _root.getNextHighestDepth() ↑で得られる値は「数値」です。 「どこそこの深度○」という「住所番地のようなもの」ではなく 「単なる数値(0,1,2,3…)」 が得られるだけです。 > _mcの中にポップアップするballoon_mcを入れており > そのような構造の_mcを_rootに複数並べています。 この部分を階層図に表すと次のようになりますよね。 　_root(メインのタイムライン(階層)) 　　　└_mc 　　　　　└balloon_mc balloon_mc をいくら高い数値に swapDepths しようとも _mc 内での表示順序が上の方になるだけですから _mc より上にあるものを飛びこすことはできません。 　※swapDepths で balloon_mc を 　　 AAA より上には移動できない↓ 　　_root(メインのタイムライン(階層)) 　　　　├AAA(上レイヤー) 　　　　└_mc(下レイヤー) 　　　　　　└balloon_mc balloon_mc を _root の最高深度に配置したいのでしたら balloon_mc を 最初から _root に配置しておくか， または ライブラリ から MCシンボル を attachMovie するなど 別の方法をとるべきです。 ～ ライブラリ から MC を attachMovie する方法例～ ライブラリ にある balloon_mc のシンボルMCを選択し プロパティ の リンケージ より 　□ ActionScriptに書き出し 　□ 1フレーム目に書き出し にチェックを入れ 　識別子：[　　　　　] の欄でたとえば「Balloon」という識別子を与えます。 その Balloon を _root の最高深度に配置するスクリプトは 次のようになります。 ------------------------ //_root の最高深度に //ライブラリの識別子「Balloon」のMCを //「balloon_mc」というインスタンス名で呼びだす _root.attachMovie("Balloon","balloon_mc",_root.getNextHighestDepth()); //適当に座標を指定 _root.balloon_mc._x = Stage.width / 2; _root.balloon_mc._y = Stage.height / 2; ------------------------ なお， どうしても 　「_mc の中の balloon_mc が 　　_root の最高深度に出る」 というような演出を見せたい場合は そのように見えるように 　「_mc の中の balloon_mc の 　_visible を false にすると同時に 　Balloon をattachMovie する」 　(↑本物は消して替え玉にすり替える) などというような『手品』を考える必要があると思います。 画像：識別子を付ける場面↓
「設定？」 と訊かれましても 何のソフトでの設定かわからないので誰も答えようがありませんが， wmode="window"　は， 基本的には設定とかそういうものではなくて SWFファイル（Flashの閲覧用ファイル）をHTMLに貼り付けるときのパラメータです。 HTML作成ツールによって「設定？」は変わりますし 場合によっていわゆる「設定」ではできないソフトもありますし， タグによって，また，JavaScript を使用した場合と使用しない場合など， 様々な場合があります。 何にしても SWFファイル（Flashの閲覧用ファイル）をHTMLに貼り付けるときのパラメータです。 テキストエディタなど(またはHTMLエディタのソース編集)でその該当部分を追加するとか書き替えれば良いと思います。 Google検索「object embed wmode="window"」 http://www.google.co.jp/search?hl=ja&q=object+embed+wmode%3D%22window%22
if A ～ else if B～ else if C～.... は先頭から順番に評価しますから、とうぜん、順番に意味があります。 また、条件式には書かないことが多いですが、「直前までのifの条件が不成立で、かつ」という 条件が付いてます。 上の例なら else if B → if !A and B else if C → if !A and !B and C です。順番が変われば条件も変わってくることが解ると思います。 それをふまえてこのスクリプトを見ると A: _root.get_tabaco == false B: _root.get_tabaco == true C: _root.state_tabaco == 2 です。 ここで、A,Bに注目すると、通常、 a != false ⇔ a==true です。 つまり、 Aが成り立たなければ、必ずBが成り立ちます。 A→B→Cの順番で評価したら、 AかBかでどちらかが必ず成立つので、Cまで進むことはありません。 A→C→Bの順番で評価したら、 Bを評価する前にCを評価するので、Cの条件での判定ができます。 ついでにいうと、「○全て実行されます。」の方の最後の「else if(_root.get_tabaco ==true)」は条件が成立つことが明かなので、 else だけで十分です。
テキストフィールド：インスタンス名「A」 と ボタン：インスタンス名「nyuuryoku」 が フレーム1 にあり テキストフィールド：インスタンス名「B」 が フレーム5 にあったとします（↓図）。 その場合， フレーム1 には次のように書けば ご質問で書かれていらっしゃるようなことができますが。 ------------------------------------- //このフレーム(フレーム1)で停止 stop(); //ボタン「nyuuryoku」を押したときに実行 nyuuryoku.onPress = function() { //変数 「hennsuu」 に テキストフィールド「A」内の文字を代入 hensuu = A.text; //フレーム5 に進める gotoAndStop(5); //テキストフィールド「B」 に 変数 「hennsuu」 の値を表示 B.text = hensuu; }; -------------------------------------
FLAファイル 内の メインのタイムラインのフレーム1のスクリプトの18行目に 次の一文が見られます↓。 var wrap:MovieClip = _root.createEmptyMovieClip("wrap", 0); これは 「_root(メインのタイムライン) の 深度0 に 「wrap」 という空のムービークリップを作成せよ。」 という意味です。 その 深度0 の「wrap」 内で色々なことが起こるように書かれてあるようです。 ですからまず， > 他のムービークリップが表示されません。 と書かれていらっしゃる そのステージ上の 「他のムービークリップ」 に 例えば「my_mc」という インスタンス名 を付けます。 その「my_mc」を 深度0 より上に持って行けば ゆらゆら文字よりも上に表示されるはずですから， FLAファイル 内の メインのタイムラインのフレーム1の最初辺りにでも my_mc.swapDepths(1); と書けばゆらゆらよりも上に「my_mc」が表示されると思います。 (何でしたら my_mc.swapDepths(1) の 1 を 1000 や 10000 にしても良いです。) その他詳細は Google などで 「Flash 深度」 や 「Flash swapDepths」 のように検索してもらえば その辺のことが書かれてあるページが見つかると思います。
モーショントゥイーンされてるものは タイムラインがそのモーショントゥイーンの キーフレームに合っている時にしか選択できません というかできなくなりました 以前はキーフレームでないところでも動かせて 意図しない所にキーフレームができたりして ちょっと面倒だったのが改善したカンジです
var spotName = "spotName" + onMapButton_num + "_mc"; これ↑では 変数「spotName」の値として 文字列「spotName0_mc」などが入るだけです。 "インスタンスへの参照" が入るのではなく "単なる文字列" が入るということです。 したがって例えば spotName1_mc.gotoAndStop("white"); と書いていらっしゃる部分を _root[spotName1_mc].gotoAndStop("white"); または this._parent[spotName1_mc].gotoAndStop("white"); などのようにすると動くかもしれません。 Google検索「配列アクセス演算子」 http://www.google.co.jp/search?hl=ja&source=hp&q=%E9%85%8D%E5%88%97%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90
MovieClip の継承している Sprite の継承している DisplayObjectContainer を参照してみてください。 表示オブジェクトのコンテナとして機能する基本クラスですので、子表示オブジェクトを取得するメソッドが用意されています。子表示オブジェクトは、それらのメソッドを通して取得します。 以下のメソッドなどを使用すると、子表示オブジェクトを取得出来ます。 // 指定のインデックス位置にある子表示オブジェクトインスタンスを返す getChildAt(index:int):DisplayObject // 指定された名前に一致する子表示オブジェクトを返す getChildByName(name:String):DisplayObject まず A から B を取得し、その後に B から C を取得する形になります。 // B が A の 0 番の位置にある子表示オブジェクトと仮定した場合 var B:DisplayObject = A.getChildAt(0); // C が B の 0 番の位置にある子表示オブジェクトと仮定した場合 var C:DisplayObject = B.getChildAt(0);
そこはマイナーチェンジの番号 ちょっとセキュリティー改善したとか どっかの動作の不具合修正しました ってレベルのアップデートのバージョンを 示す番号だと思いますよ
期限が過ぎてしまいましたが…… トップレベルの Date クラス、flash.utils.Timer クラスを使用出来ると思います。 Date オブジェクトの getHours()・getMinutes() メソッドで、それぞれ時・分を取得し、現在の時間からアニメーションを開始する時間までの差を、Timer オブジェクトで登録し、イベントを発生させてみてはいかがでしょうか。 Date オブジェクトのメソッド // 時（0 ～ 23 の整数）部分をローカル時間で返す getHours():Number // 分（0 ～ 59 の整数）部分をローカル時間で返す getMinutes():Number Timer オブジェクト // Timer オブジェクト生成 var timer:Timer = new Timer(時間の差（ミリ秒）, 1); // イベントリスナを登録 timer.addEventListener(TimerEvent.TIMER, イベントハンドラ); // スタート timer.start(); Timer オブジェクトは誤差が出てしまう可能性がありますので、アニメーションを開始する時間より少し前に設定し、その時間になったところから、1 分置き・または何秒置きに監視した方が良いと思います。 また、現在の時間がアニメーションを開始させる時間と重なっていたら、Timer オブジェクトを生成することなく、アニメーションを途中から開始させてはいかがでしょうか。 参照URL： http://help.adobe.com/ja_JP/AS3LCR/Flex_4.0/Date.html http://help.adobe.com/ja_JP/AS3LCR/Flex_4.0/flash/utils/Timer.html
ActionScript 2.0 以下と 3.0 以上とでは 根本的な考え方や捉え方が変わりますよ。 ムービーの構造も違います。 ですから 単純な ActionScript の変換 などでは対処できませんが， 書かれていらっしゃるスクリプトを なるべく忠実に単純に ActionScript 3.0 に変換(？) すると次のような感じになります。 ---------------------------------------------- //FlashVars 内の変数「result」の値を受け取り 変数「res」に代入 var res:String = loaderInfo.parameters.result; //Loaderインスタンス「my_ld」を作成 var my_ld:Loader = new Loader(); //リクエストするファイルのURLを入れる変数を宣言 var my_file:URLRequest; // もし res の値(文字列)が "0" であれば if (res == "0") { //リクエストするファイルのURLを「main.swf」にする my_file = new URLRequest("main.swf"); // もし 変数 res の値(文字列)が "1" であれば } else if (res == "1") { //リクエストするファイルのURLを「1.swf」にする my_file = new URLRequest("1.swf"); } //Loaderインスタンス「my_ld」にファイルをロード my_ld.load(my_file); //Loaderインスタンス「my_ld」をこの階層に配置 this.addChild(my_ld); ---------------------------------------------- なるべく同じになるように変換っぽくはしてますが実際は変換ではありません。 自分の意識で「Loader」なども作成する必要がありますし， FlashVars 内の変数は 特別な入れ物（loaderInfo.parametersオブジェクト）内に入りますから， これも FlashVars であることを意識して そのオブジェクトを明示する必要があります。
ActionScript 3.0 と言えども フレームレート プロパティ は stage の frameRate プロパティ ですから 取得できたり 変更できるのは Stage 全体(ムービー全体)ですね。 ムービークリップ ごと などはできません。 > あきらあめるためにもご教授願います。 あきらめたいのかあきらめたくないのかよくわかりませんが 一応 あきらめない（あきらめられない）方向で。。。 そもそも 「フレームレート」 とは 「１フレーム進める時間間隔」 なのですから 「フレームレート」 自体にこだわる必要はないと思います。 （stage.frameRate=○○ の路線で考えることはやめにしましょうという意味です。） setInterval や Timerクラス のスクリプトを使って その ムービークリップ のフレームを操作(gotoAndStop();)すれば良いと思います。 あと Event.updateAfterEvent() メソッドも組み合わせて。 「Adobe Flash Platform タイマーと ENTER_FRAME イベント」 http://help.adobe.com/ja_JP/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffb.html FlashゲームPG講座 For AS3.0【タイマーについて】 より「Timer クラスを使用する」 http://hakuhin.jp/as3/timer.html#TIMER_01
自分でObjectタグとか書いてフラッシュを 配置したのでなくてまだそのアラートが出てくるってことは もう新しいＩＥではAC_runactiveContentsが使えなくなったか JavaScriptが無効になってるか… （新しいＤＷだとFlash読み込み用スクリプトが 外部ファイルじゃなくなってるみたいで AC_runactiveContentsはなくなっちゃったみたいです） こういうIEのアラート押さえ込むようなことするものは SWFobjectとかいろいろ他にもあるので（まあ定番はこれなんですが） AC_runactiveContentsではどうもだめみたいだって時は 探してみて下さい
吹き出し（hukidasi）は ボタン(btn1)の子として addChild するのではなく スクリプトで書いていらっしゃるように 吹き出し（hukidasi）は stage(または root) に addChild するので良いと思います。 ご質問で hukidasi.visible=false; と書かれていらっしゃるスクリプトのすぐ下辺りにでも hukidasi.mouseEnabled = false; という１行を追加すれば良いと思います。
単純に 「その WINDOWS PC の IE(6) の Flash Player のバージョンが低いから。」 という理由なのではないでしょうか？ 一般的に AS3 なら 少なくとも IE の Flash Player のバージョンが 9 以上である必要があります。 ご質問の SWF を 書き出したバージョンが 仮に Flash Player 10 でしたら 少なくとも IE の Flash Player のバージョンが 10 以上である必要があります。 「その WINDOWS PC の IE(6) 」 で http://get.adobe.com/jp/flashplayer/ を訪ねて Adobe Flash Player の最新版(現在は 10.1) をインストールすれば良いだけのことかもしれません。
添付画像をご覧下さい。赤い丸はオン・オフボタンです。ページ A ではなく、ページ B のようにされたいということで宜しいでしょうか。違いましたら補足下さい。 ページ A も B も、ほとんど同じ作りになっています。ページ A のフラッシュは、オン・オフボタンの他にもコンテンツがありますが、ページ B のフラッシュは、オン・オフボタン以外のコンテンツを排除して、ボタンのみにしています。 ページ B のように、オン・オフボタンのみの小さなフラッシュを作り、ソースの param のサイズも変更し、パンくず部分などに設置されてはいかがでしょうか。
元の画像があるってなるとビルドアニメーションの スクリプトってわけにもいかないのでマスクでしょうね 普通にオーサリングでマスクをする場合 レイヤーやシンボルは一つしか 有効にならないという制限がありますが スクリプトで 植物画像MC.mask=マスクMC とかやった場合はそういう制限がなくて楽です この場合はマスクのビルドアニメーションを スクリプトで作るということもできますし しかしあまりに形状が複雑だと 一生懸命画像にマスクをあわせるより 消し込みリバースした方が楽な場合もあります その辺は裁量ですね
ソースを拝見したところ、_cube は、コンストラクタ内のローカル変数として定義されています。ですので、コンストラクタのブロックを抜けた loop メソッドからは参照出来ません。 _cube を Box クラスのインスタンス変数として定義すれば、参照することが可能になります。 デモ（インデントには日本語の空白が入っています） public class Test1 { 　public function Test1() { 　　// コンストラクタ内のローカル変数として定義 　　var sprite:Sprite = new Sprite(); 　　// エラーは起こらない 　　sprite.x = 100; 　} 　private function move() { 　　// エラー 　　sprite.x = 200; 　} } public class Test2 { 　// インスタンス変数として定義 　private var sprite:Sprite = new Sprite(); 　public function Test2() { 　　// エラーは起こらない 　　sprite.x = 100; 　} 　private function move() { 　　// エラーは起こらない 　　sprite.x = 200; 　} }
HTML に貼り付けた以上 勝手にローディングされるのは Flash に限らず JPEG でも GIF でも，その他 HTML 自体も全てがそうです。 さらにその上， 「Flash をローディングさせない」という命令が仮に Flash からできるのであれば それはすなわち 「Flash をローディングしたからできること」ですから それは矛盾しているとも言えます。 ◎ 解決策の方向性１ HTML に貼り付けた以上 Flash は勝手にロードされるのですから 単純に HTML に貼り付けなければ良いのではないでしょうか。 JPEG なども普通はそうしますよね？ 大きな写真をたくさんページに貼り付けるとページが重くなるので １つのページ上にはサムネイル用の小さなJPEGでも置いておいて そのサムネイル写真をクリックすると 同窓 または 別窓 または 小窓 などでその 大きなJPEG を表示させるとかです。 Flash のキャプチャ画像でもサムネイルJPEGにして サムネイルにしてそのサムネイルをクリックすれば その Flash が何らかの形で表示されるようにすれば良いと思います。 その「何らかの形で表示」させる方法は沢山ありますから その「具体的な方法」をどうするのか書かれなければ答えようがありません。 ですからこれは 「解決策１」 ではなく 「解決策の方向性１」 です。 また そうする場合は， Flash ではなく HTML や JavaScript の話になります。 ◎ 解決策の方向性２ HTML に貼り付ける Flash (SWF) は 別の SWF をロード表示させる「親SWF」ということにして その 「親SWF」 に用意したボタンを押すことによって 「子SWF」 をその 「親SWF」 にロードさせても良いと思います。 要するに 「TV の装置部分」 だけを SWF で作成し HTML に貼り付けておいて その TV 部分のボタンを押すなりチャンネルを変えると それに応じた 「番組」 のSWF を TV の中にロードすれば良いということです。 （ある意味 YouTube みたいな感じ） これをするには 親SWF に「子SWFをロードする」 ための しくみ や ActionScript が必要になります。 具体的な しくみ や ActionScript は 作りたいものによって変わりますし また Flash や ActionScript のバージョンによって変わりますから これも 「具体的な方法」 や 「バージョン」 が何なのかを書かれなければ答えようがありません。 ですからこれも 「解決策２」 ではなく 「解決策の方向性２」 です。 大まかな方向性だけで回答を終わるのも何ですから もう少しだけ進んだところまで書きます。 （これ以上はさらに分岐が多すぎて書けない。） ActionScript 2.0 以下（Flash 8 以下）であれば ムービークリップ(MovieClip) を何らかの形で作成して そのムービークリップに loadMovie するのがオーソドックスで簡単な方法です。 Google検索「Flash loadMovie」 http://www.google.co.jp/search?hl=ja&q=Flash+loadMovie&aq=f ActionScript 3.0 （Flash CS3 以上）であれば Loader クラスのインスタンスを ActionScript で作成して その Loader に load するのが普通の方法です。 Google検索「Flash Loader load」 http://www.google.co.jp/search?hl=ja&safe=off&q=Flash+Loader+load&aq=f
コンピュータのプログラムやプログラムで使う値は、”メモリ”という場所に格納されます。 ActionScript でも同様に、スクリプト自体や数値・文字列といった値、ムービークリップなどの作品を構成する要素も全て、メモリのどこかに格納されています。 ActionScript で扱う値やムービークリップなどの部品の多くは、複数の情報でできています。 例えばムービークリップは、絵のデータや画面での位置・大きさ、gotoAndPlay などの機能といった、多くの情報で構成されています。 これらは１件ごとに整理し、いわばメモリの中に作られた１つの町に住む住民たちのような形で格納されます。 町が作られたメモリ上の場所で書くとスクリプトが分かりにくくなるので、実際の場所は明かされません。 代わりに、町の場所を知る者を置き、この者を介して用のある住民を訪ねて行ける仕組みになっています。 具体的な例で言いますと。 ステージにムービークリップを配置し、インスタンス名を” mc ”と付けたとします。 すると、このムービークリップを構成する様々な住民（＝情報）が集まった町が、メモリのどこかに作られます。 できた町の場所は、インスタンス名である mc が知っています。 ムービークリップの表示位置を知りたい時や、フレームを切り替える gotoAndPlay などの職人に仕事を頼む時は、mc に案内を頼んで用のある住民を訪ねて行くわけです。 １件のデータに関する情報を持つ住民の集まる町のことを”オブジェクト”、この町の場所のことを”参照”といいます。 では、ムービークリップがステージにない時はどうでしょう。 この場合は、メモリのどこにも、このムービークリップの町は作られません。 スクリプトで mc という名前の案内役を作ったとしても、そもそも町が存在しないために、mc にはどの場所も記録されていません。 この状態が null です。 mc が場所を知らないのに、「あの町に住む○○に仕事を頼みたいから、案内してほしい」と言っても、話になりません。 これが、「 null オブジェクト参照のプロパティまたはメソッドにアクセスできない」というエラーです。 null とは、本来はメモリのどこかの場所を知っているはずのものがどの場所も知らない状態のことを指す、特殊な値です。 ここではムービークリップを例にしましたが、ムービークリップ以外のデータを扱う時も変数に null が入る場合があります。 null は値ですから、実は、明示的に変数に入れることもできます。 － － － － － void は関数に関係のある言葉です。 関数の詳細は、入門書や解説サイト等をご参考になさってください。 なお、関数から持ち帰ってくる値（戻り値）と void の意味は、以前、説明したことがありますので、よろしければご参照ください。 　・[return]の役割について 　　http://okwave.jp/qa4447665.html 　・actinscript3でvoidの意味 　　http://okwave.jp/qa4540185.html 　　（↑ void については＃３で説明しております） ActionScript で扱うデータは全て、１件ごとの情報が集まる町（オブジェクト）の形でメモリに格納されています。 （中には、内部で便宜をはかってそのように見えないものもありますが、今回は触れません） 変数に値を入れると、メモリの中に町が作られてその場所（参照）が変数に入り、変数が持つ場所をもとに必要な情報を取り出します。 町には様々な種類があり、同種の町は似た構造をしています。 この種類のことを”データの型”といいます。 変数には、１度決めた町と同種の町の場所を入れなければならない決まりになっています。 例えば、ムービークリップの町の案内役と決めた mc に文字列の町の場所を覚えさせようとすると、エラーになってしまいます。 案内役の型を決め、案内を頼んでくる者が求める型と一致させることは、トラブルをなくすためにも大切なことです。 void はデータの型の１つです。 ただ、ムービークリップや数値とは違い、「何もないことを表す」という不思議な型です。 null はどの町の場所も指していないことを表す”値”で、入れようと思えば変数にも入れられるのに対し、void はメモリの中にできる町の種類の１つなので、変数に入れることはできません。 void は関数を定義する時に、関数から持ち帰ってくる値がないことを表すためだけに使われます。
携帯端末でインタラクティブなFlashを作りたい場合、swfファイルに直接リンクさせます。 下記URLに携帯達末でアクセスしてみてください。 http://ddd.f00.jp/d/button.swf
buttonModeプロパティは DisplayObjectContainerクラスを継承するインスタンスのうちでも Sprite以下のものにしかありません。 つまりLoaderクラスにはbuttonModeプロパティはありません。 したがって Spriteインスタンス の中に Loaderインスタンス を入れれば良いでしょう。 ------------------------------------ //ロード用のオブジェクト格納用Spriteを作成 var img_spr:Sprite = new Sprite(); //座標を指定 img_spr.x = 100; img_spr.y = 100; //ロード用のオブジェクトを作成 var img:Loader = new Loader(); //「button.jpg」のURLRequestを作成 var imgURL:URLRequest = new URLRequest("button.jpg"); //イメージのロード開始 img.load(imgURL); //リンクをするように記述 img_spr.addEventListener(MouseEvent.CLICK, imgClick); //img_sprのボタンモードをtrueにする img_spr.buttonMode = true; //imgをimg_spr内に配置 img_spr.addChild(img); //img_sprをrootに配置 addChild(img_spr); ------------------------------------ いわゆるボタンモードの機能は もとはボタン(今のSimpleButton)にしかなかったものです。 そのボタンモード機能が MovieClip まで広がったのが Flash MX（Flash Player 6）で そのボタンモード機能が Sprite まで拡張されたのが Flash CS3（Flash Player 9）です。 「いわゆるボタンモードはボタンにしかない」 というのが本来の出発点ですから 「ボタンモードは何でもかんでもにある」 と捉えるほうがおかしいと言えばおかしいのです。 というか そう考えればすんなり納得できるのではないかと思います。
下記のサイトをご参照下さい（Flash CS4 を使用したことが無いため間違っているかも知れません）。 『ActionScript 3.0 のソースパスの設定』という項目が、該当するのではないかと思います。 http://help.adobe.com/ja_JP/Flash/10.0_UsingFlash/WS3e7c64e37a1d85e1e229110db38dec34-7fa4a.html#WSB1F410E6-F7BD-443a-97E7-13DE866CA732
「簡単」というのがどういう程度かよくわからないのですが。。 参考URLのチュートリアルをご覧ください。 FLVには「ポスターフレーム」の機能はありません。 このチュートリアルでは、停止状態のFLV Playbackコンポーネントの直上に、ポスターフレーム（としての）pngをぴったり配置し、スタートボタンクリックで、pngを消し、FLVを再生する方法をとっています。 それ以上簡単に、ということであれば、ビデオ編集ソフトで先頭フレームの画像を差し替えるしかないのでは。
「シンボルをクリックする」の具体的意味がわかりません。 「ステージの任意の位置をクリックする」という意味と勝手にします。 まず 「yubi1」をMC(ムービークリップ)で作成して そのMC内のタイムラインを２フレームにします。 そして そのMC内のタイムラインのフレーム1には "yubi1の画像" を配置して MC内のタイムラインのフレーム2には "yubi2の画像" を配置し， クリックする前は MC内のタイムラインをフレーム1で stop() させておいて クリックしたときに MC「yubi1」内のタイムラインを gotoAndStop(2) すれば良いのではないでしょうか。 ※↓下の図をご参考に↓ こうすれば "yubi1の画像" と "yubi2の画像" を 頻繁に入れ替える場合でも簡単になります。 フレーム1 に "yubi1の画像" を配置し フレーム2 に "yubi2の画像"を配置しムービークリップに 「yubi_mc」 というインスタンス名を付けたとします。 その場合， １回目のクリックで "yubi2の画像" にするだけのときのスクリプト例↓ ------------------------ //本物のマウスを隠す Mouse.hide(); //「yubi_mc」がマウスメッセージを受け取らないようにする yubi_mc.mouseEnabled = false; //「yubi_mc」内をフレーム1で止める yubi_mc.stop(); //マウスが動いた時に関数mouse_moveを実行 stage.addEventListener(MouseEvent.MOUSE_MOVE,mouse_move); //関数mouse_moveを定義 function mouse_move(event:MouseEvent):void { //「yubi_mc」をマウスの座標に移動 yubi_mc.x = stage.mouseX; yubi_mc.y = stage.mouseY; //表示を即更新 (移動の もたつきを防止) event.updateAfterEvent(); } //マウスがステージ外に出た時に関数mouse_leaveを実行 stage.addEventListener(Event.MOUSE_LEAVE,mouse_leave); //関数mouse_leaveを定義 function mouse_leave(event:Event):void { //「yubi_mc」をとんでもない座標に移動(消す) yubi_mc.x = -5000; } //マウスアップした時に関数mouse_upを実行 stage.addEventListener(MouseEvent.MOUSE_UP,mouse_up); //関数mouse_upを定義 function mouse_up(event:MouseEvent):void { //「yubi_mc」内をフレーム2で止める yubi_mc.gotoAndStop(2); } ------------------------ クリックする度に "yubi1の画像" と "yubi2の画像" を入れ替える場合は 上のスクリプトのうち最後の「関数mouse_upを定義」の部分を 次↓のように変えます。 --------------------- //関数mouse_upを定義 function mouse_up(event:MouseEvent):void { //もし「yubi_mc」内の表示フレームが1であれば if (yubi_mc.currentFrame == 1) { //「yubi_mc」内をフレーム2で止める yubi_mc.gotoAndStop(2); //それ以外は(=表示フレームが2であれば) } else { //「yubi_mc」内をフレーム1で止める yubi_mc.gotoAndStop(1); } } --------------------- 　
そもそも 関数 mouseUp 内のスクリプトは なぜそんなにまわりくどいの（遠回りなの）でしょうか？ 　色を数値にして 　　その数値を文字列にして 　　　その文字列を数値にして 　　　　その数値を色にする そんな遠回りをせずに普通に 　色を数値にして 　　　その数値を文字列にする 　　　また その数値を色にする で良いのではないでしょうか？ ↓つまり↓ function mouseUp(evt:MouseEvent) { var pixelValue:uint = bmpData.getPixel(evt.stageX,evt.stageY); colBox2.text = pixelValue.toString(16);//取得したカラーを代入 colorTrans.color = pixelValue; trans.colorTransform = colorTrans; } あえてご質問のようにまわりくどくする場合は 次のように↓するとか， function mouseUp(evt:MouseEvent) { var pixelValue:uint = bmpData.getPixel(evt.stageX,evt.stageY); colBox2.text = pixelValue.toString(16);//取得したカラーを代入 colorTrans.color = uint("0x" + colBox2.text); trans.colorTransform = colorTrans; } または， 次のように↓するとか， function mouseUp(evt:MouseEvent) { var pixelValue:uint = bmpData.getPixel(evt.stageX,evt.stageY); colBox2.text = pixelValue.toString(16);//取得したカラーを代入 var color_num:uint = new uint("0x" + colBox2.text) colorTrans.color = color_num; trans.colorTransform = colorTrans; } ですかね。
全自動で動くものなら書かれていらっしゃることも理解できるのですが マウスが乗ったときにも動作するのですよ。 マウスが介入すればたくさんの分岐があると思います。 なんだかわかりませんが， とりあえずマウスのことは一切無視した場合を書きます。 書かれていらっしゃるページの次の部分↓ --------------------------------- // 自動で動かす関数 function autoRollOver():Void { cnt = (cnt<datArr.length-1) ? cnt+1 : 0; movArr = datArr[cnt]; tw(); } --------------------------------- これを次のように変えます↓ --------------------------------- //フラグとなる変数を用意 var flg = true; // 自動で動かす関数 function autoRollOver():Void { //もしflgがtrueであるなら if (flg) { cnt = (cnt<datArr.length-1) ? cnt+1 : 0; //もしcntがdatArrの要素数-1になればflgをfalseにする flg = (cnt == datArr.length-1) ? false : true; movArr = datArr[cnt]; tw(); } } --------------------------------- これでフラグが true であるときのみ自動で動きます。 もし マウスが１回でもどれかのパネルに乗ったときに 自動で動くのを解除したいのでしたら 上のようにスクリプトを変更した上でさらに スクリプトのずっと下の方にある // パネル01～0? ロールオーバー時の動作 this["panel0"+(i+1)+"_mc"].onRollOver = function():Void { clearInterval(myID); movArr = datArr[this.n]; tw(); }; の部分の tw(); のすぐ下の行辺りにでも flg = false; を入れれば良いと思います。
その PHP ファイルにアクセスしたとき 何某かの単なるテキストが返る(表示される)のでしたら LoadVars クラスのメソッドで LoadVarsインスタンスにその PHP をロードすれば良いと思います。 その PHP ファイルにアクセスしたとき XML データが返る(表示される)のでしたら XML クラスのメソッドで XMLインスタンスにその PHP をロードすれば良いと思います。 ロードした後， ロードしたファイルから各データを抽出したりパースしたりする方法はわかりません(誰にもわかりません)。 データの形がどのようなものであるかによって方法は変わりますし， また逆から言えば Flash で取り出しやすいような形にすべきです。 とりあえずは単なるテキストをロードしてみてはいかがでしょうか。 そうすれば PHP で作るべきデータの形がわかってくると思います。 Google検索「LoadVars」 http://www.google.co.jp/search?hl=ja&q=LoadVars データがXMLの場合はこの辺で検索です↓。 Google検索「XML.load Flash」 http://www.google.co.jp/search?q=XML.load+Flash&hl=ja&lr=lang_ja ※注意 別ドメインのPHPが出力するデータを Flash でロードすることはできませんよ。 クロスドメインのポリシーファイルの設置などが必要です。
HTML や CSS や JavaScript は関係ありませんよ。 というか 日頃HTMLページに Flash の SWF ファイルを貼り付けるときに HTML や CSS や JavaScript を使うのでしたら フル画面のFlash でも使うだけのことで， フル画面のFlash だからそれらが必要になるということはありません。 HTML 側としては Flash の SWF ファイルを 100％ 表示させれば良い（width も height も "100%" にすれば良い）だけです。 そのとき SWF の周りの余白が気になるようでしたら CSS で マージンを 0 にすれば良いです。 単にそれだけのことですから， フル画面のFlash であるからと言って特殊な知識や技術が必要なわけではありません。 ですから作成するにあたってとりあえずは HTML や CSS や JavaScript を忘れた方が良いと思います(雑念になるなら全く意識しない方が良い)。 問題は それらではなく Flash と ActionScript です。 と言っても そういうレイアウトにすること自体はそんなに難しいことはありません。 「Flashが表示されたとき」と「ステージがリサイズされたとき」のタイミングの両方で， 表示させるムービークリップなどのインスタンスの座標を指示するというだけのことです。 ActionScript 3.0 の場合は とりあえず次のページの次の項目↓について理解するようにします。 FlashゲームPG講座 For AS3.0【Stage クラスについて】 Flash の整列する位置を設定する http://hakuhin.jp/as3/stage.html#STAGE_03 それがわかれば 中央の 黒い■ や 下の赤い帯 を ムービークリップ で作成して それらのムービークリップの座標を 「Flashが表示されたとき」と「ステージがリサイズされたとき」のタイミングの両方で指示してやれば良いということになります。 具体例は次のようなページに書いてくれています↓。 「フルFlashサイトの作り方の基本まとめ(ActionScript3.0)」 http://www.aoharu-b.com/cgi/sk/2010/02/flashactionscript30.html 「[AS3]フルブラウザ、リキッドレイアウト」 http://alwaysfinetuning.com/ao-blog/2009/01/as3-3.html あと ムービークリップを作成するときに 「基準点」について「意識して」作成してください。 ムービークリップの座標とはムービークリップの「基準点」の座標です。 「ムービークリップの基準点」 http://homepage3.nifty.com/ginga-b/flash5/mc_refpoint.html 一般的には ActionScript云々よりも 空間認識（x-y平面座標 のしっかりしたイメージ）をもつことの方が 難しい人にとっては難しいと思います。 空間や座標のイメージを頭の中に簡単に作れる人であれば 何にも難しいことはありません。
要は ActionScript 2.0 以下であった MovieClip.onReleaseOutsideイベントハンドラメソッドが ActionScript 3.0 から削除されてしまったからやりにくい（考えにくい）わけですね。 ドラッグするムービークリップには「my_mc」というインスタンス名(または変数名)が付けてあったとします。 その場合，次のようにするのが１つの方法です。 ------------------------------------------------ //「my_mc」に対してMOUSE_DOWNのイベントリスナーを登録 my_mc.addEventListener(MouseEvent.MOUSE_DOWN,dragStart); function dragStart(evt:MouseEvent):void{ evt.currentTarget.startDrag(); } //「stage」に対してMOUSE_UPのイベントリスナーを登録 stage.addEventListener(MouseEvent.MOUSE_UP,dragStop); function dragStop(evt:MouseEvent){ my_mc.stopDrag(); } ------------------------------------------------ 要するに 押すターゲットはムービークリップにして 放すターゲットはステージにするということです。 または， 「EventDispatcher.addEventListener()メソッド」 http://www.fumiononaka.com/TechNotes/Flash/FN0608004.html ↑上記ページのクラスファイル「MyButton.as」を使わせてもらって 上記ページにあるように「my_mc」のシンボルの設定を「MyButton」クラスにして フレームに書くスクリプトを次のようにしても良いと思います。 ------------------------------------- my_mc.onPress = function() { my_mc.startDrag(); }; my_mc.onRelease = function() { my_mc.stopDrag(); }; my_mc.onReleaseOutside = function() { my_mc.stopDrag(); }; ------------------------------------- 　
メッセージボックス の意味がわかりません。 メッセージボックス とは何でしょうか？ VBA で言うところの MsgBox のことでしょうか？ 仮に VBA の MsbBox であった場合でも， 大きく分類すると使い方は２つあって 本当に閲覧者のために出す本来の メッセージボックス 的使い方と 変数に値が得られたかどうかを確かめる際に使う デバッグ 用の使い方があります。 つまり 仮に 「VBA の MsbBox」 と限定しても どういう場合の MsgBox のことかわかりません。 上記でいうところの 「VBA の MsbBox」 を ブラウザの JavaSctipt で言うならば， alert（） 関数 の近い意味になります。 「VBA の MsbBox の デバッグ的使い方」 に近いものであれば ActionScript 1.0 ～ 3.0 では trace() がそれに当たります。 http://www.google.co.jp/search?hl=ja&q=trace+ActionScript ↑しかし， trace() はムービープレビュー時などに使える 作成者側のスクリプトであって， ブラウザを通した閲覧者環境では何も表示されません。 Flash の場合， 見た目のインタフェイスは自作するというのが根本ですから， 「VBA の MsbBox の 閲覧者のために出す本来の メッセージボックス的使い方」 のようなものでしたら そのメッセージボックスをムービークリップで自作するのが一般的ではないかと思います。 （何かを作って，作ったものを出したり引っ込めたりするのが Flash の本業です。） メッセージでも何でも適当なものを作って それを出し入れすれば良いだけのことだと思います。 自作せずに 「VBA の MsbBox の 閲覧者のために出す本来の メッセージボックス的使い方」 のものを表示させるのでしたら， ActionScript 2.0 の場合， UIコンポーネントに Alertコンポーネント があります。 http://www.google.co.jp/search?hl=ja&q=Alert+ActionScript Flash MX 2004 と 8 の Professional 版 くらいの のコンポーネントから 一応はそのようなものがあります， このようなものを使っても良いかもしれません（私は使いません）。 ActionScript 3.0 では上記のようなものは見あたりませんね。。。 誰も使わないので消したのではないかと思います。 何にしても上記の内容は 「私の勝手な推測」に過ぎません。 メッセージボックス の意味が変われば回答なども変わるでしょう。 また バージョン によっても回答は変わる可能性がかなりあります。
バージョンを書かれていないので何とも言えませんよ。。。 Flash CS4 (Flash Player 10) 以上なのか Flash CS3 (Flash Player 9) 以下なのか この辺で変わります。 また ActionScript のバージョンも書かれていない。 Flash CS4 以上をお持ちであれば y軸３D回転の部分は簡単なことです。 ActionScript なんか使わなくても ステージ上で写真をグリグリ３D回転させることができますから， ムービークリップの中で写真が回転するだけのアニメーション(モーショントゥイーン)を作成しておいて ステージ上の任意の場所プがクリックされるなどしたとき 左で大きくなるムービークリップ内を play() で再生させるようにすれば 「回転のみ」は非常に簡単にできます。 また ActionScript を使うとしても CS4 以上 なら 3D回転させることは簡単です。 「インスタンスのy軸における回転角の値の範囲」 http://www.fumiononaka.com/TechNotes/Flash/FN1008002.html 残る問題は 「順繰りに各ムービークリップを目的の座標と深度に移動させる」部分のみになります。 ここは結構頭を使うと思います。 CS3 以下であれば ３D回転の敷居はかなり高くなります。 Papervision3D などを使った方が楽かもしれません。 確か ActionScript 2.0 版もあったと思います。 その３D回転部分で四苦八苦した上に 「順繰りに各ムービークリップを目的の座標と深度に移動させる」部分も考えなければなりません。 この辺は ActionScript 2.0 と 3.0 では書き方や考え方を変えなければなりません。 バージョンによっていちいち説明したり回答を変えて書くのは不可能です。
AS2.0ですが、以前、「憲ちゃん」サイトに投稿した際のサンプルがありましたので、下に、FLAをアップしておきます。ダウンロードして、弄ってみて下さい。
＃１です。 ActionScript は大文字で始まる型の名前を慣例にしているだけで、大文字/小文字で始めなければならない文法上の規定はありません。 型の名前は ActionScript 3.0 になっても規定が特に追加されておらず、それはつまり、文法の範囲内で自由に付けて構わないということです。 明確な規定がないのなら、新たに導入する型の名前を大文字始まりにする義務もありません。 自由に名前を付けていいのに、慣例に反して名前の統一感を欠いてでも、なぜ小文字だけの型の名前が導入されたのか。 型の名前の由来まではいちいち説明する必要がなく、その理由はおそらく Adobe のサイトにも Flash の仕様書にも書かれていないでしょう。 公表されていない以上、真相を知っているのは開発者だけですから、理由は推測するしかないと思います。 ActionScript はＣ言語系の文法や発想をいろいろと取り入れてきました。 ですから、今回、整数型を導入するにあたり、Ｃ言語系と同じ int の名前を採用したのではないかと推測できます。 また、符号なしの uint は大文字始まりにすると UInt になり、ActionScript には” UI ”で始まるクラスが多く紛らわしくなるから、といった理由もあるのかもしれません。 ちなみに、関数の戻り値がないことを表す void は、ActionScript 2.0 では大文字始まりで Void と書きますが、3.0 では小文字の void に変更されました。 このあたりからも、Ｃ言語系の表記に合わせようとしていることが窺われます。 型の他にも、ActionScript の名前には統一されていないところが多々あります。 例えば、メソッドの名前は小文字始まりを推奨しているのに、グローバル関数の中には大文字で始まる名前の関数もあります。 これは、互換性や使い勝手を考慮しながら、添削を繰り返して進歩してきた結果だと思います。 今回の件も、名前の統一感はさておき、Ｃ言語系の言語にある int 型を名前ごと取り入れた、それだけのことではないでしょうか。 どうしてそんなことをしたのかは現時点では見えてきませんが、今後、Ｃ言語系と同様にプリミティブ型は小文字で、といった規格を作っていくつもりなのかもしれません。
＃１＆２ です 返事が大変遅れてしまいすみません。 > 「town1」はムービークリップに変換し、 > モーショントゥイーンで動かしています。 ということは root(メインのタイムライン)のフレームを使って 「town1」というインスタンス名のムービークリップを移動させている。 ということになるのではないかと思います。 もしそうであれば 「rootのタイムラインを止める必要がある」 ということになります。 したがってその場合は ご質問で書かれていらっしゃる次の文↓を function rolloverHandler(event):void{ town1.stop(); } 次のような感じ↓に変える必要があります。 function rolloverHandler(event):void{ MovieClip(root).stop(); } しかし。。。 もしそうであると， ムービー自体は Spriteクラス を継承したものではなくて MovieClip を継承したクラスになると思います。 そうである場合は ご質問で書かれていらっしゃる次の文↓を public class komoTown extends Sprite{ 次のように↓に変える必要があると思います。 public class komoTown extends MovieClip{ これに限らず， ドキュメントクラスのクラスファイルは だいたいどの場合も extends MovieClip にしておくのが無難だと思います。 Flash 自体は＝Flashのメインタイムラインは ムービークリップの一種ですから。
書かれていらっしゃるスクリプト中にある onEnterFrame = function(){…} は スクリプトを書かれていらっしゃるタイムラインに対して(_rootに対して)定義している onEnterFrameイベントハンドラメソッドです。 つまり _root.onEnterFrame = function(){…} と書いているのと同じことです。 １つのムービークリップ(_rootもムービークリップの一種) に対して 同じ種類のイベントハンドラメソッド は１つしか定義できません。 _root.onEnterFrame = function(){A}; _root.onEnterFrame = function(){B}; _root.onEnterFrame = function(){C}; と書いた場合，結局 _root.onEnterFrame = function(){C}; だけ書いたのと同じになります。 （同じ関数名の関数を再定義し直しているだけ） 回避策としては， ボタンをボタンインスタンスとして用意するのではなく ボタンをムービークリップインスタンスとして用意し そのムービークリップに対して 各ムービークリップ.onEnterFrame = function(){…}; を定義するのが一般的です。 しかし ボタンはボタンインスタンスでしか用意できない場合は， onEnterFrame 定義用のムービークリップを作成しても良いと思います。 それと... var なしで関数内に変数を作成すると その変数はグローバルなタイムライン変数になってしまいますよ。 その点も入れてスクリプトを修正↓ ================= stop(); sx = 3; var i; //----------- for (i = 1; i < 4; i++) { Nov = "bt" + i; //_rootの深度iにムービークリップ「bt[1～4]_mc」を作成 _root.createEmptyMovieClip(Nov + "_mc", i); _root[Nov].onRollOver = function() { Name = this._name; btOverMotion(Name); }; _root[Nov].onRollOut = function() { Name = this._name; btOutMotion(Name); }; } //----------- function btOutMotion(eachNo) { //↓このNoはローカルであるべき var No = eachNo; //各ムービークリップに対してonEnterFrameを定義 _root[No + "_mc"].onEnterFrame = function() { if (_root[No]._xscale < 100) { delete this.onEnterFrame; } else { _root[No]._xscale -= sx * 2; _root[No]._yscale -= sx * 2; } }; } //----------- function btOverMotion(eachNo) { //↓このNoはローカルであるべき var No = eachNo; //各ムービークリップに対してonEnterFrameを定義 _root[No + "_mc"].onEnterFrame = function() { if (_root[No]._xscale > 120) { delete this.onEnterFrame; } else { _root[No]._xscale += sx; _root[No]._yscale += sx; } }; } ================= このままでも動作に支障はないようですが 意味合いからすると Nov = "bt" + i; なども本当は var Nov = "bt" + i; のようにすべきだと思います。
