雛形となるHTMLに　可変要素の部分に　なにかルールを決めてキーワードを記述し プログラムが　そのキーワードを探して、プログラムで取り出した文字に置き換えているところですね。 この例としては、キーワードのルールは　！名前！　なのでしょう。 キーワードとしては、HTML内で使ってなさそうな文字列であればなんでも　よい訳ですが ! を付けているのは、HTMLタグやHTML中の文章として発生しなさそうなのと 前後に！を付けることで、対象外のキーワードが部分一致してしまわないための工夫でしょう。 （ 頭だけ！を付けて、　!url と !url2　と記述してしまうと、、s/!url/xxxx/で 　!url　→ xxxx　の置き換えだけでなく、　!url2　も置き換えてしまってｘxxx2にしてしまうので）
＞　ブラウザ経由だとユーザーとしてログインしていないですが、それでrsyncを動かすことはできるものでしょうか？ rsync自体は問題なく実行できますが、ブラウザ経由で実行した場合のコマンド実行ユーザーはapacheの実行ユーザーになるので、wwwとかデーモン実行用のユーザーで実行されます。 ＞　外部サーバーのCGIで書き込みがあったときに、別のサーバーに同じデータを差分コピーしたいという目的でしたが、apacheやrsyncの実行ユーザーのことを考えると難しそうですね。 リアルタイム性に拘らなければ、cronを使って5分に1回rsyncを実行すると言った方法もあります。
ひとつ気になる点として、配列要素を参照するときは@ではなく$を使います。 >if(@dbline[1] eq @data[0]) { ではなく if($dbline[1] eq $data[0]) { が正しいと思います。
問われているのが名称なのか機能なのかわかりませんが、どっちも簡単に… 「@$」「%$」は変数名につけるPrefixです。 リファレンス変数「$○○」の実データが配列なら「@」、連想配列なら「%」を付けないと正常にデリファレンスできないので、「@$○○」のような記述になります。 「->」はアロー演算子です。配列にアクセスするときや外部モジュール内の関数にアクセスするときに使います。 「=>」は連想配列の初期化をするときに使います (コンマ区切りより見やすい)。名前は…知りません。
BEGIN文の中で@INCにパスを追加する方法はどうでしょうか？ -- BEGIN { push(@INC, '/usr/local/sbin'); }
a=`cat 111.txt` の時点で改行が空白に変わるので、a="444 444" と同じになります。 ファイルの内容で置換したいときは、 sed 's/222/cat 111.txt/e' 1.txt のように、e オプション(コマンド実行)を使います。
モジュールを有効に使えれば良いでしょうが plain入れ子ならベタにテキスト処理など plainは本体のみ、それ以外はヘッド込みになります メーラーの仕様、知らないのでヘッドは工夫して下さい テキストのみのemlはpack('c',27)置換して use strict; my(@plain_1,@html_1,$an_1); open $an_1,'hoge.eml' or print"$!\n"; while(<$an_1>){ if($_ =~ m|text/plain|){ while(<$an_1>){ ($_ !~ m|text/html|) ? push @plain_1,$_:last; }} push @html_1,$_; } print"plain\n @plain_1"; print"html\n @html_1"; __END__
/<!--[\s\S]*?-->/ 　でコメントアウトを抽出して、それを元の文字から除去する感じですかね
perlですよね。 ＞文字コードの問題かと思って どこって。 文字コード指定がhtmlヘッダにしかないのだけど。 CGIヘッダと、入出力指定にも文字コード指定をしないとサーバーが勝手にコード指定してしまうのでCGIが不安定になる。 テキストファイルの保存形式も結構重要。 テキストファイルだからって中身が何でもいいわけじゃない。 文字化けしないための処置は以下。 CGIだけがutf-8保存ファイルでその他のテキストファイルがsjis保存、htmlもsjis指定の場合。 #!/usr/bin/perl use utf8;#以下の文字コードがutf8で記述されているとCGIに対して宣言。日本語記述が出る前に宣言。スクリプト途中でコードを変える時にも使用できる。 use CGI; use Encode;#標準で用意されていなければ自前でlibフォルダーを作ってサイトからダウンロードして保存しておく。 use open IN => ":encoding(cp932)"; # 入出力ファイルがWindowsのShiftJIS宣言 use open OUT => ":encoding(cp932)"; use open IO => ":encoding(cp932)"; binmode STDIN, ":encoding(cp932)";#標準入出力print文のShiftJIS宣言 binmode STDOUT, ":encoding(cp932)"; ついでに、cgiがutf8でhtmlがsjis指定で入力フォームのデータが日本語を使用しているなら文字コード指定が必要。なければいらない。 $text =decode( 'cp932',$http->param("formdata")); htmlがsjis指定だとこうなる。 初歩の初歩的なミス。 cgiサーバーが「文字コード指定をしていないcgiスクリプト」を文字コード違いで読込んでしまうと、保存形式を変えてもコードを変えてくれないので、文字コードを正しく指定すること。 cgiファイル他すべての保存形式ががsjisの時は、これを宣言しないといけない。 この場合は、使用できない関数がある。（文字検索で文字化けなど） #!/usr/bin/perl use cp932;#以下の文字コードがsjisで記述されているとCGIに対して宣言。 入出力のcp932宣言はいらない。
原則として、Internal server error （500エラー）はサーバ側の処理の問題なのでブラウザは関係ないはずです。Internal server error が出ているようであればサーバログにエラー内容が出ていると思うので、そちらをまずは確認してください。ブラウザが原因で起きる可能性としては、プラグインやアドオンが導入されていて、それらが変な情報をサーバに送っていてエラーになっていることはあります。アドオンを全部オフにして試してみるのはアリだと思います。 ちなみに自分の環境のIE（11、10、９）で該当のURLを開いてみましたがroomidエラーという赤字のエラーが出ている画面が出ました。
これでいいかな？ 実践もいいけど、perl・CGI・OS・PCの入門書なんかもちゃんと読んでアカデミックな部分でも理解してね #!/usr/bin/perl print "Content-type: text/plain\n\n"; foreach(sort keys %ENV){ print "$_: $ENV{$_}\n" } exit;
OSには環境変数という変数が利用者に対して提供されています 　コマンドが入力されたら実行ファイルをどこをどのように探すのかとか 　OSの名前は何なのかとか 　利用しているユーザーの名前は何なのか といった情報です perlとくにCGI環境などでよく利用されるのは 　リモートユーザーのIPアドレス 　リモートユーザーのブラウザID といった情報でしょうか %ENVにはそういった情報をperlから参照できるようにあらかじめ用意された変数です 入門書などによくあるサンプルですが foreach(sort keys %ENV){ print "$_: $ENV{$_}\n" } で主要な環境変数の中身を参照できます いちおう主要なと書いたのは、ハッシュのキーを明示しないと状況によっては参照できないものもあります perlよりもOSそのものをユーザーレベルで無く管理者レベルで理解しないと難しい概念ですが、頑張ってください　PCのオーナーは自覚さえあれば誰もが管理者なのです
こんにちわ。 概ね以下のような感じでしょうか。 1. STDINから入力を受け取る 2. chompで改行を削除 3. 連想配列に入力がキーとして存在するかチェック 　3.1 存在する場合はlastでwhileループを抜ける 　3.2 存在しない場合はwhileループを続行 ---------------------------------------------------------------------- my %hash = ("AP" => "Apple", "BN" => "Banana", "OG" => "Orange"); my $input = ''; print("好きな果物を入力してください[AP/BN/OG]"); while (defined($input = <STDIN>)){ chomp($input); if(exists($hash{$input})) { #入力がhashに存在するkeyならwhileを抜ける last; } print("３種類から選んでください”); } print("あなたの好きな果物は" . $hash{$input} . "ですね"); ---------------------------------------------------------------------- >また入力には<STDIN>を使い引数はchmopで処理すると良いとアドバイス >を貰いましたがchompの使い道がよくわかりません。 chompは変数(文字列)の末尾の改行を削除する関数です。 例えば、 >"好きな果物を入力してください[AP/BN/OG]" AP と入力すると$inputの中身は"AP\n"というように最後に改行文字が入っています。 改行文字が入っていると連想配列のキーのどれにも一致しなくってしまうので、 chompで削除する必要があります。
生のHTMLを作っているなら HTMLのソースファイルをブラウザで表示すれば確認できますが、 perlでHTMLを生成するCGIの場合は、perlソースを表示したいのではなく perlを実行した結果を表示したいのですから、 perlをCGIとして実行するためのWebサーバー(ApacheとかnginxとかIIS）が必要です。 なお、IISだと、別途ActivePerlのインストールも必要です。 しかし、自身のPCにWebサーバーをインストールしなくても、 最終的には、レンタルサーバーや、プロバイダのWebサーバーを 使って公開するでしょうから、そこで開発するということも可能であります。 つまり、perlを自分のPCでコーディングして、そのファイルを本番サーバーにFTPでputして、 ブラウザで本番サーバーのURLにアクセスして実行してみて、 不具合があればperlを修正して またFTPしてから実行（これの繰り返し） という感じです。 （出来合いのperlを設置して、多少設定変更するだけという場合は 　ほとんどこれで間に合います） ただ、本格的に開発をするということなら、 修正のたびに、FTPで更新する手間や 無限ループ作ってしまって暴走させて、同じサーバーの利用者に迷惑かけたり、 エラーメッセージなしで、Server Internal Error(500)のみがでて、エラー解析に手間がかかる ということもあるので、自前の開発環境がローカルにあるほうが　開発効率はよいでしょう。
こんにちわ。 UserAgentにCookieを設定していないからではないでしょうか？ $cookie_jarがnewされたままになっているので、 $ua->cookie_jar($cookie_jar); ように設定してあげてみてはどうでしょうか？
Perl には substr_count はありませんが、サブルーチンで作ることは難しくはありません。以下は骨組みだけです。 sub substr_count { scalar @{[$_[0] =~ /$_[1]/g]}; } print substr_count('PHPperlPHP', 'PHP'), "\n"; # 2
なるほど、Search pattern にはデリミタ(区切り文字)も含めるようですね。 となると、下記の様になるのかも。 /post-(\d+)\.html/ /post-([0-9]+).html/ なお、チェックボックスは下記の様な意味だと思われます。 case-insensitive : 大文字小文字を区別するか否か multi-line : ^と$を改行の前後にマッチさせるようにするか否か dot-all : .(ピリオド)を改行にマッチさせるようにするか否か
> $com "正解！"; = （イコール）が抜けてる。 それから、「何故か挙動がおかしい」じゃ何も分からないので、 「どういう動作を期待しているのか」、「実際にはどんな動作になってしまうのか」をちゃんと書いてください。 ============================== #テストプログラム sub check{ 　my ($true, $rands, $big) = @_; 　my $com = "???"; 　 　# 本当よりランダムが大きい 　if ($true < $rands) 　{ 　　# 正解 　　if ($big == 0) 　　{ 　　　$com = "正解！"; 　　} 　　# 不正解 　　else 　　{ 　　　$com = "不正解…"; 　　} 　} 　# 本当よりランダムが小さい 　if ($true > $rands) 　{ 　　# 正解 　　if ($big == 1) 　　{ 　　　$com = "正解！"; 　　} 　　# 不正解 　　else 　　{ 　　　$com = "不正解…"; 　　} 　} 　print $true, $big?">":"<", $rands, " ===> ", $com, "\n"; } check(1,4,0);　　# 1<4 ===> 正解！ check(1,4,1);　　# 1>4 ===> 不正解… check(10,1,0);　 # 10<1 ===> 不正解… check(10,1,1);　 # 10>1 ===> 正解！ check(2,2,0);　　# 2<2 ===> ??? check(2,2,1);　　# 2>2 ===> ???
　データの「書き換え」については、ファイルが言語・OS（ファイルシステム）を通じて実際にどのように扱われているのかをよく知っておくことが必要です。 　Windows/UNIX系を問わず、一般的なファイルシステムのファイル操作では 「データのある部分を違う長さのデータで置き換える（部分挿入・部分削除）」 という処理は、ファイルの末尾でない限り一度の操作では出来ません。 原稿用紙に鉛筆で文章を隙間なく書くことを想像してみてください。 あとから途中に一文字付け足したり、一文字削除したくなったら、文章の終わりまで一度読んで記憶してから、その場所から最後までを上書きする必要があります。先頭や途中のマスを増やしたり減らしたりすることはできません。それと同じです。 Perlの場合、 ・tell()関数で現在の読み書き位置を調べる ・seek()関数で読み書き位置を指定する（ファイル先頭からのバイト数、またはファイル末尾） ・読み込み用関数（read()や行入力演算子<FH>） ・書き込み用関数（print()など） ・ファイル末尾の切捨て（truncate()） ・ファイル末尾の位置（＝ファイルサイズ）を調べる（-s演算子） などを組み合わせてやれば、一応書き換えは実現できます。 ただしこの方法はデータが（ディスクの一時領域を節約できるというささやかなメリットはあるものの）処理は大変複雑になります。 唯一の例外は、書き換える元データと新データのサイズが一致している場合、いわゆる固定長データフォーマットであることが保証されている場合で、かつデータの部分削除機能が不要な場合は部分上書きのみで安全な書き換えができます。 で、解決策ですが、ディスク容量に十分な余裕（元データ容量の2倍＋α）があるのであれば ・ファイルBから新規データを読む ・ファイルAから既存データを1行ずつ読む（読み込み専用として） ・書き込みは全て新規ファイルCに行う ・処理が最後まで終わったらファイルBを削除してファイルCをファイルBにリネームする（File::Copyモジュールを使えば、動作環境に依存しますがmove()だけで済ませられる場合も多くあります） としたほうが処理はシンプルになりますし、処理が何らかの理由で中断してしまった場合にファイルBの元データが破損する恐れもありません。 例としては以下のようになります。 # 「ファイルAの内容をファイルBに条件付きで反映させたい」のならば、 # 読み込みループを回すべきなのはファイルBだと思うのですが・・・ # 提示されたスクリプトが合っているという前提でとりあえず書きます。 open(my $NEWLOG, "<", "/△△/ファイルB") or die; flock($NEWLOG, 2);# とりあえずここではファイルBを排他処理用ロックファイルとして使う my $new = <$NEWLOG>;# ファイルB、先頭の1行しか読んでませんが本当にいいんでしょうか・・？ open(my $LOGFILE, "<", "/○○/ファイルA") or die; open(my $TEMPLOG, ">", "/△△/ファイルC") or die; while(my $yomitori = <$LOGFILE>){ if(ある条件1){ print $TEMPLOG "$kakikomi\n"; } if(ある条件2){ my $kakikae = ''; # ←ここに書き換え用データ$kakikaeの生成処理が入ります $new =~s/\n/ $kakikae\n/; print $TEMPLOG "$new"; } } close($TEMPLOG); close($LOGFILE); unlink("/△△/ファイルB") or die; rename("/△△/ファイルC", "/△△/ファイルB") or die; close($NEWLOG);# ファイルBを閉じると同時に排他処理が解除される サンプルが20年前のPerl4の文法でしたので、Perl5の文法で書き直してあります。 # もし参考にした参考書やスクリプトがmyなどを一切使わないPerl4の文法で書かれていたら、まずそれらを捨てるところからはじめてください・・・。 最後に、同時に複数プロセスが同じデータファイルに対してアクセスする可能性がある場合（代表例はCGIスクリプト）、flock()などによる排他処理の実装をお忘れなく。でないとデータファイルが壊れます。 上記サンプルのように、読み込みと書き込みを同じ流れで行う場合、全体をひとつの排他処理でくるんでやる必要があります。 排他処理は書き込みを行うルーチンだけでなく、読み込み専用のルーチンにも入れておかないといけません（例えばこのルーチンがファイルBをunlink()した瞬間に他のプロセスがファイルBを読みに行った場合、エラーになったり既存データがなくなったように見えます）。 単体実行しかしないスクリプトであっても、うっかり複数のコンソールから同時実行してしまうミスに備えて、データファイルへのアクセス（またはプロセスそのもの）には常に排他制御を実装しておくことを強くお勧めします。
echo "http://okwave.jp/question/new/index.html?abcdefg" |perl -ne 's/^.*:\/\/.[^\/]+//;s/\?.*$//;print'
コマンドラインの最初の引数にスクリプトファイルを指定して、残りに処理対象のファイルを指定すれば、前回の回答と同じ処理となります。置き換えは、スクリプトファイルに追加していきます。 perl -pi replace.pl a1.xml a2.xml b1.xml replace.pl s/tokyoto/kanagawaken/g; s/saitamaken/tibaken/g;
$iに関するところを全部出してみて、 ここでの処理は間違っていないから。
既にご存知かもしれませんが、EclipseにPerl用のプラグインを使うのはいかがでしょうか？ エディタではなく統合開発環境となってしまうので、小規模なアプリケーション開発にはちょっと重い感じもしますが・・・。 また、PHP用のプラグインもありますので、 言語問わず同一の開発環境を使えるのはメリットかもしれません。 エディタ限定ということでしたら、TeraPadはいかがでしょうか。 Perl専用ではありませんが、軽量で使いがっても良く、 一応、Perl(.pl)の場合には色分けもしてくれます。
OKかどうかはhogehogeの内容次第ですが、if文の構文としては間違っていないです。
　 念為ですが、@INCはどうなってます 　 手作業で古いバージョンを置いたって事ありませんか 　 パスの確認は perldoc -l Time::Local 　
ファイルを書き換えたいのであれば、 読み書き両用モードでオープンしてください。 そうしないと排他制御もうまくできません。 （読み込みモードopen→close→書き出しモードopen→closeでもできますが、排他制御が不完全になります。） 以下サンプル。 ============================================== use utf8; #ソースコードはUTF-8で記述 use strict; #厳しい文法チェック # ファイルオープン、文字コードUTF-8 # ファイルの文字コードがUTF-8以外の時は open(my $fp, "+<:encoding(cp932)", "data.txt" ) の様に指定 my $st = open(my $fp, "+<:utf8", "data.txt" ) or die "File open error"; flock($fp, 2); # 読み込み my @data = <$fp> ; # 編集 @data = grep { my @temp = split("<>"); $temp[0] ne "5" } @data; # 書き出し seek($fp, 0, 0); #書き込む場所をファイルの先頭に truncate($fp, 0); #ファイルサイズを0byteに print $fp @data; close($fp); ============================================== 2引数openや、ベアワードをファイルハンドルに使う書き方は ものすごく古い書き方なので、 上記サンプルでは使っていません。 なお、提示のソースですが、 @DELや$tmpnumが説明無しに出現しているのが気になります。 特に$tmpnumほうは記述ミスでは？
何でKをローカル変数にしないの？ Kをローカル変数にして、op_1の中でKが必要なら、引数として渡さないと。
my $a = "http://AAA/BBB/???/CCC"; my @b = split("/",$a); my $ZZZ = $b[4];
並べ替える単位は１行ごとの文字コードの大小順であって お望みの順序とは違うかもですが、 例えば DOS プロンプトにある SORT でソートできます。 コマンドプロンプト または DOS画面で TYPE INFILE.TXT | SORT > OUTFILE.TXT または SORT <INFILE.TXT >OUTFILE.TXT 後者の方が実行時間は早いみたいです。
#!/usr/bin/perl open(F, "abc.csv"); while(<F>){ chomp; @x = split(/,/, $_); $fruit{$x[0]} = $x[1]; } close(F); print "=> "; while(<STDIN>){ chomp; print "$fruit{$_}\n"; print "=> "; } darkstar:~/tmp> ./foo => or orange => ap apple => me melon => ap apple =>
#13です。 >あと、変換前にカンマの使用があります。 変換前の文字列にカンマがあるということなので、 変換するファイルをタブ形式で定義したバージョンのスクリプトを 参考URLに書きました。（バージョン３ （CL.3）になります。）（カンマをタブに替えただけす。） ファイルの１行は 変換前文字列<tab>変換後文字列1<tab>変換後文字列2<tab>・・・変換後文字列N の形式で定義してください。 <tab>はタブ文字"\t"を意味します。 変換前文字列、変換後文字列の何れも　カンマ(",")を変換文字として使用可能です。 例 ,1<tab>A<tab>B は ",1"をAに変換し、かつ ",1"をBに変換します。 >ちなみに前文はケース２の場合を想定してました。 定義の方法はケース１で行っていますが、 どうしても定義２でなければいけない理由があるのでしょうか？ もし、そうであれば、その旨補足ください。 スクリプトをケース２の形式に対応させるのは、簡単にできます。
メール送信はスパムとかDoSとかのはなしがあって制限が多くなっているので案外苦労したりします。 ＞ループで回して送信した方が、制限がない分いいですよね。 そうでも無くて、SMTPセッション数を制限している場合もあります。 1通のメールで宛先が300の場合、SMTPセッション数は1ですが、 宛先1つのメールを300通送るとSMTPセッション数は300です。 これが影響する場合もあります。（もちろんサーバのポリシー次第です） 現実的には制限を越えないぐらいの数で回すということになると思います。 例えば1通で宛先を50件として必要な回数回すような感じです。 また、ループもそのまま回すのではなく適切なWaitを入れる方が良いです。 余談ですが、 携帯メールに送信する場合は、宛先不明アドレスにも制限があるのでこちらもフォローする必要があります。
#2の繰り返しになります。 > %$itemsのキーを取得するのはではないのですね。 は正しいのですが、その取得したキーを「使っていない」のです。 http://perldoc.jp/docs/perl/5.20.1/perlsyn.pod#Foreach32Loops マニュアル(の和訳)です。 > foreach ループは 通常のリスト値に対しての繰り返しを行い、変数 VAR に リストの要素を繰り返し一回に一つずつセットします。 > VAR が省略された場合には、$_ に値が設定されます。 とあります。 foreach ( keys %$items) は、この 「VAR が省略された場合」に相当します。 ということは、リスト値 keys %$items から取り出した値は $_ の設定されています。 その $_ に設定した値を使わずに、「 $key 」を出力しようとすれば、全然違うものが出力されるのは当り前です。 また、この前にある my $key ; という文と、このforeach は「無関係」 です。 修正するなら、実行ブロック内では $_ を使うか、foreachに使う変数として$keyを指定するか、です。 my $key; で宣言しただけでは、 $key の中身は「初期化していない値(uninitialized value)」です。 Perlの標準動作では、uninitialized valueを使って"キー値 : $key\n" 等としても、エラーになりません。 ですが、 perlに-wオプションを付けると、警告を出すようになります。 その警告が、Use of uninitialized value $key ～ です。
ZIPファイル解凍して 「OPC.pm」というファイルを ActivePerlをインストールしたディレクトリ内の 「c:\?????\lib\Win32\OLE\」に放り込む 出来れば追加モジュールなので 「c:\?????\site\lib」の中に「Win32\OLE\」というサブディレクトリを作って放り込んでやるのが普通 でも、DOSプロンプトからPPMコマンドでGUIから一覧を出して「Win32-OLE-OPC」モジュール追加してやるのが一番確実かも(バージョンは古い可能性があるけどそれ用に配布されてるものだから)
単に、ファイル名が.cgiになっているだけ、中身は正しいのでは？ あるいは、wgetに指定したURLが違っているか
「圧縮ファイル」じゃないファイルと同じだと思う. どこに Perl が関係するのかさっぱり分からんけど.
< を &lt; > を &gt; に置換すればいいと思うわ より完璧にするなら " を &quot; に置換するとなおいいわ
unlink は　ファイル名にワイルドカードや正規表現を含めることはできません。 但し　ファイル名の配列を指定することは可能です。 以下のようにしてください。 --------------------------------- @result = glob("./hoge/$temp*.html"); unlink @result; ----------------------------------
他人の「perl」をカスタマイズして使うことぐらいしか私は出来ませんが、 10年ほど前にJavaが消えると言われ、5年ほど前にFlashが消えると言われ 3年ほど前にHTML4.01が使えなくなると言われましたが、意外と皆元気です。 プログラマー（理系）の人って自分と違うやり方だと批判ばかり言いう人も居ますので 慎重に情報集めしてみた方が良いと思います
むりやり one-liner: @ref[sort {$a<=>$b} map {{map {$ref[$_] => $_} 0 .. $#ref}->{$_}} @input]
No.1 です > aaaa.pl が必要という認識で良いでしょうか。 > 置き場所(ルートからのパス等)などを添える必要はないでしょうか。 方法はありますが、少々面倒になりがちなので、オススメしかねます /hoge/aaaa.pm package aaaa; our $data = "ほげ"; /sample/bbbb.php <?php # /hoge が perl の @INC に入っている $data = shell_exec("perl -m'aaaa' -e 'print \$aaaa::data'"); # そうでなければ直接指定 $data = shell_exec("perl -I'/hoge' -m'aaaa' -e 'print \$aaaa::data'");
http://maps.googleapis.com/maps/api/geocode/json?address=<URLエンコードした住所>にアクセスし、json形式でデータをもらう。 jsonデータの中に"geometry" : -> "location" があるので、緯度経度を取得できる。 例 東京都港区芝公園1丁目5番25号 http://maps.googleapis.com/maps/api/geocode/json?address=%E6%9D%B1%E4%BA%AC%E9%83%BD%E6%B8%AF%E5%8C%BA%E8%8A%9D%E5%85%AC%E5%9C%921%E4%B8%81%E7%9B%AE5%E7%95%AA25%E5%8F%B7
２文字限定でよければ、正規表現の置換を使って変換することができると思います。 my $foo = $ARGV[0]; $foo =~ s/\\./qq("$&")/eeg; print "$foo\n"; $ perl unescape.pl 'abc\tdef\\ghi' abc　 　def\ghi シングルクォート内での \\ の扱いは、Bash と Perl では異なります。Bash では \\ のままですが、Perl では \\ を \ に変換します。
少々泥臭いですすみません #!/usr/bin/perl # 使い方の例 # perl このスクリプト.pl TGAAGTGCA # TODO 要件に合わせて改造 $pattern = (@ARGV == 1)? $ARGV[0]: 'TGAAGTGCA'; open(F, 'foo.fasta') || die "no file error"; $cache = ''; $match = 0; foreach (<F>) { # シーケンスデータの始まり if (/^>/) { $match = 0; $cache = $_; next; } # シーケンス文字列に該当パターンが含まれるか検証 if (!$match && /$pattern/) { $match = 1; print $cache; # ここまでのシーケンスデータを出力 } # 入力行を出力またはキャッシュ if ($match) { print $_; } else { $cache .= $_; } } close(F);
すみません, ちょっと確認ですが print if ( /〔a/i ); を print Encode::encode('utf-8', $_) if ( /〔a/i ); にしたら (これでエラーになるなら use Encode; を最初の方に追加して上の Encode::encode をただの encode にする) どうなるでしょうか? 余談ですが, この位置に if をつけるときにはかっこはなくてもよかったりします.
あなたがつくられたスクリプトをできるだけ生かすようにして連想配列を つかったスクリプトを作成しました。 いかのようになります。 ------------------------------------------------------------- $csvfile1 = $ARGV[0]; $csvfile2 = $ARGV[1]; #$csvfile1全体を一気に読み込む open(DAT1, $csvfile1) || die $!; @lines1=<DAT1>; close (DAT1); #$csvfile2全体を一気に読み込む open(DAT2, $csvfile2) || die $!; @lines2=<DAT2>; close (DAT2); #$csvfile1から連想配列を作る foreach $line (@lines1){ chomp $line; @data = split(/,/,$line); $hash1{$data[0]} = $data[1]; } #$csvfile2から連想配列を作る foreach $line (@lines2){ chomp $line; @data = split(/,/,$line); $hash2{$data[0]} = $data[1]; } #以下$csvfile1のデータを元にして出力する処理 #$csvfile1の連想配列のキーだけを取り出す、そしてソートする @key1 = sort(keys(%hash1)); #取り出したキーを１つずつ処理する foreach $key (@key1){ #第1列目のデータが$csvfile1,$csvfile2の両方に存在するものだけ出力する if (exists($hash2{$key})){ print $key,",",$hash1{$key},",",$hash2{$key},"\n"; } } ------------------------------------------------------------- 尚、第1列目のデータが両方のファイルにあるものだけを出力しています。 例えば、aaa.txtの1行目 06011800, 5.3 の06011800がbbb.txtに無い場合は、そのデータは出力しません。 (逆のケースも同様です)
use PDL::Ufunc; を追加し、次でループ脱出 if(all $ans_now == $ans_before){last;} ただし、$ans_nowは今回の演算結果, $ans_beforeは前回の演算結果 PDLのhelp allより: ======================= Module PDL::Ufunc all Return true if all elements in piddle set 　　...(snip) =======================
No2さんのが近いと思いますが、() はその内部に任意の正規表現を書けるからでしょう。 /a)b/ が /a\)b/のように解釈されOKだとして、それを() で囲もうとした途端に破綻します。 /(a)b)/ はどう解釈すれば良いでしょうか？あるいは、このときは /(a\)b)/ と書かないとエラーにしますか？
> 「$hoge$_」のような書き方は出来ないのでしょうか。 似たようなことをやる方法はありますが、その書き方は推奨されていないと思います。 実行中のプログラムの変数を文字列だと思い、実行中のプログラム中の変数と連結してその値を得るには一つメタな立場にあがらないといけません。例えるなら、プログラムを実行している視点から、プログラムを書いている視点にあがるとも言えるかもしれません。多くのスクリプト言語にはそれをするためにevalという命令が用意してあります。 ただ、evalはそこに書かれている文字をプログラムだと思って愚直に実行するので、そこに書かれる文字を完全に制御できないと非常に危険です。よって、まともな人ならevalを実用するプログラムには使いません。なお、perlのevalには環境を分けるなど別の使い方もあります。詳しくはこれを御覧ください。 http://www.effectiveperlprogramming.com/2011/03/know-the-different-evals/ 一応、evalを使った書き方です。 $hogehoge+=eval('$hoge' . $_);
であれば, 一番簡単なのは perl -n "script.pl" "in.txt" > "out.txt" じゃないかな?
べたでやるなら、こんな感じでしょうか。 while(<>){ chop; @x = split(/,/,$_); $len = length($x[1]) - $x[2]; $x[1] = substr($x[1], 0, $len); } あとはこんなやりかたも。 while(<>){ chop; @x = split(/,/,$_); for(1..$x[2]){ chop($x[1]); } }
Mobile::UserAgentは古すぎか。。。 HTTP::MobileAgentのdisplayメソッドを使えば、多少ましでしょうが、 HTTP::MobileAgentは2012年が最新なのでどちらにしろ完璧な解像度を得るのは 不可能でしょう。
> # MIMEエンコード > $mail_to = mimeencode($MAILTO); > $mail_from = mimeencode($FORM{'name'}); > $mail_subject = mimeencode($FORM{'subject'}); > > # 文字コードの変換 > $body = jcode::jis($user_owner); 先頭が小文字の jcode は、UTF-8 をサポートしていないので変換できません。また、mimeencode も mimew.pl のものだとしたら、やはり UTF-8 はサポート外だと思います。
>少なくとも、$subject は定数なので、ユーザからの入力は反映されません。 $subject は例としてあげただけで $to や、その他に参照される変数なども同じですが大丈夫でしょうか。 実際にできるかどうかは別として他の思い当たるのは、例えばそのメール送信処理のcgiに $ telnet そのサーバのホスト名 80 GET パス?SUBJECT=... ように直接urlでアクセスできてしまうとか、 それを処理しているサーバのsendmailが外部から直接アクセス可能で自由に利用できる状態になってるとか。 今のところ思いつくのはこれくらいです。
正規表現の置換部はダブルクォート文字列と同様に評価されるので、次の２つの文は同じように機能します。質問のケースでは、変数を２重に置き換えなければならないので、明示的にダブルクォートが必要になります。 $string[$i+1] =~ s/$search/$1回/g; $string[$i+1] =~ s/$search/"$1回"/eg;
プロセスIDを付けると何がおこっているのかわかりますよ。 以下、$$はプロセスIDを表わしています。表示がくずれるので空白2文字を全角空白にし ていることに注意。 use strict; use warnings; my $i = 0; while ( $i < 3 ) { 　　if ( fork() ) { 　　　　print "parent($$) hello -> $i\n"; 　　　　last; 　　} 　　else { 　　　　print "child($$) hello -> $i\n"; 　　　　sleep 3; 　　　　print "child($$) exit -> $i\n"; 　　　　$i++; 　　} } print "parent($$) finish\n"; --- $ perl -w foo.pl parent(24503) hello -> 0 parent(24503) finish child(24504) hello -> 0 child(24504) exit -> 0 parent(24504) hello -> 1 parent(24504) finish child(24510) hello -> 1 child(24510) exit -> 1 parent(24510) hello -> 2 parent(24510) finish child(24511) hello -> 2 child(24511) exit -> 2 parent(24511) finish
どちらも同じ意味です. 同じですが.... $c eq 10 って条件が何をしたいのかわからん. 「どうなるか」はもちろんわかるけど, 「どうしてそう書いたのか」がわからない.
おそらく、ブラウザ依存のことなので、サーバー側でやることは無いでしょう。 ローカル側で設定できるかどうか、調べてないのでわかりません。 ただ、「クリックしたら自動実行」みたいなことは、セキュリティの関係でどんどん厳しくなっていく傾向にあります。 TIFFでなければならないのでしょうか? ブラウザで標準で対応しているような形式(JPEG,PNG等)にすれば、いちいち聞いてこないはずです。 TIFFが必要なら、画面表示用PNGとダウンロード用TIFFを別に用意するとか。
単純に環境変数USER_AGENTを判別すればよかろうかと・・ ただ、ブラウザの機能、あるいはアドオンで一斉に取得する方法がありますので、その場合は無理です。 　たとえばfirefoxでしたら DownThemAll!( https://addons.mozilla.jp/firefox/details/201 ) ScrapBook( https://addons.mozilla.jp/firefox/details/427 ) 　などを使われた場合は無理です。 　いずれにしてもカウンターはおまけ機能で信頼性のあるものではありません。十数年以上前には流行していましたが・・。 ＞何かプロバイダの検索収集かなと思うのですが、こんなのはカウントしたくないのです。 　所詮、そうしたものですから期待しないほうが良いでしょう。
Perlは汎用のプログラミング言語で、CGIに特化したものではありません。 そのため、PHPのように「フォームで入力された情報が勝手に変数に入る」ということはありません。 明示的に情報を取り込む必要があります。 ・自前でデータ取り込みプログラムを作る ・CGIモジュール等の既存の物を使う よほど古いPerlとかで無い限り、CGIモジュールを使うのがよいでしょう。 「CGI.pm」で検索すれば、解説サイトが見つかります。
>原因がわかりません。 CGIになっていないからでしょう。 http://homepage2.nifty.com/sak/w_sak3/doc/sysbrd/pe_kj01.htm のサンプルと見比べてくださいな。 結果を受け取ったWebサーバは、ソレをどうしたらいいのかわからんので500エラーなんでしょう。 画像としてクライアントに返せばいいの？ ただのテキストとして返せばいいの？ それとも謎のバイナリデータなのぉぉぉ？？？？ わからないのぉぉぉぉぉ＞500エラー
そのハッシュから @a = (['A', 'a', 7], ['A', 'b', 3], ...) って配列を作ればいいんじゃね?
　Perlを使う分には、実質的な差はないと思います。CPANもそのまま使えます。 　私は、テスト用に専用のパーテーション(G:)を割り当てていまして、Cygwinはそのドライブのルートにインストールしています。それは、Perl経由でUNIXのシェルを扱う可能性があるからです。すなわち G: 　|-- Cygwin 　|-- usr/ 　|　　|-- local 　|　　|　　　|-- apach <--- apachはここ 　|　　|　　　|-- bin <-- perlはここにインストール 　|　　|　　　|-- cpan　ここに自動的に入る ・・・・ 　|-- user/ 　|　　|-- oruka 　|　　　　　|-- html/ 　|　　　　　|-- cgi-bin/ とか・・・ ＞ターミナルの選択も合わせておすすめを教えていただければと思います。 　意味がわかりませんが、普段はCygwinの標準--tcshからですが・・
なにか大きな誤解をされている。 ＞CGIのプログラムを作る前はHTMLだけで作っていました。 ＞<form action="mailto:メールアドレス"～ ＞CGIでメールフォームを作る 　というのは、言葉として成り立たない。 　あくまでメールフォームはHTMLで作成されます。 【引用】＿＿＿＿＿＿＿＿＿＿＿＿ここから ユーザは一般に、テキストを追加する、メニュー項目を選ぶ、等してこれらコントロールを変更してフォームを「完成」させ、その後フォーム処理のためにWebサーバやメールサーバ等のエージェントへとフォームを提出する。 ￣￣￣￣￣￣￣￣￣￣￣￣￣ここまで［Forms in HTML documents (ja)( http://www.asahi-net.or.jp/%7Esd5a-ucd/rec-html401j/interact/forms.html#h-17.1 )］より 　そして、サーバーにあるCGIプログラムで処理して送信されます。 ・受け取ったデータをメールの本文データに作り変える。 　　文字コードをiso-2022jpに変換する ・メールヘッダを作成する ・サーバーにあるMTA(Mail Transfer Agent)、例えばsendmailやqmailに送りつける。 　このCGIプログラムを作ってサーバーに設置し、動作するように設定しなければなりません。
http://www.bribes.org/perl/ppm のリストを見ると GD-SecurityImage-AC.ppd, Image-Magick.ppd が存在するのでインストール可能だと思えます。 実際に自分の環境でやってみましたが、どちらも ppm(GUI経由) でインストールできましたよ。 環境 Win7(64bit) Active-perl(32bit) This is perl 5, version 16, subversion 3 (v5.16.3) built for MSWin32-x86-multi-thread GD-SecurityImage-AC.ppd をみると <ARCHITECTURE NAME="MSWin32-x86-multi-thread-5.16> とあるので AcrivePerl の64bit バージョンだとはじかれている可能性もあり得ます。
UTF-8 の内部文字列にすれば、tr で文字単位で変換することができます。プログラムのソースが EUC-JP でとのことなので、少し厄介なところはあります。 use strict; use Encode; use NKF; my $str = "\xAD\xEA０１01アア"; $str = decode 'utf8', nkf('-Ew', $str); my $from = decode 'utf8', nkf('-Ew', '０-９Ａ-Ｚａ-ｚ　（）＿＠ー'); eval "\$str =~ tr/$from/0-9A-Za-z ()_\@-/;"; $str = nkf '-We', encode('utf8', $str); print "$str\n"; 私の Linux 上のパソコンでは、上記のコードで (株) は文字化けせずに全角の０と１を半角に変換します。
http://search.cpan.org/~kwilliams/Path-Class-0.33/lib/Path/Class/File.pm の中の ----------------------------------------- $file->stringify This method is called internally when a Path::Class::File object is used in a string context, so the following are equivalent: $string = $file->stringify; $string = "$file"; ----------------------------------------- じゃないかな? Perl はわからんけど。
perl -e 「スクリプト」 と実行するときに、コマンド全体は実行する環境に従います。変数の置換とか、特殊文字の処理は、この段階で行われます。 そうして完成した「スクリプト」の内容はPerlの文法に従います。 「スクリプト」を一つの引数として解釈させる方法は、環境依存です。 Windowsから実行する場合は、コマンドプロンプトの仕様に従うことになります。 空白等を含む文字列を ' で括ってその文字として扱う、というのは、Unix系シェルでの機能です。 Windowsでは、' にそのような意味はありません。 スクリプト中に"" (ダブルクォート2つ)は、Perlの文法に従うので、Perlで同じ意味を持つ別の表現に置き換えることができます。 ということなので ・' ではなく、全体を " でくくる。Windowsの仕様 ・" 中に " を書きたいときは、 \" 等とする。Windowsの仕様 ・あるいは、今回の場合なら、Perl上では "" と '' は同等なので、スクリプト中では '' を使う ということになります。 コマンドプロンプトの仕様を確認しようと検索したところ、次のようなサイトがありました。 http://d.hatena.ne.jp/thinca/20100210/1265813598 これを見ると、WindowsでPerlのワンライナーやろうとすると、大分面倒なことになりそうです。
ファイルの先頭を見て、#!だったらその行を実行コマンドとして実行、というのは、Unix系OSの機能です。 Windowsでは使えません。 http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%90%E3%83%B3_%28Unix%29 scr は、たしか、Windowsのスクリーンセーバー用に使われていたと思います。 どうしてもscrのままで、となると難しいと思います。 BATファイルに埋め込んで、shebang風に使う、という方法はあるのですが。 Windows shebangで検索するといくつか見付かります。
Webサーバはなんです？ >metaでEUC-JPをしていればブラウザ側で自動判断してくれると思っていたのですが、違うのでしょうか？ >HTMLでmeta以外に文字コードを指定するところがあるのでしょうか？ Webサーバの設定によっては化ける。という例がありますね。 「Apache 文字化け」辺りで検索すると情報が見つかるでしょう。 http://tech.bayashi.net/pdmemo/chara2.html ってことで……そのCGIはHTTPレスポンスヘッダのContent-typeは出力していますか？ さらに、Content-typeでcharsetを指定していますか？ # charset指定していないとWebサーバのデフォルト設定が使用されるでしょう。おそらく。
こういうことですか？ while(<>){ chomp; @temp = split(/,/ $_); if(/2013\/11\/19,09:00:00,13:00:0/){ print "$temp[13]\n"; print "$temp[14]\n"; } }
img要素内のURLでしたら、 m/<img src="([^"]*)/ で良いでしょう。 Perlは最長マッチですので、 <img src="" width="" height="" alt=""><img src="" width="" height="" alt=""> のような場合・・最初のsrc="から行末の"にマッチチしないようにする必要があります。
> my $tree = HTML::TreeBuilder->new; > $tree->parse($content); > $tree = decode("UTF-8",$tree); > $tree = encode("Shift_JIS",$tree); > ... > my @items = $tree->look_down('id', 'sideRanking')->find('li'); $tree に decode と encode の戻り値を代入している部分は誤りです。decode と encode は文字列を返すので、$tree はオブジェクトではなく通常の文字列を格納する変数になってしまいます。 なお、HTML::TreeBuilde を始めとした質問に書かれているモジュールをあまり使ったことがないので明快な解答を示すことができませんが、文字コードの変換を最後に移したらどうでしょうか。 print encode("Shift_JIS", decode("UTF-8", $_->as_text)), "\n" for @items;
printの直後、スペースのつもりで、全角空白を書いちゃってますね。
Perlはほとんど無関係、おそらく単なるHTMLの問題です。 恐らくは、<from>の前にある（端折られた）HTMLに、<a>タグがあって閉じられてない？
>>となりますと、Perlの場合は、IF文の条件式全体は変数にできないという認識でよろしいのでしょうか。 もし、変数の中身を条件式として使えるとなれば、「たんなる文字列」と「条件式を示す文字列」のどっちかを判別しないといけません。 それを示すものが無いですからね。
＞通常、Perlでcgiを作成すると、動的なURLになると思いますが、それを静的なURLへ変換しています。 　URLはQUERY_STRINGまでを言います。 プロトコル+ドメイン+PATH_INFO+QUERY_STRING 　PATH_INFないし、QUERY_STRINGでURLが構成されるなら重複は起きません。ただ、あまりにQUERY_STRINGが長い・・他の情報も加わっているならうまくインデックスされない場合もあるので、他の情報は標準入力STDINから渡せば良いですよ。もちろんPATH_INFOで渡すほうがスマートです。 　タイトルは関係ないです。検索エンジンは内容とURLでインデックス作りますから・・ 例) http://hpcgi1.nifty.com/Iruka/ENV_FORM.cgi/page2.html http://hpcgi1.nifty.com/Iruka/ENV_FORM.cgi/page3.html http://hpcgi1.nifty.com/Iruka/ENV_FORM.cgi/page4.html?subPage=1 とかね。
こちらのモジュールを使うのはどうでしょうか？ http://cpansearch.perl.org/src/TOKUHIROM/Geography-JapanesePrefectures-0.11/lib/Geography/JapanesePrefectures/Unicode.pm 最新のバージョンならromanという読み仮名もデータに入っていますね。
QUERY_STRINGの解釈は、すでにそのCGIで使われているので、それに加えれば良いです。 cmd=s&xxxx&xxx&Tfile=Data&TrColor=%xxx&Sort=xxx_xxxx ?以降がそうです。 　CGIに情報を渡す方法は、method="get" (デフォルト)のQUERY_STRONGと、method="post" による標準入力(STDIN)と、PATH_INFがあります。 　⇒入力フォーム編（GETとPOSTデータを受け取るには） - futomi's CGI Cafe( http://www.futomi.com/lecture/form/ ) 　この処理については、あなたのCGIによって様々ですから、具体的なコードは示しようがないですが、あなたのCGIを見ればいずれも書かれているはずです。REQUEST_METHODの値で分岐しているはずです。 　if($ENV{'REQUEST_METHOD'} eq "post"){・・・移行 　ただ、ページの切り分けでしたら、PATH_INFO(とSTDIN)を使うほうがSEOの上から最善の方法です。検索エンジンを含むユーザーには、 http：//xxx.jp/xxx/xxxxxxx/xxxxxx.cgi/page1 　としか見えませんから、keywordやdescriptionは最近の検索エンジンは一顧だにしてませんしね。 ・Enviroment Variable and FORM,COOKIE 　　 http://hpcgi1.nifty.com/Iruka/ENV_FORM.cgi/page1.html ) 　　 http://hpcgi1.nifty.com/Iruka/ENV_FORM.cgi?page=1 )
別解を、ワンライナーで、 for f in *.{jpg,png,gif,bmp,jpeg};do echo ${f%.*} ${f#*.};done
以下のようにしてください。 ------------------------------ #通常休診設定 $hdayfl = "./datas/hday7.txt";open (DT,"<$hdayfl");$hday1 = <DT>;close (DT); #$hdayを$hday1に変更する #重要休診日 $regular = "./datas/regular.txt";open (DT,"<$regular");$hday2 = <DT>;close (DT); #$hdayを$hday2に変更する $hday = $hday1 . ',' . $hday2; #・・・この行を追加 以降は変更無し ------------------------------ 質問ですが 11-28とは11月28日という意味でしょうか？ もし、そうだとすると、通常休診日と重要休診日とで日付が重複することはないのでしょうか。 （例えば、12-13がどちらのファイルにも入っている場合です。） その場合、12-13が重複するので、片方を、取り除く必要があると思いますが、 それは行わなくても良いのでしょうか。そもそも、日付の重複は発生しないのであれば、 このことは、問題になりません。 もし、日付の重複があって、それを取り除く場合は、更にスクリプトを変更する必要があります。
＞もちろん、以下の様な方法でファイルに書き込めるのは判っております。 　いや、全く分かってないから、書き出せないのですね。 #!/usr/bin/perl open(IN, "data.txt") or die ; open(OUT,">output.txt") or die; foreach (<IN>){ my $line=""; my (@data,@out)= (); chomp; @data = split(' ',$_); foreach(@data){ push(@out,$_/100); } $line = join (" ",@out); print OUT "$line\n"; } close (IN); close (OUT); __END__
成功しています。 インストールされたファイルは、port contents で確認できます http://guide.macports.org/chunked/using.html#using.port.contents
もし、Encode::from_to($_, 'shiftjis', 'utf-8');としても表示がおかしいとしたら、それ以外のところでプログラムが間違っているのでは？ 例えば二重引用符やエスケープが出てこない単純なCSV形式のファイルの3番めの要素をとってUTF-8に変換してHTMLとして表示するプログラムはこんな感じで書けますが、これで問題なく表示できると思いますよ。 use strict; use Encode; # ファイルからデータを読み込み my $input_file = "./datas/pdtscrt.txt"; open(my $fh, "<$input_file") or die; my @input_data = <$fh>; close($fh); # CSVの3番目の要素を抽出 my @selected_data = (); foreach (@input_data) { my @cols = split(/\,/, $_); push(@selected_data, $cols[2]); } # 3番目の要素を選び、ShiftJISをUTF-8に変換 my $out; foreach (@selected_data) { Encode::from_to($_, 'shiftjis', 'utf-8'); $out .= $_ . "<br />"; } # HTMLとして出力 print << "__EOM__"; Content-Type: text/html; charset=UTF-8 <!doctype html> <html><head><meta charset="UTF-8"> <body> $out </body> </html> __EOM__ ちなみに、質問にあるコードでちょっとおかしいと思うところはあります。 例えば、 foreach(@Pscrt){ use Encode; Encode::from_to( $_, 'utf8', 'shiftjis' ); $Pscrtfl .= $_; } の$Pcsrtfl .= $_;が何をやりたいのか自分にはわかりません。 これは次のところでファイル名を入れてましたよね？ $Pscrtfl = "./datas/pdtscrt.txt"; open (DT,"<$Pscrtfl"); @Pscrt = <DT>; close (DT); あとはCGIで表示するHTTP ヘッダーのContent-Typeなどで宣言しているcharsetが間違っているとかでしょうか。
http://matsup.blogspot.jp/2012/12/freebsd-perl-netsmtptls.html 上記のページに、今回の質問と同じトラブルが取り上げられています。とりあえず、バージョンを調べてみてはどうでしょうか。それで、原因が同じであれば、サポートに解決を依頼する必要があるかも？
えぇと, 実は「属性の順番に意味がある」方が (ある意味) 簡単だったりします. というのは, そのような場合には元のソース自体で ・styleClass → paramId → paramName → action という順に属性が表れる という仮定ができる可能性があるからです. もしそうなら難しくないですよね. これが, 「元のソースからして属性の順番がぐちゃぐちゃ」ということになると, わりとまじめに属性を処理する必要があります. まあできるんだけど, そういうことだと s でちまちま置換するよりも「元のソースから目的の文字列を『構築』する」という方針を考えた方が早いような気がする. 例えば $ref = "numa"; $paramId = "Id"; $paramName = "Name"; $class = "push"; $click = "URL"; $content = "ソース"; と変数に値があるときに <s:a href="numa" paramId="Id" paramName="Name" cssClass="push" onclick="URL">ソース</s:a> という文字列を作りたい (上の変数の値を href や paramId などの属性の値にする) としたら, どう作りますか?
> Perlの勉強に時間を割くより、掲示板の投稿内容が1ファイルずつになっているので、1つのファイルに集約し、Excel　or Accessに取り込む等して加工した方が全然早いのでは・・・と考えた次第です。 何か誤解を与えてしまったようで申し訳ございません Perlについて勉強したら？と言ってるわけじゃなくて、Perlが動くようにしたら？と言っております 掲示板ソフトを作ればいいなんて本末転倒なアドバイスはしてないつもりだったのですが・・・ たとえ話で申し訳ありませんが、Excelについて知らなくてもExcelのファイルを開ける方法くらいだったら手間じゃないと思います Officeや互換ソフトまたはExcel単体なりをインストールすればよいだけ むしろExcelのファイルを畑違いのソフトで開こうとするほうが大変ではないでしょうか？ 新しいサーバまでおったてたのなら、以前の状態に戻すのがベストなアドバイスかとおもったんですが、あまり重きは置いていなかったんですね もうわかってらっしゃると思いますので、余計なお世話かもしれませんが、データをOffice系ソフトで扱いたいということならデータファイルをExcel-CSV形式に編集しなおす以外ないと思います ただ、データ量に比例してたいへんな手間になると思います（少なければそれでもいいとおもいますが） 同じような回答になると思いますがOfficeとかのカテゴリで質問したほうがご希望の回答が得られるかもしれません
単純な解決方法 置換の順番を変える。 /html:text/ は"html:text"にも"html:textarea"にもマッチするので、先に/html:textarea/を処理する。 /html:text / と半角スペースを含めてマッチさせる。 　Perlを含めて最長マッチをしますからね。
perlに引数を渡すまえに、shellがエスケープ処理を展開してしまいます。 なので、コマンドラインでは、それを抑止するために、 '　'　で囲む必要があります。 perl grep.pl 2 '\d{4}\/\d{2}\d{2}' test.txt
簡単ながら s/(?<=html:textarea\b[^>]*)\bproperty\s*=/name=/g; s/(?<=html:textarea\b[^>]*)\bstyleClass\s*=/cssClass=/g; s/<html:textarea\b/<s:textarea/g;
「言葉足らず」というか, 何をどうすればいいのかさっぱり分からない. 上だけ見ても ・(1) と (2) の間にある「↓↓」は何を意味するのか ・「valueとnameがpropertyになる」とはどういう意味なのか (そして「value」や「name」, あるいは「property」がどこから出てきたのか全く説明がない) がさっぱりわからないし, 「上記の変換」と書いてあるわりには何をどう「変換」したのか読み取れない. また, 「上記の変換では」とあるからには「それ以外の変換」というものも想像できるが, それではどうなるのかが書かれていない. 下も同じようなもの. その特定したい value とか var はどこから決まるのか, そして「変換する」とは何をどう変えることなのかがどこにも書かれていない.
1. ハッシュを使う 2. 「別ファイルの数値」を覚えておいて 1行ずつチェック
いまひとつ、おっしゃっていることがわからないんですが ○ 番号順に並び変えるのは出来ている、ということでよろしいですか? ○ どんなデータ構造で記憶しているかがわかりませんが $data[0] = '1(ID)<>1(並び順番)<>…' ; $data[1] = '2<>2<>…' ; ... みたいなリスト構造だったら、並び変えたあと、「並び順番」のデータをそのまま使うのではなく。添字($data[0]の0,$data [1]の1)+1を使えばいいし foreach $d (@data) みたいに使っているなら $no=1; foreach $d (@data) { ... ; $no++ ; } のようにした$noを使えばいいです(#1にあるカウンタです) ○ 重複がある ⇔ ($i != $j) かつ ($data[$i]の『並び順番』 == $data[$i+1]の『並び順番』) となる ($i ,$j) (0<=$i,$j<データ数)の組合せが存在する ⇔『並び順番』でソートした状態で、 ($data[$i]の『並び順番』 == $data[$i+1]の『並び順番』) となる $i (0<=$i<データ数-1)が存在する です。 効率を考えなければ、総当たりするだけの簡単なプログラムです。
> エラーチェックははずそうと思います CGI:Carpは「エラーチェック」ではありません。 通常、CGIでエラーになった時などは「500 Internal Server Error」とかブラウザに表示されるだけで、何が起ったかわかりません。 それを、Perlのエラーメッセージをhttpサーバーのログやブラウザ画面に出力するようにして、エラー内容を確認できるようにするためのものです。 fatalsToBrowserは、エラー内容がブラウザに表示されるので、公開している状態での使用はセキュリティ上問題ですが、CGI::Carp自体は、ログや特定のファイル等に出力されるので、ちゃんと設定した上で残すのがいいかと思います。 > :formはHTMLのフォームを出力するだけですか？ http://perldoc.jp/docs/modules/CGI-3.49/CGI.pod#CREATING32STANDARD32HTML32ELEMENTS: http://perldoc.jp/docs/modules/CGI-3.49/CGI.pod#CREATING32FILL-OUT32FORMS: HTMLの文字列を作成します。出力はしません。 > perlはphpと違ってuse CGIを使わないと定義された関数を使えないんですか？ 外部で定義された関数を、何の手続きもなく使える言語、というのは、ちょっと思い付きません。 PHPでも、requireとかを使って別のファイルに書かれたプログラムを呼び出したりしますよね? CGiモジュールは、Perlという言語の一部ではなく、後から機能を追加するモジュールです。 現在では、Perlをインストールすると、多くのモジュールも一緒にインストールされますが、本来は、別途インストールしなければ使えないものです。
間が空いてしまってすいません ご質問に開いて閉じると書いてあったので画面上の話かと思いました ファイルのopen/closeの話だったんですね 失礼いたしました Ｗｅｂで利用するCSV変換ということで 　Ｅｘｃｅｌ2003までなら「Spreadsheet::ParseExcel」 　Ｅｘｃｅｌ2007なら「Spreadsheet::XLSX」 をcpanからダウンロードして利用するとよいと思います とくに前者はサンプルが充実していて大変参考になります 後者も使い方がシンプルでＣＰＡＮのサイトの紹介コードで充分理解できます どちらもPurePerlなので、サーバのＰｅｒｌモジュールとしてビルド・インストールしなくても「use lib」で簡単に扱えるのが特徴です 数年前に実際に使ったことがありますが、シートが複数でも問題無かったうえにレンタルサーバ上でも動作しました
３回呼び出しの負荷がかかります。 PerlでもPHPでも同じ。
以下のようにしてください。 -------------------------------- usestrict; usewarnings; #ソートルーチン sub mysort{ $a cmp $b; } opendir(DIR,"."); my@dirfiles = readdir(DIR); closedir(DIR); my@files = grep(/\.data$/,@dirfiles); foreach my $file (@files){ open(FH,$file); my@lines = <FH>; close(FH); my@newlines = sort mysort @lines; my$newfile = $file; $newfile =~ s/\.data$/.txt/; open(OFH,">$newfile"); print OFH @newlines; close(OFH); } ----------------------------------------- 上記のスクリプト（goo.plとします）を aaa.dataと同じディレクトリにおいてください。 そのディレクトリ下で perl goo.pl と入力してください。 ソートされた aaa.txt ・・・ zzz.txtが作成されます。 ソートは１行をまるごとソートしています。（文字として比較） もし、ソートの方法で、別な方法を希望の場合は、その旨補足してください。 windows7 perl 5.14 で動作確認済みです。
ひとさまのサーバ設定状況がどうなってるかは実際にさわっていないので想像するしかないんですが まずは、コマンドライン（mysqlクライアント）でつながってテーブルまで見えるかどうかでしょうか？ Webでどうこうより、機能を切り分けて、DB側からアプローチして見ることです このソースをざっと見る限りじゃ問題はなさそうに見えるので、権限だったり、ポートだったり、DB側の設定ミスだったりとかの環境問題でしょうか
一応 http://perldoc.jp/docs/perl/5.8.8/perlref.pod という方法はありますが ハッシュを使って $abc{'2013'} = <<"EOF"; あいうえお EOF <strong>$abc{$seireki}</strong> みたいにやるとか、他の方法を考えた方がいいと思います > $123 = "$seireki";　　　　　# 代入 エラーになりませんか?
そこの文字列は「Perl の文字列」として解釈されるんだから, カラム名として使いたい文字列をハッシュのキーに使っても無意味じゃん. ちゃんと「name_en が 'USA' で name_jp が 'アメリカ合衆国' というタプル」を作らないと.
> (1)元のサーバでは問題なく動作していたのですが、..... 私自身使ったことがないのでよくわからないのですが、mod_perl 等の常駐型の Perl を使うとグローバル変数などに不都合が出るというのは聞いたことがあります。サーバを変更して正しく動作しなくなったのなら、その可能性もあると思います。 > (2)呼び出し先でwhile文を一つ入れることで、配列の ..... ハッシュは iterator (反復子) と呼ばれる内部的な変数で、どこまで読んだか記憶しています。while ループで空リストを返すまで実行すれば iterator はリセットされますが、そうでない場合は次の位置から再開されることになります。次のコードを参照してみてください。 %hash = (one => 1, two => 2, three => 3); @key_list = keys %hash; print "１回目:\n"; while (($key, $value) = each %hash) { print "$key => $value\n"; last if $key eq $key_list[-1]; } print "２回目:\n"; while (($key, $value) = each %hash) { print "$key => $value\n"; } print "３回目:\n"; while (($key, $value) = each %hash) { print "$key => $value\n"; } 上のコードは１回目は出力されますが、iterator はリセットされていません。２回目は何も出力しませんが、質問の余計な while と同様に iterator をリセットします。そのため、３回目は出力されることになります。keys や values はその都度 iterator をリセットするので、次のようにするのも一方法かと思います。 foreach $key (keys %DATA1) { $value = $DATA1{$key}; ...
いろいろ試してみたので結果を書いておきます。 ■前提 Perl 5.18.0　にて Plackを使ってcgiを動かしてみました。 ■結果 indexの画面は問題なく表示されますね。 で、新規登録画面も問題なく表示されるのですが 登録するロジックの部分がどうも怪しい感じですね。 具体的には、クエリのmodeの値がaddの時add関数に飛ぼうとしているのですが クエリのmodeにaddが見当たらない・・・ そのため、一生懸命登録しようとしても登録用のdata.datファイルにいつまでも情報がたまらずという感じがします。 これ以上は、作成者さんの意図が汲み取れずここいらで断念してしまいました。 (自分もがっつり眺めているわけでないので、見落としがあるかもですが、少なくとも登録する分岐には移動してくれなかったのは確認してます…) ■おまけ ロリポップのperlのバージョンが5.8.8(2006/1/31リリース)であることを考えると 2005年のソースだから古くてうんぬんという意見はどーかと思います。 そもそも全く表示されないとかでしたら、設定とか属性とか間違っている 可能性もあるのであきらめず、見直してみてはどうでしょうか？？ ※もうちょっと詳しい情報があったほうがよいっすね。 ※表示されるけど○○が動かないとか。そもそも全く動かないとか。 ※自分は、perlに詳しい人じゃないので参考情報程度でお願いします。
＞$str = encode('sjis', $str); 何がしたいの？ encodeは「perlの内部文字列を、指定された漢字コードの文字列にするだけ」ですよ。 URIエンコード、URIデコードは、別の関数を使います。 http://slashdot.jp/journal/450313/%E3%83%A1%E3%83%A2%EF%BC%9APerl%E3%81%A7URL%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89%E3%83%BB%E3%83%87%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AFURIEscape%E3%82%92%E4%BD%BF%E3%81%86 なお、pack、unpackは「時代遅れ」なので使わない方が良いです。
使っている Perl のバージョンと実際にそのような挙動が確かめられる例を見せてください.
> ファイルを読み書きする場合に使用するflockですが、closeする前に別ファイルのflockは使用できるのでしょうか？ はい。できます。 ただ、デッドロックをしないように気をつけてください。 flockによるロックはファイルごとに設定されるので、一つのプログラムから複数のファイルを開き、それぞれにflockを発行することができます。 ちなみに、後述するドキュメントによると、OSがflockをサポートしている環境では、perlのflockはOSのファイルをロックする仕組みを呼び出し、そのファイルを独占します。一応、知っているとは思いますが、共有ロックでのflock中に別のプログラムが排他ロックをかけると、共有ロックがはずされるまでそのプログラムは待たされます。排他ロック中に他のプログラムが排他ロックをかけると、そのプログラムは排他ロックがはずされるまで待たされます。なお、ファイルのロックはファイルをcloseした時か、プログラムの実行が修了した時に自動的にアンロックされるので明示的にアンロックをする必要はありません。 参考URLとなると、これでしょうか。 Perlのflock関数についての説明です。 http://perldoc.perl.org/functions/flock.html (和訳) http://perldoc.jp/func/flock このflock(2)というのは例えばこれですね。 http://www.freebsd.org/cgi/man.cgi?query=flock&sektion=2 OSにファイルをロックする仕組みが予め備わっています。 デッドロックについては、これでも読んでください。 http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%83%E3%83%89%E3%83%AD%E3%83%83%E3%82%AF 典型的な起こし方はこんな感じでしょう。 あなたが2つのプログラムを使っていて、プログラムAではfile1、file2の順でロックをとり、プログラムBではfile2、file1の順でロックを取ると、運が悪い時にデッドロックが置きます。 この状況では、プログラムAがfile1をロックした時にプログラムBが動き出し、file2をロックすることがありえますが、そうなるとプログラムAはfile2がアンロックされるのを待ち、プログラムBはfile1がアンロックされるのを待つので、どちらもアンロック待ちで止まってしまいます。 典型的な防ぎ方はロックの順序をすべてのプログラムで一定にすることです。 つまり、必ずfile1、file2の順で取るようにするなどします。そうすると、あとから来たのはfile1のロックを取れずに待っている間に先のプログラムは処理を完了させることができます。 まあ、一つのプログラムから複数のファイルを開いてロックを取れます。ただ、複数のロックを取る場合、デッドロックに気をつけてください。
質問の意図を取り違えていたかもしれません。 ダウンロードを開始する前にファイルサイズを知りたいのではなくて、 ダウンロードが完了する前にファイルサイズが知りたいということですね。 以下の例が参考になると思います。 404 Blog Not Found:perl - LWP::UserAgentで進捗表示しつつダウンロード http://blog.livedoor.jp/dankogai/archives/51141631.html 上の例では省略されていますが、:read_size_hintでコールバックを呼ぶサイズを指定できます。
$message2 = $message; $message2 =~ s/<br>.*//g; とか？
ご提案の方式のアルゴリズムはいわゆる転置インデックスだと思います。 http://ja.wikipedia.org/wiki/%E8%BB%A2%E7%BD%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9 "全文検索エンジン"などの言葉で検索するといろんな人が色んな物を作っているので、自分だったらそれを再利用できないかをまず考えます。 一応、自作するとしたら参考になりそうなURLを貼っていきます。 http://gihyo.jp/dev/serial/01/search-engine http://gihyo.jp/dev/serial/01/make-findspot ご提案の方式は上記の説明に比べるとちょっとナイーブかもしれません。
Perlのevalは、「その文字列が、最初からプログラムに書いてあったかのように解釈されて、実行される」というものです。 http://perldoc.perl.org/functions/eval.html http://perldoc.jp/func/eval $s='$a=10+5' ; eval $s ; # => $sが展開され $a=10+5 ; と書いてあるかのように解釈されて実行される なので、「そこで実行したいプログラムになるような文字列」を用意します。 my $f = '0123' ; my $t = '4567' ; my $x='abc0123' ; # ここで $x =~ tr/0123/4567/ を実行したい eval "\$x =~ tr/$f/$t/" ; # say "\$x =~ tr/$f/$t/" ; #↑が期待通りの文字列か確認 っていうか、ちゃんと例が載ってますよね http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators http://perldoc.jp/docs/perl/5.16.1/perlop.pod#Regexp32Quote-Like32Operators
CGI.pm の v2.15 以降であれば、-override に真を設定すれば常に -default の値が表示されるようになると思います。 textfield(-name=>'name', -default=>"" -override => 1),
system 関数では出力を受け取ることができないので、コマンドラインで書くときと同じようにするとファイルに保存できます。 open FILE, 'fileA' or die $!; while (<FILE>) { my $line = $_; chomp $line; system("ls -l $line >> fileB") == 0 or die "system failed:"; } close FILE;
回答１の方でほとんど答えは出ているようですが。 for ($j = 0; $j < 7; $j++){ $each = $man[$j]; } こうゆうことではないでしょうか。
いくらでも方法はあります。 例えば。 「行の先頭にある[XXXX] の中を取り出し、 XXXX , の置換する」 と考えれば s/^\[([^]]*)\]/$1,/ ※ \[ と \] の間にある 0個以上の[^]] (]では無い文字。[^の直後の場合、]をエスケープしなくても大丈夫) を () でグループ化 ※ 置換内容は、$1で先にグループした部分を引用 となります。 なお、置換に失敗したときは偽になるので、置換に成功した行だけ出力すればよいので、 print OUT if( s/^\[([^]]*)\]/$1,/ ) ; で十分です。 Perlの正規表現は強力で、いろんなことができます。 正規表現そのものもそうですが 「どうやったら目的のものを得られるか」、いくつかのパターンを覚えておくとよいでしょう。 http://perldoc.jp/docs/perl/5.16.1/perlretut.pod http://perldoc.jp/docs/perl/5.14.1/perlre.pod
残念ながら print $out $_; でがまんしてください.
http://perldoc.jp/docs/perl/5.12.1/perlunicode.pod#User-Defined32Character32Properties 上記を読みながら、書いてみた例。
+>>をご使用なので、ファイルハンドラが最後に移動してないでしょうか。 ハンドラが最後に移動しているので、whileは実行されておらず、常にファイル末尾に1行目が出力されるというシナリオを想像します。 Perlfaqを使用して… $lines = 0; $filename = "yahho.txt"; open(FILE, "+<$filename") or die "Can't open `$filename': $!"; #open に+<を使用 while (sysread FILE, $buffer, 4096) { $lines += ($buffer =~ tr/\n//); print "p"; } print FILE ++$lines . "やっほ～\n"; 注意　open時にファイルの存在は保証してください。存在しない場合エラーです。
\Q～\E
#2補足について。 この内容だと、Fortranでは単精度で処理されています。 参照: http://www.nag-j.co.jp/fortran/FI_17.html#AUTOTOC_17_3 実装にもよりますが、Cで言えば、float相当です。 http://ja.wikipedia.org/wiki/%E5%8D%98%E7%B2%BE%E5%BA%A6 にあるように、有効桁は、10進で7桁程度です。 Perlの内部ではCで言えば、double相当の精度で計算しています。 http://ja.wikipedia.org/wiki/%E5%80%8D%E7%B2%BE%E5%BA%A6 にあるように、有効桁は、10進で15桁程度です。 違いが出ているのは、7桁目です。 これは、単精度にとっては精度ぎりぎりの桁なので、誤差が出る箇所です。 対し、倍精度にとっては、まだ余裕のある桁です。 この差が、集計結果の違いに出ているのだと思われます。
なんたって、Larry Wall氏自身が著した「ラクダ本」 　⇒O'Reilly Japan - プログラミングPerl 第3版 VOLUME 1( http://www.oreilly.co.jp/books/4873110963/ ) 　⇒O'Reilly Japan - プログラミングPerl 第3版 VOLUME 2( http://www.oreilly.co.jp/books/4873110971/ ) 　第３版より２分冊になりました。 　すでにC言語の経験があれば、Larry Wall氏の文才と近藤 嘉雪氏の名訳が楽しめるでしょう。 　使い始めると、クイックリファレンスも良いですが、まずなによりも「ラクダ本」
仮数部の整数部と仮数部の少数部と指数部とを分けて、あとで組み合わせるとどうでしょう？ $ echo '5.726440e+05' | sed 's/+\|\./ /g' | awk '{print "0." $1 $2 "+" $3+1}'
１）についてはNo1の方の回答の通り、全てが順番に同じ経路で配送される保証はありませんので、短時間に続けて送信したら、途中の経路やプログラムを実行したマシンのMTAのスプール状況次第で順番はバラバラになります。 ２）はタイムゾーンの設定の問題じゃないでしょうか。 届いたメールのヘッダー情報を見てDateフィールドのタイムゾーンがどうなっているか確認しましょう。
> # 排他処理開始 > open(LOCK,"$lockfile"); > flock(LOCK,2); このやりかただと、たぶん質問者さんの意図通りにはなりません。 プログラムの動作に10分以上かかって次のプログラムが起動した場合、 後から起動したプログラムは ・flock の呼び出しで、先に起動したプログラムが終了する(ロックが解除される)まで待つ ・その後で、処理を実行する ということになります。 重複実行はしませんが、起動した回数だけ必ず処理を実行しますので、 処理に毎回10分以上かかるような状況になった場合、どんどん未処理(終了待ち)のプロセスが増えていくことになります。 flock の処理は、 flock(LOCK,6) or die("実行中です"); とした方がいいでしょう。 flock は、第2引数が2(LOCK_EX)の場合は、あとから実行した方はロックが解除されるまで動作が停止しますが、 第2引数が6(LOCK_EX|LOCK_NB)の場合は、あとから実行した方がロック中だった場合は、0(エラー)を返します。 そのため、こうすることで、 「そのファイルがロック中であるならばプログラムは処理を行わずすぐに終了する」 という処理になります。
SQL文の記述ルールで文字列はシングルコーテーションで囲まなければいけない事になってます。 あと、LIKE検索なのにワイルドカードを使って無いようですが、いいのでしょうか？ ワイルドカードを使わないならLIKEではなく　＝　にして完全一致検索させた方がいいと思いますよ。
次のプログラムを使って、自宅でテストしたところ接続に成功しました。プログラムの誤りではなく、connect 試行中に時間切れになっているのではないかと思います。 use strict; use warnings; use Socket; socket(SOCK, PF_INET, SOCK_STREAM, 6) or die $!; eval { local $SIG{ALRM} = sub { die "timeout1"; }; alarm 5; connect(SOCK, sockaddr_in("80", inet_aton("192.168.0.13"))) || die "$!"; alarm 0; }; if ($@) { alarm 0; print $@; die; } close SOCK; print "connect test OK\n"; 参考までに記すと、開いていないポート番号を指定した場合は、瞬時にエラーになります。 > 接続を拒否されました at xxx.pl line 10. > 接続を拒否されました at xxx.pl line 10. >...propagated at xxx.pl line 17. 誤った IP アドレスに指定すると、数秒後に以下のエラーメッセージが表示されます。 > ホストへの経路がありません at xxx.pl line 10. > ホストへの経路がありません at xxx.pl line 10. > ...propagated at xxx.pl line 17. alarm 2; に変更すると、タイムアウトエラーに変わります。 > timeout1 at xxx.pl line 8. > timeout1 at xxx.pl line 8. >...propagated at xxx.pl line 17.
エラーメッセージの > Perhaps the capitalisation of DBD 'MySQL' isn't right. at C:/Apache2.2/htdocs/00001/shinki_data_sakusei.pl line 33. は「たぶん DBD の 'MySQL' の大文字・小文字が間違ってるんじゃないかなぁ」と読めます。おそらく > my $db = DBI->connect( "DBI:MySQL:dbname = $dbname;host = $dbhost", $user, $pass ); の MySQL が問題ではないかと。
xxx,yyy,"z,zz",XXX,"YY,Y",ZZZ,111,222 の意味は xxx　　yyy　　z,zz　　XXX　　YY,Y　　ZZZ　　111　　222 と言う意味です。 CSVはアプリケーション依存ですから、excelのCSVとして { my $tmp = $line; $tmp =~ s/(?:\x0D\x0A|[\x0D\x0A])?$/,/; @values = map {/^"(.*)"$/ ? scalar($_ = $1, s/""/"/g, $_) : $_} ($tmp =~ /("[^"]*(?:""[^"]*)*"|[^,]*),/g); } です。★ただし内容に改行を含まない場合です。 ⇒ Perlメモ/CSV形式の行から値のリストを取り出す( http://www.din.or.jp/~ohzaki/perl.htm#CSV2Values ) 　より引用。 　これをサブルーチンとして、$lineごとに呼び出せばよいでしょう。 while(<IN>){ my $line = $_; &csv2list($line); } ＞""内のコンマを取りたいのですが、どうしたらよいでしょうか？ 　このサブルーチン内か、処理後に改めて行いますが、大体文字はよほど注意しないと他の文字と衝突します。
ppmで DBD::mysql(DBD-mysql)はインストール済なんですね。 そうなのでしたら、おそらく > my $db = DBI->connect('DBI:mysql:localhost', $user, $pass,); のように、mysqlを小文字で指定していないのが原因でしょう。 Windowsではファイル名の大文字小文字は区別されませんが、 Perlとしてはモジュール名は大文字小文字が区別されます。
＞login_data　というテーブルを適当作成しました。 とありますが、プログラムからはデータベース名がlogin_data、テーブル名がtestと読めます。
昔の話ですが、ガラケーのキャッシュが効いていて投稿できない場合はactionタグに"hoge.cgi?random"という風にランダムな引数(時間をつけたりrandで生成したり)をつけて、違うURLとすることでキャッシュを回避していました。最近の端末でもそんなことあるかどうかは変わりませんが…
文字コードの違いと、UTF-8フラグの有無が考えられます。 $wordに入っている文字列の文字コードと、Perlスクリプトが書かれている文字コードを一致させる必要があります。 また、双方がUTF-8で一致していたとしても use utf8;等で、Perlスクリプト内ではUTF8フラグ付きになっていて、$wordにはフラグ無し、 あるいは、 $wordが何かのモジュールで処理されたUTF8 フラグ付きになっていて、Perlスクリプトにはフラグ無し という状態でも一致しません。 最近なら、次のようにやるのがよいでしょう。 ・スクリプトは use utf8; を使い、UTF-8で記述する。 ・プログラム中では、UTF-8フラグ付き文字列で処理する。 　ファイル等からの入力はPerlIOを利用したり、Encode::decodeしたりしてUTF8フラグ付きにする。 　ファイル等への出力は、PerlIOを利用したり、Encode::eecodeしたりしてUTF8フラグをはずす。
こうですかね。勘違いしていたらすみません ハッシュの値でソートしたキー配列 my %s = ( ... ); my @v = sort { length $s{$b} <=> length $s{$a} } keys %s; キー配列からハッシュを参照 foreach (@v) { printf "%s => %s\n", $_, $s{$_}; }
5.14.4.1405 perl -e "use Win32; print Win32::BuildNumber();" は1405が返ってくるでしょうか。 http://docs.activestate.com/pdk/9.2/Release.html を見ると、 build 5.14.0.1400 for Perl 5.14とあり、 build 5.12.0.1200 or later for Perl 5.12のように、or laterとないので、5.14.0以外のバージョンは利用できないかもしれません。 5.16.0.1600 or later for Perl 5.16 とあるので、5.16.2で同じエラーとなった理由はわかりませんが…（試される際5.14と5.16を共存してインストールはしていないですよね？）
一般的なプログラムの動作として、スクリプト側で排他処理をしてないのであれば、「10分間隔で起動」されれば「10分おきに動作する(場合によっては重複して同時実行する)」だけです。 Perl処理系(ActivePerlなど)が勝手に「二重起動させないようにする」ようなことはありません。(用途によっては、並列で同時に複数実行させたい場合もありますので、そんな勝手なことをされては困ります) 同時実行させたくない場合は、スクリプト側で排他処理を実装してください。
Perl twitter関連のモジュール群は以下のURLにあります https://metacpan.org/release/MMIMS/Net-Twitter-4.00003 Version1.1移行ガイド https://metacpan.org/module/MMIMS/Net-Twitter-4.00003/lib/Net/Twitter/Manual/MigratingToV1_1.pod Oauth Toolは適切であることを前提に回答するとして、 上記URLでお示ししたドキュメントと比較すると、OAuthのtraitsが微妙に違うのが気になります。 traits => [qw/API::RESTv1_1/],
肝心な部分がないので・・・ 　連続投稿を禁止する手段として最も手軽なのは、クッキー(HTTP_COOKIE)の利用です。さらに厳密にしたい場合は、投稿者のIPアドレス(REMOTE_ADDR,REMOTE_HOST)とユーザーエージェント(HTTP_USER_AGENT)をセットにして時間とのtableを作成して参照すると良いでしょう。 　HTTP要求ヘッダから、これらのデータを取得して、クッキーの値が指定された時間以内だったら「連続投票は出来ません」と返せばよいです。厳密にしたい場合は、タイムテーブルを作っておいて、そこにデータがあるIPアドレス/ユーザーエージェントは拒否するとかですね。 　投票データと、管理データは分けるほうが良いです。
この内容なら、もっと古いバージョンでも動きそうなのですが。 「さ」は、いわゆる「だめ文字」ではないですし。 test.txtとtest.plとで文字コードが違ってたりしませんか? もっと複雑なのになると、このままでは、日本語がバイト毎に分解されて処理されるので、問題になります。 例: 'あい' =~ /^(..)/ は、$1='あい' にならない。$1='あ'の1バイト目 'あ'の2バイト目 になる その場合は、UTF8フラグ付きにencode/decodeして使えば日本語の1文字を「1文字」として扱ってくれます。 5.8.8だと、UTF8フラグ付き文字列も使えるレベルになっていたはずです。
以下効率や「分かりやすさ」は完全に無視. とりあえず「5行おき」を無視して「5行ずつ」でその処理をすることはできますよね? 例えば sub collect { my @lines = @_; my @data = (split ' ', $lines[2])[0]; for my $l (@lines) { push @data, (split ' ', $l)[1..3]; } print join("\t", @data), "\n"; } で表示できます. あとは, 読み込んだ全データに対してこれを回せばいいので @lines = <>; for my $i (20..$#lines) { collect(@lines[$i-20, $i-15, $i-10, $i-5, $i]); } でいけそう.
角度が分かっていれば -rotate しかないかな？
まず、チェックボックスのnameは固定にします。HTMLを吐き出すcgiにに記載するフォーム側は、 <input type="checkbox" name="flist" value="$_">$_ <br> xxx.cgiは、 $form = new CGI; @list = $form->param("flist"); でvalueを取得できます。これで解決出来ませんか？ あと、気になったのですが、readdirしてるので、この場合ファイルもチェックボックスに出てしまいますよね？
Malformed UTF-8 character というメッセージは、いわゆる「フラグ付き内部文字列 (UTF-8)」への変換が適切に行われていないことを示しています。元の文字列の文字コードの指定誤りが、主な原因となります。メッセージの末尾には「ファイル名と行番号」が示されているはずですので、それを手がかりに調べていけばよいと思います。
セッションの保存領域に追加の情報を格納したいという質問でしょうか？ たとえば $s->param('user', 'XXX'); で保存できます。セッションファイルを見てください。'user' => 'XXX' という文字列があるはずです。 取得したいときは、 $s->param('user'); で取得できます。
perl -pe 's/MIYAKE_(ILF|HF|LF)\b/$&U/ if /^(\S+\s+){5}$/' inputfile 正規表現の最後に \b (単語境界) を追加すれば、末尾が U になっている文字列は置き換えないようになります。
単純にフォームをCGIから出力させればよいだけです。 __END__ 以降に書かれたデータ(テンプレート)は、perlから<DATA>で利用できますから、呼び出されたとき、データを受信した都度に、内容を書き換えて出力すれば良いです。
エラーになるのは、CGIとして間違っているからであって、Perlとしての間違いではありません。 http://oshiete.goo.ne.jp/qa/8060013.html > ヘッダ(複数行の場合あり、空行不可) > 空行 > 本体 print "content-type:text/html;charset=utf-8\n\n"; は print "content-type:text/html;charset=utf-8\n"; # HTTPヘッダ:改行までが一つの項目 print "\n"; # ヘッダの終端 を1つにまとめたものです。
(?!～～) で、「～～でない」という意味です。 つまり、行頭から「$varの中身」と「:」があり、その次が「*RK*」でない文字列
webサーバで動作するperlのプログラムを呼び出したいならhttpリクエストで呼び出せばいいです。 もしローカルPCで動かしたいのであれば、perlのプログラムは単にファイル名を取得する「だけ」であれば、全てVBAでやったほうがいいでしょう。 ファイル名なんかは簡単に取れますし、デバッグも楽な分VBAでやることをお勧めします。
そうか, シンプルに s///eg でいいんだ. e の存在を忘れてた.... 「URL を表す正規表現」を $url_regex とすると s/$url_regex/index($&, 'hoge.com') == -1 ? 'abc.com' : $&/eg; とか.
下の例は意味不明ですが (「[00:]で始まるものがない場合は」と書いているがすべてのデータが「00:」で始まっている), 本質的には何も考えず 「00:」で始まる行を見つける →その前にある「23時台で始まる行」だけを別の配列に切り出す (元の配列からは取り除く) →それぞれの配列を個別のファイルに出力する でいいのでは?
> showでfetchrow_arrayなどは使えないのでしょうか？ 使えるみたいです。
connect() || connect() || die という書き方が良いかはともかく、 少なくとも2つ目の接続が成功すればdieはしないと思います。 use strict; use warnings; use Socket; my $host1 = 'localhost'; my $port1 = '1234'; my $iaddr1 = inet_aton($host1); my $sock_addr1 = pack_sockaddr_in( $port1, $iaddr1 ); my $host2 = 'localhost'; my $port2 = '80'; my $iaddr2 = inet_aton($host2); my $sock_addr2 = pack_sockaddr_in( $port2, $iaddr2 ); socket( my $sock, PF_INET, SOCK_STREAM, 0 ) || die "$!"; connect( $sock, $sock_addr1 ) || connect( $sock, $sock_addr2 ) || die "$!"; close($sock);
「cgi-lib checkbox」で検索すると、いくつか見つかります。 それには「複数のチェックボックスから受け取った$in{CHECKBOX}は\0で区切った文字列になる」と書いてあります。 \0は通常文字として表示されないので "A\0B\0C" は、画面上は ABC と見えてしまいます。 このプログラムでは、 "1-\02-\03-" というのが入っているはずで、これを/-/でsplitしたら "1" "\02" "\03" というリストになり、\0は数字ではないので、　\02 は「2」ではなく「0」になります。 最初のだけ、\0がないので、数値として有効になります。 > printf STDERR "l:%s,r_no:%s, Judge:%d\n",$l.$r_no, ($l == $r_no); > これの構文の意味が理解できてないので、そのままそれをループの中に入れてみて試しましたが、何も起きませんでした Perlの基本なので覚えてほしいのですが STDERR(標準エラー出力)に、"l:%s,r_no:%s, Judge:%d\n"　という書式で、続く値を出力する、というのものです。 Cのfprintfに相当します。 http://perldoc.jp/func/printf STDERRだと、httpサーバー(Apacheとか)のログかなんかに残っていると思います。 あるいは、適当なファイルをopenしてSTDERRの代わりにしてもいいかと思います。
ざっと検索してみますと、確かにちょいとわかりにくいサイトが多めですね・・。 CGI::Sessionモジュールの日本語マニュアルページがありましたので、こちらが一番読みやすいかと思いました。ただ、「より深く学ぶには」のとこのチュートリアルが日本語訳されていないようです・・残念。 英語版チュートリアルはこちら↓ http://search.cpan.org/~sherzodr/CGI-Session-3.95/Session/Tutorial.pm CGI::Sessionモジュールの日本語マニュアルページ↓
#1 のやり方は「シュワルツ変換」の一種だと思う. ただし, 単純に添え字をソートした方が速いかもしれない. 例えば my @lengths = map { length } @out; my @indices = sort { $lengths[$b] <=> $lengths[$a] } 0..$#out; とする手もある.
-------------- foreach(@csvdata){ use Encode; # この行と Encode::from_to( $_, 'utf8', 'shiftjis' ); # この行を挿入 $downloaddata .= $_; } -------------- 上記のように２行挿入してみてください。 PerlのバージョンによってはEncodeモジュールが入ってない場合はエラーになります。 お試しください。
検索したら、こんなのがありました http://bokut.in/mt/2012/04/perl-win32-unicode.html
>1回目の呼び出しでソケットをクローズせずに処理を終了し、2回目でソケットの生成、接続をせずに直接HTTP通信をしようとしてもうまくいきませんでした。 HTTP通信だと…サーバ側から切断されると思いますが……。 その為、再利用は無理かと。 HTTP1.1なら、KeepAliveにすることで一定時間は接続したままにできるとは思われますが、 1回目と2回目に間が開く場合は無理…でしょう。 # 元々、KeepAliveは取得したHTML内での画像などを取得する際に再利用しよう…って意図っぽいですし。
「perl ssl」で検索すると… http://netandfield.com/~shinoda/tech/0068_ssleay_install.html とか見つかりますが、SSLeayモジュールは入っていますか？
いい方法というか、普通に親子関係を配列に入れていおいてたどればよいと思いますが... 最初のforeachで親子関係を格納した配列を作って、ハッシュから値も引けるようにしておきます。 あとは再帰的に親子関係をたどりながら結果を格納していきます。 sub convert_data { my $d = shift; my @data = @$d; my @root = (); my @child = (); my %map = (); foreach my $elm (@data) { my ($id, $parent, $content) = split(/<>/, $elm); $map[$id] = $elm; if ($parent eq '') { push(@root, $id); next; } if (!defined($child[$parent])) { my @dummy = (); $child[$parent] = \@dummy; } $ref = $child[$parent]; push(@$ref, $id); } sub push_child { my $ref = shift; my @ret = (); foreach my $id (@$ref) { push(@ret, $map[$id]); if (defined($child[$id])) { push(@ret, &push_child($child[$id])); } } return \@ret; } return &push_child(\@root); } my $nodes = &convert_data(\@data); 最近Perlを書いていないのでデータ構造はあまりエレガントではないですが。
先越されちゃいましたけど、書いちゃったので投げておきます。 use strict; use warnings; my @group1 = (1..5); my @group2 = (6..8); # 出力バッファ@bufに@group1をコピー my @buf = @group1; # @bufをランダムに並べ替える for(my $i=@buf; $i>0; $i--) { my $r = int(rand($i)); ($buf[$i-1], $buf[$r]) = ($buf[$r], $buf[$i-1]); } # @group2から1つ選んで@bufの末尾に追加 push(@buf, $group2[int(rand(@group2))]); # @bufの先頭の2個または3個を@bufの最後尾に移動する push(@buf, splice(@buf, 0, 2 + int(rand(2)))); # @bufをカンマでつなぐ my $q_list = join(',', @buf); print $q_list;
> if($where){ これは、$whereという変数が示す値が真か偽か、で判定されます。 このプログラムで$whereに代入されるのは「ただの文字列」です。 if( $where ) が if ($rec ne '' and (略) )になって、neによる比較やandに論理計算がされるわけではありません。 eval関数を使うと、文字列をPerlのプログラムとして解釈して eval($where) が $rec ne '' and (略) になって、neによる比較やandに論理計算がされます。 ただ、現状は $where="$rec ne '' ";の時点で$recが展開されます $rec='a b c d' だと eval($where) は a b c d ne '' となり、期待通りの動作をしないでしょう。 一つは、エスケープを使うなどして、 $whereを期待通りの式にするものです。 $where="\$rec ne '' "; にすれば、$recという文字列がそのまま残るので eval($where) → $rec ne '' となります。 ただ $where .= "and $rec=~/$_/ "; を $where .= "and \$rec=~/\$_/ "; としてしまうと、$_は既に変化しているので期待通りにはならないし、 $where .= "and \$rec=~/$_/ "; だと、 xxx.txt内の単語が「X/Y」だったりすると $rec=~/X/Y/ となり文法違反です もう一つは(こちらを勧めます) 「判定式の文字列」を作るのではなく、判定結果そのものを求めるものです。 ne , andなどは真か偽の値を返します。その値を変数に入れることができます。 $where = ($rec ne '') ; だと、$recが''なら偽、 $recが''でないなら真が$whereに代入されます。 $where .= "and $rec=~/$_/ "; を $where = $where and ($rec=~/$_/ ); にすれば、それまでの$whereと、 ($rec=~/$_/ ) とのandとなります。 if($where)とすれば、$whereの真偽によって分岐します。 あとは open (IN<, "xxx.txt"); は open (IN, "<xxx.txt"); か open (IN,'<', "xxx.txt"); の間違いだとして。 $rec=<IN>; これは xxx.txt の「最初の1行」を「改行付きで」読みこむことになります。 @rec=split(/,/, $rec); で、最後の要素には改行文字が付いたままです。 それでよろしいですか? xxx.txtに日本語等の多バイト文字を使用していませんか? 文字コードによっては、期待通りに動作しないかもしれません。
手許で確認したところ、install Text::CSV_XSで /use/lib/gcc/i686-pc-cygwin/4.5.3/cc1.exe: error while loading shared libraries: cygmpfr-4.dll: cannnot open shared object file: No such file or directory とエラーになりました。 このメッセージを読めが「共有ライブラリcygmpfr-4.dllが見つからない」のが原因だとわかります。 ・Cygwin用の共有ライブラリは cygなんたら-番号.dll というファイル名になっている ・コンパイル時に、上記共有ライブラリを使えるようにするには、libなんたら.dll.aをリンクする ・実行時に必要なファイルと、コンパイル時に必要なファイルが別のパッケージになっているものが多く、コンパイル用は～-devel というパッケージ名になっている という点を考えると、必要なのは mpfr だとわかり、http://cygwin.com/packages/ で確認すれば、libmpfr-develというコンパイル用パッケージがあるのがわかります。 libmpfr-devel(と、これが依存するパッケージ)をインストールしたら、install Text::CSV_XS ができました。 ただ、その時のメッセージからすると、 rebaseall やperlrebaseを実行する必要があるかもしれません。 今回、私の環境に、mpfrが入ってなかったので、上記のように原因がわかりました。 しかし、別件で既にmpfrがインストールされていたら、「こちらでは問題ないから、何が原因かわからない」となっていたでしょう。 質問するときは「ダメ」とかいった抽象的なものではなく、具体的にどう「ダメ」なのかを書くようにしましょう。 エラーメッセージが出ていたら、まずはそれを読んで意味を考えましょう。
それでエラーログが保存されるのは、通常、エラーメッセージは標準エラー出力STDERRに出力するようになっていて、それを「画面」からファイルに切り替えているからです。 扱いは通常のファイル出力と同じなので、print STDERR ～ 等として日付でもなんでも出力することが可能です。 # もしかして、理屈もわからずに、呪文のように使ってませんか?
BEGINブロックは一番最初に実行されます。 この場合、$err_log = "./log/err_log/err.txt"; より前です。 なので、open時の$err_logは空です。 $err_log=をBEGINブロックに入れるか、openをBEGINブロックから出すか、になります。
とりあえず $db = DBI->connect( "略", $user, $password, { mysql_enable_utf8 => 1, } ); としてみては、どうでしょうか。 $user, $password には、それなりの値が入っているものとします。
root権限はないが、シェルを使えるということであれば、No1の方が示した手法がよいと思います。 > インストールせずにCPANサイトからモジュールをダウンロードしてきて使用する方法はありますか？ とのことですので、この手法を説明します。 その前に、Perlの@INCという特殊変数（配列）はご存知でしょうか？ @INCにはライブラリ（モジュール）が保管されているパスが入っています。 ですので、@INCにご自分が使いたいモジュールを置いたパスを追加してやれば、任意のモジュールが使えることになります。 その具体的な手法は過去のQ&Aで回答していますので、そちらをご覧ください。 http://okwave.jp/qa/q6029558.html なお、上記リンク先の BEGIN は、ご利用になるあるいはご自分で作成したPerlスクリプトの一番上でも一番下でもどこに挿入してもOKです。 ※BEGINブロックは、そのPerlスクリプトが読み込まれた際に一番最初に実行される部分です。
最終的にどの文字コードにしたいのでしょうか? そのCSVはどのように確認したのでしょうか? utf-8フラグを落した文字列を出力すれば、そのファイルのコードはUTF-8になります。 CSVを確認したのが Excelだとすると、そのままでは文字化けします。 他のUTF-8に対応したテキストエディアで確認すれば、文字化けしていないと思います (メモ帳ではだめです) ExcelではUTF-8のcsvを読もうとすると、文字化けすることがあります。 これは、Excelでは、Shift_JISだと勝手に解釈するからです。 これを避けるには ・BOM付きのUTF-8でCSVを記述する ・Shift_JISでCSVを記述する となります。 後者の場合、encodeを使ってShift_JISに変換します。このときに、UTF8フラグも落してくれます。 http://www.rwds.net/kuroita/program/Perl_unicode.html#encode
Perl殆ど書いたことないから自信ないが、 エラーメッセージからすると、ソースコード上PathやTypeの後ろに【全角空白】があるのではないかと思う。半角空白やタブではなく。
CreateはDDLです。 DDLはロールバックできない。 Oracleもロールバックできない。 SQLServerはロールバックできる。
モジュールの中の処理を追っていくとNet::HTTP::Methodsの中の http_configureというルーチンが、おかしなことをしているようです。 http_configureの前 $VAR1 = { 'Proto' => 'tcp', 'PeerAddr' => '::1', 'SendTE' => 1, 'PeerPort' => 80, 'LocalAddr' => undef, 'KeepAlive' => '' }; http_configureの後 $VAR1 = { 'Proto' => 'tcp', 'PeerAddr' => '::1', 'PeerPort' => 1, 'LocalAddr' => undef }; となって、ポート番号が1にかわっています。IPv6のアドレス記法に使われるコロン(:)と URLでポート番号を指定するときの記法(localhost:8080など)の コロン(:)を区別していないようです。 Linuxを使っているのでしたら、/etc/hostsに ::1 ip6-localhost ip6-loopback などが登録済みと思うので、http://ip6-localhostで試すといいかもしれません。
改行文字が何だか分かりませんが、¥nとします。 いろいろ問題がありますね^^; $value =~ s/>(&gt;[^<]*|>[^<]*)/&gt;&gt;<font color=\"red\">$1<\/font>/g; のあとに $value =~ s/>/&gt;/g; $value =~ s/</&lt;/g; は、せっかくのfontタグが無効になってしまいますよね。 $value =~ s/>/&gt;/g; $value =~ s/</&lt;/g; のあとに、 $value =~ s/&gt;&gt;(.*?)¥n/&gt;&gt;<font color=\"red\">$1<\/font>¥n/g; で、どうでしょうか。
> Wide character in print at .. お馴染みの警告です。 そのままのメッセージで検索すれば、原因と対処法がわかると思います。 http://www.rwds.net/kuroita/program/Perl_unicode.html
　保存の方法は、何だっていいです。ようするに、次に、サーバー側でCGIを起動した時に、参照できれば良いだけです。 　テキストファイルに書くも良し。データベースに入れるも良し。perlだと、普通は、このあたりの２択かな。 　空のファイルのファイル名で記録というのもありかもしれません（レコード管理が楽ちん。検索も削除も追加も全部ファイルシステムにお任せ=^・。・^=）。 　レジストリに入れるという手も（普通はしません=^・・;=） 　 　アプリケーションサーバーを利用してだと、もっと選択肢は豊富にありますけどね。
ifの中の処理の最後でlastします。 もっともっと良いやり方いっぱいあるけど、 最初は今のソースにlastを付けるところから始めましょう。
>原因、解決策等おわかりであれば 「浮動小数点 誤差」で検索して下さい。 今回の場合、増分が0.001なので…… 1000倍の下駄を履かせて扱う。って方法があるかと。 「固定小数点 下駄」辺りで検索して下さい。
>私が不思議に思うのは、メール自体は送信されますが、ページには500エラーと表示されてしまうことです。 そのcgiのページを開いた時にサーバから返されるhtmlは無いんですか？ サーバがcgiにデータを引き渡して結果のhtmlが返されるのを待っているのに何も返さずにcgiが終了したからInternal Server Errorになった。 という可能性は無いのですか？
「0 から始まる」は簡単でしょうに. ・0 から始まる ・0A0 なら 11桁, そうでなければ 10桁 なら /^0(?(?=[1-9]0)\d{10}|\d{9})$/ くらいでできない?
あなたには「コーヒー」と4文字に見えるだろうし、「ー」一文字を分割することなでできない、と思っているかもしれませんが (何も指定しなければ)Perlには 「コの1バイト目」「コの2バイト目」...「ーの1バイト目」「ーの2バイト目」... というように見えています。「ー」は複数の文字なので、途中で切ることもできます。 (文字コードによって、1文字が何バイトに相当するかが違います) split(/[、,]/, $moneyline); は、 「、」か「,」の2文字のどちらか ではなく 「、の1バイト目」か「、の2バイト目」か、..「,」のいずれか という意味になります。 なので、「、の1バイト目」と「ーの1バイト目」が同じなら、「ーの1バイト目」が区切り文字となり、次の項目が 「ーの2バイト目」から始まることになります。 ★[ヒ=. という結果から考えて、Shift_JISで書いてないでしょうか? そうだとして、文字コードを調べると ー は 0x81 0x5b 、 は 0x81 0x41 と、1バイト目が一致します。 0x5b だけだと、 [ という文字なので、実行結果とも一致します。 ちなみに 0x41 は A なので、 「CAFFEE」があったら「C」「FFEE」に分割されてしまいます。 対策は、分割されないようにすること。 utf8文字列を使うと、日本語でも1文字と扱えるようになるので 　use utf8 ; を追加、スクリプトはUTF-8で記述 　入出力時には、encode/decodeでutf8文字列とバイト列の変換を行う ということになります。 少しややこしいかもしれませんので、書籍はサイトを参考によく勉強してから使ってください http://www.rwds.net/kuroita/program/Perl_unicode.html
No1 のお礼にあるプログラムを見る限り JIS でファイルに保存し、異なる環境 (UTF8, Shift_JIS など) で表示しているに過ぎないのではないかと思います。確認方法として、ブラウザを利用することができます。xxx.txt などの名前で保存して、ブラウザで正常に表示されて文字エンコーディングが JIS (ISO-2022-JP) になっている、または文字エンコーディングを JIS (ISO-2022-JP) にしたら正常に表示された、のような現象であれば文字列として壊れてはいません。 文字列を変換するには、Encode モジュールを利用するのが簡単かと思います。なお、'utf8' のところは環境に合わせて変更してください ('shiftjis', 'cp932', 'euc-jp' など)。 use Encode; ... @$message = map { encode('utf8', decode('jis', $_)) } @$message;
まず、次の点を意識してください。 ○ Perlにとっては、それは「ただの文字列」であって、「時刻」などではない ○ 文字列を数値演算しようとすると、「先頭の数値と見做せる箇所」が表す数値に変換される $ip[1]='2013-02-12 17:03:45' $time='2013-02-12 20:27:26' の場合 $time=$time-$ip[1]; これは ・ - による数値演算 → 両辺は数値と見做す ・ '2013-02-12 20:27:26' → これは只の文字列。先頭の2013だけが数値と見做せるので、 2013 という数値に変換 ・ '2013-02-12 17:03:45' → これは只の文字列。先頭の2013だけが数値と見做せるので、 2013 という数値に変換 →$time= 2013 - 2013 = 0 となり、その「0」と出力されるのが「Perlとして正しい動作」です。 日付の計算をしたいのなら ○DateTimeモジュール等を利用する ○$ip[1]を分解して、timelocal等で epoch秒を計算、 localtimeと比較する ○$ip[1]を分解して、$sec,$min,$hour,$mday,$mon,$yearとそれぞれ比較、集計して差を求める 等の手段を使う必要があります。
IPアドレスから複数のホスト名が出てくる場合もあります。 さらに提示されているホストは、複数のネームサーバを介して名前とIPの変換を行いますが、 そのネームサーバの設定が一部異なっているようです。 そのため、名前解決時に使用するサーバの割り当てが変更する都度、結果も変わっているようですね。
new CGI::Sessionして、それをHTMLレスポンスのヘッダにprintすると、 新しいセッションIDがクッキーに保存されることはわかる? > sessionIDがページを更新するたびに変わってしまいます。 > その結果、前回セッションに保存した値を読み込めません。 セッションを書き込む処理と同じことをしてるんだから、そりゃそうなるでしょ。 以下、ためしてないけど my $cgi = new CGI; print $cgi->header(-charset=>'UTF-8'); CGI::Session->name("SESSION_ID"); my $session = CGI::Session->load("driver:File", $cgi, {Directory=>'./session'}); if ( $session->is_expired ) { # セッション満了 } elsif ( $s->is_empty ) { # 認証失敗 } else { # 認証成功 }
> file名が一度変わり、さらに変わるときに既に出てきたfile名はエラーとする　です。 同じfile名の行はひとかたまりに成っていなくてはダメということでしょうか？ であるなら、生成する部分で「直前のfile名と違い、かつ、既に出現済のfile名を取得した」場合にエラーにすれば良いでしょう。 例) ---------------------------------------------- my $previousFile = ''; while (<FILE>) { if ($_ =~ /(\S+)\s+(\S+)/) { if ($previousFile and $2 ne $previousFile and exists($data{$2})) { die "$2は既に出てきたためエラーとして処理をストップしました"; } $data{$2}{$1} = 1; $previousFile = $2; } } -------------------------------------------------- > これをループ文(whileやforeach)などで取り出す場合の記述例を御教授願います。 %result のキーでループさせてその内側で値の配列をループさせれば全要素を走査できます。file名順に並べなくても良いなら while と each の組合せでも大丈夫です。 例) ---------------------------------------------- foreach my $file (sort(keys(%result))) { print "* $file\n"; foreach my $str (@{$result{$file}}) { print " - $str\n"; } } -------------------------------------------------- 単に配列が値になっているハッシュというだけの話なので、perlの制御構文やハッシュの使い方を調べれば、走査のやり方は分かるでしょう。 http://rfs.jp/sb/perl/02/06.html http://rfs.jp/sb/perl/02/05.html なお、ベストアンサーはどうでも良いですが、マルチポストは止めましょう。いちおう、このサイトのルールですし、質問する方も回答する方も面倒なだけでしょう。
emacsを使ってませんか? ~はバックアップで、ファイルを読み込んだ時点での内容が入っています。 http://www.bookshelf.jp/texi/emacs-20.6-man-jp/emacs_15.html#SEC107 #～#は自動保存されたものです。通常は、C-x C-s等で明示的に保存すると、削除されます。 http://www.bookshelf.jp/texi/emacs-20.6-man-jp/emacs_15.html#SEC113 Perlの実行とは関係ありません。
NO.1 さんの言う通りですが、別案として。 並列処理しているそれぞれのプロセスで違うファイルに出力し、子プロセスがすべて終了した後に、親プロセスでそれらのファイルを順番にくっつけるという方法はどうでしょうか。
並列処理、ってそういうもの(子プロセス同士の実行順番が一定とは限らない)だと思いますが。 順番が重要なら、それを制御する必要があります。 ・親プロセスで結果を受けとって、順番に並べてファイルに出力 ・子プロセス側で、「自分の番」が来るまで、ファイル出力を待つ ・子プロセス1の終了を待って子プロセス2を実行(並列の意味無し) 等
フローチャートを書いてみましょう。 それでは、エラーがなければ送信されますよね。 　確認画面に、チェック用のinput hiddenでコードを含めて、そのコードがなければ確認画面を表示する。あれば送信とすれば良いです。 　この値は、時間コードにしてチェックすると、時間をチェックできるでしょう。必要なら暗号化したものにしてチェックするとか。
多くのプログラミング言語で、整数と実数は区別されています。 整数/整数は整数になり、小数点以下が無くなります。通常切り捨てです。 例: 1/4=0 実数で計算するなら、実数同士で計算します。 例: 1.0/4.0=0.25 数字だけを記述すると、整数になります。 実数を記述するには、小数点が必要です。 このとき、小数点の上又は下が0の場合、その0を省略できます 1.0→1. 0.3→.3 0→0. 又は.0 詳しくは、その言語の「リテラル」を調べてください。 で、Perlの場合は、この区別が無いので無意味、というのは既出の通りです。 ついでにいえば、これは誤差が大きくなる記述です。1/60をかけるより、60で割る方がいいです。
あくまで一般論ですが, CGI として動かすときとコマンドラインから実行するときとではディレクトリや実行ユーザ, あるいはパスなんかが違うことは多いと思うので, コマンドラインから実行してちゃんと動いたとしても「CGI として動作するかどうか」は別問題だったりします. perl 内部でエラーチェックができるとか, あるいはログにエラーが出ていれば容易に解決できそうなんだけど....
通常、Shift_JISの2バイト文字は「2文字」として処理されます。 'ヤツ'は2文字ではなく、 "\x83\x84\x83\x63" の4文字です。 同様に、このロシア文字も2バイト文字なので、それぞれが2文字扱いです。 ここで、'с'は"\x84\x83"です。 この"\x84\x83"がヤの2バイト目+ツの1バイト目と一致します。 対策は、次のどちらかになります。 ・2バイト文字を考慮するものを利用する。場合によっては自作する。 ・Encodeモジュールを使って、 utf8文字列にdecodeする。 utf8文字列にすれば、多バイト文字でも「1文字」扱いになるので、index等が普通に使える。
> while($line=<IN>){ <> (ダイヤモンド演算子) では、改行コードも含めて入力されます。 よって、 $line = "でーた\n" としたような状態になっています。 $data にはformから入力したので、改行コードは付いていません。 これでは絶対に一致しません。 while($line=<IN>){ chomp $line ; if ( $line eq $data ) { $flag = 1; } } という感じに、chomp関数を使うなど、改行コードを削除するのが,Perlでの常套手段です。 あとは、細かいことになりますが > open(IN , "<:uft8" , "data.dat"); 戻り値を確認して、エラーのときは、適切な処理をするようにしましょう。 > open(OUT,">>data.dat"); INでは3引数で使ってるのですから、OUTの方も3引数使っては? エラー処理も入れましょう。 ただ、このままだと、同時にアクセスがあったときに、不具合が発生する可能性があります。 「perl 排他制御」で検索して、調べてください。 今回の場合だったら '+<' で読み書き用でopen→flock等の排他処理→読み込み→(closeはしない)→seekで末尾に→追記→close というのが常套手段でしょう。 > print "Content-Type: text/html; charset=UTF-8\n"; > print "$data $pr<br>\n"; HTTPのヘッダは、空行で区切りです。\nで改行するなら、\n\nと改行だけの行が必要です。 その後もHTMLとしては変ですが、それはとりあえず置いておきます
@tangoc = map { my $a = $_ ; map { $a . $_ } @tangob } @tangoa; ちょっと気持ち悪いな。
このくらいなら, 変数を使えばいいような気がする. 例えば $pattern = quotemeta '/^\d+$|^\d+\.[05]{1}$/'; $replacement = '/^[0]+$|^[0]+\.[0]+$/'; s/$pattern/$replacement/og; とか.
「うまくいかない」の具体的な内容 Perlのバージョン Jcodeのバージョン その状況が再現できる、具体的なプログラム を提示してください。 > 半角カタカナ→全角カタカナ h2z を使っているなら、EUC-JPへの変換は不要です。 > 半角小文字英字→半角大文字英字 この範囲は、Shift_JISでもEUC-JPでも(UTF-8でも)同じコードを使っています。 なので「Shift_JISをEUC-JPに変換しなくても大丈夫」なのではなく、「Shift_JISをEUC-JPのつもりで処理しても、たまたま影響が無い」のではないかと > 全角英数字→半角英数字 Jcodeのh2zでやろうとしているなら、対象外です http://search.cpan.org/~dankogai/Jcode-2.07/Jcode/Nihongo.pod#(21322)(35282)_(8592)(8594)_(20840)(35282) Jcodeのtrでやろうとしているなら、EUC-JPである必要があります http://search.cpan.org/~dankogai/Jcode-2.07/Jcode/Nihongo.pod#(27491)(35215)(34920)(29694)(12456)(12511)(12517)(12524)(12540)(12479)
ググると、 「ebcdic->sjis変換で失われたシフト文字分の空白をEncode::CJKConstantsで復活」 http://d.hatena.ne.jp/end0tknr/20090222/1235302471 という記事がありました。 シフト文字分の空白を付け加えて文字数(バイト数??)をカウントするという方法でうまくいかないでしょうか。
おっしゃるとおり、プログラム中こういう箇所がそんなにない場合や、1つのファイルでプログラムを配布したい場合、ヒアドキュメントが簡単で良いと思います。 $var = "test"; print << "__EOM__"; <?xml aaa=111 bbb=222 ccc=333> <A>$var</A> <B>$var</B> <C>$var</C> | | | <Z>$var</Z> <END></END> __EOM__ あるいは、複数のファイルになっても良いなら、テンプレートエンジンを使うという方法もあるかもしれません。構成やデザインを別ファイルで用意して、表示の時に組み合わせると、表示部分の変更のためにわざわざPerlのコードを見たり理解したりする必要がなくなりますが、そういうことをしたい場合はまずテンプレートエンジンを使います。テンプレートエンジンとしては、HTML::Templateというモジュールがよく使われるようですが、インストールされていないと使えないようなので、インストールが面倒くさかったらこういうのもあるようですね。 http://anond.hatelabo.jp/20071030153111 HTML::TemplateというとHTML専用のように見えますが、ぱっと見、何にでも使えるように見えました。 テンプレートエンジンに興味を持ったらModel View Controller (MVC)についてもちょっと調べてみるとよいでしょう。テンプレートエンジンを使っていると、表示するテキストの部分 (例えばHTMLなど) を書くときはそちらに集中できて良いですよ。
\s+ という表現を知ってるのにそれを知らないって言うのも奇妙な話・・・ .（ドット）が任意の文字なので .+ なら1文字以上の任意文字列 .* なら0文字以上の任意文字列 になりますよ。 なお、任意文字というのは空白文字も含みますのでそれが意図通りでないのなら適宜適切な表現を使ってください。 細かいことは「perl 正規表現」で検索して調べた方がたぶん速いです。 あとついでに、 .は任意の1文字なので hoge.jp という正規表現は hogeXjp とかにもマッチしちゃいますよ。
何のためにどうしたいのか不明ですが、 "114.114.96.20" というデータから、4バイトのバイナリデータを得たい～～この場合は"\x72\x72\x60\x14"～～ということなら、 $x = "114.114.96.20"; $y = pack("C*",split(/\./,$x)); さらにそれを数値～～この場合は0x72_72_60_14==0b01110010_01110010_01100000_00010100==1920098324～～に直したいなら、 $z = unpack("N",$y);
114.114.96.20 158.217.208.15 この2つの違いは? 具体的、どんなものは出力したくて、どんなものは出力したくないのですか? 前回の続きだとして ・最初に見つかったものだけを出力したい → 1つ出力したところで、lastとかでループから抜ける。 出力したかどうか、何番目かを記憶する変数を用意して、1つめのときだけ出力する 等 ・( IPアドレス [IPアドレス])になっている行だけを出力したい → ifで判定する条件を、これだけがマッチするようにする ・IPアドレスが特定の範囲だったら →抜き出したIPアドレスから値を取り出し、その範囲かどうかを判定する など、目的が違えば、やり方も変わります
「一番最初にマッチした値を知りたい」のなら, マッチした時点でループから脱出すればいいじゃん.
たぶん実例が見たいのでは。 とりあえずこんな感じですか？ --------------------------------------------- #!/usr/bin/perl my @aDATA = ("りんご","キャベツ","バナナ","みかん"); foreach(@aDATA){ 　my $sNAME = $_; 　foreach(1..10){ 　　print $_.' - '.$sNAME."\n"; 　} } --------------------------------------------- 注意：コピペするならインデント用の全角空白に気をつけてね
まず、その日付から、数字のところだけ取り出すことはできますか? 正規表現なりsubstrなりで数字のところを抜きだせば、Date::Local::timelocal でtimeが返す値(エポック秒)を計算できます。 http://perldoc.perl.org/Time/Local.html 他に時刻操作に関するモジュールがいろいろとあります。CPAN等で検索するとよいでしょう。 例えば http://perldoc.jp/docs/modules/Time-Piece-1.08/Piece.pod ただ、これらのモジュールが日本語混りの文字列をうまく操作できるかは不明です。
「シェルのモディファイア」で変換されてしまう、という話なら、Perlは直接関係ありません。 方法として ・シェルで変換しないようなコマンドラインを、system関数に渡す # ただ、 xxxx.com:22 をなんかに変換してしまうようなシェル、というものに思い当るものがありません。 ・引数をリストにしてsystemを実行することで、シェルを通さないで実行する system('program', "${host}:22") ; http://perldoc.jp/func/system http://perldoc.jp/func/exec これでだめなら、別の問題でしょう。 # $hostの後ろに空白とか改行コードとかが付いてるとか ちなみに、コマンドラインシェルから program xxxx.com:22 を実行したらちゃんと動作するのですか?
正規表現で迷ったら、まずは perldocの perlre を読んでみましょう。 http://perldoc.jp/docs/perl/5.14.1/perlre.pod 通常、正規表現を改行で分割して表記することはできません。 改行文字が「改行文字に一致するパターン」としての意味を持ちます。パターン中に\nと書くようなものです。 .演算子は文字列を連結する演算を行うものです。正規表現内は、明示しない限り「演算」はしません。 連結の演算するなら、 パターンでよく使う「.(任意の1文字)」が文字列連結に使われてしまいます 対処法としては ・/x を使う。詳細はマニュアルで ・予め文字列変数に入れて、それをパターンに使う $pattern = '^\s+\S+\s+(\S+)\s+(\S+)\s+\S+\s+(\S+)'; $pattern .= '\s+(\S+)\s+\S+\s+\S+\s+\S+\s+\S+' ; $pattern .= '\s+\S+\s+(\S+)\s+\S+\s+\S+' ; if($test =~ /${pattern}/){ ～ ・このパターンに限っては、「1個以上の空白で区切られた文字列」なので、 @test1=split(/\s+/,$test) ; とsplitして if(scalar @test1== 14) { # splitされた項目数を数える→過不足あるなら期待しているデータではない $test1[2], $test1[3],$test1[5] ;# $1,$2..に相当する位置 等必要な箇所を使う、という方法もあります。
提案させていただいた#1,#2の$value1引数は取り下げます。 決定的にまずいところがありました。 sizeof(struct tfield) = 276 sizeof(struct tfield *) = 4 struct tfield *p,*head[30];→head[30]でないとメモリに収まりません。 メモリの割当ですが、以下のようにするようです。Perlが機能を提供しています。 http://argrath.ub32.org/perldocjp/5.10.0/perlguts.html#memory_allocation Newx(pointer, number, type); Newxc(pointer, number, type, cast); Newxz(pointer, number, type);　　　　（これだけは獲得した領域を0で埋める） ケーススタディが多くてXS/Perlgutsの日本語資料はなかなかあたれませんね。
Shift_JIS コードを使っている場合、パターンマッチ以前の問題として、日本語文字列に uc を適用するとその時点で文字化けの可能性があります。 $name = "テニスコート"; $name = uc $name; print "$name\n"; # ウカスコーエ 元の文字列を大文字化せずに正規表現に /i フラグを付ける対応策があるのですが、この場合も正規表現に日本語文字列が含まれていると問題があります。日本語文字は２種類の文字にマッチしてしまうものが多数あります。"テニスコート" の例では "ー" 以外の文字が２種類の文字にマッチするので、32 (2 の 5 乗) 種類の文字列とマッチすることになります。 対応策としては、"テニスコート" は index で、"TENNIS" は正規表現の /i フラグで処理するのがいいと思います。 if (index($name, "テニスコート") >= 0 or $name =~ /TENNIS/i) { push(@error, 'テニス関係は入力できません'); }
数が違うなら自力で揃えればいいんじゃないの? それか, 違っていてもいいように GD::Graph をいじるか.
どこらへんが難しいかわかりませんが、こういう感じでしょうか？ my @animals = ( {'name' => 'gorilla', 'number' => 4}, {'name' => 'panda', 'number' => 2}, {'name' => 'sea otter', 'number' => 3}, {'name' => 'sparrow', 'number' => 1}, {'name' => 'rabbit', 'number' => 2}, ); sub choose_animal { my $num_all_animals = 0; foreach my $elm (@animals) { $num_all_animals += $elm->{'number'}; } my $choice = rand($num_all_animals); foreach my $elm (@animals) { $choice -= $elm->{'number'}; if ($choice < 0) { return $elm->{'name'}; } } } print &choose_animal()."\n"; 簡単に解説しておくと、 perldoc -f randすれば、randのマニュアルが出てきます。 | rand EXPR | rand Returns a random fractional number greater than or equal to 0 | and less than the value of EXPR. (EXPR should be positive.) つまり、10以下の乱数が欲しかったらrand(10)でいいわけですね。これは少数で出てきますが特に整数にする必要はないのでこのまま使います。ちなみに、下記のプログラムはint(rand(10))などして整数に直してもちゃんと動くはずです。 ある割合で物を選びたい場合、rand(選びたい割合の合計)として、if文で分けるのが普通でしょう。 元の問題を説明のために書き換えて、次の割合で表示させることを考えます。 ゴリラ(2) ラッコ(1) 子犬(3) この場合、if文で普通はこういうプログラムを書きます。 $choice = rand(2 + 1 + 3); if (0 <= $choice && $choice < 2) { print "ゴリラ"; } elsif(2 <= $choice && $choice < 2 + 1) { print "ラッコ"; } elsif(2 + 1 <= $choice && $choice < 2 + 1 + 3) { print "子犬"; } これは、全く同じ動作をさせつつこう書き換えられます。 if (0 <= $choice && $choice < 2) { print "ゴリラ"; } else { $choice -= 2; } if (0 <= $choice && $choice < 1) { print "ラッコ"; } else { $choice -= 1; } if (0 <= $choice && $choice < 3) { print "子犬"; } else { $choice -= 3; } そのままforeachで書き換えると、 foreach my $elm (@animals) { if ($choice < $elm->{'ratio'}) { print $elm->{'name'}; break; } $choice -= 3; } のように書けます。 randの引数もforeachを使って計算し、breakさせる代わりにreturnさせると上のようなプログラムになります。
PHPは、出力バッファが有効な場合全ての処理が終わってからWebサーバに結果を返すので、全ての処理が実行されます。 Perl はひとつ処理が終わる度に随時Webサーバを通じてブラウザに結果を返しているので、ブラウザ側がLocationヘッダーを受け取った時点でリダイレクト処理に移ってしまえば、セッションは切断されPerlの処理も中断されます。 従って ＞　どこかで、リダイレクト後は処理を行わないから必要ない というのもあながち間違っていませんが、Locationヘッダーを送ったら即処理が止まるかというと、厳密には止まっていません。 Locationヘッダーを書き出した後の処理で、何らかのデータファイル等を書き換えるような処理を行っていると中途半端なデータができてしまう恐れもあるので、プログラム側で終了を明示する方が問題を起こさないと思います。
http://perldoc.jp/docs/perl/5.14.1/perlpod.pod =forを認識した時点で、それ以降 =cut までは、プログラムではなく、ドキュメントです。 ただの文章なので、何が書いてあっても、プログラムとして動作しません、
test.xml の中身を <XMLDOC> <MODESMESSAGE> ... <MODESMESSAGE> <MODESMESSAGE> ... <MODESMESSAGE> ... </XMLDOC> のようにタグで挟めば、よいと思う。 <XMLDOC> は単なる例で別に何でもよい。 よく知らないんだけど、挟まないとひとつの XML 文書にならないのじゃないかな ???
実機で試してないのでなんともいえないけど フォームに ------------------------------- <input type="hidden" name="mode" value="send" /> ------------------------------- を足して clipmail.cgiのセッションチェック（たぶん確認画面表示のタイムアウト監視）をはずしてみてはどうでしょうか？ ------------------------------- # セッションチェック &check_ses; ------------------------------- を ------------------------------- # セッションチェック ## &check_ses; ------------------------------- こんな感じに
> print FILE "@memory"; > ... > print FILE "@data"; ダブルクォート文字列の中で配列を展開すると間に半角スペースを挟むので、配列が行で構成されている場合は２行目以降の先頭にスペースが付くことになります。他の部分にも多少問題がありそうなコードですが、とりあえず次のようにしてみては ... ? print FILE @memory; ... print FILE @data;
２つのサブルーチンは指定された曜日・時刻のエポック秒を返すだけなので、変更する部分は質問に書かれているサブルーチンの中身ではなくサブルーチンを呼び出す部分だと思います。GetNextWDayTime(1, n, n, n) あるいは GetLastWDayTime(1, n, n, n) のような形で呼び出していると想定されますが、その第１引数が曜日ですので、それを 1 から 3 に変更すればよいと思います。
エラーがおきているのは本当にこのスクリプトですか？全体の一部を抜き出したりとかしてません？ > 使用しておりますサーバーはコアサーバーです。 自分のPCにperlを入れて、コマンドラインから動かすとどうなりますか？
split して適当な部分を取り出す.
ドキュメントを見る限りできそうできそうですね。 http://perldoc.jp/docs/modules/Inline-0.43/C/C.pod CCFLAGSに-openmp　あるいは　/openmp（コンパイラ依存） を追加して、ソースに#pragma ompで追加していけばなんとかなるかも。 http://perldoc.jp/docs/modules/Inline-0.43/Inline.pod の中央あたりに、コンパイラオプションを設定した例があります。 またLDDLFLAGSが使えるので、別途openMPでコンパイルしたサブルーチンをリンクしてinlineCから呼び出してもよいかもしれません。 Windowsの場合必要なのかわかりませんが、UNIX系OSの場合は OMP_NUM_THREADSを設定しておかないと並列実行はしてくれませんので、注意してください。 他のスクリプト言語ですが、CやFortranで書いたサブルーチンをswigでライブラリ化して使っています。 サブルーチンをコンパイルするときに並列化などのオプションを追加しておくと並列実行できています。 またGPUを使った計算も可能でそれも実際に使っております。 コンパイラが対応しているとインラインでも同じことができるはずです。
http://easycgi.xrea.jp/perltips/mailform.htm サンプルどうぞ。 cgiの処理としては、特定のメールアドレスにフォームから受け取った情報を適当に処理するなりして送信するまでです。 受信したメールをどうするかは、メーラー等の設定によります。 こちらは、スクリプトとは完全に無関係で、メールの受信設定になりますので、とりあえず、加味する必要はありません。 一応、基本的で調べづらい点 htmlフォームは <form action="************"> で指定された場所にデータを送信します。
表示がくずれるので、空白2文字を全角空白にしていることに注意。 なお、 0 .. 10000000 の和は long で表現できないので、 double に加算しています。 #!/usr/bin/perl use strict; use warnings; use feature 'say'; use Inline C => 'DATA'; my @data = (0 .. 10000000); my $ret = add(\@data); say $ret; __DATA__ __C__ #include <stdio.h> double add(SV* array_ref) { 　　int i; 　　int len; 　　double sum; 　　AV　*av_ptr; 　　SV **num_ptr; 　　sum = 0; 　　av_ptr = (AV*)SvRV(array_ref); 　　len = av_len(av_ptr) + 1; 　　for (i = 0; i < len; i++) { 　　　　num_ptr = av_fetch(av_ptr, i, 0); 　　　　sum += SvIV(*num_ptr); 　　} 　　return sum; }
配列 @a に対し $#a で「@a の最後の添字」が得られるというのはよく知られているところですが, $#a を左辺値として使うと「@a の最後の添字を決める」ことができます. 例えば $#a = 6; とすると, @a の大きさは (添字にして 0～6 の) 7 となります. 配列が大きくなる場合は undef で埋め, 小さくなるときには余計なところがだまって消滅します. んで #4 の「美しくない」ってのは, map を単に「ならべる」ために使うのがうれしくないなぁ, と. @a = ([([(0) x ($z+1)]) x ($y+1)]) x ($x+1); とできればいいんだけど, 実は間違っている. 以下は #6 向け (笑) perl 5.14 の場合, 代入する値が定数なら 0 でも 100 でも同じコードを吐きます. まぁ, 0 であったところで何かが簡単になるわけじゃないので, わざわざ変える必要もないでしょう. そして, 機械語の場合でも「引き算」と「排他的論理和」と「単に 0 を代入」とで, 微妙に動作が違うことがあったりする. 例えば 8080 とか Z80 とかだとフラグの変化が全て違うので, 変なことをすると「0 を代入」じゃないと動かないことがある (この辺は 8086 でも同じだったはず). 一方 68000 では「0 を代入」で十分なので, 排他的論理和を使う必要はありません (使ってもいいけど何もかわらない).
$aと$bは定義済みの変数であるため、my宣言せずにuse strictしていてもエラーになりません。 perlのわかりづらいところでもあります。 http://perldoc.jp/docs/perl/5.14.1/perlvar.pod --- $a $b sort() を使うときの特殊パッケージ変数です; "sort" in perlfunc を 参照してください。 この特殊性により、$a と $b は、たとえ strict 'vars' プラグマを 使っているときでも (use vars や our() を使って) 宣言する必要が ありません。 これを sort() 比較ブロックや関数で使えるようにしたい場合は、 my $a や my $b としてレキシカル化しないでください。
aaa, bbb, ccc のディレクトリをそれぞれ opendir で開いて、目的のディレクトリ (11_2, 9_20 等) を取得するようにすればうまくいくと思います。 #!/usr/bin/perl use strict; use warnings; my @directory=qw/aaa bbb ccc/; foreach my $dname (@directory) { opendir(DIR,"./$dname") or die $!; my @sdir = readdir(DIR); close(DIR); foreach my $sdir (@sdir) { if (-d "./$dname/$sdir" and $sdir =~ /^\d+_\d+$/) { opendir(DIR, "./$dname/$sdir") or die $!; my @file = readdir(DIR); close(DIR); print join("\n", @file), "\n"; } } }
配列の比較方法にもっと良い書き方がありそうですが、例えばこんな感じでしょうか。 use strict; use File::Copy 'move'; sub readfile { my ($filename, $lines_to_cut) = @_; open(my $fh, "<", $filename) or die "cannot open < $filename: $!"; my @lines = <$fh>; close($fh); return @lines[$lines_to_cut .. $#lines]; } sub is_same_array { my ($r0, $r1) = @_; my @a0 = @$r0; my @a1 = @$r1; if ($#a0 != $#a1) { return 0; } for (my $i = 0; $i < $#a0; $i++) { if ($a0[$i] ne $a1[$i]) { return 0; } } return 1; } my $LINES_TO_CUT = 9; my $FILE_A = 'a.csv'; my $FILE_B = 'b.csv'; my @a_csv = readfile('a.csv', $LINES_TO_CUT); my @b_csv = readfile('b.csv', $LINES_TO_CUT); if (is_same_array(\@a_csv, \@b_csv)) { print "$FILE_A and $FILE_B are same.\n"; } else { print "$FILE_A and $FILE_B are different.\n"; print "Moving $FILE_A to $FILE_B.\n"; move($FILE_A, $FILE_B); } readfileで各行が配列の要素となった配列を、$lines_to_cut行分だけ省いた形で返してもらえるので、is_same_arrayにて単純にその比較をして同じか違うかを判定しています。 CSVとして同じかどうかなんて判断していないので、CSVとしては同じものでも違う書き方をしていたら違うと判断します。例えば、"abc"とabcは同じと本来は解釈すべきですが、こいつは単純な配列の要素の比較しかしないので違うと判断します。
あるべき動作仕様やデータフォーマットの詳細、動作環境などがわかりませんので、 スクリプトを動作させた場合に考えられる問題を列挙します。 ● 各データファイルのフォーマットはタブ区切りになっていますか？ 仕様として言及されていませんが、split /\t/ で処理している以上は ファイルの列がタブ区切りになっていないとデータ列を正しく読み取れません。 その結果、$fact[2]と$oct[1]がいずれも未定義値になっている場合には if($fact[2] =~ /$oct[1]/) { ... } は常に真と判定されます。 $fact[2]と$oct[1]に正しい値が入ることを保証するために、 列数が異なる場合にはエラーとなるような例外処理が必要かもしれません。 @fact = split /\t/, $line; if(@fact != 2) { die("Bad csv format at RNA.csv, line $.\n"); } @oct = split /\t/, $octline; if(@oct != 3) { die("Bad csv format at oct_gene.csv, line $.\n"); } なお上記のケースでは、Perl5ではuse warningsプラグマを有効にしていれば 実行時に未定義値に関する警告を出してくれます。 use strictやmyによる変数宣言と合わせてチェック機能を有効活用することを 強くお勧めします。 ●各データファイルの改行コードは実行環境の改行コードと一致していますか？ Perlを実行するプラットフォームOSとデータファイルの改行コードが 一致していない場合にもデータ読み込み時の破損が起きる可能性があります。 例として、UNIX/Linux系プラットフォーム（改行コード＝LF）のPerlにおいて Windows環境で作られたテキストファイル（改行コード＝CR+LF）を読ませた場合、 chompでは末尾のLFのみが削られ、CRが残ってしまってデータが化けることになります。 この場合、Perl5.8以降であれば、3引数のopen()やbinmode()を使って open(FILE, ":crlf", "RNA.csv"); または open(OCT, "oct_gene.csv"); binmode(OCT, ":crlf"); とすることで入力時にテキスト中のCR+LFの改行をLFに統一することができます。 Mac（改行コード＝CR）で実行する場合も同様の注意が必要になる場合があります。 Windowsでも、Cygwin環境で実行した場合はUNIX系と同じ挙動になるはずです。 バッドノウハウとして、chompを複数回実行するという裏技？もありますが、 場当たり的対処方法なのでお勧めしません。入力フォーマットの方を厳格にすべきです。 ● 文字列の比較方法は意図したものになっていますか？ 「alphabetの群は空白で区切られています」とあるにもかかわらず、 空白を一切考慮しないロジックになっているのが気になります。 上記のサンプルでは、「Nanog homeobox」に対しては「Nano」「g h」「home」「box」なども マッチすることになります。 これが意図する仕様かどうか確認した上で、もし必要であれば比較元と 対象文字列のそれぞれについて、空白でsplitしてから個別比較する処理を追加してください。 また、/$oct[1]/とした場合、$oct[1]は一般文字列ではなく正規表現として解釈されます。 単純に文字列を含んでいるかをチェックしたいのなら、\Q～\Eを使って if($fact[2] =~ /\Q$oct[1]\E/) { とするか、あるいは正規表現を使わずに if(index($fact[2], $oct[1]) >= 0) {# 文字列を含まない場合は-1が返る でチェックしなければいけません。 でないと$oct[1]に正規表現のメタ文字が含まれている場合に意図しない結果になります。 $oct[1] = 'a.c' のときに 'abc' にもマッチしてしまうということです。 ● 比較対象およびファイル出力する内容の、列の選択は正しいですか？ 配列の添え字は1ではなく0から始まることに注意してください。 print WRITE $fact[2] . "\t" . $oct[1] ."\n"; で出力されるのは、 「RNA.csvの3列目とoct_gene.csvの2列目をタブ記号で連結したもの」 です。提示仕様にある「一致した行の1列目を出力する」とは異なるように 読み取れます。1行目ならわかるんですが・・。
$line .= $hash{$top} if exists $hash{$top}; # 次の行と同じ $line = $line . $hash{$top} if exists $hash{$top}; . は文字列連結演算子で、元の文字列の末尾に文字列を追加する場合は .= の省略記法が使えます。上のコード自体は特に問題にならないと思うので、原因は別のところにあると思います。修正したコードの一部を記しますので、もう一度実行してみてください。 my %hash = map { /(.+?)(\t.+)/ } @data2; foreach my $line (@data1) { my $top = substr $line, 0, index($line, "\t"); $line .= $hash{$top} if exists $hash{$top}; print OUT "$line\n"; } これでも、やはり @data1 と同じ出力になるとしたら、次のようなコードで %hash を出力してみてください。元のファイルのフォーマットに問題があって、例えば先頭の単語の前後に半角スペースがあると、ハッシュのキーと $top が一致しなくなります。 print "|$_| => |$hash{$_}|\n" foreach keys %hash;
ん～, それくらいなら特に困ることもなく @keys = grep { $hash{$_} eq $value; } keys %hash; で終わり (比較に何を使えばいいのかは知らん) では?
はじめまして。 自分はperl5.8から使い始めたものです。 >require 'jacode.pl'; ええと、jcode.plの質問ですよね？ そもそもjcode.plはutf8に対応してません。 use utf8プラグマも確かperl5.8以上じゃないと動作しなかったような…。 まぁnkfやiconvなどのUnicodeに対応済みの文字コードを変換するコマンドがあれば、perlからシェル呼び出して上手く変換できるかもですが、ソースコードの作りが面倒くさいと思います。 perl5.8以上インストールするか、レンタルサーバー変えたほうがいいと思います。 Encode.pmがあれば悩む必要がありませんよ、まぁ無理なのかもしれないでしょうけど。
あれ、このコードで空白行削除されませんか？ 読み出しファイルの「（必要な空白）」って最初の空白行ですよね？ >@data = grep {!$count{$_}++} @data; これはハッシュに存在しないものだけ配列に格納してるんで、最初の空白行だけに整形されるはずですが。 空白行にひとつ以上のタブや半角・全角スペース文字が来たりしてたら動作しないとは思いますが。
>$string1 = <FILE1>; これは配列で受け取ってないので、入力ファイルから1行だけ取得する処理です。 なので全行を読み込むのであれば、No.1さんの言うとおり、ループさせる必要があります。 ループの書き方ですがファイルハンドルをwhileでループさせるか、一度配列に落としてforeachでループさせるかがベタではないかと。配列に落とすんならこんな感じですかね…。 --- my @data = <FILE1>; chomp @data; foreach my $line (@data) { my @array = split(/\t/, $line); my %count; @array = grep {!$count{$_}++}@array; foreach my $element (@array) { print OUT "$element\t"; } print OUT "\n"; } --- 改行を削除しないと整形したファイルの先頭に\tがつくんで、とりあえずchompして、レコードの最後に改行付けてます。
一つ目のループの継続条件は、forの2つ目の式、つまり、 $_ =<stdin> ですから、 ** 一つ目のループはstdinが終了する(End of FIle)まで繰り返します ** つまり、一つ目のループが終った時点で、 stdinは終了してますから 二つ目のループでstdinから読もうとしても、何も読めずに終了します。 対処法は、あなたが期待するものによります。 ○400行目までをdata1,401行から800行までをdata2にしたいのなら、 一つのループで行数によって分岐すればいい。 for($line =0;$_ =<stdin>;$line++){ if($line < 400){ #1～400行まではここ @line = split/,/,; $data1 +=$line[1]; } elsif($line < 800){ #401～ 800行まではここ。400行までは上のifにいくので、ここには401行目以降しか来ない @line = split/,/,; $data2 +=$line[1]; } } そもそも、行番号が決まっているなら、終了条件に$_=<stdin>など使わなければいい。 #1～400行まで for($line =0;$line < 400;$line++){ $_=<stdin> ; #一応、終了チェックを入れたけど、入力行数が確実にあるなら入れなくてもいい if(not defined $_ ) {last ; } @line = split/,/,; $data1 +=$line[1]; }
「正しい書き方」という意図がよくわからないんですが $a1 = abs($a1); で絶対値にしてはだめなんですか？ いろいろなやり方を選択できるのがperlの面白さです。 いろんなやり方があるので意図した結果が得られればそれは正しい書き方かなと思います。
tr
ファイルオープンと各行を読み込んで出力するならこんな感じですかね。 open関数は3引数、ベアワード抜きにしたいもんですね。 ------------------------------------------------------------ #!/usr/bin/perl use strict; use warnings; open my $fh, "<", "FileFullPath.txt" or die $!; while (my $line = <$fh>) { chomp($line); #行末の改行コードを削除する print $line, "\n"; } close $fh or die $!; おまけ。 プログラムの入り口で内部表現(utf8フラグ)に変換して受け取り 出口で元に戻したいよねぇーというなら --------------------------------------------------------------------------------- #!/usr/bin/perl use strict; use warnings; use utf8; use Encode; #テキストはutf8で書かれているとする。 open my $fh, "<:encoding(utf8)", "FileFullPath.txt" or die $!; while (my $line = <$fh>) { chomp($line); #行末の改行コードを削除する print encode_utf8($line), "\n"; } close $fh or die $!;
いまいち正確な仕様がわからないので・・・ 一番最初の文字をキーに並び替えを行うということで書いてみたのですが 大きな流れは、こんな感じ。 ファイルに書いてあるデータを読み込む。 1行ずつ受け取りタブでsplitする。 最初の文字をキーに配列に残りデータをpushする 出力。 おしまい。 #!/usr/bin/perl use strict; use warnings; #データの記載されたファイルを開く open my $fh, "<", "hoge.txt" or die $!; my (%hash, @data); while (my $line = <$fh>) { chomp($line); #行末の改行コードを削除する #1.tabで分割 @data = split(/\t/, $line); #2.ハッシュに、最初の文字をキーに。値を配列のリファレンスとみなし # 2番目の要素から最後の要素を配列のスライスとしてpushする push @{$hash{$data[0]}}, @data[1, -1]; } close $fh or die $!; #3.出力 for my $key (sort keys %hash){ #最初の文字(大文字のアルファベット)と残りを配列として扱い tabでjoinして出力 print join("\t", ($key, @{$hash{$key}})), "\n"; }
ダイヤモンド演算子 <> は「改行」まで一緒に取り込みます。 $_ =<stdin> で、$_に改行まで含めた1行が取り込まれています。 対策方法は次のいずれかです。(両方やったら今度は改行がなくなります) ・chomp関数などで末尾の改行を削除する。 ・出力時によけいな改行を付けない。 今回程度ならどちらでもいいです。 過去の質問からして、このあと @data=split(/,/) ; 等として利用するのではないか、と予想されます。 この場合、改行を取り除いておかないと、@dataの最後の要素が改行付きのものになります。 例: 10,11 → splitしたら $data[0]='10'; $data[1]='11\n'; になります。 <>の使い方は、Perlの基礎です。 もうちょっと基礎を勉強した方がよくないですか?
こちらにありますよ http://collie.dip.jp/postmail.html
手元にperlがないので実際に動かしてないですがこんなかんじですかねぇ open (FH, $ARGV[0]); #$ARGV[0]はファイル名 while (<FH>) { @line = split /,/; $x += $line[0]; $y += $line[1]; } close (FH); print "x=$x y=$y";
CGIスクリプトにはWebサーバから標準入力(STDIN)でデータが渡されます。 そうじゃないのもありますけど。 CGI->new()とすると標準入力から読み取ろうとします。 CGI->new()を二つ実行すると、一つ目のCGI->new()が標準入力を掴んで、 二つ目のCGI->new()ではパラメータが取れません。 したがって、通常CGI->new()は一つだけ生成します。 一方のCGI->new()はhtml生成用などで、パラメータを取ったりアップロードファイルを読んだりする必要がないときは、 CGI->new(""); などとすることで、標準入力を掴まないCGIオブジェクトを生成できます。
この例だとCSVとか列とか全然関係無いですね。 常套手段として方針は2つ (1)先に3行だけのCSVにする (2)Perlで3行だけ (1)なら、Cygwinの(というか、UNIX系OSで標準的な) headコマンドとセットにして head -3 data1.csv | perl test1.pl # headコマンドがなんだかわからなければ、man head を実行してみる。 # | (パイプ)がなんだかわからなければ、「標準入出力」「リダイレクト」「パイプ」あたりで検索して概念を覚えておくといろいろ便利 (2)なら、#1を参考に。
メールを送信するときは。文字コードが非常に重要になります。 Content-Type: ヘッダをつけるようにしてください。 ヘッダをつけたとしても、一部のMUAは正しく認識してくれません。 ISO-2022-JPかUTF-8が無難と思われます。 ソースからヘッダを含めてjisに変換しているようですので、適切なContent-Type: ヘッダがあれば良さそうですね。 （ヘッダを含めてconvertはあまりにも乱暴です。） 複数バイト系の文字列は、(まずあり得ませんが)途中通過するMTAで欠落する場合があります。 7bitで表現できないコードは、BASE64でエンコードしてください。 メール送信の仕組みの基本を理解して、プログラミングされる様、お願いいたします。
はじめまして。 >申込者に自動返信（文章つき）をするにはどのように修正するのですか。 提示されたソースコードでは「申込者」に該当する部分が見当たらないので、何がしたいのかわかりません。 申し訳ありませんが、具体的に例示していただけませんか。
画像はヘッダーと呼ばれる部分に画像の種類が書かれていますが、文字はそうなっていません。 ですが、テキストエディタは、自動的に文字コードを判断しています。 文字数が少ないと間違いも多いですが。 仕組みは、コードの特徴で判断しているらしいのですが、詳しくは知りません。 なので、全体の言語の特徴で判断するのはどうですかね？ 文中に複数の言語がある場合は、さらに難しいですが、ある程度は可能かと。 国が決まっているのなら、文章解析で、例外が少ない言語がその言語かと。 日本語解析なんかは、mecabなんかが有名です。 一番簡単なのが、ブラウザなら、送信情報に国の情報をいれるとか。
こんなのとか。
ソースをそのままコピーしたものですか？ No.1さんとかぶりますが、 $date = $cgi->escapeHTML('$date'); '$date'は、シングルクォートは、いらないのではないでしょうか？ あと、 > Date::Simple::data これは、Date::Simple::dateではありませんか？最後は「a」ではなく「e」です。 > $date_check = ''error; シングルクォートが二つ前にあって、errorを括っていません。 以上、ざっと見た範囲で、気になった部分を書いてみました。
位置が決まれば、そこに物体があると。。。？これもうわかんねぇな。 なお、以下の例は 一つの位置に二つの物体があるか、 二つの位置の同じ物体が存在する とたぶん破綻します。 例えば、 x => 1, y=> 2, a => 100, b => 200 x => 1, y=> 2, a => 300, b => 400 x => 1, y=> 2, a => 100, b => 200 x => 3, y=> 4, a => 100, b => 200 表示がくずれるので空白2文字を全角空白にしていることに注意 #!/usr/bin/perl use strict; use warnings; use feature 'say'; use Data::Dumper; { 　　package DualHash; 　　sub new { 　　　　my ( $class, %args ) = @_; 　　　　bless \%args, $class; 　　} 　　sub set { 　　　　my $obj　= shift; 　　　　my %hash = (@_); 　　　　my $x　　= $hash{x} // die 'need x'; 　　　　my $y　　= $hash{y} // die 'need y'; 　　　　my $a　　= $hash{a} // die 'need a'; 　　　　my $b　　= $hash{b} // die 'need b'; 　　　　$obj->{pos}->{$x}->{$y}　= { a => $a, b => $b }; 　　　　$obj->{data}->{$a}->{$b} = { x => $x, y => $y }; 　　} 　　sub get_pos { 　　　　my $obj　= shift; 　　　　my %hash = (@_); 　　　　my $a　　= $hash{a} // die 'need a'; 　　　　my $b　　= $hash{b} // die 'need b'; 　　　　return ( $obj->{data}->{$a}->{$b}->{x}, 　　　　　　$obj->{data}->{$a}->{$b}->{y} ); 　　} 　　sub get_data { 　　　　my $obj　= shift; 　　　　my %hash = (@_); 　　　　my $x　　= $hash{x} // die 'need x'; 　　　　my $y　　= $hash{y} // die 'need y'; 　　　　return ( $obj->{pos}->{$x}->{$y}->{a}, $obj->{pos}->{$x}->{$y}->{b} ); 　　} 　　sub change_pos { 　　　　my $obj　 = shift; 　　　　my %hash　= (@_); 　　　　my $old_x = $hash{old_x} // die 'need old_x'; 　　　　my $old_y = $hash{old_y} // die 'need old_y'; 　　　　my $new_x = $hash{new_x} // die 'need new_x'; 　　　　my $new_y = $hash{new_y} // die 'need new_y'; 　　　　my ( $a, $b ) = $obj->get_data( x => $old_x, y => $old_y ); 　　　　$obj->{pos}->{$new_x}->{$new_y} = { a => $a,　　 b => $b }; 　　　　$obj->{data}->{$a}->{$b}　　　　= { x => $new_x, y => $new_y }; 　　　　delete $obj->{pos}->{$old_x}->{$old_y}; 　　　　if ( 0 == scalar keys %{ $obj->{pos}->{$old_x} } ) { 　　　　　　delete $obj->{pos}->{$old_x}; 　　　　} 　　} 　　sub change_data { 　　　　my $obj　 = shift; 　　　　my %hash　= (@_); 　　　　my $old_a = $hash{old_a} // die 'need old_a'; 　　　　my $old_b = $hash{old_b} // die 'need old_b'; 　　　　my $new_a = $hash{new_a} // die 'need new_a'; 　　　　my $new_b = $hash{new_b} // die 'need new_b'; 　　　　my ( $x, $y ) = $obj->get_pos( a => $old_a, b => $old_b ); 　　　　$obj->{data}->{$new_a}->{$new_b} = { x => $x,　　 y => $y }; 　　　　$obj->{pos}->{$x}->{$y}　　　　　= { a => $new_a, b => $new_b }; 　　　　delete $obj->{data}->{$old_a}->{$old_b}; 　　　　if ( 0 == scalar keys %{ $obj->{data}->{$old_a} } ) { 　　　　　　delete $obj->{data}->{$old_a}; 　　　　} 　　} 　　1; } my $dual_hash_1 = DualHash->new; $dual_hash_1->set( x => 1,　y => 2,　a => 3,　b => 4 ); $dual_hash_1->set( x => 10, y => 20, a => 30, b => 40 ); my ( $x, $y, $a, $b ); ( $a, $b ) = $dual_hash_1->get_data( x => 1, y => 2 ); say $a, ', ', $b;　　# 3, 4 ( $x, $y ) = $dual_hash_1->get_pos( a => 3, b => 4 ); say $x, ', ', $y;　　# 1, 2 ### old_a => 3, old_b => 4, new_a => 300, new_b => 400 ### x => 1, y => 2 $dual_hash_1->change_data( 　　old_a => 3, 　　old_b => 4, 　　new_a => 300, 　　new_b => 400 ); ( $x, $y ) = $dual_hash_1->get_pos( a => 300, b => 400 ); say $x, ', ', $y;　　# 1, 2 ( $a, $b ) = $dual_hash_1->get_data( x => 1, y => 2 ); say $a, ', ', $b;　　# 300, 400 ### old_x => 10, old_y => 20, new_x => 100, new_y => 200 ### a => 30, b => 40 $dual_hash_1->change_pos( 　　old_x => 10, 　　old_y => 20, 　　new_x => 100, 　　new_y => 200 ); ( $a, $b ) = $dual_hash_1->get_data( x => 100, y => 200 ); say $a, ', ', $b;　　# 30, 40 ( $x, $y ) = $dual_hash_1->get_pos( a => 30, b => 40 ); say $x, ', ', $y;　　# 100, 200
一例
　自分はPerlを書かないので直接の回答ではないです（なんとなく、コードの意味はわかりますが）。 　まず「Perlでのファイル処理方法について 」では、カテ違いと思われて、回答が付きにくいです。表題を変えて、再質問する事をお奨めします。 　次にPerlを自由自在に読める人も、少なくともここには余りいないと思います。（数学的）状況を整理し、ふつうの言葉で質問する事もあ奨めします。 　あるいはPerlには、「直線近似ライブラリ」などがあるのかも知れませんね。そうであってもなくても最初に、メニューの、 　　［カテゴリ］⇒［[技術者向け]コンピューター］⇒［プログラミング］⇒［Perl］ の板に同じ質問を投げてみるのは、悪くないと思います。Perlを自由自在に読める人がいる訳ですから(^^)。
一応念のため: #1 にはタイポがある. 本意は BEGIN { undef $/; } s/Convert\(\K.*?text\s*=>\s*(".*?"),/$1/sg;
2つの方法があります。 1）レスがついたときに親記事を呼び出し、親記事を最後にpush()する。 573行目辺りからcloseするまでを書いてあげました。 #ログファイル読み込み open(IN, "$logfile"); @xx = <IN>; foreach ( @xx ){ ($no,$resno,$name2,$subject2,$hp2,$mail2,$comment2,$host2) = split(/,/,$_); if($no eq $res){$oya=$_; } else{push(@xx2,$_);} $no++; } push(@xx2,$oya); push(@xx2,"$no,$res,$namae,$subject,$hp,$mail,$comment,$host\n"); #ログファイル書き込み open(OUT, "> $logfile"); print OUT @xx2; close(IN); close(OUT); 2）レスがついたときに、親記事えお呼び出しての$noを最新の$noに変更するsubを作る。 ただし、表示する$noと順番を管理するIDとしての$noを別に増やさなければいけません。($no,$no2,$res,$name,$subject,$hp,$mail,$comment,$host) とてもシンプルなコードですが、蛇足かもしれませんが。完了メッセージは、一応終了してから表示させた方がいいです。 web上で公開するならいろいろセキュリティをつけなければいけません。
ppmに見つからないモジュールはいつもこうしてます(普通はLinuxサーバでやるんで方法２はごくたまに) 方法その１：モジュール検索に自分のオリジナルディレクトリを追加してみる Email-Simpleのモジュールはみたところバイナリは無さそうですので １．そのままＤＬした後（Email-Simple-2.102.tar.gz） ２．適当なところで解凍 ３．解凍したディレクトリlibを自分の動作させようとしているプログラムのあるところに移動して名前をlibsとかに変える ４．自分のプログラムの頭のほうに「use lib './libs';」とか、１行いれて実行してみる もし駄目なら以下の方法 方法その２： 開発環境を入れて正攻法でモジュールインストールしてみる 　ActivePerlがコマンドプロンプトから実行できるようにしておく(まあ普通にインストールしてれば・・・) 　さらにMinGWとnmake.exe(これは探すの大変かも→ＭＳのＦＴＰサイトにあった：「ftp://ftp.microsoft.com/Softlib/MSLFILES/nmake15.exe」)を入れてgccがmakeでコマンドプロンプトからビルド可能な環境にしておく(この辺はググればいろいろと出てきます：要するにWindows上でgccの開発環境を整える) 　方法２－１． 　　「perl -MCPAN -e shell」でＣＰＡＮサイトからインストール　指示に従ってエラーなく最後まで通れば完了 　さらにもうひとつの方法２－２．（昔のperlモジュール導入方法） 　　ＣＰＡＮから落としたファイルを解凍後、「perl Make.PL」実行後、「make」「make install」でエラーなく最後まで通れば完了 いづれもＰＰＭとは関係ないのでＧＵＩでは情報が出ません 後者はＰＰＭのデータベースがいじれれば更新可能かも、ググって見てください まあざっとですが・・・
案a)sortして、値の切り替わりを見ながら数えてゆく(unix系でよくやるsort|uniq -cの手法)。 案b)連想配列を利用して、それぞれの個数を数える。 ――とか。 Perl FAQの、行の出現頻度を数えるサンプルが参考になりますよ。 http://search.cpan.org/~flora/perl-5.14.2/pod/perlfaq6.pod#How_can_I_print_out_a_word-frequency_or_line-frequency_summary?
mecabには詳しくはないのですが そこのマニュアル見る限り、 > "C:/Program Files (x86)/MeCab/bin/mecab.exe" "今日は晴れだ。" のように、「引数に指定した文字列を解析する」という機能は無く、指定したものはファイル名と解釈されるようです。 標準入力には対応しているようなので `echo "今日は晴れだ。" | mecab` とか open2を使う必要がありそうです。 # パスとか文字コードとは適宜変更する
多分、and の優先順位が , よりも低いせいだと思う。
このコードには、ファイルの読込み処理が書かれていません。 ファイルを読み込むには、通常は、下記の簡単なコードで十分です。 use CGI; print "Content-type: text/html; charset=UTF-8\n\n"; my $query = new CGI; my $filename = $query->param('filename'); my $mimetype = $query->uploadInfo($filename)->{'Content-Type'}; my @mytbl = (); while (<$filename>) { push(@mytbl, $_); } @mytblに読み込んだファイルの内容があります。
qw は実質的に q + split だから.
なんでそんなことをしたいんですか? ハッシュと無名リストへのリファレンス使って my %a =() ; $a{$mystr}=[1,2,3] ; とかやった方がいろいろ便利だと思うんですが。 ・変数名に使えない文字を$mystrに使える ・keys,each,exists等のハッシュを操作する関数が使える
消したいディレクトリの中にファイルが入っていませんか？ まずは、ファイルを全て消してから、ディレクトリを削除してください。 または、ファイルがあっても消す方法が参考URLにありましたので、参照してみてください。
($secg,$ming,$hourg,$mdayg,$mong,$yearg,$wdayg,$ydayg,$isdstg) = gmtime(time + 30*24*60*60); 上記の30が30日ですから半年にしたいなら183にすればOKでしょう。 すると$date_gmtが今日から半年後の日付になると思います。 全ソースみてないので他のコードに不備があればわかりませんが・・・
手元で試してみた... んだけど, 2 の結果は 999 になってる. ちなみに Windows Vista Business, ActivePerl は 5.14.2 Build 1402 および 5.16.0 Build 1600 で確認. なお, 構文解釈上 2 と 3 は同じなので同じ結果になるはずです.
何がどう上手くいかないんですかね？ use POSIX 'strftime'; $SIG{ALRM} = \&timeout; eval { alarm 5; my $str_time = strftime( "%Y-%m-%d %H:%M:%S", localtime ); print "$str_time\n"; my $line = <STDIN>; alarm 0; }; sub timeout { print "time-out\n"; my $str_time = strftime( "%Y-%m-%d %H:%M:%S", localtime ); print "$str_time\n"; exit 0; } --- $ perl -w foo.pl 2012-08-16 03:53:35 time-out 2012-08-16 03:53:40
Shift_JIS使ってませんか? もしそうなら、いわゆる「だめ文字」と呼ばれる問題です。 ーの2バイト目は [ です。「ー」と一文字に見えますが、Perl内部では2文字として処理されます。 そのため、メタ文字 [ に対する ] が無いのでエラーになります。 「ソ」「表」等の2バイト目が\なのは有名ですが、正規表現では、他にも注意しないといけない文字があります。 https://sites.google.com/site/fudist/Home/grep/sjis-damemoji-jp/table Perlで考えたら@もリストに使いますから、正規表現でなくても問題になりえます。 あと、これはPythonでの話しですが、Perlでも同じような現象が起こります。 http://oshiete.goo.ne.jp/qa/7630123.html 最近のPerlなら、 ・ use utf8;してutf-8でスクリプトを記述 ・入出力はencode/decodeでバイト列⇔utf8文字列の変換する。(またはPerlIOを使う) のがいいと思います。 > if (index($::FORM{'body'},$_) >= 0) { index関数は、文字列を単純に比較するだけです。 正規表現ではありません。なので [ が混っていても問題ありません。
ディレクトリに複数ファイルができていいなら CGI::Session::Driver::file - search.cpan.org http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session/Driver/file.pm 一つのファイルにまとめたいなら、DB_Fileを使って CGI::Session::Driver::db_file - search.cpan.org http://search.cpan.org/~markstos/CGI-Session/lib/CGI/Session/Driver/db_file.pm
いや・・・あの No.1さんがもう全部説明してくれてるんだけど・・・ gは本質じゃないから s/<regex>/<replace>/e を考える． eをつけることで，<replace>を実行させる ＃じつは ee というオプションもある・・・ ということで， s/あいうえお/($hensu = $&) =~ tr{ＡＢＣ}{abc}, ($hensu) =~ s{１２３}{123}, ($hensu) /eg; ・・・みにくいから s/あいうえお/ ($hensu = $&)=~ tr{ＡＢＣ}{abc}, ($hensu)=~ s{１２３}{123}, ($hensu) /eg; ってのは，$_ の中の「あいうえお」にマッチした部分が $& にはいって それを $hensu に代入して tr して その結果の $hensu を s{} して， それを $hensu として評価させて 結果，$_ の「あいうえお」を$hensuの中身で置換する ってところかなー こんな書き方自分じゃしないからなー。。。 こんな書き方するよりも 順番に if なり何なりできちんと書いたほうが可読性があがるからいいと思う． ついでに・・・$& ってのは正規表現の効率をめっちゃ悪くするから注意 The use of this variable ($&のこと) anywhere in a program imposes a considerable performance penalty on all regular expression matches. To avoid this penalty, you can extract the same substring by using @-. Starting with Perl 5.10, you can use the /p match flag and the ${^MATCH} variable to do the same thing for particular match operations.
こんにちは。 $req = $ua->request($r); を $req = $ua->get('http://○○/'); に変更するとこちらでは動作しました。
ダブルクォート文字列の中にクォートされたダブルクォートがなければ、次の文で両方に対応できると思います。 my $key = ($line =~ /("[^"]+"|[^,]+)/g)[$ccsv]; $key =~ s/"//g; # 必要かも
こんにちは。 開発しようとしている端末のOSは何でしょうか。 それによって少し異なりますが、手っ取り早いのはxamppを導入すると良いです。 一回のインストールでほとんどのWebの機能がインストールされます。 http://www.apachefriends.org/jp/index.html
10.7でやりましたが次の方法でできました。 まず、5Cで￥と表示されるフォントをさがす必要があります。 文字ビューア（メニューバーのひらがなや英字を選択するところ）でShift-JISコードを表示すればどのどのフォントが使えるかわかります。OSXに最初からインストールされているものでは見つからず、マイクロソフトのフォントのほとんどは￥と表示されますので、ターミナルの表示フォントをそれらにすれば可能です。 私の環境ではoptionキーを押さずに円記号を押すと＼になりますが、何かソフトを入れてたかな？？ MS Office（試用版を含む）をインストールすればマイクロソフトのフォントは自動的にインストールされます。 UTF-8の場合は￥と＼とは違うコードですので気をつけてください。
なぜ誰も質問に回答しないのでしょう? http://search.cpan.org/~rjbs/perl/pod/perlsyn.pod に "Many of Perl's syntactic elements are optional. Rather than requiring you to put parentheses around every function call and declare every variable, you can often leave such explicit elements off and Perl will figure out what you meant. This is known as Do What I Mean, abbreviated DWIM. It allows programmers to be lazy and to code in a style with which they are comfortable." とあるとおり、Perl は省略の多い言語なので読みづらいと思います。 ご質問のプログラムを省略せずに書くと次のようになります。 $seconds = shift(@ARGV) || 60; $| = 1; for $_ (1 .. $seconds) { sleep 1; print "$_\r"; } print "\n"; $s を $seconds に変えてみました。 @ARGV は argument vector の略称で、コマンド プロンプトから >perl timer.pl 180 のようにプログラムを実行した場合に、コマンドライン引数である「180」が格納される配列です。 shift は配列の先頭の要素を取り除いて返す関数ですが、配列を何も渡さないと @ARGV を shift します。 つまり shift() は shift(@ARGV) と同じです。かっこは省略可能なので単に shift と書いても同じです。 (ただしサブルーチンの中での shift は shift @_ を意味します。) したがって $s = shift || 60; というのはコマンドライン引数が渡されたらコマンドライン引数、渡されなかったら「60」を $s に代入するという意味になります。 この書き方はコマンドライン引数を受け取りつつ、デフォルト値も設定したいときによく使われます。 $| = 1; については説明は不要でしょう。 for (1 .. $s) { # ここに繰り返したい処理を書く } の 1 .. $s というのは「1 から $s までの整数のリスト」を意味します。 この .. というのは範囲演算子と呼ばれるもので、たとえば 1 .. 10 と書くと (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) というリストを簡単に作ることができます。 しかし、この場合は「1 から $s までのリストを作る」というよりかは、「要素数 $s のリスト」を作って、それを for 文でループすることにより、「$s 回ループさせる」ことを目的としています。 たとえば同じ処理を 10 回繰り返したいときは for (1 .. 10) { # ここに処理 } と書けばよいわけですが、それと同じで for (1 .. $s) { # ここに処理 } と書くことで同じ処理を $s 回繰り返すことができるわけです。 繰り返すごとに $_ に 1 から $s までの整数が順番に代入されていきます。 sleep 1; を $s 回繰り返せば $s 秒 sleep したことになりますから、もとのプログラムの意味が明らかになったかと思います。 また何かありましたら補足してください。
適当。表示がくずれるので、空白2文字を全角空白にしていることに注意。 #!/usr/bin/perl -T use strict; use warnings; use utf8; use CGI; use CGI::Carp qw(fatalsToBrowser); use CGI::Pretty; use Encode; use LWP::UserAgent; use HTTP::Response; use HTML::TreeBuilder; use constant URL => q{http://ejje.weblio.jp/content}; my $q　　= CGI->new(); my $word = $q->param("word"); my $mean = q{}; if ( defined $word ) { 　　my $ua = LWP::UserAgent->new; 　　$ua->agent('Mozilla/5.0'); 　　$ua->timeout(10); 　　my $url = URL . '/' . $word; 　　my $req = HTTP::Request->new( GET => $url ); 　　my $res = $ua->request($req); 　　if ( $res->is_success ) { 　　　　my $tree = HTML::TreeBuilder->new; 　　　　$tree->parse( decode( 'utf8', $res->content ) ); 　　　　my ($attr) = $tree->look_down( 'class', 'Kejje' ); 　　　　$mean = $attr->as_HTML; 　　} 　　else { 　　　　$mean = $res->error_as_HTML; 　　} } else { 　　$word = ''; } my $body = do { local $/; <DATA> }; $body =~ s/%%word%%/$word/; $body =~ s/%%mean%%/$mean/; binmode STDOUT, ':encoding(utf8)'; print $q->header( -charset => 'UTF-8' ), 　　$q->start_html( -title => "test", -lang => 'ja', ), 　　$body, 　　$q->end_html; __DATA__ <form method="get"> Word : <input type="text" name="word" /><br/> <input type = "submit" /> </form> <hr> Word : <br> %%word%% <br> Mean : <br> %%mean%%
関西電力の方でエラーが出ないというのは間違いですね。それだけ抜き出して 試してみてください。同じエラーになると思います。 で、何が問題かというと、LWP::Simpleモジュールを読み込む前に、そこで定義されている head関数を使っていることです。use文をファイル冒頭に移動すれば問題ないと思います。
これとかどうですか http://collie.dip.jp/LinkShu.html
PODを見ながらやってみました。 こんな感じではないでしょうか。 #!/usr/bin/env perl use v5.16; use warnings; use utf8; use open IO => qw/:utf8 :std/; use autodie; use XML::LibXML; my $string = << 'EOF'; <?xml version="1.0" encoding="UTF-8" standalone="no"?> <!DOCTYPE aaa PUBLIC "-//bbb//CCCC//EN" "ddd.dtd" []> <doc> ....... </doc> EOF my $dom = XML::LibXML->load_xml(string => $string); my $dtd = $dom->internalSubset; say ref $dom; say ref $dtd; say $dtd->toString; 「XML::LibXML::Element」には、DTDを取り出すメソッドがないくさいので、もともとの「XML::LibXML::Document」オブジェクトから「XML::LibXML::Dtd」オブジェクトを引っこ抜いてくるのが楽な気がします。 結果は下記のようになりました。 XML::LibXML::Document XML::LibXML::Dtd <!DOCTYPE aaa PUBLIC "-//bbb//CCCC//EN" "ddd.dtd"> 僕もあまり詳しいわけではありませんので、ご参考になるかどうかわかりませんが……。
えぇっと.... わざわざそんな面倒なことをする理由が思いつかない. 配列とリファレンスを使えば同じことができる. たとえば「lineほげほげ」は, 配列を使って ${'line'.$i} = $_; の代わりに $line[$i] = $_; とすればより簡単になるのでは. ところで, forループの中で my するとその変数は「forループの外」では使えないような気がするんだが....
学習したいなら目標をあれやこれや欲張らずに基本から一つ一つこなしましょう プラモ作るのが得意だからといって実用的なジャンボジェット機がそのまますぐ作れるわけではありません 「ローカル」とか「サイト制作」とか記述されてますのでWindows環境だと思いますが適切なアドバイスが必要なら利用環境も記述したほうが良いと思います XPなら構築は簡単ですがVista以降はちょっと面倒な場合があります お手軽に構築する手段としては、今まで入れた単体のapacheとか全部取っ払って「xampp」をひとつ入れれば必要な環境は整うでしょう ただし、perlにこだわりがあってActivePerlでないとやだって人は、xamppの古いバージョンのxampplite　＋　ActivePerl　＋　lnhdr-1.52-x86.msiがお勧め インストールや使い方はそれぞれの説明サイトをしっかり読んでください また、これで構築できても理解できてることにはならないことに注意してください 認識されている部分で、多分早とちりされていると思われるところを指摘します > ●Perlを使えるようにしたいと思い、perlを使っている友人に相談。 > 　すると、httpdをインストールするように言われインストールする。 まずはWebサーバ環境を用意しろという意味だと思います 今あるものとは別にという意味ではないと思います Webサーバにも確かに種類はありますがここで言ってるhttpdというのはApache2だと思います もちろんCERNのhttpdという可能性も有ります。 どちらにしても学習用なら特殊な事情がない限りWebサーバはひとつあれば充分です > ●しかし、ポート番号が塞がっているらしくhttpdを起動できない。 なにも設定チューニングをせずに使おうとするとデフォルトでポート80が指定されてるから後から動かしたほうがエラーになります ひとつの便所を複数人で使おうとするようなもんです ひとつのWebサーバで設定により複数のポート番号を使うことも条件付（勝手に使っちゃいけない番号がある）で可能です。 ところでポートってなにか知ってますか？　Well known portとか。もし知らなければまずはTCP/IPの基本からはじめましょう。 > ●ググった調べてみると、appacheの設定をイジることで、apacheでperlを動かせられるということを知る。 ただ、Webサーバの設定をいじっても動かせるとは限りません それと、apacheが動かすんじゃなくて、apacheがcgiを通してOSにwebクライアント権限でプログラムを動かすようにオーダーを出すだけで、条件が整ってれば動作するしそうじゃなければ拒否されます システムのプログラムですからperlだろうがC言語(コンパイル要)だろうが、標準入出力を持ったOSの下で動作するプログラム言語なら何でも良いのです > ●現在、解決方法に対する自分の認識は、[１]httpdで使うポート番号を他のものに変える 　 [２]apacheの設定をイジってperlを使えるようにする。 ポート番号は何の関係もありませんし解決策にもなりません apacheの設定も必要だがperlのシェバング指定(1行目)のパスと実際にインストールされているperlのパスをそろえることが大事 基本的なことですが「ファイル(通常：テキスト・通常：バイナリ・ディレクトリ・キャラクタ型デバイス・ブロック型デバイス)」「パス」「環境変数」「リンク(特にシンボリックリンク)」ってなにかがわかっていないと自力では障害対応は困難です 本格的に勉強するなら古いＰＣなんかにＬｉｎｕｘやＢＳＤでサーバ立ち上げて室内にＬＡＮを組みapacheなんかはtarボールから試行錯誤してインストールしたほうがよっぽど勉強になると思います
パスが通らない、となるとカレントディレクトリが違うのでしょう。 それを調べて見ては。
仕様です.
あの、私のや他の回答をよく読んで考えてください。 for(my $i=0;$i<@data;$i++){ $data[$i]=Encode::from_to($data[$i],'shiftjis','utf8'); #Shift-JISからUTF-8に変換 $data[$i]=~s/\s+//g; print OUT $_; } この部分は **** $_には何の影響も与えません **** よって、** 出力に関することだけに注目したら ** for(my $i=0;$i<@data;$i++){ print OUT $_; } これと等価です。どこで「Shift_JIS からUTF-8へ変換」してますか? $_は「while (<IN>){」の<IN>で1行読み込まれ、「chomp ($_);」で末尾の改行コードが削除されただけで、移行なにも変化していません。コードは入力のまま=Shift_JISです。それをそのまま出力すればShift_JISになるのが正解です。 しかも、項目数分だけ繰り返し出力されます。 (重複行になる、と#1に書いたのはchompのことを失念していた私のミスです) @dataを変更したのなら、出力するのは@dataでしょう。 join(",", @data)とすれば、項目をカンマ区切りの文字列にすることができます。 あと#2にあったfrom_toの使い方。マニュアルをよく読みましょう http://perldoc.perl.org/Encode.html#[$length-=]-from_to($octets,-FROM_ENC,-TO_ENC-[,-CHECK]) ・$octetsを直接変換する ・$octetsの長さを返す とあります。つまり $data[$i]=Encode::from_to($data[$i],'shiftjis','utf8') だと,$data[$i]には元の内容は破棄されて、文字列の長さになってしまいます。 各項目毎に処理したい、という意図はわかりました。 ですが、文字コードの変換が項目毎に違うなんてことはまず無いでしょう。 それならば、$_で1行をコード変換→splitして項目毎の処理、としてもいいのでは? ついでにPerlIOを使って open (IN, "<:encoding(shift_jis)", $input_file) or die "$!"; open (OUT, ">:utf8", $output_file) or die "$!"; とでもやれば、プログラム中はコードをあまり意識せずに文字列処理ができます。
こんにちは。 1,2ヶ月がじっくり腰を据えてなのか、ほかの仕事の合間なのかにもよりますが、やる気次第だと思います。 良い機会ですので一つ一つクリアしていけるように勉強しては如何でしょうか。 (perlでもPHPでも良いですが) メールを送る機能の要件を満たしているのであればperlでのDB登録を勉強するのが早いでしょう。 perlでmySQLへの接続等 http://tech.bayashi.net/pdmemo/perl_dbi_mysql.html (他のDBでも大差ないと思います)
sudo yum install -y perl-CPAN
とりあえず perldoc は見るべし. スコープをおいておけば 1. $test = 0; 1'. ($test) = 0; とか 2. @test = (0, 1, 2, 3, 4, 5); 2'. (@test) = (0, 1, 2, 3, 4, 5); とかの違いを考えればよく, 下は全く同じです. 上の 2つは, 1 では左辺がスカラーなので右辺もスカラーコンテキストで評価されるのに対し 1' は左辺が配列であるため右辺も配列コンテキストで評価します. とはいえ, 今の場合は右辺をスカラーコンテキストで評価しても配列コンテキストで評価しても大差ない結果になります (逆にいうと「コンテキストによって結果が変わる式」を使うなら違う結果になる, ということでもある). 一方, my は「単項演算子」とみることができるため, my ($foo, $bar); と my $foo, $bar; とでは違う意味になります.
glob関数は?
ん～, perldoc を読んだ限りでは無理っぽいです. とりあえず @ で受けておいて, サブルーチンの方でチェックするしかないんじゃないかなぁ....
このプログラムは、おそらく期待通りの動きをしません。 ここに書かれた通りならプログラムが間違っています。あなたが入力したのなら、入力間違いしていると思われます。 使われている命令自体は、Perlの基礎です。 なので、個々の命令については理解はできているものとして、解説はしません。 「連結リスト」という、データ構造は理解できてますか? それを、このプログラムではどうやって実現させてますか?ハッシュ?クラス?リスト(データ構造としての連結リストではなく、Perlの機能としての)? $old = A→B→C→D→undef(終端判別用) となっているリストを $new = D→C→B→A→undef にして、$newを返す、というのが期待される動作だと思われます。 ここで「→」は A->NEXT = B となっていることを表現しています。 my&new=undef; は my $new=undef; の間違いでは。 連結リストにハッシュが使われているなら {'NEXT'} 等と{}を使います。 リストが使われているなら、どこかで use constant NEXT=>1 などとNEXTに値を設定しているはずです。 どちらが正しいか、あるいは、これ以外なのか、確認してください。 動作がわからないなら、コンピュータになったつもりで、自分で実際に実行してみましょう。 ・初期状態 undef($new) A($old)→B→C→D→undef ・whileループ A($cur,$old)→B→C→D→undef ・$oldを次の位置へ A($cur)→B($old)→C→D→undef ・$curの矢印を$newへ変更 undef($new)←A($cur) / B($old)→C→D→undef ・$newを変更: これが提示されてるプログラムに抜けている undef←A($cur, $new) / B($old)→C→D→undef ・whileの次のループ undef←A($new) / B($cur, $old)→C→D→undef ・$oldを次の位置へ undef←A($new) / B($cur)→C($old)→D→undef ・$curの矢印を$newへ変更 undef←A($new) ← B($cur) / C($old)→D→undef ・$newを変更 undef←A ← B($cur, $new) / C($old)→D→undef 以下同様。最終的に undef←A ← B← C ←D($new) / undef($cur, $new) でwhileの条件が偽→終了
## 面白そうだったので、自分流に書いてみました。 ## 適当に書いたので、バグがあったらごめんなさいです。 ## ← ##で始まる行は解説用コメントです use strict; use warnings; use utf8; binmode(STDOUT, ':utf8'); binmode(STDERR, ':utf8'); ## エラー出力も考慮しましょう my $dir = './data'; # 処理するディレクトリ my $motoFile = 'customer.txt'; # もとファイル # データファイル読み込み my @array; open(my $fh, '<:encoding(cp932)', "$dir/$motoFile") or die 'ファイルが開けません。',"$!"; while(my $line = <$fh>) { chomp $line; ## 「配列リファレンスの配列」を作る。複数カラムでのソートが楽になります push(@array, [ split(/,/, $line) ]); } close($fh); # 配列リファレンス内の指定カラム値を比較して配列をソート ## どこを使ってソートするかわからなかったので ## とりあえず[37]～[41]でソート my @sorted = sort { $b->[37] <=> $a->[37] || $b->[38] <=> $a->[38] || $b->[39] <=> $a->[39] || $b->[40] <=> $a->[40] || $b->[41] <=> $a->[41] } @array; # ソート済みデータファイル出力 ## 分類用フラグは後付けで計算 open(my $fh_out, '>:encoding(cp932)', "$dir/out.txt") or die "Can't open: $!"; for(my $i=0; $i<192; $i++) { # 192等分したブロックの先頭と終了のインデックスを求める ## 余りの分を先頭に近いブロックに寄せる方法については宿題としておきます（難しくないです） my $start = int(@sorted * $i / 192); my $end = int(@sorted * ($i+1) / 192) - 1; # 分類用フラグの計算 my @flag_value = ( int($i / (4 * 2 * 4 * 2)) % 3 + 1, int($i / (2 * 4 * 2)) % 4 + 1, int($i / (4 * 2)) % 2 + 1, int($i / 2) % 4 + 1, $i % 2 + 1, ); # 出力範囲の表示 ## とりあえず標準出力に。 ## データ形式に合わせて見やすいように整形するといいでしょう printf( "[%d, %d, %d, %d, %d] (%s, %s, %s, %s, %s) ～ (%s, %s, %s, %s, %s)\n", @flag_value, @{$sorted[$start]}[37..41], @{$sorted[$end]}[37..41], ); # ブロック毎にフラグを上書きしながら出力 for(my $j=$start; $j<=$end; $j++) { ## 分類用フラグをどこに立てるかわからなかったので ## とりあえず[2]～[6]に立てる @{$sorted[$j]}[2..6] = @flag_value; # 出力 print $fh_out join(',', @{$sorted[$j]}),"\n"; } } close($fh_out); ## 具体的な用途が不明なので以下は独り言ですが、 ## 正直なところ、カラム内にインデックスフラグ立てるメリットは ## ほとんどない気がします・・。 ## 結果を別ファイルに分けるならわかるのですが、それならなおさら ## カラム内にフラグを持たせる必要はないように思えます。
とりあえず「if文の書き方」を学び直すべし. あと, 9行目のエラーは「1行目にエラーが出ないこと」をふまえてじっくり見直すとわかるかもよ.
＞WWW::MechanizeはJavascriptは実行できないのでしょうか？ そうですね。 Javascriptでやっていることと同等のことを自分でプログラムする必要があります。
[ANo.1] の補足をみて、一つわかったこと。 ｜ちなみに、 ｜XSLファイル内で、 ｜<xsl：output method="xml"> ｜を指定してから、 ｜XSL変換を実施すると、 ： ： ： ｜XML形式ではなくて、 ｜text形式でファイルが出力されてしまう xslt が XML を出力するように書いてないからじゃない？
たしかに、constantで実行前にエラーになりましたね。ただし、以下の場合は通ります。 - MyUtil::KEY_FOO_NAME を KEY_FOO_NAME と書いちゃう - MyUtil::KEY_FOO_NAME を書き忘れちゃう use strict; use warnings; use feature 'say'; { 　　package MyUtil; 　　use constant KEY_FOO_ID => 'id'; 　　use constant KEY_FOO_NAME => 'name'; 　　sub foo { 　　　　my ($args) = @_; 　　　　say "id[" , $args->{MyUtil::KEY_FOO_ID} , "] "; 　　　　say "name[" , $args->{MyUtil::KEY_FOO_NAME} , "] "; 　　} } MyUtil::foo( { MyUtil::KEY_FOO_ID => '01', KEY_FOO_NAME => 'YAMADA' } ); MyUtil::foo( { MyUtil::KEY_FOO_ID => '01' } ); とりあえず、考え付くのは、 1. 新しく提案されたconstant hash key方式を使う 2. 諦めてruntime checkする 3. 1.と2.を組合せる 4. Perl6だと名前付きのパラメータを指定できる(?)よくわかんない http://perlcabal.org/syn/S06.html#Named_arguments --- runtime check ----- 自分で use strict; use warnings; use feature 'say'; use Error qw(:try); sub valid_args { 　　my $params_ref = shift; 　　my $args_ref　 = shift; 　　for my $param ( @{$params_ref} ) { 　　　　if ( !exists $args_ref->{$param} ) { 　　　　　　die "Not passed : $param for ", ( caller 1 )[3], '()'; 　　　　} 　　} } sub foo { 　　valid_args( [qw(name age)], {@_} ); } foo( name => 'A', age => 1 ); try { 　　foo( age => 1 ); } catch Error with { 　　my $e = shift; 　　say $e->text;　　# Not passed : name for main::foo() }; ----- モジュールで use strict; use warnings; use feature 'say'; use Error qw(:try); use Sub::Args; sub foo { 　　my $args = args( 　　　　{ 　　　　　　name => 1,　　# mandatory 　　　　　　age　=> 0　　 # optional 　　　　}, 　　　　@_ 　　); } foo( name => 'A' ); foo( name => 'A', age => 1 ); try { 　　foo(); } catch Error with { 　　my $e = shift; 　　say $e->text; }; ----- 引数の明示という観点からのPerlモジュール群 | hirobanex.net http://hirobanex.net/article/2011/06/1306973413
cookieをprintしたあとにスリープして待ってるでしょ。 ブラウザはHTTPリクエストを投げるとき、以下のような文字列を投げる。ようするに、「開いた」ときにcookieを投げる POST /xxxx.cgi HTTP/1.1 Cookie: hoge="fuga"; ... ダイナミックにセット/ゲットしたけりゃ、javascriptでcookie読み書きして、AjaxでCGIと通信するしかない。
perldoc perlre ... x Extend your pattern's legibility by permitting whitespace and comments. Details in "/x" ... xモディファイヤは、正規表現が見やすいように、空白とコメントを許可します。 表示がくずれので空白2文字を全角空白で書いていることに注意 use feature 'say'; my $text = ' Hello '; $text =~ s/ 　　　　　　　[ ]Hello[ ] # greeting 　　　　　/!!! Word !!!/x; say $text; # !!! Word !!!
＞『変数(1)』の値と別の『ハッシュ(2)』のキーに一致するものがあれば、ハッシュの値を『別のスカラー変数(3)』に代入したい 変数(1) ≡ $a、ハッシュ(2) ≡ %h、別のスカラー変数(3) ≡ $b――として、 $b = $h{ $a } ――で良いんでは。 一致しないときの仕様がdon't careということで。
split にて分割をすればよさそうです。 my @strlist = split(/ /, "AAA aaa AaAa"); $strlist[1];
␣はスペースということですね？ #!/usr/bin/env perl my @array1; my @array2; while(<DATA>) { 　　# WAY1: use regexp 　　my ($str) = $_ =~ /^.+?\s(.+?)\s.+$/msx; 　　push(@array1, $str); 　　 　　# WAY2: use split 　　my @columns = split(' ', $_); 　　push(@array2, $columns[1]); } print "$_\n" foreach @array1; print "$_\n" foreach @array2; __DATA__ AAA aaa AaAa BBB bAb BbBb CCC Abc CcCc
このプログラムがしているのは、パスワードとして利用可能な文字を@wordsに登録し、その中からランダムに文字を選ぶということですよね？これだと、記号が選ばれる可能性はあっても、必ず記号が選ばれるかは保証されません。なぜなら、期待する条件を満たすかをチェックするコードは一切無いからです。 つまり、 for (my $var = 0; $var < $lng; $var++) { my $words_num = @words; $ps = $ps . "@words[rand($words_num)]"; } という、パスワードを生成しているコードを下記のようなコードに書き換える必要があるでしょう。 while (1) { for (my $var = 0; $var < $lng; $var++) { my $words_num = @words; $ps = $ps . "@words[rand($words_num)]"; } 条件を満たすかチェックし、満たした場合のみbreak, 満たさない場合は$psを''でクリア。 } $num などの条件を一切無視すると、チェックするコードはこんな感じですね。 if ($ps =~ /[0-9]/ && $ps =~ /[a-z]/ && $ps =~ /[A-Z]/ && $ps =~ /[#$%()-=略]/) { break; } else { $ps =''; }
起動時のカレントディレクトリが異なる理由や変え方は分かりませんが、 スクリプト側でしょっぱなに chdir(dirname($0)); のようにして 明示的に移動してしまってはいかがでしょうか。 use Cwd; use File::Basename; my $scriptDir = dirname($0);# あるいは __FILE__ から取り出す printf("%s: %s\n", '$0', $0); printf("%s: %s\n", '__FILE__', __FILE__); printf("%s: %s\n", 'cwd', cwd()); printf("%s: %s\n", 'ENV-p', $ENV{'PWD'}); printf("%s: %s\n", 'ENV-s', $ENV{'SCRIPT_FILENAME'}); # CGIで動かすときはこれを使う?(未確認) print "\n*** chdir to $scriptDir\n"; chdir($scriptDir); printf("%s: %s\n", 'cwd', cwd()); $0 や __FILE__ に「フルパス」が入っているかどうかは環境依存らしいですが、 Windows(7(x64) および XP(x86)) で ActivePerl (5.14.2)を動かす分には 期待通りに動作するようです。
1行1文ならばとりあえずどうやって文単位で分割するかは考えないで済みます。 一番簡単なのは、入力ファイルを2回読むことです。1回目は全部で何行(何文)あるかを数えるだけ、その結果を使って先頭から10%と末尾から10%にあたる行(文)を別のファイルに書き出すのが2回目。 入力ファイルを1回しか読んではいけないという条件がつくと少々面倒になりますし、先頭から10%の出力を行うのに必要なメモリ量が膨れあがります。
こんにちは。 先にpunycode変換してはいかがでしょうか？ そうすれば半角英数になるので扱いができると思います。
こんにちは。 １つ質問させてください。 Perlでプログラム言語をかけますか？ 区切り文字などの指定がなかったので ご自分で編集することができるということであれば ざっくりとプログラムを回答させてもらいます。 ＥＯＳは改行とありますが、level表記の後には改行はないのでしょうか？ Car car level1 Airplane airplane level1 Snacks 　snacks level2 ... [改行] Upon upon level3 ということでしょうか？ あと、要望の確認ですが、 １．三つのファイルがあります。 ２．ファイル２を読み込んでファイル２内の第二引数を配列Ａに取り出します。 ３．ファイル３を読み込んで単語と、出現回数のハッシュＢに取り出します。 ４．配列Ａの単語がハッシュＢのキーと一致する（単語で同じものがあれば）場合 　　ハッシュＢの値を加算してハッシュＢ２をつくります。 ５．ファイル１を配列Ｃに読み込みます。 --------------------------------------- ここまではなんとなくわかるのですが、それ以降がよくわかりませんので わかりやすく説明していただけると助かります。 （該当行というのが不明なのですが）ハッシュＢのキー（もしかしたら配列Ａ）の単語が 　含まれている配列Ｃを探し出す。（複数行含まれている場合は1つだけ？） 該当の行（配列Ｃの行番号のこと？）と、ＥＯＳまでの出現回数（これはをハッシュＢ？それともハッシュＢ２？？）を出力し、その都度、出現回数の多い順に文をソートするプログラム
りだいれくと それにしても, 「@words[0]」なんて書き方誰が教えるんだろう....
http://code.activestate.com/ppm/XML-LibXSLT/ XML-LibXSLT is unavailable in PPM, because there aren't any builds for it in the package repositories. Click the linked icons to find out why. だそうです．つまり「オフィシャル？なものはない」ので ないものは入れられないということなのでは？
>21000×0.7は14700のはずかと思いますが、なぜか14699になってしまいます。 浮動小数点の誤差…でしょう。 http://d.hatena.ne.jp/perlcodesample/20080828/1219924206 とか見てみるとよいかと。 21000×7÷10で計算してみてはどうですかね？
＞と思い、ネット上を探しておりましたが、 ＞具体的な方法が見つけられなかった為、 XML::libXML 定番だと思うがこれじゃだめなの？ XML::libXML::Dtdってのもある． ＃Dtdを読ませることはないのでXML::libXML;Dtdは使ったことはない
まず、<*.html>が原因かどうかの確認。 @files = <*.html> ; だけのスクリプトが動作するかどうか。 動作しないようなら、ここでのメモリ不足なので、対策をする。 例えば、opendir, readdir, closedir を使う。 my $dirname = '.' ; opendir my $dp, $dirname ; while(my $fname = readdir $dp){ # 今回はカレントディレクトリなので不要だが # readdirでは名前しか得られないので、実際にopenなどで使うには # opendirに使ったディレクトリを追加する my $fullname = $dirname . '/' . $fname # html以外は対象外 if ( $fname !~ /.*\.html$/ ) { next ; } ... $fname/$fullnameについての処理 ... } closedir $dp; 動作するようなら、その後の処理が問題。 今のやり方(一時ファイルに出力→リネーム)でやるなら、@record=<IN_FILE>;などと全部取り込まなくても、一行ずつ処理すればいい。 @record=<IN_FILE>; foreach $record (@record){ $record =~s/aaa/bbb/isg; } print OUT @record → while(my $record = <IN_FILE>){ $record =~ s/aaa/bbb/isg; print OUT $record }
Mozilla Thunderbirdのメニュー「ツール」＞設定とデータのインポートで、Outlookを対象に選択できると思いますが、取り込めたら、Thunderbirdに、次のAddonのImport Export Toolsを入れたら、対象フォルダの右クリック＞インポート・エクスポート＞「フォルダ内のすべてのメッセージをエクスポート」で、個々のtextファイルまたは単一のtextファイルにエクスポートできます。 但し、添付ファイルは当然落ちますが、添付ファイル名はメールの内容の末尾にスタンプされます。 https://addons.mozilla.org/ja/thunderbird/addon/importexporttools/ その他、Thunderbirdに取り込む方法として、次のOutlook Export Toolで、Outlook.pstをターゲットに各通のemlファイル（一応、テキストファイルの一種）に変換抽出できれば、Thunderbirdのフォルダ画面にドラッグ＆ドロップや、Import Export Toolsを導入後では、入れたいThunderbirdのフォルダの右クリックメニューから、emlファイルのあるフォルダから一挙に取り込めます。 http://www.yamamototakashi.com/soft/outlookexporttool/
一行ずつ$q->p()してるので、 　<p><FONT color="blue">【a】</FONT></p> 　<p><INPUT TYPE="text" NAME="mmm" VALUE="" SIZE="25" MAXLENGTH="25"></p> になっているのでしょう。pタグは分かりますよね？ $q->p()は消して、こっちの方がラクかも。 # EOF（任意の文字）で囲まれた範囲を$bodyに代入する my $body = <<EOF; <body> <font... 　. 　. 　. EOF # ココ、先頭にスペース入れたりすると動かないので注意 print $body; CGIのモジュールはパラメータ受け取ったりするのは便利ですが、 ちょっとしたHTML書くだけなら #!/usr/bin/env perl my $msg = "<div>Hello, World!</div>"; print "Content-type: text/html\n\n"; print $msg; これでも。
これ、結果どうなったか、ブラウザで、実際の表示とソース、両方確認しましたか? textareaに"$testbr" と表示されたのではないですか? #ついでに、ソースを見れば「value=$initText」となっているはずです。 ' (シングルクオート)と "(ダブルクオート)での挙動の違いを理解してください。 Perlの基本です。 '<textarea name="freeans" rows="5" cols="30" value=$initText wrap="hard">あいうえお"$testbr"かきくけこ </textarea>' では、これ全体がシングルクオートで括られた1つの文字列です。 シングルクオートの中では$での変数の展開等は行いません。 よって"$testbr"は、そのまま「"$testbr"」という文字列になります。 \による展開も\自身と'にしか効かないので '<textarea name="freeans" rows="5" cols="30" value=$initText wrap="hard">あいうえお\nかきくけこ </textarea>' も改行にはなりません。 一旦閉じて文字列の連結を使うとか '<textarea name="freeans" rows="5" cols="30" value=' . $initText . ' wrap="hard">あいうえお' . $testbr . 'かきくけこ </textarea>' ダブルクォートを使う(文字列中のダブルクォートは\でエスケープ)とか "textarea name=\"freeans\" rows=\"5\" cols=\"30\" value=${initText} wrap="hard">あいうえお${testbr}かきくけこ </textarea>" が常套手段でしょう。
こんにちは。 セキュリティを強化するためには、どのようなタイプの攻撃手法があるかを 知っておく必要があります。 そして、それぞれに対して、どのような対策を取るのかということを 考えなくてはいけません。 Ｐｅｒｌに限った話ではないですが、ＷＥＢ上のプログラムにおいて 特定の言語向けに考えられた手法を除いて一般的な攻撃手法は ほぼ同じです（SQLインジェクション等） その上で本をご紹介します。 不正アクセスや情報漏えいを防ぐWEBアプリケーションのセキュリティ完全対策 http://www.amazon.co.jp/Web%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E5%AE%8C%E5%85%A8%E5%AF%BE%E7%AD%96%E2%80%95%E4%B8%8D%E6%AD%A3%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%82%84%E6%83%85%E5%A0%B1%E6%BC%8F%E6%B4%A9%E3%82%92%E9%98%B2%E3%81%90-%E5%BE%B3%E4%B8%B8-%E6%B5%A9/dp/4822229718 セキュアなWebアプリケーション開発 http://www.amazon.co.jp/%E3%82%BB%E3%82%AD%E3%83%A5%E3%82%A2%E3%81%AAWeb%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E9%96%8B%E7%99%BA-%E3%83%95%E3%82%A9%E3%83%AA%E3%82%B9%E3%82%BF%E3%83%AB-%E3%82%B8%E3%82%A7%E3%83%95/dp/479731804X/ref=sr_1_1?s=books&ie=UTF8&qid=1337052163&sr=1-1 また、よくあるセキュリティホールをまとめてくれているＯＷＡＳＰなども参考になります。 https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project http://owasptop10.googlecode.com/files/OWASP%20Top%2010%20-%202010%20Japanese-A4.pdf 上で紹介させていただいたような個別のセキュリティについて難しいなと思われるのであれば 簡易的にはなりますが２つ対応策があります。 完璧なセキュリティというよりは、とりあえずセキュリティ対策してますというレベルですが、 簡単ないたずらレベルであれば攻撃は免れます（＾＾） １．フレームワークや抽象化ライブラリを利用すること。 　　フレームワークや抽象化ライブラリには攻撃を防いで切れるコードが含まれています。 　　（正確に言うと”含まれていることが多い”ですが、一般的なものは含まれています） 　　ただし、フレームワーク側のセキュリティホールをつつかれる恐れはありますが、 　　何も対策していないよりはましではないでしょうか。 ２．ＷＥＢサーバー側でセキュリティを確保すること。 　　mod_securityや、Webアプリケーションファイアウォールにてセキュリティを確保するやり方です。 セキュリティについて勉強することは大変だとは思いますが、ある程度は勉強しないと難しいとおもいます。 PHPなどはPerlに近い言語のため、攻撃手法を知るための書籍として購入して 対策方法はＷＥＢで探すというのも1つの手だとは思います。 例えば、”SQLインジェクション Perl”や、”XSS Perl”、”CSFR Perl”などで検索するイメージです。
丸数字はJISコードで定義されてないので、括弧１等に置換するしかない。 s/\x{2460}/(1)/ とかでしょうか。
fetchrow_hashrefが「一般的」では無い文字(≒いわゆる半角英数記号以外)を\でエスケープした形式で表示しているだけで、実際には \x{767b}→登 です。 $a = $VAR1->{'登録日'}とすれば $aに2012-05-06 00:52:40.39496が入ります。 (use utf8;してあって、スクリプト自体がUTF-8で記述されている場合) このあたりの扱いは少々ややこしいので、下記のようなサイトや参考書をよく読むことをお勧めします http://perldoc.jp/docs/perl/5.10.0/perlunicode.pod http://www.rwds.net/kuroita/program/Perl_unicode.html
$ping->service_check( 1 ); ――を追記してみるとか。
単に「動きません」じゃなくて、どう動かないのかを書きましょう。得られた出力が自分の期待していたものと違うとか、プログラムは起動するけど途中でエラーになるとか、そもそも起動できないとか。 あとはそのCGIプログラムを動かす環境についての情報も必要です。OS、Perl、HTTPサーバなどの種類とバージョンは欲しいところ。/usr/local/bin/perlとあるから何らかのUNIX系OSなのだろうというところまでは推測できますが。 本題に戻ると、1行目と2行目の後に use MIME::Base64 (); を足したらどうなりますか？ また、"Content-type:"のコロンの後ろには空白を1文字入れておくのが一般的でしょう。
表示がくずれるので、空白2文字を全角空白にしていることに注意。 use strict; use warnings; use utf8; use CGI; use CGI::Carp qw(fatalsToBrowser); use CGI::Pretty; use HTML::Template; my @week_caps = ( 　　{ jp => '日', class => 'sunday' }, 　　{ jp => '月', class => 'monday' }, 　　{ jp => '火', class => 'tuesday' }, 　　{ jp => '水', class => 'wednesday' }, 　　{ jp => '木', class => 'thursday' }, 　　{ jp => '金', class => 'friday' }, 　　{ jp => '土', class => 'saturday' } ); my @calendar = ( 　　[ '', '', 1,　2,　3,　4,　5 ], 　　[ 6,　7,　8,　9,　10, 11, 12 ], 　　[ 13, 14, 15, 16, 17, 18, 19 ], 　　[ 20, 21, 22, 23, 24, 25, 26 ], 　　[ 27, 28, 29, 30, 31, '', '' ] ); my @month_weeks = (); for my $week (@calendar) { 　　my @wdays = (); 　　for my $i ( 0 .. 6 ) { 　　　　push @wdays, { class => $week_caps[$i]->{class}, day => $week->[$i] }; 　　} 　　push @month_weeks, { WDAYS => \@wdays }; } my $template = HTML::Template->new( filehandle => *DATA ); $template->param( 　　WEEK_CAPS　 => \@week_caps, 　　MONTH_WEEKS => \@month_weeks ); my $q = CGI->new(); print $q->header( -charset => 'UTF-8' ), 　　$q->start_html( -title => "TEST", -lang => 'ja', ), 　　$template->output, 　　$q->end_html; __DATA__ <table> 　<tr> 　　<TMPL_LOOP NAME=WEEK_CAPS> 　　　 <th class="<TMPL_VAR NAME=class>"><TMPL_VAR NAME=jp></th> 　　</TMPL_LOOP> 　</tr> 　<TMPL_LOOP NAME=MONTH_WEEKS> 　　<tr> 　　　<TMPL_LOOP NAME=WDAYS> 　　　　<td class="<TMPL_VAR NAME=class>"><TMPL_VAR NAME=day></td> 　　　</TMPL_LOOP> 　　</tr> 　</TMPL_LOOP> </table>
my $jpholiday = isHoliday($spdate->{year}+0,$spdate->{month}+0,$spdate->{day}+0); か?
「perl word count hash」で検索してこんなのとか。 http://www.google.co.jp/search?hl=ja&q=perl+word+count+hash&lr=lang_ja#hl=ja&gs_nf=1&pq=perl%20word%20count%20hash%20golf&cp=20&gs_id=1m&xhr=t&q=perl+word+count+hash&pf=p&sclient=psy-ab&oq=perl+word+count+hash&aq=f&aqi=&aql=&gs_l=&pbx=1&bav=on.2,or.r_gc.r_pw.r_qf.,cf.osb&fp=827e273e02024e8a&biw=988&bih=939&bs=1
これは、perlの問題ではなく、出力結果がどう解釈されるか、の問題です。 perlから&を出力するなら、普通に print "&"で問題ありません。 「テキストファイル」と言いながら、実際にはXMLであり、XMLの文法として &で始まる実体参照だと解釈され、処理しようとしら定義されていないのでエラーになった、というのが今回の現象です。 「Perlから」とかは関係なしに、「XMLとして正しい出力」を考え、その通りになるように「Perlのプログラムを作る」のが正解でしょう。 タグの中身をs/&/&amp;/gとでもやって全部置き換えるとか、XML関係のモジュールを使うとか。
Perlはちょっとうろ覚えですが、単に取り出すだけなら文字列のまま取得してもいいかも。 ------------------ $N= 5; $n=$N-1; @arr; while ( $str =~ m/(([\d\.]+)　[\d\.]+　[\d\.]+\n(?:\2　[\d\.]+　[\d\.]+\n){$n,})/og ){ push(@arr,$&); } #確認 print "<pre>"; foreach $var (@arr) { print "$var<hr>"; } print "</pre>"; ------------------ ～以上ではなく、厳密にN回なら カンマなしで{$n}
unless(/^[0-9A-Z][-\.\w]+[0-9A-Z]$/im){print "ERROR"}
$in{n} の {n} の n が実際はリテラルの数値である場合は、{n} が量指定子と解釈されてしまいます。 use strict; my %hash = qw(2 two two 2); print "match\n" if "xtwoy2z" =~ /$hash{two}/; # OK print "match\n" if "xtwoy2z" =~ /$hash{2}/; # エラー(Global symbol "$hash" ...) エラーメッセージから $hash は、スカラー変数と解釈されていることがわかります。use strict もなく、スカラー変数の $in がない場合は、/&amp;n=$in{2}&amp;/ は /&amp;n={2}&amp;/ という正規表現が適用されることになります。エラーを回避するためには、kmee さんの回答にある ${in{n}} とするか、キーをクォートして $in{'n'} のようにするか、あるいはキーを変数経由で渡すなどのいくつかの方法があります。
例文のスクリプトが文法的に変なので、方法だけ書きます。 (split /\x0d\x0a/, $res->as_string)[-1] とすれば、おっしゃるものは取得できます。 ですが、リクエストボディに改行コードを含んでいた場合は意図せぬ結果になることでしょう。 バイナリデータだから改行コードが存在しない、というのは特殊な場合であって、一般的ではないです。 リクエストボディだけを取り出したいということであれば、普通は $res->content の方を使います。
> ($sec, $min, $hour, $mday, $month, $year, $wday, $stime) = localtime(time()); こちらでは、月を「$month」変数で受け取っているのに、 > my $time = sprintf("%04d\/%02d\/%02d %02d\:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec); こちらでは、変数「$mon」を出力しているからです。$month+1にしましょう。 こういうエラーは「use strict;」で防ぐことができますので、use strict を使うことお薦めします。 http://dqn.sakusakutto.jp/2008/06/perlcgiuse-strict.html
質問には肝心なところが書いてないので... FORMのenctype属性値 text/plain はダメだと思います。ファイル添付は無いですからデフォルト（application/x-www-form-urlencode）のままで良いはずです。削除してください。
ポイントとなるのは、CSV形式の行からの値の取出し、WWWへのアクセス、XMLの構文解析の方法かと思います。 モジュールのインストール方法については分かりますよね？ CSV形式の行からの値の取出しですが、「Perlメモ」さんが参考になります。 http://www.din.or.jp/~ohzaki/perl.htm#CSV2Values WWWへのアクセスですが、LWPが定番のモジュールです。これを使えば簡単に目的のページの内容を取得できるかと。 http://homepage3.nifty.com/hippo2000/perltips/LWP.html あとはXMLの構文解析をするXMLパーサですが、これもいくつかモジュールが有ります。 http://www.ibm.com/developerworks/jp/xml/library/x-xmlperl1.html http://homepage3.nifty.com/hippo2000/perltips/xml/parser.htm 下記のページも参考になるかも知れません。 http://www.ibm.com/developerworks/jp/webservices/library/itm-ws4/#e
表示がくずれるので、空白2文字を全角空白にしていることに注意。 use strict; use warnings; use constant CUT_INDEX => 3; my @data = (); while ( my $line = <DATA> ) { 　　$line =~ s/\x0D?\x0A?$//; 　　push @data, [ split ' ', $line ]; } print_data(@data); # 0 1 2 3 4 # 9 8 7 6 5 # 6 5 4 3 2 # 7 8 6 9 2 # 8 0 9 8 1 my $line_len = scalar @data; for ( my $i = 0; $i < $line_len; $i++ ) { 　　if ( $i < ( $line_len - 1 ) ) { 　　　　$data[$i]->[CUT_INDEX] = $data[ $i + 1 ]->[CUT_INDEX]; 　　} 　　else { 　　　　splice @{ $data[$i] }, CUT_INDEX; 　　} } print "\n"; print_data(@data); # 0 1 2 6 4 # 9 8 7 3 5 # 6 5 4 9 2 # 7 8 6 8 2 # 8 0 9 sub print_data { 　　my @data = (@_); 　　my $line_len = scalar @data; 　　for ( my $i = 0; $i < $line_len; $i++ ) { 　　　　my $row_len = scalar @{ $data[$i] }; 　　　　for ( my $j = 0; $j < $row_len; $j++ ) { 　　　　　　print $data[$i]->[$j], ' '; 　　　　} 　　　　print "\n"; 　　} } __DATA__ 0 1 2 3 4 9 8 7 6 5 6 5 4 3 2 7 8 6 9 2 8 0 9 8 1
どうしてもIf-Modifed-Sinceが知りたい場合は、NPHスクリプトを使ってください。 通常CGIでは、Last-Modifed を出力しておけば、If-Modifed-Sinceなリクエストの場合、 CGIが出力したLast-Modifedを元に、Apache側で判定して、全データを返すか「304 Not Modified」を返すかを切り替えてくれます。 CGI側でIf-Modifed-Sinceヘッダの内容を知る必要はありません。 そもそも、通常のCGIでは、出力ステータスを変えられない(「304 Not Modified」を返すことができない)ので、If-Modifed-Since を取得出来ても意味もありません。 一方、NPHスクリプトの場合、ステータス出力などもすべてCGI側で処理する必要がありますが、 そのおかげで必要に応じて 304 を返すことも出来るようになります。 そして、NPHスクリプトであれば、リクエストヘッダの全データが引き渡されますので、If-Modified-Since も、$ENV{HTTP_IF_MODIFIED_SINCE} で参照できます。 http://www.kishiro.com/apache/nph_script.html
＞こちらは旧サーバーからファイルをtar.gzで圧縮してローカルに落とし、新サーバーへtar.gzをバイナリ転送後、新サーバー側で展開する形で移転しましたので転送モードの相違はないと思いますがどうでしょうか。 と言うことですが、症状からすると改行コードの問題（もしくは目に見えない文字の問題）です。 サーバーにログオン出来るなら、 $ cat -v xxxx.cgi | head で、 #!/usr/local/bin/perl と表示されるか(これが正常)、あるいは、 #!/usr/local/bin/perl^M と表示されるか、あるいは、^Mでない別の何かがくっついてないか、確認してください。 あと、可能ならapacheのエラーログを確認してください。
XPath の書き方なんてほとんど忘却の彼方なんだけど, //item/description/text() だと 「『item要素の子供である description要素』の子供であるテキスト部分」 ってことにならないかなぁ. つまり, XPath で 「『item要素の子供である description要素』の子孫であるテキスト部分」 を指定すればいいような気がする... けど, //item/description//text() みたいにかけるんだっけ?
こんにちは。 No2の方法になります。 画面を表示後、非同期(裏側で)取得した画面サイズをサーバ側にpostします。 サーバ側で値を受け取ったあとその受け取った値に基づいて処理をして結果を返します。 その結果を画面で受け取って画面書き換え等の処理を実施します。 ==== 動作サンプル http://hppg.moe.hm/okwave/qa/q7373761/ 上記ソースを見てもらうと <div id="result"></div> というエリアのみですが画面サイズ等表示されていると思います。 これは画面表示後にdisplay.phpに送信し、display.phpでHTMLを出力します。 それを<div id="result"></div>に反映させています。 disoplay.phpでは送られてきた値を使って自由にHTMLを出力することが可能です。 ※例はPHPですがperlでも同じです。(サーバ側は何でも良い)
UTF8フラグを外せばよいです。 Windows XP では 下のスクリプトをUTF8 で保存し、実行すると文字化けしないで「かきくけこ.txt」が作成されます。文字コードにCP932を指定していますが、SJISとほぼ同じです。 Vista でも同じではないでしょうか。 use strict; use warnings; use Encode; use utf8; my $file_name="あいうえお.txt"; open my $out, ">", Encode::encode('CP932', $file_name) or die; print $out Encode::encode('CP932', "こんにちは\n"); close $out; my $new_name = "かきくけこ.txt"; rename Encode::encode('CP932', $file_name), Encode::encode('CP932', $new_name); exit;
あなたのシステムが全く分からないので一般的な方法として。 １．送信メールにおいてエラーメールを受けるアドレスを明確にしておく（Envelope-Fromで）。 ２．受け取るアドレスのaliasesなどでエラーメールをスクリプトに渡す。 ３．スクリプトでエラーメールの内容を判断し、必要であればデータベースをアップデートする（アドレスを削除するとか、配信スキップフラグを立てるとか） この方法では、メルマガを送信しているスクリプトとは全く別の仕組みを作ることになります。 参考例）http://www.drk7.jp/MT/archives/000890.html
Windowsでは歴史的要因からShift_JISと思われていますが、WindowsXP(2000)以降は、UTF8を内部的に使用しています。 　しかし、Perlは、しばしば古いUNIX上で動かす可能性もあるため、EUCで様々な処理を行い、必要に応じて入出力の段階で変換しています。基本的にEUCでは文字化けが起こりにくいことと、豊富な歴史的産物が使えるからです。 ★Perl正規表現雑技 ( http://www.din.or.jp/~ohzaki/regex.htm ) ★Perlメモ ( http://www.din.or.jp/~ohzaki/perl.htm ) 　また、テキストエディタですが、さすがにメモ帳は勧めていません。 ・元に戻る回数が限定されている。 ・改行コードの違い,タブ,全角と半角の文字の区別が付かない ・検索・置換が、不便 ・正規表現が使えない ・様々な文字コードを扱えない 　そのため、特に初心者には「テキストエディタ EmEditor - EmEditor Free ( http://jp.emeditor.com/modules/download2/rewrite/tc_5.html )」などの高機能テキストエディタを勧めています。初心者には必需品です。リンク先の下のほうにfree版へのリンクがあります。 　当然、UTFであってもBOMをつけないで保存できます。 　
SSHでパスワード無しでログインするには、秘密鍵を作ってそれを使う方法は有ります。 http://www.atmarkit.co.jp/flinux/rensai/linuxtips/447nonpassh.html 一方 Perl でSSH接続するためのライブラリとして Net::SSH::Perl や Net::SSH2 や Net::OpenSSH などが在りますので、それらを使う方法も有ります。 Net::SSH::Perl が古くから使われているので資料は豊富ですが、 Net::SSH2 や Net::OpenSSH の方が使いやすいという評価も有るようです。 http://homepage3.nifty.com/hippo2000/perltips/net/SSH.htm http://search.cpan.org/~rkitover/Net-SSH2-0.40/lib/Net/SSH2.pm http://search.cpan.org/~salva/Net-OpenSSH-0.57/lib/Net/OpenSSH.pm
最近のPerl(5.8以降?)だったら、このような「3バイト」ではなく「1文字」として処理する方法があります。 こういう1ラインな書き方だとちょっとめんどうですが。 http://www.rwds.net/kuroita/program/Perl_unicode.html > 2桁ずつとって10進に \343 など、3桁の数字 は8進数です
cpanからLWP最新版をインストールして試した感じだと、問題なく取得できてるような。
"way_$i" でいいんじゃね? あるいは keys 使うとか.
URLの ? の後の物は、QUERY_STRINGという環境変数に入るので、下記で参照できます。 $ENV{"QUERY_STRING"}
端末タイプの表を作って繰り返しの中で判定してはどうでしょうか。 use strict; use warnings; use Encode; use utf8; my %agent_type = ( qr/msie/i => 'pc', qr/firefox/i => 'pc', qr/docomo/i => '携帯', qr/kddi/i => '携帯', ); my $ua = $ENV{'HTTP_USER_AGENT'}; my $ua_type = "その他"; foreach my $key ( keys %agent_type ) { if ( $ua =~ $key ) { $ua_type = $agent_type{$key}; last; } } print Encode::encode( 'utf8', $ua_type ), "\n"; ハッシュで作った表だと、上から順に比較されるわけではないので、比較パターンとする文字列はユニークにしないといけません。
端的に言えば「our するなりパッケージで修飾するなりしてください」となります. 詳細はこんな感じ: このエラーはコンパイル時のエラーであって実行時のエラーではありません. つまり, 実行に先立つコンパイルのときに「use strict が有効なのに my も our も state もされていない (かつパッケージ名での修飾もされていない) 変数 $hoge が現れた」というエラーです. 「require されたファイルの中に our がある」のは確かですが, 次の 2つの理由によりそれは影響しません: ・use とは異なり, require によるファイルの取り込みは実行時に行われます. つまり require 'test_sub.pl'; とあってもコンパイラは test_sub.pl の中は見ません. したがって「test_sub.pl の中の our」はコンパイル時には影響を与えません. ・また, our の有効範囲はレキシカルスコープに制限されています. そして「1つのソースファイル」はレキシカルスコープとなりますから, require をコンパイル時に行っても「test_sub.pl の中の our」は test_sub.pl の中 (もちろん our 以降の) でしか有効ではありません. 余談ですが, use strict もレキシカルスコープで有効となります. つまり, 「test_sub.pl の中の use strict」はそれを require した test_main.pl では無効です (し, 逆に require する前に test_main.pl で use strict してもそれは test_sub.pl には影響しません)
while文の中にチェックするためのif文が入っている時点で、間違っていると思います。ざっとプログラムを読んだ感じだと、ファイルの最初に出てくる記事のID、パスワードと一致しない場合にエラーを出すようになっているように見えます。つまり、最初に出てくる記事のIDと違うものを入れた場合にたまたまエラーになります。 自分だったら削除の有無を示すフラグを追加して、全部の記事を調べたあとに削除フラグが立っていなかったらエラーにします。実行させていないので、微妙にバグがあるかもしれませんが、コードにすると下記のとおりです。 変更箇所の前後にコメントをつけています。 @new=(); open (IN,"$file") || error("システムエラー","ファイル「$file」を開くことができません。"); # 記事が削除されたことを示すフラグを追加 $article_removed = 0; # ここまで while($data = <IN>) { $flag=0; ($no,$res,$date,$cntr,$email,$tall,$weight,$age,$sub,$com,$live,$select,$photo,$pw) = split(/<>/,$data); if ($FORM{'pass'} eq "$ad_pass") { foreach $del (@DEL) { if ($no eq "$del") { $flag=1; last; } } } else { if ($FORM{'del'} eq "$no") { if (!($pw)) { &error("入力エラー","指定された記事には削除キーが設定されていません。"); } if (crypt($FORM{'pass'},$pw) ne "$pw") { &error("入力エラー","パスワードが間違っています。"); } $flag=1; } } # $flag==1の時は記事が削除されるので、$article_removedの値を1に変更 # 元のプログラムを次のように変更。 if ($flag == 0) { push(@new,$data); } else { $article_removed = 1; } #ここまで } # $article_removedが0のままだったら指定された記事番号が無いのでエラー if (!$article_removed) { &error("入力エラー","記事番号が存在しません。"); } # ここまで close (IN);
UTF-8を使うのであれば、 Jcode.pm を使うといいと思います。
こんにちは。 削除を実行するところにパスワードの判定のif文があると思いますが、そこの中にさらに管理者パスワードと一致するかを入れれてあげれば判断できると思います。 $pass = 入力されたパスワード if ( $pass eq $owner_pass || $pass eq $pw ) { $msg = "投稿者が削除"; if ( $pass eq $owner_pass ) { $msg = "管理者が削除"; } } ただ、偶然にも管理者パスワードと一致した場合は判断つきません。 管理者パスワードを誰も選ばないようなパスワードにしておけばある程度判別できるかもしれませんが完全ではありません。
C:\inetpub\wwwroot\ ディレクトリのNTFSアクセス許可を調べましょう。 http://awoni.net/tips/iis_acl/
~/.cpanm/build.logにログが残るから、何かわかるんじゃないですかね。
サンプル(SHIFT_JIS) ＿はタブに戻す /cgi-gin 　|-- template.cgi 　|-- template/ 　　　　|-- 001.html 　　　　|-- 002.html hoge.com/cgi-gin/template.cgi/001.html #!/usr/local/bin/perl use strict; my $templatePATH = './template'; if (open TEMPLATE,$templatePATH.$ENV{'PATH_INFO'}){ ＿print "Content-Type: text/html; charset=Shift_JIS\n\n"; ＿while(<TEMPLATE>){ ＿＿print ; ＿} } else{ print "Content-Type: text/html; charset=Shift_JIS\n\n"; print "<html><head><title>error</title></head><body><h1>エラー</h1>\n<p>テンプレートを指定してください。</p>\n"; print "</body></html>\n"; } __END__
1.レンタルサーバ上でのパーミッション設定は正しいでしょうか？ 2.そのレンタルサーバではCGIの設置が可能で実行させることが許可されていますか？ 3.レンタルサーバでCGIの設置に関して指定のフォルダがあるなど設置制限はありませんか？ 4.CGIはレンタルサーバやURLに合わせてカスタマイズ（修正）していますか？
表示がくずれるので空白2文字を全角空白で書いていることに注意 use strict; use warnings; use feature 'say'; my $text = 'hello :-)'; my $word = ':-)'; if ( $text =~ m/\Q$word\E/ ) { 　　say 'matched';　　# matched } my $quoted = quotemeta $word; say $quoted; # \:\-\) if ( $text =~ m/$quoted/ ) { 　　say 'matched';　　# matched }
各行のそれぞれのデータ項目がカンマで区切られているというなら split を使えばいい.
> 「use utf8;」で、スクリプト内で扱う文字コードを > UTF8にする事で可能になるという理解でよろしいでしょうか？ ちょっと違う。 use utf8はスクリプト自体をUTF-8で記載することを宣言する物。 だからスクリプトはちゃんとUTF-8で保存してください。 これによって、perlは「スクリプト内」の文字列を正しく文字列として扱えます。 これでケアできるのは「スクリプト内」の文字列なので、 「スクリプト外」（STDINとかコマンドライン引数、ファイル）からやってきた文字列として扱うつもりのデータは decodeしてperlが文字列として扱えるように変換しなければなりません。 （例えそのデータがUTF-8文字列であってもです、decodeを省略できるのはASCIIやLatin-1だけ。） 逆に、「スクリプト外」（STDOUTやファイル）に文字列を出す場合は、 所望の文字コードにencodeする必要があります。 ただし、PerlIOレイヤを使えばこの処理は若干省略可能です。 　binmode STDOUT, ":utf8"; はSTDOUTに出力するときのencodeを省略する為の物です。 これがないと、printのたびに print encode( 'utf8', $no ); とかする必要があります。 use utf8で検索すれば上の方にこんなページが引っかかります。 http://www.rwds.net/kuroita/program/Perl_unicode.html http://hikoboshi.org/perl/utf8.html http://blog.livedoor.jp/dankogai/archives/51224106.html
サーバーアナライザー http://www.futomi.com/library/servana.html を使用して、ご利用のサーバーに必要なモジュールがインストールされているかを確認して下さい。 インストールされていなければ、RSSリーダーの説明ページに書かれてあるとおりに、それらをダウンロードして、設置してください。
「その処理をしたいところ」で #2 の getData を除いた部分を実行すれば, @data に処理したあとのデータが入る, はずです. そのデータは結局, もとと同じく 3<><>2012/01/12(Thu) 08:42<>ウサギ<>Yahoo<> のような形になっているだけですから, その「表示」は既にできているはずじゃないですかね.
そもそもやりたいことは「一定の文字数で切る」ことなんでしょう? だとしたら, 「文字」の世界で考えるべきであって, 「バイト列」なんてものを持ち出すのは混乱の本でしかありません. で今の Perl で一番簡単なのは #1 にあるように Encode::decode→s///→Encode::encode とやること. これなら「バイト列」なんて厄介なものを持ち出すことなく「文字」の世界だけで完結します. ちなみに今の Perl なら s/// は $str =~ s/^.{$view}\K.+/.../; の方が効率よさそう. 余談ですが, 当然 g は不要ですね＞#1.
１対ｎマッチングを応用してもできるのではないかと思います。 まず、前提として、 　１．1行に重複していない1英単語だけのファイルを「xxx.txt」とします。 　２．1行に重複している可能性のある1英単語だけのファイルを「yyy.txt」とします。 　３．上記2つのファイルの英単語は昇順に並んでいるものとします。 　４．「xxx.txt」と「yyy.txt」の両方にある英単語については「英単語と出現件数」を出力します。 　５．「xxx.txt」だけにある英単語については「英単語と出現件数(結果として0)」を出力します。 　６．「yyy.txt」だけにある英単語については何も出力しません。 　７．４と５での出力ファイルを「zzz.txt」とします。 とします。 上記の前提で作成したのが以下のサンプルです。 --------------------------------------------------------------------------------- # ファイルのオープン open(IN1,"xxx.txt");　　　#マスターファイル open(IN2,"yyy.txt");　　　#トランザクションファイル open(OUT1,">zzz.txt");　　　#出力ファイル # 初期値設定 $high_value　=　pack("h8","ffffffff");　#終了判定 $in1_key　=　undef;　　#マスタキー $in2_key　=　undef;　　#トランザクションキー $occur_ctr　=　0;　　　#出現回数 # １件目のデータ入力 s_in1(); s_in2(); # 主処理 until　($in1_key　eq　$high_value　&&　$in2_key　eq　$high_value)　{ # マッチングの時（両方のファイルにデータがある） 　if　　($in1_key　eq　$in2_key)　{ 　　until　($in1_key　ne　$in2_key)　{ 　　　$occur_ctr++; 　　　s_in2(); 　　} 　　　$out1　=　join("\t",$in1_key,$occur_ctr); 　　　print　OUT1　"$out1\n"; 　　　s_in1(); 　　　$occur_ctr　=　0; 　} # マスタオンリーの時（マスタファイルだけにデータがある） 　elsif　($in1_key　lt　$in2_key)　{ 　　　$out1　=　join("\t",$in1_key,$occur_ctr); 　　　print　OUT1　"$out1\n"; 　　　s_in1(); 　} # トランザクションオンリーの時（トランザクションファイルだけにデータがある） 　elsif　($in1_key　gt　$in2_key)　{ 　　　s_in2(); 　} } # マスタファイル入力 sub　s_in1　{ 　if　　($line1　　=　<IN1>)　{ 　　　chomp($line1); 　　　$in1_key　=　$line1; 　} 　else　{　　　　#マスターファイルが終了のとき 　　　$in1_key　=　$high_value; 　} } # トランザクションファイル入力 sub　s_in2　{ 　if　　($line2　　=　<IN2>)　{ 　　　chomp($line2); 　　　$in2_key　=　$line2; 　} 　else　{　　　　#トランザクションファイルが終了のとき 　　　$in2_key　=　$high_value; 　} } # ファイルのクローズ close(IN1); close(IN2); close(OUT1); --------------------------------------------------------------------------------- ※なお、カラムをそろえるために、全角スペースを使っていますので、 　このままコピー・ペーストしても動作しません。この点はご注意ください。
「最初のaaaを選択する」と言い換えても何をしたいのかはやっぱりわからんのだけど (「選択する」だけでは意味がない), 形としては open my $fh, '<', ファイルA; my $count_item = 0; my $saved_item = undef; while (<$fh>) { if (/(aaa)/) { ++$count_item; last if $count_item >= 2; $saved_item = $1; } } if ($count_item >= 2) { $saved_item を使ってなんかする } とか, かなぁ. 固定文字列だから index の方がいいかもしれんけど, その辺は気分しだい.
ついでにいうと, while ループの最初の chop は chomp にした方がいいと思う. ここで chop を使う理由として唯一思い当たるのは「chomp がない」ということで, そうだとするとその「古い参考書」とやらはバージョン 5より前 (つまり Perl 4.x の時代) か? もちろん「対応しているバージョン」は「参考書」に書いてあるはずだから調べてほしいんだけど, もし本当に「バージョン 4.x 対応」とあるならそんな「古文書」は見ないことにして「今の Perl 用に参考になるもの」を探すべき. バージョン 5.x であっても 5.8 以前なら同様の対応をお勧めします. 5.8→5.10→5.12→5.14 とちょっとずつ変化してるんだけど, とりあえず 5.8 をおさえておけばいいでしょう. 本題については, たとえば「split の結果を受け取る配列変数を 1個用意する」という方針でもいいし, もっとシンプルに書くなら実は while (<>) { chomp; push @ARRAY, [split]; } でもいい.
初心者がよくやるんですが、文字列の比較演算子はeqです。 if($astrology eq "*Aries*"){print "おひつじ座 <br />$astrology \n";} elsif($astrology eq "*Leo*"){print "しし座　<br />$astrology\n";} else{print "その他<br />$astrology\n";} ==は数値比較で、数字同士を比較するときに使います。 if($flag==1){ print "true\n"; } else{ print "false\n"; }
基本的には 1行ずつハッシュで覚えていけばいいだけだと思うんだけど... どこがわからんのでしょうか?
腐るほどある。 https://www.google.com/search?q=CGI+OR+PHP+%E3%83%95%E3%83%AA%E3%83%BC
手直しを希望とのことなので直しました。 ファイル名を毎回入力するのは面倒ですから、第一引数から取るようにしてあります。 Windows環境では入力ファイルをドラッグ＆ドロップすれば動作すると思います。 #!/usr/bin/perl use strict; # ファイル名を設定 my $ifname = shift or die "第一引数にはファイル名が必要です\n"; my $ofname = "out.txt"; #出力ファイル # ファイルを開く open(IN, $ifname) or die "入力ファイルを開けません"; open(OUT, ">", $ofname) or die "出力ファイルを開けません"; # データを処理 while(<IN>){ if(my($text, $message, $to_user) = m/"(.+?)":"(.+?)","(.+?)"/){ print(OUT "$text => $message, to $to_user\n"); } } # ファイルを閉じる close(OUT); close(IN);
#No.2です。 さして考えもせず「コレ系は二次元ハッシュ」と答えてしまいましたが、 実際に考えるとただのハッシュでした。 失礼しました。 while( <DATA> ) { chomp; my ($subject, %results) = split /,/; my $result; foreach ( sort { $results{$b} <=> $results{$a} } keys %results ) { $result .= "$_,$results{$_},"; } $result = substr($result, 0, -1); print "$subject," . "$result\n"; } __DATA__ 数学,山田,60,佐藤,80,蓑田,55,岸本,90,小笠原,75 英語,山田,70,佐藤,50,蓑田,81,岸本,99,小笠原,80
すみません。No.2で、半角で記述したので、両方とも,で表現されてますね。 $in{"name"} =~ s/,/＆＃44;/g; 実際には「＆＃44;」は、全て半角で記述して下さい。
表示がくずれるので空白2文字を全角空白1文字で書いていることに注意 use strict; use warnings; use feature 'say'; my $a1 = 1; my $a2 = 2; my $a3 = 3; my $a4 = 1; my $a5 = 2; my $a6 = 3; my $top = 'Not Found'; for my $num ( reverse 1 .. 6 ) { 　　my $var = eval '$a' . $num; 　　if ( $var == 1 ) { 　　　　$top = $num; 　　　　last; 　　} } say $top; # 4
> my $url = $in{'q'}; # ここでエラーが出ます。 クエリストリングは自動的に $in に格納されるわけではないから。 キーワード「query_string perl get」でGoogle検索してみてはいかがでしょう。
この質問をどう、見るかが問題かもしれない。 まあ、それは、それとして、 ＞なにか他に必要なソフトがあるのか、 ＞PCだけでできるのか、 ＞どこを操作すればよいのか そのように思う方が、扱うものではありません。サポートに連絡して（アドビ社）、どうすればいいのか聞けばいいだけです。 あなたと同じ内容のブログをみましたが、アフェリエイとか、宣伝用のページでした。つまり、分かる方だけ、わかったください。 レベルの記事です。 ちなみに、パースとは、いろんな意味がありますが、XMLの場合、書式等を検査して、違うところを発見して、指摘しれくれる、APIレベルのモジュールで提供されている物です。 ＞パースできてかつ と言うことは、書式があっていている（XMLとして正しい）。と言うだけの事。ただし、通っただけでは、通常意味がなく、そのXMLファイルを使う側（アプリ）の、スキーマ等の決まりごとでタグ及び、構造がなされていないとだめです。 そこで次の、 ＞「well formed」 なんて意味不明な、単語がでてきます。 http://search.yahoo.co.jp/search?b=1&n=10&ei=UTF-8&fr=ie8sc&p=%22well+formed%22%E3%81%A8%E3%81%AF リストされるサイトを読めば、在る程度理解できると思いますが、XMLなどの教則本には、最初の章で、でてくる「XMLとは」のレベルの話です。 前述にも書きましたが、XMLとしての書式はあっていても、それを使う側に、このようなフォーマットにしてください。と言う決まりごとを定義してあるものです。その代表例がHTML文です。あれをXMLと言うものからみると、 H1、TABLE ,P なんて言うタグも、実は、文をH1はで表示するためのタグではなくただH１です。それをH1として表示させるには、どこかに「H1とは」と言う定義を持っている必要があります。DTD、スキーマと呼ばれるものをもっていて、そこにH1の定義があるわけです。 それが、「well formed」　であり、「形式が整えられている」と言う事をさす。ということは、その逆の物（反意語）も、あるわけで、両方とも、用途によって使い分けるわけです。 本来、「well formed」であるXML文は、書式が最初からあっているわけであって、元のブログの著者の方は、どうも英語風に表現しているようです。外人か、翻訳した、サイトかもしれませんね。だれかた英文を、日本文で紹介している。 よくあるんですよね。 いや、この投稿も、そのひとつかもしれない。 「well formed」にするためには、スキーマ又はDTDが必要です。その辺の話が、どこにも出てきませんよね。もとのブログには。 そう、本当に操作した人が書いたブログなのか、とても怪しい。 それとも、アドビのプレミアのDTDを包括しているのでしょうかね、そのライブラリーは。 もっとも、壊れているXML文をパースできるように、するということは、もともと、特定のDTDを元にして書かれているXMLなので、XMLとして正しいように修正してやれば、おのずと、できたXMLは「well formed」として正しいだけのことだと思う。 それを、わざわざ ＞パースできてかつ「well formed」なXMLも出力してくれた。 なんて表現するのは、どうもおかしい。ブログを書いた人も、たぶん質問者と同じレベルの方でしょうね。 ＞なにか他に必要なソフトがあるのか Perlが必要です。 ライブラリーをダウンロードしてください。 makefileが付属しているので、それを活用しましょう。 http://search.yahoo.co.jp/search?b=1&n=10&ei=UTF-8&fr=ie8sc&p=perl+makefile%E3%81%AE%E6%B4%BB%E7%94%A8 なんて検索すると、わかると思う。 わからなかｔったらDL元に問い合わせるだけ。 ちなみに、Perl　を使わなくてもできるので、これらの投稿って Perl　信者　にしか見えない（一生懸命広げようとしている人。自分が取得した技術などに固執する方）。
File::Basenameを使うのがよいかと。 http://perldoc.perl.org/File/Basename.html もしかすると、cmd.exeでdirとforを使うか、Scripting.FileSystemObjects使うほうが楽かもしれない。
1)読んだ行が区切られる単位なのか、要素なのかを分けて、 2)指定されたファイル名でオープンしたり、出力が終わったらクローズしたり を割とそのまま書けばよいかと思います。 # 質問文中ではコロンやスペースが全角なのでそのつもりで書いてあります my $items = 0;# これからファイルに出力する行数 while (<>) { if ($items == 0 && /：/) {# ：の行が区切られる単位とし、 chomp; my ($name, $num) = split(/：/); $num =~ s/　//g;# 全角スペースが入っているようなので消しておく $items = int($num);# ：の後の数字がそのグループに入る要素数である。 print "$name, $items\n"; open OUT, ">$name" or die "Cannot open $name..."; }elsif ($items > 0) {# データ数分出力 print OUT $_; if (--$items == 0) {# 最後の項目だったら close OUT;# ここでおしまい } } } # 最初の if に $items == 0 が入れてあるのは、項目にコロンが入っていたらハマるからですが、 # 先に if ($items > 0) { ... } elsif (/：/) { ... } と書けば条件式はシンプルになります。 # ここでは（データファイルの出力順に合わせて）グループ名の指定かどうか判定する方を先にしました。
1) フォームのパラメータを何かに保存 2) 保存したものを読み出す 3) フォームのパラメータのデフォルト値としてセット すればOKです。 モジュールを使っていいなら、例えば以下のようになります。アカウント管理していないことと、表示がくずれるので空白2文字を全角空白で書いていることに注意。 #!/usr/bin/perl -T use strict; use warnings; use utf8; use CGI; use CGI::Carp qw(fatalsToBrowser); use CGI::Pretty; use HTML::FillInForm; use Storable qw(nstore retrieve); use constant QUERY_FILE => './serialize.dat'; my $q = CGI->new(); my $html = do { local $/ = undef; <DATA> }; my $output; my $sended = $q->param('send'); if ( defined $sended ) { 　　nstore( $q, QUERY_FILE ) || die QUERY_FILE; 　　$output = HTML::FillInForm->fill( \$html, $q, target => 'form1' ) 　　　　|| die "$!"; } elsif ( -r QUERY_FILE ) { 　　my $saved_query = retrieve(QUERY_FILE) || die QUERY_FILE; 　　$output 　　　　= HTML::FillInForm->fill( \$html, $saved_query, target => 'form1' ) 　　　　|| die "$!"; } else { 　　$output = $html; } print $q->header( -charset => 'UTF-8' ), $output; __DATA__ <!DOCTYPE html 　　PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 　　 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns="http://www.w3.org/1999/xhtml" lang="ja-JP" xml:lang="ja-JP"> 　<head> 　　<title>Test HTML::FillInForm</title> 　　<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 　</head> 　<body bgcolor="#ffffff"> 　　<form name="form1" method="POST"> 　　　 Name : <input type="text" name="url" /> 　　　 <br /> 　　　 <input type="radio" name="look_behind" value="A" checked="checked" />Value A 　　　 <input type="radio" name="look_behind" value="B" />Value B 　　　 <input type="radio" name="look_behind" value="C" />Value C 　　　 <br /> 　　　 <input type="checkbox" name="checkbox1" value="ON" lablel="checkbox_label" />checkbox1 　　　 <input type="checkbox" name="checkbox2" value="ON" lablel="checkbox_label" />checkbox2 　　　 <br /> 　　　 <select name="select1"> 　　　　 <option value="option1">option1</option> 　　　　 <option value="option2">option2</option> 　　　　 <option value="option3">option3</option> 　　　 </select> 　　　 <br /> 　　　 <input type="submit" name="send"　value="send" /> 　　</form> 　</body> </html>
1オクテット = 1バイトと考えます。 UTF-8では日本語の全角半角1文字は3から4バイトですが、OK? > なお、データ中に\nを含む場合は、それがぶった切られないようにする方法はないでしょうか？ ??よくわからず。 適当。以下、表示がくずれるので空白2文字を全角空白1文字で書いていることに注意。 use strict; use warnings; # for testing my $wrap = 5; my $string1 = 'A' x 10; my $string2 = 'B' x 13; for my $string ( $string1, $string2 ) { 　　print qq(\x0A\x0D"$string"\x0A\x0D); 　　print "---\x0A\x0D"; 　　while ( $string =~ m/([\x00-\xFF]{$wrap,$wrap})/g ) { 　　　　print $1, "\x0A\x0D "; 　　} 　　my $rest = length($string) % $wrap; 　　if ( $rest > 0 ) { 　　　　print substr( $string, -$rest ), "\x0A\x0D "; 　　} 　　print "---\x0A\x0D"; }
%USERSをData::Dumperで直列化して、別ファイルに引き渡して復元するとか。 perldoc Data::Dumperで使い方が参照できます。
No2です。 （１）についてですが、 カンマが一つという決まりがあるのであれば 以下の正規表現で取れます ([+|-]?\d+,?\d+.\d+) ただし、抜き取っても「,」が入ってしまうため、 文字列になってしまいます。その後の計算ができません。 ちょっと考え方を変えて、 「>"何らかの文字列"円」で正規表現を書き、 その後で、数値として認識できるように「,」を取り除いてみてはいかがでしょうか 以下のような感じになるかなと思います。 while( my $line = <$file_handle> ){ 　　if( $line =~ />(.*)円/ ){ 　　　　$result = $1; 　　　　$result =~ s/,//g; #,を取り除きます。 　　} } (2)についてですが my ( $year, $month, $day, $hour, $min ); if( $line =~ /(¥d+)年(¥d+)月(¥d+)日 (¥d+):(¥d+)/ ){ 　　$year = $1; 　　$month = $2; 　　$day = $3; 　　$hour = $4; 　　$min = $5; } で各値を取得できると思います。
http://www.ideone.com/LMvNU 一例として。
「特定の項目を持つ配列」を作るには、別に split して連想配列にしなくても、 配列の要素から目的の条件に合う要素を抽出する grep を使えば1行で書けます。 あらすじはこんな感じ my @items = <IN>;# （この行の上下のopen/closeは記述省略） my @data = <DATA>;# 両方一気に読み込んじゃうことの是非は置いとく map { chomp;# 改行がついたままなので削る my $pat = $_;# grep の中で $_ が使われるので別の変数にコピる my @line = grep(/^$pat/, @data);# ここでマッチする行を抽出 # ここで回答 No.1 への補足にある、ランダム出力のループを使う } @items; # "map", "foreach (@items)", "while (<IN>)" のどれが好みかは置いとく
それなら例えば while (my $line = <>) { chomp $line; my ($id, @data) = split /,/, $line; my %count; my @item; for (@data) { push @item, $_ unless $count{$_}++; } print $id; for (@item) { print ",$_,$count{$_}"; } print "\n"; } とかでどうだろ.
適当。表示がくずれるので、空白2文字を全角にしていることに注意。 use strict; use warnings; use autodie; for my $file (@ARGV) { 　　my $new_file = $file . '.new'; 　　open my $fh,　　 '<', $file; 　　open my $new_fh, '>', $new_file; 　　while ( my $line = <$fh> ) { 　　　 if ( $line =~ m{(\s*)<title>(.*)</title>(\s*)$}i ) { 　　　　　 my $title = $2; 　　　　　 print {$new_fh} $1, 　　　　　　　 qq(<meta property="og:title" content="$title" />), $3; 　　　 } 　　　 print {$new_fh} $line; 　　} 　　close $fh; 　　close $new_fh; } ---- perl -w foo.pl foo1.html foo2.html
> しかしブラウザに (略) > が表示されてしまいます。 それは、バッチファイルが出力したものでしょう。 バッチファイルが出力したものも、CGIの出力に混ざってしまいます。 Perl側で対応する場合は、 system '… > nul' としてください。 あるいは、バッチファイル側で、1行目に @echo off という行を追加してもいけるかと思います。
正規表現式で\sは、スペース、タブ、改行のいずれかを意味します。 (参考) http://www.site-cooler.com/kwl/perl/8.htm#8-2
my $arrayref = $dbh->selectall_arrayref('select * from user_info', {Slice => +{}}); print Dumper($arrayref); --- $VAR1 = [ 　　　　　{ 　　　　　　'name' => 'Alice', 　　　　　　'id' => '1' 　　　　　}, 　　　　　{ 　　　　　　'name' => 'Bob', 　　　　　　'id' => '2' 　　　　　} 　　　　];
use strict; use warnings; # 時刻をキーとする出力用ハッシュ my %data; open(my $fh1, '<', 'test1.txt') or die($!); while(<$fh1>) { chomp; my($time, $data1, $data2) = split /,\s*/; # 配列のリファレンスを生成し、$timeをキーとするハッシュに値として代入する $data{$time} = [$data1, $data2, "-999.0", "-999.00"]; } close($fh1); open(my $fh2, '<', 'test2.txt') or die($!); while(<$fh2>) { chomp; my($time, $data3, $data4) = split /,\s*/; if(exists $data{$time}) { # ハッシュのキーがすでに存在する ＝ test1.txtに同じ時刻の値があった場合 # 配列のリファレンスを参照して配列の値を一部上書きする $data{$time}->[2] = $data3; $data{$time}->[3] = $data4; } else { # ハッシュのキーが存在しない ＝ test1.txtに同じ時刻の値が無かった場合 # 配列のリファレンスを生成し、$timeをキーとするハッシュに値として代入する $data{$time} = ["-999.0", "-999.0", $data3, $data4]; } } close($fh2); open(my $fh_out, '>', 'test.txt') or die($!); # ハッシュのキー（＝時刻文字列）をソートしてループを回す foreach my $time (sort keys %data) { # 配列のリファレンスを配列に戻したものを時刻と一緒にカンマ区切りでくっつける print $fh_out join(', ', $time, @{$data{$time}})."\n"; } close($fh_out); exit; =comment ・Perlで「値の重複チェック」をするなら、まず最初にハッシュを使うアルゴリズムを検討します。 ハッシュとは、（誤解を恐れずに言うのなら）任意の文字列を添字に持つことが出来る配列変数のようなものです。 同一のキーがすでに存在するかどうかを高速に（ほぼ一瞬で）調べることができるという利点があります。 ただし、キー（とペアになる値）の順序情報はハッシュ単体では持っていませんので、 データの順序関係が必要になる場合は、（今回の回答サンプルのように）キーでソートしたり、 別途ソート用の配列を作るなどの工夫が必要です。 ・ハッシュは配列と同様に、１つのキー（添字）につき１つの値しか持つことができませんが、 リファレンスという仕組みを使うことで「配列のハッシュ」や「配列の配列」などを実現できます。 サンプルではハッシュの値として配列データを持つ「配列のハッシュ」を作りました。詳細は検索してみてください。 ・今回のサンプルでは、元データのデータ検証や出力フォーマットの再整形が不要に見えましたので 簡略化のために全て文字列データとして扱っています。 再整形の必要があるならprintfでどうぞ。 ・時刻文字列（hh:mm:ss）は秒単位での一致確認をする限りにおいては分割の必要がありません。 桁ごとに数値比較するよりは、まとめて文字列比較したほうが簡単で速いです。 例として、分単位でまとめる場合には、時刻をばらして「hh:mm」をキーとするハッシュを作ることになるでしょう。 ・利用する変数を必ずmyで宣言するなど、（Perl4ではなく）Perl5の文法で書くことをお勧めします。 use strict; use warnings; と組み合わせれば、変数名の間違いや初期化忘れに対して警告やエラーを出してくれます。 一番厄介な「エラーの出ない不具合」をある程度未然に防ぐことができます。 質問者さんのサンプルで言うと、$mや$nを0で初期化せずに使っている部分などが警告対象となります。 ・詳細は検索してみてください。 参考になるキーワード：「Perl ハッシュ」「Perl 変数 リファレンス」「Perl5 use strict」など。 =cut
http://www.ideone.com/Awdrp
「my $items = $tree->look_down('class', 'referencelink')->find('li'); で処理が止まってしまいます」 というなら, 「if (!defined($items))　や　if ($items=="")で判定」するタイミングってないと思うんだけど.... ちと調べた限りでは, いったん look_down の返り値を変数で受けないとダメっぽい.
「モノの本」とやらの記述で疑問が湧いたら、まずはマニュアルを良くよみましょう。 http://perldoc.jp/func/open > MODE が > の場合、ファイルは出力用に開かれ、既にファイルが ある場合は切り詰められ(上書きされ)、ない場合は新しく作られます。 > ファイルに読み込みアクセスと書き込みアクセスの両方をしたいことを示すために、 > や < の前に + を付けることができます: (略)-- +> モードはまずファイルを上書きします。
%SIG
基本的にはキーブレイク処理の応用で対応できます。 キーブレイクした最初のデータごとに出力ファイルをオープンしていき、 オープンした出力ファイルに出力する方法をとります。 具体的には以下のような手順になります。 １．タブ区切りファイルの最初の項目について昇順に並べ替えておきます。 　　(元々昇順に並んでいる場合は、この処理は不要です) 　　※以下、サンプルスクリプトをあげます。 　　　"input.txt"が元々の「タブ区切りファイル」 　　　"output.txt"が「タブ区切りファイル」の最初の項目である"SRR_1"や"SRR_2"などを 　　　昇順に並べ替えた結果になります。　 open(IN1,"input.txt"); open(OUT1,">output.txt"); @record　　=　(); $in1_ctr　=　0; while　(<IN1>)　{ 　　chomp($_); 　　$record[$in1_ctr]　=　$_; 　　$in1_ctr++; } @sort_rec　=　sort　{　 　　　　　　my @a　=　split("\t", $a); 　　　　　　my @b　=　split("\t", $b); 　　　　　　$a[0]　cmp　$b[0]; 　　　}　@record; foreach　$record　(@sort_rec)　{ 　print　OUT1　"$record\n"; } close(IN1); close(OUT1); ２．キーブレイクした最初のデータごとに出力ファイルをオープンしていき、 　　オープンした出力ファイルに出力します。 　　※以下、サンプルスクリプトをあげます。 　　　"input.txt"が昇順に並べ替えた「タブ区切りファイル」 　　　出力結果は同じフォルダにできているはずです。 　　　出力したい項目は最初のタブ区切りファイルの2項目目と3項目目だけ、 　　また、"SRR_1"などの区分は1,000項目未満という前提で作成していますので、 　　必要に応じて変更してください。 open(IN1,"input.txt"); $in1_key　=　undef;　　#入力キー $in1_ctr　=　undef;　　#入力キーごとの件数 @in1　　　=　undef;　　#入力データの配列 $sv_key　　=　undef;　　#保存した入力キー while　(<IN1>)　{ 　　chomp($_); 　　@in1　=　split("\t",$_,-1); 　　$in1_key　=　$in1[0]; 　if　($sv_key　ne　$in1_key)　{　 　　　$w_out　=　OUT.sprintf("%03d",$in1_ctr); 　　　$w_file　=　">".$in1_key.".txt"; 　　　open($w_out,"$w_file");　 　} 　$out1　=　join("\t",$in1[1],$in1[2]); 　print　$w_out　"$out1\n"; 　$sv_key　=　$in1_key; } close(IN1); ※上記は、スクリプトを見やすくするために全角スペースを含んでいます。 　このまま、コピー・ペーストしても実行できませんので、ご注意ください。
#2のスクリプトの実行でエラーになったということですが、お使いになっている perlはどういったものでしょうか。 わたしの手元で12.1と14.1で実行してなんの問題もありませんでした。 perl -v として実行するとどういった出力がされますか? This is perl 5, version 14, subversion 1 (v5.14.1) built for MSWin32-x86-multi-thread (with 1 registered patch, see perl -V for more detail) Copyright 1987-2011, Larry Wall Binary build 1401 [294969] provided by ActiveState http://www.ActiveState.com Built Jun 16 2011 18:54:40 Perl may be copied only under the terms of either the Artistic License or the GNU General Public License, which may be found in the Perl 5 source kit. Complete documentation for Perl, including FAQ lists, should be found on this system using "man perl" or "perldoc perl". If you have access to the Internet, point your browser at http://www.perl.org/, the Perl Home Page.
こんな感じですね。 my $s = 'congratulations!'; ($s) = ( $s =~ /([a-z]+)/ ); print $s,"\n\n"; my $t = 'good luck!'; my @t = ($t =~ /([a-z]+)/g ); foreach my $w (@t) { print $w, "\n"; }
PerlによるMySQL DBへのアクセスでは、DBIモジュールを使うのが最も代表的な方法です。 DBIモジュールとDBD::mysqlモジュールが利用できる環境が必要です。 以下に、DBIモジュールによるファイルアップロードのサンプルを示します。 #!/usr/local/bin/perl ←利用環境に合わせて書き換え use strict; use warnings; use CGI; use CGI::Carp qw(fatalsToBrowser); use DBI; use DBD::mysql; # 各種設定 my $db_host = 'localhost';# DBホスト名 my $db_name = 'dbname';# DB名 my $db_user = 'user';# DBユーザー名 my $db_pass = 'password';# DBパスワード # CGI POSTデータ取得 my $cgi = new CGI; my $fh = $cgi->param('fileform') or die "Upload file is missing\n";# <INPUT>要素のNAMEを指定 binmode($fh); read($fh, my $file, -s $fh); close($fh); # DBに接続 my $dbh = DBI->connect("DBI:mysql:host=${db_host};database=${db_name}", $db_user, $db_pass) or die $DBI::errstr; # SQLでファイルバイナリをINSERT my $sth = $dbh->prepare('INSERT INTO tablename SET file=?') or die $dbh->errstr; # DBテーブル構造に合わせて適宜変更 my $rv = $sth->execute($file); if(! $rv || $rv eq '0E0') { die $sth->errstr; } $sth->finish; # DB切断 $dbh->disconnect; # CGI結果出力 print "Content-Type: text/html;\x0D\x0A\x0D\x0A"; print "<html><body>Upload done.</body></html>"; exit; =comment データベーステーブルを生成するSQL文の例： CREATE DATABASE IF NOT EXISTS dbname DEFAULT CHARACTER SET utf8; USE dbname; CREATE TABLE IF NOT EXISTS tablename ( id MEDIUMINT AUTO_INCREMENT NOT NULL, file MEDIUMBLOB, PRIMARY KEY (id) ) ENGINE=InnoDB,DEFAULT CHARACTER SET utf8; =cut =comment ファイルアップロードフォームの例： <html> <body> <form method="POST" action="fileupload.cgi"><!-- ←CGIファイル名に合わせて書き換え --> <input type="file" name="fileform"> <input type="submit"> </form> </body> </html> =cut 以上です。詳細は「Perl DBI」などで検索してください。 ただし、Perlでリレーショナルデータベースを扱う以上は、PerlおよびSQLの文法については最低限の知識として勉強する必要があります。 上記のサンプルでも、データベーステーブルの生成やアカウント作成は含まれていませんので、事前に済ませておく必要があります。 Webアプリケーションフレームワークではテーブルの生成をやってくれるものもありますが、それらも勉強せずに一朝一夕で使えるものではありません。 またDBIモジュール以外にも、DBIx::Classモジュールなども多く使われています。ご自分の環境や技量に応じて使いやすいものを選ぶといいでしょう。
oオプションは「変数展開を最初の１回だけ行う」です。 一度でも $http{BODY}=~ /(?<=\[ No\.)([0-9]{$digit})(?= \/ $num)/o; を実行すると、実行した時点の値で、正規表現が固定されます。 例えば、$degitが「1」、$numが「2」の状態で、上記の行を１回でも実行すると、その行は、それ以降 $http{BODY}=~ /(?<=\[ No\.)([0-9]{1})(?= \/ 2)/o; として動作します。 ２回目の実行前に、$digitや$numの値を変更しても、それは反映されません。これらがどんな値になってようが $http{BODY}=~ /(?<=\[ No\.)([0-9]{1})(?= \/ 2)/o; として動作します。 例えば $digit=1 $num=1 while( $num < 10) { 　　$http{BODY}=~ /(?<=\[ No\.)([0-9]{$digit})(?= \/ $num)/o; 　　..... 　　$num++; } とやっても 　　$http{BODY}=~ /(?<=\[ No\.)([0-9]{1})(?= \/ 1)/o; が９回行われるだけです。 怖いのは「ループカウンタとして$numは９まで増えて９回ループして終わるが、正規表現では、ずっと同じ値で処理される」って事です。 デバッグ表示で$numを表示したら、ちゃんと値は変化しているのに、値が変化しない正規表現が繰り返されるのです。 ＞ところが最初に読み込んだファイルではうまくマッチしたのですが、２番目のファイルではマッチしません。 当たり前です。 $numも$digitも「最初のファイルを読み込んだ時にセットされた値が展開されたあと、二度と評価されない」のですから、最初のファイルと同じ物しかマッチしません。 ２番目のファイルを読み込んでも「最初のファイルで行った正規表現で実行する」ので、マッチする訳がありません。 ＞でも ＞$http{BODY}=~ /(?<=\[ No\.)([0-9]{$digit})/o; ＞だったらちゃんと$digitの値が変わったことに対応しているんです。 それは気のせいです。$digitが変化しても再評価されず、ずっと１回目の値で動いているけど、１回目も２回目以降も「偶然、マッチしてしまっただけ」です。
「混ぜるな危険。」という言葉が適切かと思います。 おそらく、似たような既存のCGIスクリプトから（意味がわからないまま）寄せ集めたのではありませんか？ CGIスクリプト冒頭で、 > #投稿された値を受け取る > if ($ENV{'REQUEST_METHOD'} eq 'POST') { > read(STDIN, $alldata, $ENV{'CONTENT_LENGTH'}); > } else { > $alldata = $ENV{'QUERY_STRING'}; > } > foreach $data (split(/&/, $alldata)) { > ($key, $value) = split(/=/, $data); > > $value =~ s/\+/ /g; > $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack('C', hex($1))/eg; > $value =~ s/\t//g; > $in{"$key"} = $value; > } と自作ルーチンでGET/POSTデータを全て%inに取得しているにもかかわらず、$name1と$name2ではCGIモジュールでもう一度取得し直そうとしています。 > use CGI; > $cgi=new CGI; > $name1=$cgi->param('handle'); > $name2=$cgi->param('number'); しかし、CGIモジュールが取得しようとした時点ではすでにPOSTデータを含んでいる標準入力（STDIN）のファイルポインタがread()によって末端に来ているため、データの取得に失敗しているのではないでしょうか。手元で検証していないので可能性の話ですけど。 どちらかのみを使えばとりあえずデータの取得はできるようになるでしょうが、冒頭部分のルーチンは1990年代、Perl4の時代によく使われていた類の太古のルーチンです。 私なら、CGIモジュールを使う方法で一本化します。 # 冒頭のルーチンを以下に差し替え。スクリプト中盤にある重複部分は削除。↓ use CGI; my $cgi = new CGI; my $name1 = $cgi->param('handle'); # なんで「$name1」なんだろう・・・ my $name2 = $cgi->param('number'); # なんで「$name2」なんだろう・・・ my $message = $cgi->param('message'); # if ($in{'handle'} ne '' && $in{'message'} ne '') { # の部分を差し替え↓ if($name1 ne '' && $message ne '') { ところで、HTMLフォームに<INPUT name="number">がないんですけど、$cgi->param('number')はどこからどんなデータを引っ張ってきているんでしょうね？ あと、質問とは内容が離れるかもしれませんが、質問者さんのスクリプトはいろいろと問題を抱えているように見受けられます。 ●HTMLフォームがUTF-8であれば、送られてくるデータもUTF-8であることが（今時のPCブラウザなら）保証されるのにもかかわらず、なぜ文字コードの自動判定（Encode::Guess）でわざわざUTF-8以外の文字コードとみなすようにしているのでしょうか。また、あえて「Shift_JIS」を使うということは、UTF-8よりも利用できる文字種がはるかに少ないということに留意してください。これらはどちらも文字化けやセキュリティホールの原因にもなります。携帯電話への対応や外部システムとの連携が必要でない限り、データ保存を含めて全てUTF-8で行うのが現代の主流です。 ●BBSデータファイルの読み書きで、（文法ではなく）ロジックに問題があります。適切な排他制御を行っていないために、読み書きが同時に発生した場合にはそれまで書き込まれたデータが失われる等の不具合が発生することでしょう。適切な排他処理の方法については、以前別の質問で回答したことがありますので参考にしてみてください。 http://okwave.jp/qa/q6697390.html http://okwave.jp/qa/q6105773.html ●この入力フォームにHTMLタグを入力したらどうなるかを考えてみてください。悪意を持って書き込んだら、入力フォーム自体を見えなくしたり、別のページに自動ジャンプすることさえ可能です。 ●ケアレスミスを防ぐために、Perl4ではなくPerl5の文法で書きましょう。スクリプト冒頭にはuse strict; use warnings;をつけて。myによる変数の初期化が必要になりますが、未定義の値が紛れ込んだりした場合に警告してくれますので、$cgi->param('number')のようなミスは避けられるはずです。 わからない点があればその旨ご返答頂ければ補足できるかもしれません。頑張ってください。
適当。表示がくずれるので、空白2文字を全角空白にしていることに注意 use strict; use warnings; use CGI; use CGI::Carp qw(fatalsToBrowser); use CGI::Pretty; use Encode; use Fcntl ':flock'; use constant LOG_FILE => '/tmp/data.txt'; my $q　　　= new CGI; my $sended = $q->param('send'); my $text; if ( defined $sended ) { 　　my $message = $q->param('message'); 　　$text = overwrite_file( LOG_FILE, $message ); } else { 　　$text = read_file(LOG_FILE); } my $script_name = $q->script_name; my $html　　　　= << "END_HTML"; <html> 　　<body> 　　　　<h2> one line comment</h2> 　　　　　　<form method="post" action="$script_name"> 　　　　　　　　Message : <input type="text" name="message" size="60"> 　　　　　　　　<input type="submit" name="send"　value="send"> 　　　　　　</form> 　　　　　　<hr> 　　　　　　<pre>$text</pre> 　　</body> </html> END_HTML print $q->header( -type => "text/html", -charset => 'UTF-8' ), $html; ### Sub Routines sub read_file { 　　my $file = shift || die "Require file"; 　　my @lines = (); 　　if ( open my $fh, '<:encoding(shiftjis)', $file ) { 　　　　flock $fh, LOCK_EX; 　　　　@lines = <$fh>; 　　　　close $fh or die "$!:$file"; 　　} 　　return join q{}, @lines; } sub overwrite_file { 　　my $file = shift || die "Require file"; 　　my $message = shift; 　　my @lines = (); 　　my $exist; 　　my $fh; 　　if ( open $fh, '+<:encoding(shiftjis)', $file ) { 　　　　$exist = 1; 　　} 　　else { 　　　　open $fh, '>:encoding(shiftjis)', $file or die "$!:$file"; 　　　　$exist = 0; 　　} 　　flock $fh, LOCK_EX; 　　if ($exist) { 　　　　@lines = <$fh>; 　　　　seek $fh, 0, 0; 　　　　truncate $fh, 0; 　　} 　　$message .= "\n"; 　　my $utf8 　　　　= Encode::is_utf8($message) 　　　　? $message 　　　　: Encode::decode_utf8($message); 　　unshift @lines, $utf8; 　　print {$fh} @lines; 　　close $fh or die "$!:$file"; 　　return join q{}, @lines; }
> unshift(@file, "$in{'name1'}\t$in{'name2'}\n"); ／／ココの部分です だと、 $in{'name1'} , $in{'name2'} が展開されます。%inというハッシュで、キーが 'name1', 'name2'の値、という意味です。 入れたいは%inではなく、単純な変数なのですから、どう書けばいいかわかると思いますが。 また、この方法を使わなくても ・sprintfを使う: sprintf("%s\t%s\n", $name1,$name2) ・文字列結合の演算子 . を使う: $name1 . "\t" . $name2 . "\n" 等もあります。 ダブルクォートの中の変数展開がよくわからないなら、後者の方法を使えばいいです。 あと、これって > @file = <FH>; > close(FH); > unshift(@file, "$in{'name1'}\t$in{'name2'}\n"); ／／ココの部分です． .......「このあたり」......... > if (open(FH, ">form.txt")) { の「このあたり」で他の人がform.txtを書き換えてしまう可能性があります。 >+等の読み書きモードでオープン→flock→読み込み→(必要ならファイルを空に)→書き込み→クローズ 等とするなどして、間に入ってこれないようにする必要があります
[] は (無名) 配列へのリファレンスを生成し, リファレンスはスカラです. つまり my @shop = [ {'start_hour'=> '1100','shift'=> [1,2] }, {'start_hour'=> '1130','shift'=> [1,3] } ]; とすると, @shop は「2個の要素を持つ配列へのリファレンス」という 1個の要素しか持ちません. やりたいことは, 本当は my @shop = ( {'start_hour'=> '1100','shift'=> [1,2] }, {'start_hour'=> '1130','shift'=> [1,3] } ); だったりしませんか?
use MIME::Base64;としたくないなら、require 'C:/Perl/lib/MIME/Base64.pm'; ついでながら、モジュール「HOGE::Fuga」がインストールされているか確認するなら コマンドラインから > perl -MHOGE::Fuga -e '' エラーが出なければインストールされています。
私なら、結果保存用配列作って該当行をpushします。 @line = split(/\n/,$content); @result = () ; foreach $line (@line){ 　　if ($line =~/a/){ 　　　 push @result, $line ; 　　} }
＞ 行の最初の”を削り、読んだものに上書きしたいのです。 ってことなら、書き換えたいファイルをa.txtとして、コマンドラインから、 perl -i.bak -pe "s/^.//" a.txt ――と実行してみるとか(各行の最初の1文字を強制的に削ります)。
条件が細かく変わり続けているので自信ありませんが・・・ 推測込みでまとめるとこういうかんじでしょうか 1, (L)12× の「ようなもの」が続くとき、末尾の一つには×がつかない 2, 末尾ひとつの「ようなもの」の直後に、「cm」がなかった場合だけ「cm」を付与したい http://ideone.com/7hrZH
テーブル作成のSQLでこけてるようですね。 perlbbs\var\sql.cgiのtype=InnoDBは、MySQL4の構文かな？ MySQL5では、ENGINE=InnoDBのようです。 まずはその辺でしょうか。
Net::SMTPのSSLだかTLSだか使う必要があると思います。 あとはAuthen::SASLがインストール済であることとか。
データ量がすくないのであれば、連想配列でいけるかと。 具体的なデータが不明なので、データ構造をどう構成すればよいかは回答不能ですが。 データ量が多いのであれば、なんらかのデータベース・ソフトを利用したほうが効率の向上が望めるとおもいます。
> $userpassをutf16にする関数の使い方はあってますか？ 本家では > my $newUniPW = $charmap->tou('"'.$newPW.'"')->byteswap()->utf16(); となっています。 よく考えたら私はActivePerlで動かしていたので、 Linux環境ではbyteswap()がないとダメとか、 どこかでチラ見した記憶が・・・曖昧ですみません。 http://search.cpan.org/~gbarr/perl-ldap/lib/Net/LDAP/FAQ.pod#..._in_MS_Active_Directory_?
正規表現「のみ」では困難で、私なら、 #! perl -p 1 while (s/(\"[^" ]+) ([^"]+\")/$1_$2/); ぐらいで妥協します。 ダブルクォーテーションに囲まれた文字列が1行に0～1個まで、 すなわち、以下のような行がないなら、もう少し簡略化できるでしょう。 aaa bbb ccc ddd eee "fff ggg hhh iii" "jjj kkk"
バックスラッシュと円マークは同じ意味です。 Windows環境だと通常はバックスラッシュも円マークで表示されますが、 そういうことではありませんか？ スラッシュの右隣のキーがバックスラッシュなので、それを押してみても円マークが表示されませんか？
「&#～;」という表現形式は、「数値文字参照」や「文字参照」と呼ばれ、 HTMLやXML内で使用される文字表現方法です。 (参考) http://ja.wikipedia.org/wiki/%E6%96%87%E5%AD%97%E5%8F%82%E7%85%A7#.E6.95.B0.E5.80.A4.E6.96.87.E5.AD.97.E5.8F.82.E7.85.A7.EF.BC.88.E6.96.87.E5.AD.97.E5.8F.82.E7.85.A7.EF.BC.89 例えば、楽は、16進数に変換すると&#x697d;になります。 この「697d」が文字コード部分ですが、特定の文字コードが使用されている わけではありません。SJISだったりUTF-16だったりいろいろあり、 使用される文字コードは、どこか別の場所に書かれています。 ただ、SJISやEUCは、たいてい0x8000以上の文字コードが使用される ようになっており、「697d」といった0x8000以下の文字コードを 使用しているのはUTF-16(Unicode)であると推測できます。 それで、 http://ja.wikipedia.org/wiki/Unicode%E4%B8%80%E8%A6%A7_6000-6FFF から「697d」の文字を調べると「楽」という感じであることがわかります。 同様の方法で「し」を調べると、ひらがなの「し」であることが わかります。 その「&#～;」で書かれているデータを「.htm」の拡張子を持つファイル名 で保存して、ブラウザで開けば、結構読めたりします。
エラーになるのは Content-Type などのhttpヘッダーを出力する前に、変数の値を出力しているからでは？ おそらく、そのCGIスクリプト中で下記などの様にして Content-Type ヘッダーなどを出力していると思いますが、その後に変数の値を出力してみればどうでしょう？ print"Content-type: text/html\n\n";
ファイル名や引数に法則性があればファイル一覧の取得などで簡便に書ける可能性もありますが、詳細が不明なのでとりあえず力技で。 use strict; use warnings; while(<DATA>) { chomp; my($filename, $p) = split /\s+/; system("./a.out -P $p -i ${filename}.wav -o ${filename}.cep"); } exit; __DATA__ test1_1 256 test2_1 500
＞ゾンビプロセス自体は、発生後に消える状態ではあります。 ゾンビプロセスの意味を理解されていますでしょうか？ 消えるなら問題ありません。正常です。 通常、プロセスは終了するとプロセステーブル上でゾンビプロセスという状態になり、親プロセスからwaitされて、プロセステーブルから消えます。 「いままでゾンビプロセスでいる時間はミリ秒単位で、気づかなかったが、ゾンビプロセスでいる時間が長くなって、人間がpsでみるとしばしば見かけるようになった」 ということであれば、親プロセスの処理が重くなったとかでしょうかね。
例えばこんな感じとか？ use strict; my %data; while (<STDIN>) { my ($key, $value); $_ =~ s/[\r\n]//; $key = $value = $_; $key =~ s/([^ ]+)\s(.*)/\1/; $value =~ s/([^ ]+)\s(.*)/\2/; push(@{$data{$key}}, $value); } while(my ($key, $value) = each %data) { print "$key "; foreach (@{$value}) { print "$_,"; } print "\n"; }
ちょっと裏技的に use Encode ; binmode(STDOUT,":bytes") ; # バイトコードをそのまま出力させるように変更 printf "|%2s\n|",Encode::encode('cp932',"あ"); # cp932にencodeすれば、2バイト文字は「2バイト=2文字」扱いになる 既出の方法の方が汎用性はありますけど。
私が実際にPerlのスクリプトでやっている事といえば、 ・ローカルIPから使用者を調べる（IP→マシン→資産管理表の使用者）。 ・ルータのログから、検索エンジンのクエリ部分をデコードしてメールで送る。 ・一つ一つブラウザを操作しないと確認できない事を一覧にしてメールを送る。 ・一つ一つブラウザを操作しないと登録できない事（CSV非対応）をやらせる。 ・テンプレートで送られてきたメールを読み取ってデータベースに登録する。 ・FTPsでデータ取ってきて圧縮して保存した後にゴミ掃除もやってもらう。 とか。 PHPではやり方が皆目見当がつかないというのであれば、 Perlでもはじめたら良いと思います。
use がコンパイル時に処理するのに対して require は「そこにきたとき」に処理します. なので, require であれば普通に if で分岐できます. use はそのまま書くと if の条件に関係なく処理するから, #1 のように eval するくらいだと思います. 十分新しい Perl なら if ってプラグマがあるんだけど, jperl にはないと思う. ところで, この length ってあってる? なんか decode っぽい気がするんだけど.... あと, 本当ならこんな小手先の対応でお茶を濁すんじゃなくって, きちんと書き直す方がいいんだよね.
ファイルというものは、原稿用紙のマス目にぎっちり文字を書くようなものだと思ってください。 途中を書き換える、というのは、消しゴムで消して書きなおすようなものです。 元と同じ文字数なら、消したところに書くだけですが、元より短かければその分が空いたままになるし、長ければマスが足りません。 ワープロやエディタのように空きを詰めたり、後へずらしたりしません。 自分で前や後へ書き写す必要があるのです。
$FORM{$name} .= (defined $FORM{$name}) ? "," . $value : $value; @value = $value; print WRITE"@value\n"; } の部分を $FORM{$name} .= (defined $FORM{$name}) ? "," . $value : $value; } print WRITE $FORM{'color'}."\n"; close(WRITE); でいいと思います。 print WRITE (defined $FORM{'color'})? $FORM{'color'}."\n":"入力がありません\n"; とやってもいいかな。
「次に書いている行」というのは、 print "$total3[1]"; print "$total4[1]"; ですよね？ 頭のほうで次の2行を足しておけば、とりあえず動くんじゃないかなとは思います。 @total3 = (0, 0, 0, 0, 0, 0); @total4 = (0, 0, 0, 0, 0, 0); ＜おまけ＞ $kensoukenや$tantou1の代入箇所等読み取れないので、全部コード貼ったほうが良いのではないかなと思いました。 各カラムの中に「,」を含むことのないCSV形式なのでしょうか？ 入力データ次第でしょうが、CSVモジュールを使ったほうが安全な気もします。 if文の内容に重複があるので、まとめた方が読みやすいかもしれません。 @total3, @total4を配列にしているのは何か理由があるのでしょうか？ ざっとみるかぎり、先頭から2番目の要素しか使っていないようにも思えます。 というあたりを、CSVモジュール以外個人的にまとめ直してみました。 （入力は標準入力に変えてあります。） http://ideone.com/cB4qR
localtime とか mkdir とかを使ってなんとかならない?
以下を組み合わせたら何かしら出来るかと思います。 # STDINで指定 chomp( my $stdin = <STDIN> ); # forで$stdin回まわす my $name = "hoge"; for (1..$stdin) { print $name . $_ , "\n"; } # Tagを回す my @tags = qw(AGT ACA TAT TGA); foreach my $tag (@tags) { print "$tag\n"; }
XMLin の前に $XML::Simple::PREFERRED_PARSER = 'XML::Parser'; としておくとよいようです。 また、XML::Simple utf8 でググると役立つ情報が多々あります。
既存のファイルの先頭に行を追加することはできないので、ファイルを全部読み込んでから書き出すことになります。なお、事前に対象のファイルを逆順にしておく必要があります。 > open( WRITE, ">> $file" ); > print WRITE"$rank\n"; > close ( WRITE ); ↓ open( READ, "<$file" ); @lines = <READ>; unshift @lines, "$rank\n"; open( WRITE, "> $file" ); print WRITE @lines; close( WRITE );
LWPを利用しないでやることになりそうなので httpプロトコルを理解するところからではないかな。
適当な事言わずにuse Benchmark qw(timethese cmpthese);。 a-zA-Zのランダム一行40字、100万行（40MB）を indexとregexで検索文字列15字にマッチした行をカウント、 これをそれぞれ100回実行したところ、大差なし。 僅かに正規表現の方が早いですね。 ちなみにregqrは、$search_word = qr/hoge/を使ったものです。 index: 83 wallclock secs (78.55 usr + 4.34 sys = 82.89 CPU) @ 1.21/s (n=100) regex: 75 wallclock secs (72.00 usr + 3.53 sys = 75.53 CPU) @ 1.32/s (n=100) regqr: 74 wallclock secs (69.78 usr + 3.62 sys = 73.41 CPU) @ 1.36/s (n=100) Rate index regex regqr index 1.21/s -- -9% -11% regex 1.32/s 10% -- -3% regqr 1.36/s 13% 3% --
それほど　プログラムができる人間ではないですが。。。 このような　ロジックではいかがでしょうか？ 連想配列hashを　2種類活用し、 1つ目のhash カラム1の種類ごとに　カラム2を足していく。 （hash｛カラム1｝に　どんどん　カラム１が同じもののカラム2の値を足していく。） hash｛カラム1｝=hash｛カラム1｝+カラム2 2つ目のhash2 カラム1の種類ごとに、各カラム１のおなじものが　何個あるか　カウントしていく。 （hash2｛カラム1｝に　カラム1が同じものをカウントしていく。） hash2｛カラム1｝=hash2｛カラム1｝+1 平均値は hash｛カラム1｝/hash2｛カラム1｝で　求まると思います。
もしかすると本来\xe3\x80\x9cだったものが、 \xef\xbd\x9eに割り振られていたのではないでしょうか？
こういうことでしょうか？ 1 while $wk =~ s/^([-+]?\d+)(\d\d\d)/$1,$2/; print $wk; https://ideone.com/hkaPM
http://www.din.or.jp/~ohzaki/perl.htm#NumberWithComma
桁あふれをおこしているようですから、自力で書き換えるしかないかと思います。 サンプルの数字は、16進数では 0x8000_0000_0000_0000 ですから、 0 の数は 63、1を含めて 64 桁ですね。 #! perl %~f1 9223372036854775808 our $decimal = shift; print $decimal, "\n"; my $dec = $decimal; my @bin = (); while ($dec > 0) { unshift (@bin, sprintf("%d",($dec % 2))); $dec = int($dec / 2); } print "0b", join('', @bin), "\n";
念のため、/var/www/html/testbbs/というフォルダはあるんですね？ コマンドラインで、/var/www/html/testbbs/に行って、touch fooとか書いたら、fooというファイルは出来ますか？ （rootではなく、一般ユーザーで） open(NS,">/var/www/html/testbbs/$newres.html") or warn "!!! Error Log==> $!"; とやってみたらどうでしょうか。 open命令で失敗すると、その理由（$!変数に格納される）が!!! Error Log==>という文字列と共にエラーログに吐き出されます。 エラーログに「何も」出ていないというのがちょっとヘンですね。 何かしら何かが表示されているものですから・・・。 あまりにも早く流れてしまっていて、ファイルの作成に失敗しているログは通り過ぎている（あるいは循環ファイルで、そのメッセージは消え去っている）とか・・・。 CGI::Carpは試してみましたか？ あまりお役に立てず、スミマセン。
use Encode qw(from_to);とするか、 Encode::from_to()とする。 あと'euc'という文字コードも該当なしなので'eucjp'とする。
サイトという言葉を使っているので、httpでの接続だと想定しますが 基本的に無理です。サイトb側でなんらかの策を取る必要があります そもそも、//サイトb/フォルダ/index.html とかあったとしても、実際に「フォルダ」というディレクトリが存在して、その中にindex.htmlというファイルがある、という保証がありません。
「フォルダにあるファイルをリストする」だけなら 1. glob を使う 2. ディレクトリハンドルを使う は考えられる.
サーバー、Webサイトは並行稼動しているのでしょうか。 cookie をセットするときに、ドメインを指定しているが、 移行先のサーバーにアクセスする際のURLのドメインと 異なる、なんてことはないでしょうか。。。
Perl のリファレンスは C などのポインタじゃないよ. Perl から C の関数を呼びたいなら... XS?
「ｈｔｔｐ」 でセットしたものを 「ｈｔｔｐｓ」 でゲットしょうとしている ということはありませんか。
やってみて失敗したのですか？ 私が試した限りでは、どちらの変数にも0が入り、 期待通りメッセージが出力されましたけど。 なので、何を問題とされているのか、 何がわからなくて質問されているのか、 私にはよくわかりません。。
選択した商品（カゴに入れた商品）の情報はどういう方法で保持するようになっているんですか。 これが示されないと答えようがありませんよ。
日本語版も。 Perldoc.jp http://perldoc.jp/docs/perl/5.10.0/perlsyn.pod これ読むと、next if $x;　のような用途に限定すべきでしょうね。
表示がくずれので空白2文字を全角空白にしていることに注意。 use strict; use warnings; use utf8; use Web::Scraper; use Data::Dumper; my $html = << 'END_HTML'; <html> 　<head> 　</head> 　<body> 　　<div id="share_item"> 　　　<ul> 　　　　<li> 　　　　　<a href="http://twitter.com/share?text=xxx&via=test_mk" target="_blank" onclick="s_omni.trackSNS('twitter')">twitter</a> 　　　　</li> 　　　　<li> 　　　　　<a href="http://www.facebook.com/share.php?u=http://aaa.c" target="_blank" onclick="s_omni.trackSNS('facebook')">face book</a> 　　　　</li> 　　　　<li> 　　　　</li> 　　　　<li> 　　　　　<link rel="mixi-check-image" type="image/jpeg" href="http://aaa.com//img/site/3.jpg" /> 　　　　　<a href="javascript:void(0);" 　　　　　　 onclick="window.open('http://mixi.jp/share.pl?u=http://aaa.com/&k=cf68" 　　　　　　 src="http://aaa.com/btn5.gif" alt="mixiチェック">mixi</a> 　　　　</li> 　　　</ul> 　　</body> 　</html> END_HTML my $scraper = scraper { 　　process '#share_item ul li a[href^="http://twitter.com/"]', 'twi_url' => '@href'; 　　process '#share_item ul li a[href^="http://www.facebook.com/"]', 'fb_url' => '@href'; }; my $res = $scraper->scrape($html) || die "$!"; print Dumper($res); # $VAR1 = { #　　　　　 'twi_url' => 'http://twitter.com/share?text=xxx&via=test_mk', #　　　　　 'fb_url' => 'http://www.facebook.com/share.php?u=http://aaa.c target=' #　　　　 }; > 「#share_item ul li」 > のように # がつく記述と付かないパターンがあるのですが、 > この違い（#が必要な時）が不明です。 「CSS 一意セレクタ」で調べてみて下さい。
具体的な実行方法を補足してください。 また、拡張子を隠す設定になっていませんか? コマンドプロンプトなどから perl スクリプトファイル名 で実行したなら、拡張子がなんであろうとPerlのスクリプトとして実行できます(少なくとも、実行しようと試みます) ダブルクリックで実行した場合は、関連付けに従って実行されます。 .plがPerlと関連付けされてるとは思います。 ただ、エクスプローラの設定次第では、実際の拡張子が隠れている場合があります。 サクラエディタで保存したときに、実際には～.pl.txtになっていて、.txtが隠れていて ～.plに見えるだけ、ということは無いですか?
表示がずれるので、空白2文字を全角空白にしていることに注意 #define _GNU_SOURCE #include <stdio.h> #include <string.h> #ifndef __CYGWIN32__ #include <dlfcn.h> #endif /* BINARY HACKS P.300 */ /* 関数への enter/exit をフックする */ #ifndef __CYGWIN32__ __attribute__((no_instrument_function)) void addr2name(void *func_address, char *func_name) { 　　Dl_info dli; 　　if (0 != dladdr(func_address, &dli)) { 　　　　strcpy(func_name, dli.dli_sname); 　　} 　　else { 　　　　strcpy(func_name, ""); 　　} } #endif __attribute__((no_instrument_function)) void __cyg_profile_func_enter(void *func_address, void *call_site) { 　　extern void *__libc_stack_end; 　　char　　　　 func_name[256]; 　　int　　　　　stack_size; 　　void　　　　*frame = __builtin_frame_address(1) + 8; #ifndef __CYGWIN32__ 　　addr2name(func_address, func_name); 　　stack_size = __libc_stack_end - __builtin_frame_address(0); #else 　　strcpy(func_name, ""); 　　stack_size = 0; #endif 　　printf("enter %s:%p, from=%p stack size=%d\n", 　　　　　 func_name, func_address, call_site, stack_size); } __attribute__((no_instrument_function)) void __cyg_profile_func_exit(void *func_address, void *call_site) { 　　char func_name[256]; #ifndef __CYGWIN32__ 　　addr2name(func_address, func_name); #else 　　strcpy(func_name, ""); #endif 　　printf("exit　%s:%p, from=%p\n", func_name, func_address, call_site); } void sub_func(int arg1, char arg2, char *arg3) { } void func(int arg1, char arg2, char *arg3) { 　　sub_func(arg1, arg2, arg3); } __attribute__((no_instrument_function)) void func_no_instrument_function(int arg1, char arg2, char *arg3) { } __attribute__((no_instrument_function)) int main(int argc, char *argv[]) { 　　int　 arg1 = 10; 　　char　arg2 = 20; 　　char *arg3 = "abc"; 　　printf("sub_func = %p\n", sub_func); 　　printf("func = %p\n", func); 　　func(arg1, arg2, arg3); 　　func_no_instrument_function(arg1, arg2, arg3); 　　return 0; } /* $ gcc -g -finstrument-functions -rdynamic foo.c -o a.out -ldl && ./a.out */ /* sub_func = 0x804891e */ /* func = 0x8048952 */ /* enter func:0x8048952, from=0x8048a13 stack size=264 */ /* enter sub_func:0x804891e, from=0x804898b stack size=312 */ /* exit　sub_func:0x804891e, from=0x804898b */ /* exit　func:0x8048952, from=0x8048a13 */
/^(q|.*&q)=([^&]+)(&.*|)$/$2/ 最後の& がつづいてるかどうかの判別をわすれていた。
２行単位で処理するようなループを書けば、正規表現マッチが簡単になると思います。 my $twoline = <FH>; while (<FH>) { $twoline .= $_; $twoline .= "printf(\"hoge\");\n" if $twoline =~ /int\s\w*\(.*\)\s*\n\s*\{\s*\n/; my ($line1, $line2) = $twoline =~ /^(.*\n)(.*\n)$/s; print $line1; $twoline = $line2; } print $twoline;
まず、お約束として、スクリプトの最初の方に use strict ; use warnings ; を書きましょう。こうすると、宣言してない変数とか、未定義値を文字や数値として利用したりするなど、通常はそのまま使えることが、エラーにや警告になります。 で、おそらく、$sdataについてエラーまたは警告が出るはずです。提示された範囲で$sdataに値が設定されているのは > $sdata="$in{'d_no'}=$in{'s_no'}=$in{'s_name'}=$in{'d_class'}=$in{'s_price'}\n"; > $sdata="$d_no=$s_no=$s_name=$d_class=$s_price\n" この2行だけです。 > ($d_no,$s_no,$s_name,$d_class,$s_price) = split (/=/, $sdata); では、最初の$sdataは無いので前の変数は全部空だし、2回目以降は先の2行のどちらかの内容が繰り返されるだけです。 初心者とのことですが、それならなおさら基礎を勉強してください。 ネットのサンプルコードを参考にするにも、どこが必要か見極められなければ意味がありません。
Perlの場合、 $a (変数) と @a (リスト) , $a[0] (リストの0番目の要素) と %a (ハッシュ) , $a{'key'} (ハッシュの'key'の要素) とは別です。 また、「ハッシュ」と「無名のハッシュ/ハッシュのリファレンス」も扱いが違います。 この部分だけでは、正しい対処はわかりません。 ・呼出側で func($form_value, %error_list) のようになっている場合: @_は「スカラーが一つとハッシュの中身」を並べたリストになり、関数内で復元させるなら my ($form_value,%error_list) = @_; です。 ・呼出側で func($form_value, $error_list) のようになっている場合: my ($form_value,$error_list) = @_; で正しく、 $error_list{'inquiry_type1'} が間違いです。 $error_listが示すハッシュのリファレンスの中にアクセスするには $error_list->{'inquiry_type1'}のようにします。 名前のこととリファレンスは基本事項なので覚えてください。
> \Q$ARGV[1]\E は、$ARGV[1]に正規表現が含まれていても、 > 普通の文字列として扱うという事なのでしょうか? はい、その通りです。私がご質問の内容を見落としていたのですが、 スクリプトの引数に正規表現を意図的に使えるようにしたいということであれば （＝sedと同様の動作を期待するなら）\Q \Eは全く必要ありません。失礼しました。 サンプルスクリプトのエラーの原因を説明するために必要だったということでご容赦ください。 もちろんその際は、各種カッコやピリオド等を必要に応じて手動エスケープしてやる必要があります。 （例：「a.txt」が「abtxt」にマッチしてしまうのを防ぐ→「a\.txt」にする） > ・「cp932文字列がバイナリとして入ってきます。」というのは、 > 2バイト文字は、2つの1バイト文字の並びとして入ってくる、つまり、 > 内部では2バイト文字として扱われないという意味でしょうか? はい、そうです。length()で文字数を確認してみるとわかりやすいです。 マルチバイト文字を1文字として扱うには、Encodeモジュール等でテキストを内部utf8表現にしてやる必要があります。 バイナリはlength()がバイト数を返すのに対して、内部utf8表現は文字数を返します。 これはUTF-8文字も同様です。UTF-8であってもデフォルトではバイナリとして扱われます。 つまり、一般的なUTF-8と内部utf8表現は異なるものです。 少々ややこしい話になるので、詳細は「Perl utf8」等で検索してみてください。 > ・最後に、 > use strict; use warnings; > は、いままでソースファイルに記述してこなかったのですが、 > これらはなぜ記述するべきなのでしょうか? スクリプトの潜在的なバグを回避するのに極めて有効な手段だからです。 今回のような小規模なスクリプトでは恩恵は少ないように思われるかもしれませんが、 ミスを防ぐために冒頭につけておくのはよい習慣とされています。 大雑把に説明すると、 ・use strictプラグマ - 宣言のない変数の使用等をエラーにする use strict; # my $hoge = 'abc'; # 変数宣言をコメントアウトすると・・・ print $hoge; # 宣言されていない変数$hogeが使われたよ、とエラーになる ・use warningsプラグマ - 未定義の値に対する操作や同名変数の二重定義等に対して警告を出す use warnings; my $hoge = 'abc'; # 変数宣言 $hoge = 'def'; # 変数の使用 my $hoge = 'ghi'; # 同名変数が同じスコープで宣言されたよ、と警告が出る といったところです。詳細は検索してみてください。
同じ数字がたくさん出てきてややこしいので説明用に use strict; $_ = [1, 2]; grep($_ == $$_[0], 3, 4) と変更します。エラー原因に関係する変更ではありません。 そもそも$_=[1,2]のままでも $_ == $$_[0] は $_がリファレンス、$$_[0]はデリファレンスしたリストの先頭要素"1" と比較すること自体が論理的に変です。言語仕様的にエラーにはなってないですが。 それが、grepで $_が対象リストの各要素に置き換わって、最初は$_="3" となり、 そのリファレンスではない"3"をデリファレンスしようとしたので Can't use string ("3") as an ARRAY ref while "strict refs" in use エラーになっています。
波ダッシュ問題という有名な問題なのでこの言葉で検索すれば詳細が得られると思います。 解決方法は色々あると思いますが、以下のように全角チルダを波ダッシュに強制変換するとか。 Perlで日本語(ISO-2022-JP)メールを送信(まとめ) http://d.hatena.ne.jp/kopug/20060903
入力ファイルの構造に乱れがなければ、次のプログラムで処理できると思います。 use strict; open IN, "FILE_A.txt" or die "Can't open FILE_A.txt: $!"; open OUT, ">FILE_B.txt" or die "Can't open FILE_B.txt: $!"; my $name; while (my $line = <IN>) { if (substr($line, 0, 1) eq '!') { $name = ''; } elsif ($name eq '') { $name = (split /\s+/, $line)[1]; } else { $line =~ s/$/ $name/; print OUT $line; } } close IN; close OUT;
日付を指定させ、それをキーにして順読みでマッチング。 そのマッチングした位置（カウンター）をキーにして、「splice」。 以外とスッキリ書けますよ。
>#2 なるほど、出力は同じでも意味合いが全然違ったんですね・・・ 添削有難うございます！ 訂正版: http://ideone.com/fPiHR
ソートには「シュウォーツ変換」と呼ばれるやり方があります。ネット上にはたくさんの情報がありますので参照してください。次のプログラムは、１行に１処理で書いています。 use strict; my @data; push @data, [$_, $., split /\s+/] while <DATA>; @data = sort { $a->[2] cmp $b->[2] or $b->[3] <=> $a->[3] } @data; @data = @data[0, grep { $data[$_ - 1]->[2] ne $data[$_]->[2] } 1 .. $#data]; @data = sort { $a->[1] <=> $b->[1] } @data; @data = map { $_->[0] } @data; print @data; __DATA__ aaa 8000 52 abc 200 48 cbd 250 31 efg 98 45 abc 390 68 ddd 89 90 aaa 65 40 fed 900 66 efgh 99 49 abc 40 40
perl -e "print 'Hello world!!';" の例とまったく同じですが。 どの辺りがわからないのでしょう?あなたの考える「正確な意味」にたりないものを補足してもらえるとありがたいです。 ・"とかが付いていない →例では、空白などが混じっているので''でかこって一つの文字列にしていますが、「shell」だけなら一つの文字列になっているのでくくる必要はありません ・;とか付いてない。文法的に違うのでは? →ブロック等の最後の;は省略できることになっています。 ・shell って関数がマニュアルに載ってない。 →Perlはモジュールを使用することで、標準では無い関数を定義できます。 いろいろ省略しないで書けば perl -MCPAN -e '&CPAN::shell();' になります(まだ足りないかも)
対象のデータのフォーマットですが > *○ △ /△/△/△/△/○.txt, ○|○): ○ > ○,△:任意の数字、または文字列です。 だったのが > Error_check: *Error, (/mmmm/xxxx/yyyy/zzzz/aaa/bbb/ccc/ddd.txt,1|0): Error_contents と食い違いがありますよね。 ・Error_check: ・*Error の後の△に対応するものは? ・開きガッコ ・二つめの○に対応するものとして取り出したい内容に .txt は含まれる? .txtのあとのカンマの後の空白 といったあたり。 最初の例だと 1|0 は1と0として取り出したいように読めるのですが、後で出された例ではまとめてのようですがこれは? また、/…/ddd.txt はなにかファイルのパスのように見えますがこの段数も二つの例で数が違います。 どちらが正しいのかあるいは可変なのか? Error_contents も本当にこの字面が並んでいるんじゃなくて、エラーの内容などを表す文字列がくるのではないですか? (Error_checkもそうだったりして?) いずれにしても、どういった書式のデータがくるのかがはっきりわかれば他の方がいろいろ例を出しているように 書きようはあります。裏を返せばはっきりしなければどうにもならないということですが。
「間違いの可能性がある」あるいは「もっと効率いい方法がある」と思います。 ・${HTTP_USER_AGENT} が UPXBrowserでもマッチします。 →UP.Browser と「.」以外が絶対に無いのなら問題にはなりませんが →.をエスケープするとか、indexを使うとか。 ・$agentの中身はどうなっているのでしょう? →UP.Browserとかが沢山あるならともかく、一つしかないのならgはいらないです →上と同様KDDI-KC3R UPMBrowser/612_7324771-K-45310 (GUI) MMP/250 みたいなのも置換されます。まずないでしょうが。 →$agent=$ENV{'HTTP_USER_AGENT'} なら、置換などせずに $agent='au' ; で済みますよね ・$ENV{'HTTP_USER_AGENT'} は今アクセスしている人のものです → 「あなたはauを使っています」みたいな使いかたならいいですが
えーと。 変換処理もされていません。ファイルを開いて読んだだけです。 $aはプログラム中「if($a =~ /&quop/){」までの間でどこにも出てきませんよね? ということは、$aは未定義で、文字列にしたら '' つまり長さが0の空文字列に相当します。 きちんと勉強するなら、最初に use strct; use warnings; を付けて判定を厳しくするといいでしょう。 また、動作確認中は、入出力のファイル名を別にして、上書きされないようにすると作業が楽だと思います。
\Q
次のプログラムは、ファイルからの読み込みに変更する必要があります。 use strict; my %file2 = (BB => [['EEE', 'RRR'], ['EEE', 'SS'], ['FF', 'TTTT']], W => [['EEE', 'TTTT']]); while (<DATA>) { my @line = split /\s+/; if (exists $file2{$line[1]}) { print join("\t", @line, @$_), "\n" foreach @{$file2{$line[1]}}; } } __DATA__ AAA BB CC DDDD AAA BBB CC DD XX BB YYY Z ちなみに、ファイルからの読み込みで %file2 を構築するには次のようにします。 while (<FILE2>) { my ($c1, $c2, $c3) = split /\s+/; push @{$file2{$c1}}, [$c2, $c3]; }
まず本題を先に済ませてしまうと my @b = ( qw(e f g) ); と my @b = qw(e f g); の間に違いはありません. 全く同じことです. 「書き換えた後のコード」で my @t = ( qw(a b c) ); となっているのは, 単に無名配列を作る [ qw(a b c) ] と形を合わせたかっただけではないでしょうか. で余談: #1 ではなんだかんだ書いたけど, でも「perlにおいて()で囲むのはリストとして扱うということ」と思っちゃうのはまあ無理ないと思います. だいたい my @a = ("a", "b", "c"); って書くしね. ただ, ここのかっこは実は「リスト」とは全く関係ありません. じゃあなんでかっこがあるかというと 優先順位を変えるため です. Perl では代入演算子の方がコンマ演算子よりも優先順位が高いため my @a = "a", "b", "c"; と書くと (my @a = "a"), "b", "c"; と解釈されてしまうのですが, それでは困るので右辺にかっこをつけています. つまり $a * ($b + $c) のかっこと役割は全く同じです. 1 の my $a = qw(a b c); は my $a = ("a", "b", "c"); と同じ意味で, この右辺は (コンマ演算子の動作により) 「"a", "b" の値は評価だけして捨て, "c" の値を返す」ということになります. なので $a の値は "c" となります. 上の my @a = ("a", "b", "c"); では右辺がリストであるのに対し下の例ではリストになっていませんが, これは「代入演算子が左辺を見て右辺の評価の仕方を変えている」からです. つまり上の例では左辺が @a と配列になっているので「じゃあ右辺はリストとして計算しないとだめだな」としますし, 下の例なら左辺 $a がスカラー変数なので「右辺はスカラーとして計算しよう」となります. 専門的には, この「○○として計算しよう」というのを「コンテキスト」と呼びます. コンテキストにはいくつかの種類がありますが, とりあえずスカラーコンテキストとリストコンテキストの 2つをおさえておけばだいたい何とかなります. 2 の my @a = qw(a b c); my $a = @a; ではまず配列 @a に値を代入します. 次にスカラー変数 $a に配列@a を代入していますが, この場合代入する変数 $a がスカラーなので右辺はスカラーコンテキストで評価されます. そして スカラーコンテキストで配列を評価すると要素数が得られる ため, @a の要素数である 3 が $a に入ります. 3 と 4 は同じ結果になりますが, ここでは代入の左辺 ($a) が「リストである」ことに注意が必要です. つまり「左辺はリスト」なので, 「右辺もリスト」として計算します. そして得られた値を「要素ごとに代入」しているので $a の値は "a" です. 「代入する変数」そのものはスカラーであっても, ($a) となっていればリストです. なお, 無名配列を作る [] や無名ハッシュを作る {} は, その内部に対し (当然ですが) リストコンテキストで評価します. さらに余談ですが, 「かっこをつけなくてもリストになる」例として「リストを要求する演算子」を挙げることができます. print はそのような演算子なので, たとえば print $a, $b, "\n"; と書くと「$a, $b, "\n" からなるリスト」に対して print を適用する, という意味になります. もっとも, 現実的にはかっこをつけないといろいろ面倒なことがあったりしますが....
一応、下記のコードで取り出すことができます。 # モジュールを読み込む use XML::Simple; # 一旦、XMLを $xml に読み込む my $xml_file = 'result.xml'; open my($fh), '<', $xml_file; my $xml = join('',<$fh>); # x-sjis-cp932 があると解析に失敗するので、 # <?xml version="1.0" encoding="x-sjis-cp932" ?> を削除 # XML を UTF-8 で書くと下記の処理はいらない。 $xml =~ s/<\?.*\?>//; # XML::Simple を使い、$ref にリファレンスのツリーとして解析する my $x = XML::Simple->new(); # パーサを作成 my $ref = $x->XMLin($xml); # 必要なデータを出力 print $ref->{result}->[1]->{redirect}; XML::Simple はこの例のように単純な構造のXMLを Perl 的な変数のツリーに変換するモジュールです。 少なくとも Perl のリファレンスをある程度理解していないと何をしているかわからないと思います。 最後の行の「$ref->{result}->[1]->{redirect}」が何を意味しているのか分からないようでしたら、まずリファレンスを学習し、XML::Simple の説明を読むとよいと思います（参照URL）。
レキシカルスコープと呼ばれるものを作るためです。 Perl では { } で囲まれた範囲（ブロック）にレキシカルスコープと呼ばれるものができます。 レキシカルスコープ内で my を付けて宣言さた変数（@new）はそのブロック終了後（対応する } より後ろ）は使えなくなり、間違えて同名の変数（@new）を再使用してしまう間違いを犯しにくくなります。 空のブロックでなくても、sub{}、if{}、foreach(){} など、さまざまなブロックでレキシカルスコープは作成されます。 「Perl スコープ」で検索されるといろいろ発見があると思います。
DESTROYを呼ぼうとして、DESTROYが存在しないのでAUTOLOADを呼びました。 オブジェクトが参照されなくなり、オブジェクトが破棄されるときDESTROYが呼ばれます。
Googleでperlをキーワードに検索すると最初の方を見ただけでも 以下のように多数の優良サイトが見つかるのですが、 それらのサイトの内容では不十分と言っておられます？ http://www.tohoho-web.com/wwwperl.htm http://www.kent-web.com/perl/ http://rfs.jp/sb/perl/ http://www.site-cooler.com/kwl/perl/ http://www.perlplus.jp/perl/ であれば、書籍を購入されるのが良いと思います。 Webとは違って検索できませんが、書籍であればスクロールとか しなくても全体を見渡すことができますので。
「上記のデータのリンクのURL「test.php?～～」の部分」としてどれをとればいいのか正確にはわかりませんが, たとえば ($url) = ($data =~ /\bhref="(.*?)"/i); ではダメですか?
C:\dev\perl\bin\ だけのジャンクションを作成したのが失敗だと思います。 C:\dev\perl\Site やC:\dev\perl\lib など他に色々とフォルダがあり、基本のpmなどはそこから読み込むので。 リソキのlinkd.exeを使っているなら、 > linkd C:\usr C:\dev\perl とやるべきじゃないですかね。
＞フォームに表示させる方法はわかっているんですが、 ＞クリックで指定した1行だけを表示する方法がわからずに困っています。 「1」「2」「3」をリンクにするならGETで、送信ボタンにするならPOSTでデータをリンク先のCGIなどに送ればいいんじゃないかな。 GETで送るなら、 ↓ここを <TD class="list2">$s_no</TD> ↓こんな感じに変えて、(form.cgiは送り先) <TD class="list2"><a href="./form.cgi?no=$s_no&name=$s_name&price=$s_price">$s_no</a></TD> from.cgiで、 my @getdata = split(/'&'/, $ENV{QUERY_STRINGS}); foreach my $s ( @getdata ) { my @arrdata = split(/'='/, $s); $h{$arrdata[0]} = $arrdata[1]; } my $value = join('=', $h{'no'},$h{'name'},$h{'price'},); print "<input type=\"text\" value=\"$value\">\n"; とかで出来ないでしょうか。 ※確認してません。あくまでもヒントなのでコピペでエラーがでたら修正してください。 POSTだと、リンクではなくて"送信ボタン"になると思うので、form.cgi 内の $ENV{QUERY_STRINGS} が使えません。 POSTの場合はstdoutを拾う必要があります。(CGI.pmを使うと楽ちんです。) てか、その一行って、$sdata そのものでしょうから、そもそも$s_XXXXに小分けして送信する必要ないかもしれませんが。。。
「attribute」ってやつだな.
これだけだとなかなか全体像が分からないのですが、 - $nや$iはループ用の変数 - join()された結果(IPアドレスか何かでしょうか) を配列(リスト)に格納 という感じで良いでしょうか。 上記であれば、 @addresses = (); # 一応初期化 push( @addresses, join(".", &ipunpack($n+$i)) ); で @addresses に要素が追加されていきます。 とりあえず「push」で調べるといいことあるかも。
perl xxxxx.pl *.txt 以下のプログラムは、文字列一覧ファイルをスクリプト内で、テキストファイルを上記のように引数として与えるように書いてあります。 use strict; my %check; open IN, "xxxxx.dat" or die "Can't open: $!"; while (my $line = <IN>) { chomp $line; $check{$line} = 1; } close IN; my ($match, $unmatch) = (0, 0); while (my $line = <>) { chomp $line; exists $check{$line} ? ++$match : ++$unmatch; if (eof) { my $judge = ($match and !$unmatch) ? "完全一致" : ($match and $unmatch) ? "部分一致" : "完全不一致"; print "$ARGV: $judge\n"; ($match, $unmatch) = (0, 0); } }
DISTINCTでどうでしょう？
> C言語の関数の様に，「他の関数に値を渡すことはできるのでは？」という思い込みから生まれた質問でした． 起動プロセスが異なるので関数というのはまた概念が異なっていますが、前回答で書きました【仮に】というところで説明した方法をかなりアクロバティックなやり方で実現することは可能です。　具体的なやり方としては「a.cgi」にWebブラウザを偽装させて同Webサーバの「b.cgi」をアクセスして起動し結果を得て、「a.cgi」側で受信した結果をクライアントに戻す際にブラウザ側であたかも「b.cgi」を実行した結果を出しているようにJavaScriptなどでこれも偽装するという方法ですが、こうすることはハック的な色あいが強いので学習以外に実用的なメリットはないと思います。　場数を踏んでゆけばおいおいわかってくることだろうと思います。 > 私は外部ＣＧＩ読み込みを行うreqguireを用いて， ここでいう「require」はCでいうところの「#include」に該当します。 ただ、これはご存知のように同一プロセス(プログラム)内での処理なので、概念そのものが異なります。 要するにCGIの呼び出しは、１プログラムの実行です。 その処理そのものはサーバ側で行われていて、結果のみがローカル側に伝えられます。 CGIなどのWebプログラミングは、近年ではお手軽に利用できるため敷居が低く感じられますが、通常のプログラミングの要素に「ネットワーク」「インターネット」「HTTP」「サーバ」「クライアント」といった別の専門要素が加わるため、各々の基本的な知識をはしょって理解することは無理があります。　あーすればこうなる的な直感でやってるセンスの良い人もいますが、応用力に限界が浅いのも事実です。 とにかく場数を踏み経験をつんでひとつでも多くの知識を身に付けながらがんばってください。
-f 'file'; -x _; とか.
> } if-else($input =~ /([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);{ if-else ってなに?
ほとんどできてます。がんばってください。 print OUT $1; は最初の一発だけ出せばいいのでopenのあとに移動すればいいでしょう。 そのあとに改行（\n）も忘れずに。
> 「ページが表示出来ない」エラー そんなエラーはPerlそのものにはありません。 例えば、このスクリプトはCGIとして実行されていて、なんかのエラーがあるのでhttpサーバーがエラーコードを返して、それをブラウザが「ページが表示出来ない」とエラー表示している、そんな感じではないでしょうか。 まずは、真のエラーの理由と突き止めるのが先決です。 PCで実行してエラーメッセージを確認する、とか、 use CGI:Carp を使ってエラーメッセージをブラウザに表示させる、とかです。 少なくとも、例示されている部分には、多少変なところはありますが、「300件を越えるとエラーになる」というような箇所はありません。あるとすれば、ここに書いてないもの、例えば url_ckeck とかです。 あとは、変数を宣言しなくても使えるPerlですが、ある程度の規模になると、やはりきちんと宣言して有効範囲を限定させることが、意図しない間違いの防止に繋がります。 use strict; use warnings ;は積極的に使いましょう。
> my $str = "(?:.*?(?:$data)){$more_than}"; > の方がちょっとだけいいかも 確かに。 more_than が大きくなるとぜんぜん違ってくるでしょうね。
perl のバージョンにもよりそうなところだがいったん内部コードに変換するのが簡単じゃないかな.
や, そういわれても, ここに挙がっている情報だけでは 「ソースとデストの両方に『使用中の IP アドレス』が入っている行を取り出す」 としか言いようがないです. で, おそらく最も素直な方法は 「『ソース』と『デスト』を取り出してそれぞれが『使用中の IP アドレス』かどうかを確認する」 ってことになると思う. 速度はさておき. ぶっちゃけたところ, どう書いたら 「ソースかデストのどちらかにそれが入っているだけでその行が抽出されてしまいました」 なんてことになるのか想像できない.
コマンドプロンプトで。 >perl -c read.cgi >perl -c patio.cgi とやると、何行目がエラーになってるか表示されます。 スラッシュが１個抜けてるようですが、適宜やりたいようにどうぞ。
$str =~ s/\[url=((?:htt|ft)ps?\:[\w\.\~\-\/\?\&\+\=\:\@\%\;\#\%\,]+)\](.*?)\[\/url\]/<a href=\"$jumpcgi?$1\" target=\"$target\" rel=\"nofollow\">$2<\/a>/ig; を $str =~ s/\[url=((?:htt|ft)ps?\:[\w\.\~\-\/\?\&\+\=\:\@\%\;\#\%\,]+)\](.*?)\[\/url\]/<a href=\"$1\" target=\"$target\" rel=\"nofollow\">$2<\/a>/ig; にする。 デフォルト http://www.kent-web.com/bbs/patio.html 使ったらどうです？ いろいろ改善したいところがあるようですが、 こういう無駄な機能はないです。
これまた、めんどくさいことしたいんですねえ。 簡単に。 $str =~ s/\[list=1\](.*?)\[\/list\]/<ol style="list-style-type: decimal">$1<\/ol>/g; $str =~ s/\[list=A\](.*?)\[\/list\]/<ol style="list-style-type: upper-alpha">$1<\/ol>/g; $str =~ s/\[list=a\](.*?)\[\/list\]/<ol style="list-style-type: lower-alpha">$1<\/ol>/g; $str =~ s/\[list=I\](.*?)\[\/list\]/<ol style="list-style-type: upper-roman">$1<\/ol>/g; $str =~ s/\[list=i\](.*?)\[\/list\]/<ol style="list-style-type: lower-roman">$1<\/ol>/g; $str =~ s/\[list\](.*?)\[\/list\]/<ul style="list-style-type: disc">$1<\/ul>/ig; $str =~ s/\[\*\]/<li>/ig; でどうでしょう。 ただし、[list=○][/list]内にない[＊]も<li>に変わります。 また、 [list] [*]aaa [*]bbb [/list] と書いたら<br>が自動で入るのでおかしくなるかも。 [list][*]aaa[*]bbb[/list] と書けばOK。 完全に対応させる気力はなかった。 ごめんなさい。 これは増やせば増やすほど負荷が増すので注意した方が良いです。
read.cgiの1031行目～1032行目付近 # クッションページに強制アクセス $msg =~ s/(?<!$jumpcgi)([^=^\"]|^)((?:htt|ft)ps?\:[\w\.\~\-\/\?\&\+\=\:\@\%\;\#\%\,]+)/$1<a href=\"$jumpcgi?$2\" target=\"$target\" rel=\"nofollow\">$2<\/a>/g; #$msg =~ s/([^=^\"]|^)(http[s]?\:[\w\.\~\-\/\?\&\+\=\:\@\%\;\#\%\,]+)/$1<a href=\"$2\" target=\"$target\" rel=\"nofollow\">$2<\/a>/g; でエスケープされているのを逆にします。 # クッションページに強制アクセス #$msg =~ s/(?<!$jumpcgi)([^=^\"]|^)((?:htt|ft)ps?\:[\w\.\~\-\/\?\&\+\=\:\@\%\;\#\%\,]+)/$1<a href=\"$jumpcgi?$2\" target=\"$target\" rel=\"nofollow\">$2<\/a>/g; $msg =~ s/([^=^\"]|^)(http[s]?\:[\w\.\~\-\/\?\&\+\=\:\@\%\;\#\%\,]+)/$1<a href=\"$2\" target=\"$target\" rel=\"nofollow\">$2<\/a>/g;
投稿者自らが修正した場合、更新されると思いますが、 管理者が修正した時に更新させたいということですか？ それなら、 edit_log.pl の129行目、130行目の $time=$ptime; $date=$dat; をコメントアウトしてあげれば良いと思います。 #$time=$ptime; #$date=$dat;
jump.cgiの20行目 if (index($ENV{'HTTP_REFERER'},$siteurl) != 0) { &error("他サイトとの共有は出来ません"); } をコメントアウトします。 #if (index($ENV{'HTTP_REFERER'},$siteurl) != 0) { &error("他サイトとの共有は出来ません"); }
アイコンはinit.cgiの287行目と288行目で指定します。 $smile1 = 'smile01.gif smile02.gif smile03.gif smile04.gif smile05.gif smile06.gif smile07.gif'; $smile2 = '(^^) (^_^) (+_+) (^o^) (^^;) (^_-) (;_;)'; 半角スペースで区切って記述します。 $smile1で区切った順と$smile2で区切る順番は連動されているので、 順番どおりに挿入します。 タグについては、 read.cgiの1301行目～1329行目で記載します。 指定したものに沿って記載するだけです。 RSS機能も修正しなければなりません。 patio.cgiの606行目～614行目までを修正します。
あなたが「使うこともできる」の意味を勘違いしている可能性は考えられます. 「値を代入できる」とは, 一言も書いてないですよね.
No 2 の Tacosan の回答で終わっていると思う。 無粋に例をあげると my @hairetsu = qw/ tom john kerry micky /; my @joinned = map { "hello " . $_ } @hairetsu; foreach my $str (@joinned) { print $str, "\n"; } みたいな感じ。 この例では、配列要素の前に固定文字列をくっつけている けど、後ろにつける場合や、固定じゃない文字列をくっつける 場合等さまざまある。
こことか： 「値に改行コードを含む CSV形式を扱う」 http://www.din.or.jp/~ohzaki/perl.htm#CSVwithCRLF 改行を含んだCSVデータの読み方の話だとしたらですが。 (サンプル7行目「安全高度爆発(safe height burst)」にダブルクォートがついてないのは、typoと予想)。 そうでなく、「先頭が"始まりでなければ前行に追加」というだけなら、こんなのとか： my $cr = ''; while (<> ){ print $cr if /^"/; $cr = chomp == 0 ? '' : $/; print; } print $cr;
一応、検索に有効なキーワードを入れてあったんだけど > Unmatched [ in regex; marked by <-- HERE in m/^\*+\s*バー 「ダメ文字」で検索。例えば http://sites.google.com/site/fudist/Home/grep/sjis-damemoji-jp ーに[が含まれているため、ここで[が始まっているのに対応する]が無い、というエラー。 []で括ってあったときは、[の中に[を書くと、「[という文字」の意味になるので、エラーにならなかった。 ー[] とすると、 「ー」の1バイト目+ [[] となって、「ー」の1バイト目+「[という文字」 となって、ーにマッチする。 あるいは、\Q \Eでメタ文字を無効にする。 > そのややこしい部分をどのように記述すればよいのかを質問したつもりでした。 「perl unicode」で検索。例えば、以下のところとか。 http://www.lr.pi.titech.ac.jp/~abekawa/perl/perl_unicode.html http://www.rwds.net/kuroita/program/Perl_unicode.html
\&sub1 とかいうように、関数名だけ(Bareword:剥き出しの単語)ではなく、関数のリファレンスであることを明記しろ、ということでは。
浮動小数点だから、仮数部と指数部で表現できる数値表現のうち、もっとも近いものに丸められるからでは？ my $num1 = 1 / 3; printf "%.64f\n", $num1; #0.3333333333333333148296162562473909929394721984863281250000000000 my $num2 = $num1 * 3; printf "%.64f\n", $num2; #1.0000000000000000000000000000000000000000000000000000000000000000 http://perldoc.jp/docs/perl/5.10.0/perlnumber.pod http://ja.wikipedia.org/wiki/%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E6%95%B0
まず、よく使われる日本語関係のライブラリですが、下記の様になります。 ---------------------------------------- ■ jcode.pl http://mikeneko.creator.club.ne.jp/~lab/kcode/jcode.html 対応Ver.　　　 : Perl4以降 対応文字コード : JIS(ISO-2022-JP), EUC-JP, シフトJIS 歌代和正さんによる日本語コード変換ライブラリ。 ■ Jcode.pm http://openlab.jp/Jcode/index-j.html 対応Ver.　　　 : Perl5以降 対応文字コード : JIS(ISO-2022-JP), EUC-JP, シフトJIS, UTF-8, UCS-2 小飼弾さんによる日本語コード変換ライブラリ。jcode.pl の後継を意図？ ■ Encode.pm http://search.cpan.org/dist/Encode/Encode.pm 対応Ver.　　　 : Perl5.8以降 対応文字コード : JIS(ISO-2022-JP), EUC-JP, シフトJIS, UTF-8, UTF-16, etc... Jcode.pm と同じく小飼弾さんによる文字コード変換ライブラリ。Perlの標準ライブラリに含まれる。Jcode.pm の後継。 ---------------------------------------- > とするとGETでの受渡も問題なかったのですが、２つを混在させても問題ないのでしょうか？ おそらく、jcode.plに含まれる関数を使っている箇所が残っていて、たまたま GET リクエストがあった際にそこを通ったのではないかと。 混在させることでエラーが発生したり誤動作することは無いと思われますが、混乱の元ですので jcode.pl の関数を使っている部分を書き換えた方が良いでしょう。 下記の行をスクリプトの中に入れれば、Internal server error の内容がブラウザに表示されるとおもいます。 use CGI::Carp qw(fatalsToBrowser); ※ エラーの情報がダダ漏れになりますので、外部に公開されていないサーバなどで試して下さい。また、修正し終わったらこの行は取り除いてください。 Perl 5.8 以降は、内部表現がUTF-8になるなど文字列全般の扱いが大きく変わったので、仕様をよく確認しておいた方が良いです。下記のサイトなどに詳しく説明されています。 http://hikoboshi.org/perl/utf8.html http://www.rwds.net/kuroita/program/Perl_unicode.html http://hikoboshi.org/perl/doc/encode_old.html Perl 5.8 以降では、入力された文字列は一度内部表現(UTF-8)に直して必要な処理を行い、出力する際にエンコードし直すのがセオリーようです。
今日以下のスレッドで解決したばかりですが・・・。 http://okwave.jp/qa/q6764643.html
n オプションをけると上手くいくかも http://linuxjm.sourceforge.jp/html/netkit/man1/rsh.1.html csh(1) を使用している場合に、 rsh の入力を端末にリダイレクトしたままバックグラウンドで動作させると、リモートコマンドから入力がない場合でも rsh は動作をブロックする。入力が必要ない場合は、 -n オプションを用いて rsh の入力を /dev/null にリダイレクトするべきである。
>internal server errorになってしまいます。 中味を見ていないので、何とも言えないです。 >やはりあの難しいけど正しいチェック方法は簡単には利用できないのですかね？ 利用はできますよ。#後で記載 >,(カンマ） のチェックをスルー と記載されていますが、参照ページの正規表現では,(カンマ）は含まれています。 実際にそういうページは存在しますし。 そのまま使えばいいだけだと思いますが、 まあ、とりあえず、以下でお試しを。 $http_URL_regex = q{^\b(?:https?|shttp)://(?:(?:[-_.!~*'()a-zA-Z0-9;:&=+$,]|%[0-9A-Fa-f} . q{][0-9A-Fa-f])*@)?(?:(?:[a-zA-Z0-9](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.)} . q{*[a-zA-Z](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.?|[0-9]+\.[0-9]+\.[0-9]+\.} . q{[0-9]+)(?::[0-9]*)?(?:/(?:[-_.!~*'()a-zA-Z0-9:@&=+$,]|%[0-9A-Fa-f]} . q{[0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&=+$,]|%[0-9A-Fa-f][0-9A-} . q{Fa-f])*)*(?:/(?:[-_.!~*'()a-zA-Z0-9:@&=+$,]|%[0-9A-Fa-f][0-9A-Fa-f} . q{])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*)} . q{*)?(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])} . q{*)?(?:#(?:[-_.!~*'()a-zA-Z0-9;/?:@&=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*} . q{)?$}; # 正常なリンク $url = "http://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE"; print "Test1<br>"; if($url =~ /$http_URL_regex/) {print "match";} else{print "no match";} # 「あ」を入れてみた。 $url = "http://ja.wikipedia.org/wiki/%E6%AD%A3あ%E8%A6%8F%E8%A1%A8%E7%8F%BE"; print "<br>"; print "Test2<br>"; if($url =~ /$http_URL_regex/) {print "match";} else{print "no match";} # ホストなし $url = "http://%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE"; print "<br>"; print "Test3<br>"; if($url =~ /$http_URL_regex/) {print "match";} else{print "no match";} # ポート付き $url = "http://okwave.jp:80"; print "<br>"; print "Test4<br>"; if($url =~ /$http_URL_regex/) {print "match";} else{print "no match";} # へんなところにポート付き $url = "http://okwa:80ve.jp"; print "<br>"; print "Test5<br>"; if($url =~ /$http_URL_regex/) {print "match";} else{print "no match";} ただ、正規表現が複雑になれば複雑になるほど、 サーバー負担も大きくなるということです。 当初の質問文には厳密にでなくてもかまわないとあったんですけどね・・・。
このような感じでどうでしょう。 foreach $lines (@lines) { $lines =~ s/(?:\x0D\x0A|[\x0D\x0A])?$/,/; ($name,$addr,$seib) = map {/^"(.*)"$/ ? scalar($_ = $1, s/""/"/g, $_) : $_} ($lines =~ /("[^"]*(?:""[^"]*)*"|[^,]*),/g); 省略; } No1,No2さん提示の "山田","埼玉県,入間市",32,"男性" "田中","埼玉県",18,"男性" "井上","栃木県,足利市",25,"女性" "志村","千葉県",33,"男性" "志村","千葉県,,,,,",3,"男性" だった場合でも動くはずです。 以下確認用 foreach $lines (@lines) { $lines =~ s/(?:\x0D\x0A|[\x0D\x0A])?$/,/; @word = map {/^"(.*)"$/ ? scalar($_ = $1, s/""/"/g, $_) : $_} ($lines =~ /("[^"]*(?:""[^"]*)*"|[^,]*),/g); $str = join " : ",@word; print $str."<br>"; } 参考：http://www.din.or.jp/~ohzaki/perl.htm#CSV2Values
Perl 単体の機能としては、簡単に「URLを指定してhttp経由でデータ取得」することはできません。そういう機能を実現するモジュールを入れる必要があります。 http経由でのデータ取得を行うモジュールにもいろいろありますが、LWP::Simple が一番簡単です。 http://www.augustus.to/blog/3128/archives/000054.html
<!--#exec cgi="～" --> <!--#exec cmd="perl counter.cgi" --> で保存しているPerlスクリプトを呼び出す。 http://d.hatena.ne.jp/tanakahisateru/20110103/1294066560
基本的な考えは合っていると思います。 単純にホームページに画像を貼り付けたいと思った時、 htmlファイルと画像ファイルが必要ですね？ タグとして <img src="画像名"> とすることで、ブラウザに画像をページ内に「読み込ませて」います。 同じように、一般的なアクセスカウンターを貼り付けようとした場合、 htmlファイルとPerlなどのプログラム（と画像でカウントを表示するなら画像ファイル）が必要です。 画像のアクセスカウンターを表示するなら、 <img src="アクセスカウンター実行ファイル"> として、ブラウザに実行ファイルをページ内に「読み込ませ」ます。 この時に、実行ファイルがアクセスを記憶して、 表示するべきカウントを表示することになりますが、 IMGタグで記載しているので、プログラム側で画像形式にして出力することになります。 JavaScriptによるカウンターを表示する場合には、 <script type="text/javascript" src="アクセスカウンター実行ファイル"></script> としてブラウザに実行ファイルをページ内に「読み込ませて」います。 この時に、実行ファイルがアクセスを記憶して、 表示するべきカウントを表示することになりますが、 数字のテキストで表示するなら、JavaScriptによる記載で、数字を出力。 画像で表示するならJavaScriptによる記載で、画像タグを出力。 ということになります。 いろいろなタイプのアクセスカウンターはありますが、 その一例ということで参考になりましたら。
>カラム属性のようなもの そうです。 すみません、「BN」ではなく、「BIN」でした。失礼しました。 DBの管理ツールとして「MySQL Workbench」などを使用しているとわかりやすいと思いますが、 「BIN」の他にも「PK」=プライマリキー、「NN」=not nullなどのチェックがあり、そういった設定項目の一つです。
質問に対して質問で返すというのは抵抗があるのですが、質問者様のあわてぶり以外伝わってこないのであえて・・・ １．エラーを出しているサーバーアプリとは？ 　　それぞれの文言から３種の状況が考えられますがそれぞれに関連性がまったく無いので矛盾だらけです 　「サーバーにアップするとエラーが出ます」→ファイル転送サーバアプリとファイル転送クライアント間のエラー？ 　「プログラムの部分をいじるとエラーが出ます」→コマンドラインでのプログラム実行上のエラー？ 　「サーバーの設定上エラー番号はわかりません」→サーバアプリ環境下での実行とはWebサーバでCGIとして実行？ ２．エラーと認識できている理由 　　何をもってしてエラーとして識別しているのかがわからない。 　　エラーメッセージのようなものが出ているのなら記述すべきかと思います。 　　「エラーが出ます」では第三者は何をどう判断してよいものかさっぱりわかりません。 ３．下記前文と後文とでは言っていることが正反対 　「たとえば$a=1;　の数字を変えてまた元に戻してサーバーにアップするとエラーが出ます。」 　「プログラムの部分をいじるとエラーが出ます。パラメーター設定の部分の数値を変更するだけではエラーがでません。」 　　「数字の部分」とは変数$aに対するパラメータのはずですが前文では変えるとエラーが出るといって後の分ではエラーが出ないといっています。 　　または、「パラメーター設定」というのはプログラム内に記述されたものでなくプログラムに渡す外部パラメータのことを指すのでしょうか？　だったら今回の質問とは何の関連性も無いのでないでしょうか(逆に記述があることでわけがわからなくなっています)。 文面から、あたふたぶりはうかがえるのですが、肝心なことをはしょりすぎていて質問内容から判断の材料となるべきものが見えてきません。 落ち着いて、あなたの元にいない第三者に質問しているという状況を踏まえた上で、状況の詳細を説明してください。
$ENV{'REQUEST_URI'}　では取得できないと思います。 htaccessで、 RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ maintainace/cgi/make_page_err.cgi?$1 [L] これで　$ENV{'QUERY_STRING'}　で取得できるのでは。
ですから、Cygwin動作中は ホームディレクトリ(bashを起動してログインしたディレクトリ)は、 Cygwin表記で /home/ユーザー名, Windows表記で Cygwinのインストールしたディレクトリ\home\ユーザー名です。 「デスクトップとか、マイドキュメントとかではありません」 > **@room ~ > $ ls > これがホームディレクトリ(~)でlsを実行した結果です。何もありません。 (正確には、.で始まるファイルやディレクトリがあるかもしれませんが) > $ cd cheminf ホームディレクトリの下になにも無いのですから、移動などできません。よって > bash: cd: cheminf: No such file or directory というエラーになります。 簡単な対処は、デスクトップにあるcheminfディレクトリをホームディレクトリの下に移動してくることです。
foreach文はオリジナルを置き換えますので注意して使ってください。 ＞$data_1 =~ s/\n//g; # オリジナル（@BASE）の対象データが書き換えられる。
CGI としてブラウザでアクセスするのではなく、コマンドラインで実行するとデータが表示されませんか。 こちらで質問としてあげられたコードをコピペしてコマンドラインで実行すると JSON データはちゃんと表示されています。 CGI としてアクセスするとうまく表示されない理由は、このプログラムで作成される出力が HTML ドキュメントとして正しくないからです。 Content-Type: text/html と <html>との間には空行が必要ですし、なによりブラウザに表示するコンテンツは、<body></body> の間に入っていなければなりません。 HTML ドキュメントの構造について調べなおすことをお勧めします。
本当に終わるか気になったので、自分のPCで試してみました。 メモリ4Gであれこれ普通に使いながら、次のものです。 ただ、内一個は途中でやめちゃいました。 まず、こんなかんじでdummyファイルを作りました Ruby # dummy作成 http://ideone.com/TDxut →1Gバイトで約2000万件の嘘データ # フィルタ元リスト作成 →dummyの頭50件の、URL内ドメイン箇所までのリスト Ruby # 文字列マッチ http://ideone.com/xPsku →約25分 # 正規表現マッチ http://ideone.com/kvSff →途中でやめた為不明 GNU/grep # grep -F -f 元リスト.txt dummy.txt →1分弱! ということで、少なくともRubyでは全く太刀打ちできませんでした。 でも、終わる分量ではあると思います。特にPerlならきっともっと早いんでしょう やっぱりgrepがおすすめですね
どう「実際に Encode::decode を使ったのか」が疑問ですが.... 少なくとも, pack しただけでダメなのは文字数を考えれば明らかで, 「pack で得られた文字列を改めて UTF-8 として解釈し直す」というのは必須なはず. あと, 「フォームで出てくる」というときに, フォントなんかも問題になりえる. そもそも UTF-16 な出力をしているときに UTF-8 な出力をしちゃったらどう考えてもダメだし, あるいは「理由はさておき UTF-8 な文字コードを上手く扱えないフォントレンダラー」だったりするとやっぱり UTF-8 じゃダメだよね. ということは, 「フォームの表示を見る」だけではダメで, HTML (なり XHTML なり) のレベルで正しくなっているかどうかから考えなきゃならないような感じがします.
Net::Twitter は特に入れるつもりはないので試してはいません。その点はご了承を。 CPAN(というかPerl)のモジュールには、高速化や、別のライブラリとの接続等の目的で、C言語などで実装されているものもあります。 なので、Xcodeが必要なケースがあります。 せめて、終ったときの最後の数行くらいは目を通してください。失敗したときにはその旨が表示されているはずです
書いた直後に気づいたんですが、このindex文だと「東大阪市○○区」みたいなのにも引っかかっちゃいますね 特に理由が無いなら、普通に文字列比較した方がいいと思います。 if ($wd =~ /^[\w.']+$/ ? $address =~ /$wd/i : index($address, $wd) >= 0) ↓ if ($wd eq $address)
stdio::getFormDataに対しての見識がないので適切な回答はできませんが、以下を試すとどうなるでしょうか？ %in = (); stdio::getFormData(\%in,1,"sjis",1,",","$updir/"); を、 use CGI; %in = map decode_utf8($_), CGI->new->Vars; に変更。 これで文字化けが解消する可能性はありますが、stdio::getFormDataに詳しい人が回答してくれるかもしれませんので、質問はオープンのままにされたほうがいいと思います。
すみません、pdicの1行形式というものが良く分かっていませんでした。 http://homepage3.nifty.com/TaN/unicode/help/OneLineFormat.html こういうルールに沿っているんですね となると、若干シンプルに出来るかと思います。 ＜元データ＞ あ /// / 母音の一 あ /// 足 / あし あ /// 畔・畦 / 田のあぜ あい /// 合い・会い / アヒ \ 名 \ あうこと。出会い… ＜置換前（正規表現）＞ ^([^/\s]+) /// ((?:[^/\s]| \\ )+) / (.*)$ ＜置換後＞ $1【$2】 /// / $3 ↓ ＜変換後＞ あ /// / 母音の一 あ【足】 /// / あし あ【畔・畦】 /// / 田のあぜ あい【合い・会い】 /// / アヒ \ 名 \ あうこと。出会い…
本家のFFFTP には、「ホストの漢字コード Unicode(UTF-8)」という設定は存在しないのですが、 どのFFFTPを使っていますか? おそらく独自にUnicode対応改造された改変版を使用されているのだと思いますが、 症状からすると、BOM付きのUTF-8でアップロードしてしまっているように見受けられます。つまり、アップロードソフトの漢字コード変換の問題です。 BOMとは、Unicode(UTF-16)において、ファイルの先頭に付加されて、バイトオーダを識別するための特殊なコードです。本来UTF-8には不要なものであり、UNIX系のサーバなどでは、これが付いているとCGIのファイルとして認識できなくなってしまうのですが、 Windows上のメモ帳など、一部のソフトでは、UTF-8でもBOMを付けるものが存在します。 もし、「UTF-8N」という設定があるのであれば、それで試してみてください。 (規格で定められた名称ではありませんが、UTF-8にBOMを付ける仕様のソフトでは、BOMを付けないものをUTF-8Nという名前の別設定で用意している場合があります) そういう設定がないのでしたら、最初から Perl のファイルを UTF-8N(正しいUTF-8)で作成・編集し、無変換設定でアップロードするしかないかと思います。 とりあえず、たとえば無料のテキストエディタでも、たとえば EmEditor Free なんかは、正しいUTF-8にも対応しています。 http://jp.emeditor.com/modules/download2/rewrite/tc_5.html
print $FORM{$_} foreach (sort {$hash{$a} <=> $hash{$b} (keys %hash)) ではだめなのかな
http://www2u.biglobe.ne.jp/MAS/perl/waza/yesterday.html
「PerlでCGI使っている」かどうかは関係ありません。 最終的に出力されるhtml(とCSS,その他)がどうなっているかです。 CSSで表現できない物はCGIを使っても表現できません。 CSSを使わない、となると、(今では悪者扱いされてる)tableによるレイアウトくらいしか思いつきません。
> foreach ( split(/\n/, $body) ) { > &jis("$_"); > print MAIL $_, "\n"; > } Shift_JISの$_をそのまま出力してるから。 現在の&jisの仕様は ・引数: shift_jisの文字列 ・戻り値:無し ・副作用: グローバル変数 $msgが、入力引数のshift_jis文字列をISO-2022-JPに変換した文字列になる です。 > また、元々参考にしたものでは####1####に > retern $msg; > があったのですが、これを入れるとsyntax errorになったので、これをコメントアウトしたらエラーにはならず送信そのものはできました 「return」 です。スペルが違います。 エラーになったからコメントアウト、では何の解決にもなりません。 「なんでもOK」なPerlですが、ある程度のものを作ろうと思ったら、やはり、プログラム構造はちゃんとした方がよいです。 グローバル変数は必要以上に使わないことです。 use strict ; を入れて変数宣言を強制するのもいいでしょう。 一例です # 引数: shift_jisの文字列 # 戻り値:ISO-2022-JPに変換された文字列 sub jis{ my $msg = $_[0]; Encode::from_to($msg, "shiftjis", $charset); return $msg ; } # $_は便利なのですが、 # 注意して使わないと意図しないところで置き換わってしまいます foreach my $l ( split(/\n/, $body) ) { print MAIL &jis($l) . "\n"; } なお、base64にも同様の問題(グローバル変数 $strの使用) があります。
問題点は４つあります。 今回の不具合においては１と２が致命的。 ３は比較的軽微なバグ。 ４以降は推奨される書き方です。 １．読み込み処理と書き込み処理が分かれているのにロックを個別に行っている。 「データを読む～データを改変する～データを書く」を一度のロックで行わないと 途中で他のプロセス処理が割り込む可能性がある。その結果、複数のプロセスが 矛盾するデータを書き込もうとした場合にいずれかのデータが失われる。 回避方法としては、下記のいずれかが有効。 ・１つのファイルに対する読み書きの場合は１回のオープン＋ロックで済ませる。 ・複数ファイルを同時に処理する必要がある場合には、ロック用ファイルを用意し これに対してロックを行ってからすべての処理を行う。 あるいは、処理の順番的に必ず最初にオープンするデータファイルがある場合は これに対してロックをかけ、すべての処理を行ってから最初のファイルを最後に クローズすることでロック用ファイルを兼ねる。 ２．（上記と併せて）書き込み処理時に上書きモード'>'でオープンしている。 上書きモードでは、ファイルオープン時にファイル内容は一度すべて消去される。 この状態で１．の状況が発生した場合、ちょうど消去されたばかりのファイルを 別プロセスが読み込むために、既存データが消えることになる。 ファイルロックはファイルオープンとは同時には行うことができないため、 ロックがかかるまでに時差が発生することに注意する。 ３．1行読み出し $lines11 = <IN11> において、末尾の改行を削除していない $accに改行がついたままになっている。$accに変更があった行だけは数値代入の 副作用で改行が外れるが、変更がなかった行は改行がついたままの状態で 書き込み時にさらに改行が付加されるため、データに意図しない空行が発生する。 ４．Perl4の文法で記述されている。 Perl4の文法でも、正しく記述すればこれ自体が不具合を起こすことはないが、 プログラムが大規模になるほどスクリプトのデバッグが難しくなる。 Perl5では、以下のような機能が用意されている。 ・宣言されていない変数などを文法エラーにする use strict; プラグマ 変数名のタイプミスを検出できる ・未定義値に対する演算などに警告を出す use warnings; プラグマ 変数の初期値設定忘れを防ぐ。ハッシュキーの打ち間違いが見つかることも。 ・ブロック内でのみ使用できるローカル変数の宣言 my 変数名の重複による誤動作等を防ぎ、変数の局所化によって見通しが良くなる ・ファイルハンドルにもmy変数を使える Perl4ではグローバル変数としてしか扱えなかったファイルハンドルを局所化 できる。スクリプト内でファイルハンドルが重複することによる誤動作を防ぐ。 上記を踏まえて修正したスクリプトは以下になります： sub count_up { my($countcsv, $page) = @_; use Fcntl; sysopen(my $fh, $countcsv, O_CREAT|O_RDWR) or error(" countcsv をopen出来ません"); flock($fh, 2); seek($fh, 0, 0); my $data = ''; while(my $line = <$fh>) { chomp $line; my($seq, $acc) = split /,/, $line; if($page == $seq) { $acc++; } $data .= "$seq,$acc\n"; } seek($fh, 0, 0); print $fh $data; truncate($fh, tell($fh)); close($fh); } count_up($countcsv, $page);
# IPアドレスのチェック結果に応じてカウント処理 sub IpCheck { _IpCheck($addr, $iplog) ? CNTUP() : NoCnt(); } # IPアドレス毎の書き込み回数チェック sub _IpCheck { my $addr = shift;# 調べたいIPアドレス my $iplog = shift;# データファイル名 my $count_max = 5;# IPアドレス毎の最大書き込み回数 # 現在日付の取得 my $today = sub { my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($_[0]); sprintf('%04d/%02d/%02d', $year+1900, $mon+1, $mday); }->(time); # IPアドレス毎の書き込み回数の読み書き use Fcntl; sysopen(my $fh, $iplog, O_CREAT|O_RDWR) or Error(5);# 読み書きモード／ファイルがなければ新規作成 eval { flock($fh, 2); };# ちゃんとロックしないと壊れます eval { chmod(0666, $fh); };# 動かない環境もあるので念のためeval binmode($fh, ':crlf') if($^O =~ /MSWin32/);# Windowsでは改行コードをCR+LFで読み書き seek($fh, 0, 0); my $lastday = <$fh> || '';# データファイルの1行目の日付を読む chomp $lastday; my %count; if($lastday eq $today) { # 日付が同じ場合だけ過去データを読む while(my $data = <$fh>) { chomp $data; my($ip, $c) = split /\t/, $data; $count{$ip} = $c; } } $count{$addr}++; return if($count{$addr} > $count_max);# 回数オーバーならundefを返す seek($fh, 0, 0); print $fh $today."\n";# データファイルの1行目に日付を保存 foreach my $ip (sort keys %count) { print $fh $ip."\t".$count{$ip}."\n"; } truncate($fh, tell($fh)); close($fh); return 1;# 書き込み可能な場合は1を返す } # Perl5の入門書を読むことをお勧めします。 # Perl4は絶滅して久しいですし、何よりPerl4で書かれたプログラムは読むのがつらい・・・
ちょっと修正 my $digit = qr{(?:\d){4,}}; my $digit_with_comma = qr{\d{1,3}(?:,\d\d\d)+}; これ以外は同じ
5.10から Tk ではなく Tkx というモジュールが添付されるようになっているのですが、 それの場合質問にあるような警告は出ないようです。 ただし、スクリプトを手直しする必要があります。 あるいは、Windows7の設定でメニューで使用するフォントをxpと同じ MS UI Gothic にしてもでないようになるかもしれません。 現状ではメイリオを使うようになっていると思います。 Windows フォントを変更する http://windows.microsoft.com/ja-JP/windows7/Change-Windows-fonts この手順でウィンドウの色とメトリックの変更画面まで行って、 「メニュー」のフォントを切り替えてみてください。
質問の趣旨に合っているかわかりませんが、プログラムを作ってみました。ロックした後の処理に時間がかからなければ、順番どおりに実行されると思います。 main.pl -------------------------- #!/usr/bin/perl foreach (1 .. 10) { system("./lock.pl $_ &"); } lock.pl -------------------------- #!/usr/bin/perl use Fcntl ':flock'; use POSIX ':sys_wait_h'; $arg = $ARGV[0]; sleep $arg; $pid = fork(); die "Can't fork: $!" unless defind $pid; if ($pid) { do { $kid = waitpid(-1, &WNOHANG); } until $kid == -1; if ($arg == 10) { print "MAIN LOCK\n"; open LC, "+<lock" or die; flock LC, LOCK_EX or die; print "OK\n"; } } else { print "lock $arg\n"; open LC, "+<lock" or die; flock LC, LOCK_EX or die; print "release $arg\n"; }
参考までに、ideoneでの実行； http://www.ideone.com/lziei 質問文の例は普通に動いてるので、SJIS変換してるあたりに原因があるかも。ないかも。
$fileName = $query->param('fileName'); で取得できるのはアップロードしたときのファイル名で、CGI.pmはそのファイル名とは別の名前でサーバ上に一時ファイルを作ります。 $query->upload()で一時ファイルのファイルハンドラを取得し、ファイルの内容を読み出します。 $fh = $query->upload('fileName'); read($fhe,$buffer,1024); ...
above_average では、「@list」すなわち、平均値以上の値を持つ要素の配列を返してます。 一方、その呼び出し部では「my $barney = above_average(100, 1..10);」で、$barney というスカラー変数で受けています。 配列をスカラーコンテキストで評価すると、その配列の要素数になりますので、 $barney には、above_average の結果の「平均値以上の値を持つ要素の数」が代入されます。 つまり、1になります。 「100」すなわち、結果の最初の要素を得たいのなら、 ---ここから--- my($barney) = above_average(100, 1..10); ---ここまで--- これで、「($barney)」という配列に、above_average の返した配列が代入されますので、 $barney には、その最初の要素である100が代入されます。 あるいは、平均以上の要素を全て表示したいのなら、 ---ここから--- my @barney = above_average(100, 1..10); print "\@barney = @barney\n"; ---ここまで--- のように配列変数で受けてください。
子プロセスはexitしてしまって構いません。 別プロセスなので、親には影響しません。 ＞パラレルでのDB格納です。 蛇足ですが、DB格納はデータベースハンドルをコピーすると異常事態にならないとも限らないので、個別に取得した方がいいですよ。 以下サンプルです。 インデントは全角スペースになっています。 ------------------------------------------------------- #!/usr/bin/perl use strict; if(fork){ 　print("parent hello\n"); 　wait; }else{ 　print("child hello\n"); 　sleep 3; 　print("child exit\n"); 　exit; } print("parent finish\n"); ------------------------------------------------------- モジュールを使うと楽です。 #!/usr/bin/perl use strict; use Parallel::ForkManager; # 並行処理は四つ my $pm = Parallel::ForkManager->new(4); my @id = (1 .. 10); for(@id){ 　# 子の処理 　$pm->start and next; 　print("this is $_\n"); 　sleep 2; 　$pm->finish; } # 親はただ待つ $pm->wait_all_children; print("parent finish\n");
0100　2455　4782　のいづれかなので ~ /0100|2455|4782/ でよいのでは。
質問内容を誤解した回答がされていますが。 ※質問者の表現も良くないかも。 サーバスペースをレンタルされている業者『Xサーバー』で設定ページが用意されているcorn機能を使ってますって事ですよね。 ※ unix/linuxのcronかどうかは不明 なので、cron使っているとしても設定ページで行なった自動実行の設定は有効に機能するよう提供されているかと思います。 『自動更新の時間になったら「Cron結果の通知アドレス」で設定したメールは届く』という事からもcronへの登録自体は問題なく行なわれており、cronは登録されているプログラムを実行しようと試みていると思われます。 登録時刻に送信され届いたメールに何が起こっているか書かれているかと思いますので、その内容やそれに対する対処法がわからない場合にはそこに書かれている内容を示した方が良さそうに思います。 > hello.cgiというプログラムを実行しようとしているので cronからではなくそのプログラムを手動で実行した時の動作は確認されているのでしょうか。 ※ perl hello.cgiとして実行するのではなく、/home/●●●/▲▲▲/public_html/hello.cgiで手動実行してご確認ください。(動かない場合には実行が許可されてない[chmod +x .../hello.cgiで許可するなど]事やプログラム作成に問題があるなどが考えられます) ※ crontabコマンドは基本的にどのユーザでも使えますよ。ただし、普通は不要なユーザには開放してないので(cron/allowやcron/denyファイルに許可・拒否するユーザを登録して制御する)使えません。
全角半角、15と9と09が入り乱れてて、状況が今一つはっきりしません。 if ( レコード =~ /抽出基準日付を使ったパターン/ ) { 抽出 } みたいなことをしたい、ということでよろしいでしょうか? 入力は現行のままにしておいて、判定時に都合のいいように変換するのがてっとり早いと思います。 # 数値に揃える $rec_h = レコードを半角化 ; # 必要ならば if ( $rec_h = /^(\d+)/ ) { # 先頭の数字を抽出 $rec_date = $1 ; #抽出した数字 } else {エラー;} $date = 抽出基準日付 ; $date =~ s/^0//; # 先頭の0を取り除く if ( $rec_date == $date ) { 抽出 } # 数値として比較 # 文字列に揃える $rec_h = レコードを半角化 ; # 必要ならば if ( $rec_h =~ /^(\d+)/ ) { # 先頭の数字を抽出 $rec_date = sprintf( "%02d",$1) ; # sprintfで0付き2桁に } else {エラー;} if ( $rec_date eq 抽出基準日付 ) { 抽出 } #文字列として比較
載せていただいたコードを元に作ってみました。（簡略化しています） ■動作確認をしたコード============ #!/usr/bin/perl use Time::Local; use warnings; #--------------------- # 引数の取得とか #--------------------- $L_Year = int(substr($ARGV[1],0,4)); $L_Mon = int(substr($ARGV[1],4,2)); $L_Day = int(substr($ARGV[1],6,2)); $L_Hour = int(substr($ARGV[1],8,2)); $L_Min = int(substr($ARGV[1],10,2)); $L_Sec = int(substr($ARGV[1],12,2)); $outfile = "./result.txt"; #--------------------- # 差分を取得 #--------------------- $L_Time1 = timelocal($L_Sec, $L_Min, $L_Hour, $L_Day, $L_Mon - 1, $L_Year); $L_Time2 = timelocal($L_Sec, $L_Min, $L_Hour, $L_Day + 1, $L_Mon - 1, $L_Year); $L_TimeRet = ($L_Time2 - $L_Time1); #--------------------- # 差分をファイルに出力 #--------------------- open (OUT,"> $outfile"); if($ARGV[0] == 1){ $L_LET = int($L_TimeRet / (60 * 60 * 24)); print OUT "$L_LET"; } elsif($ARGV[0] == 2){ $L_LET = $L_TimeRet; print OUT "$L_LET"; } close(OUT); ====================== ■気になったところ ・OUT "$outfile" だとファイルのパスをファイルに書きこむ？$L_LETの間違い？ ・$outfile（書き込むファイルのパス）が定義されていない？ use warnings; を始めに宣言しておくと、エラー部分を教えてくれますよ。
可能なら新しい今時のperlを使いましょう。 今ちょっと昔のjperlを発掘して試して見ましたが、 --- C:\> jperl -v This is jperl, version 4.036 + 1.4(WIN32, SJIS) May 25 1996 --- このjperlだと「'c:\Program' は、内部コマンド…」エラーになりましたが、 --- C:\> perl -v This is perl, v5.8.7 built for MSWin32-x86-multi-thread --- こちらのperlだと、C:\Program Files 以下のプログラムも問題無く system で実行できました。 (使ったのはActivePerlです。Windows用のインストーラがあるので簡単にインストールできます。 http://www.google.co.jp/search?q=ActivePerl&lr=lang_ja なお、どうしても jperl で動かす必要があるのなら、 >$cmd = "c:\\Progra~1\\Lhaplus\\Lhaplus.exe /c… で実行は可能だと思います。
勉強の仕方も書籍の選び方も人それぞれですからねぇ・・・ ただ、個人的には、言語学習はオライリー社の物を推薦します。 Perlクックブックとかなら、いろいろなサンプルが豊富に載っていると 思います。 が、しかし、リファレンスの勉強も必要かと思います。 リファレンスに関しては、同じくPerlリファレンスというのが オライリー社から出ていると思います。 しかし、リファレンスに関しては、勉強と言うより 辞書のような感じで引く形で使うため、読む本ではありません。 辞書を読んでも面白くないですよね。 ただ、オライリー社の物は比較的詳しく書かれているので、 読んでいて、あぁそうなのか！と納得できる事は多いと思います。 そういう意味では勉強になります。 MySQLに関しては、個人的にはMySQL徹底入門と言う本を 持ってますが、10年くらい前に買ってほったらかしです。 すみませんが、余りお勧めできる本を知りません。 また、質問者様が目標とされている、通販サイトの仕組みに ついて学ぶには、Webサーバー関連の知識も必要かと思います。 Webサーバーとして有名なのは、Apacheか、IISですね。 また、HTMLの知識も必要ですし、場合によっては JavaScriptやCSSなどの勉強も必要になってくると思います。 ただ、個人的にお勧めするのは、確かに書籍を用いて 体系的に学習するのも重要ですが、 まずは、実践をしてみて体感する事の方が重要かと思います。 ・ApacheをインストールしてWebサーバーを立ち上げる ・HTMLを勉強してApacheで表示させる ・PerlをインストールしてHello Worldを書く ・MySQLをインストールしてHello Worldに相当するデータベースを 作成する ・ApacheにPerlを組み込んでHello Worldに相当する ページを表示する ・ApacheにMySQLを組み込んでPerlからMySQLに接続する ・Apacheに認証システムを組み込む 位の事を1個ずつやっていくといいと思います。 初めてでもすんなり行けば3日、詰まっても1週間くらいで出来ると 思います。慣れてる人であれば、半日もかからずにできると思います。 1個1個の目標設定を限りなく低くしてありますから、 詰まった所がどこなのかわかりやすいと思います。 また、成功した時の達成感も得られます。 これらの事を一通りクリアしてから、興味がある所を 体系的に書籍で勉強したり、飽きてきたら、他の事を実践的に行って いくのはいかがでしょうか？ 目標を細切れにして、実践と知識の蓄積を繰り返しながら じょじょに積み重ねて行かれる方が挫折しにくいとは思います。
2008年12月が1になって2013年11月が60になるようにすればいいんですか？ Perlはやったことないので、考え方だけ書きます。 （質問の意味を間違って解釈していたらすみません） 基準となる年月（2008/12）を用意します。（以下A） 比較対象の年月を用意します。（以下B） それぞれの年, 月をYear, Monthとします。 BのYearからAのYearを引いた値をDYear BのMonthからAのMonthを引いた値をDMonth とします。 DYearは年ですから、月に直すために×12をする必要があります。 また、基準年月の値が0ではなく、1なので＋1する必要があります。 DYear * 12 + DMonth + 1 これで値が算出できると思います。 60毎に区切る必要があれば割ったり余りを出してください。 基準年月を2008/12 対象年月を2013/11　として計算してみます。 2013 - 2008 = 5 (DYear) 11 - 12 = -1 (DMonth) 5 * 12 + (-1) + 1 = 60 >Perlで月盤の60進数を作って頂きたいんです。 プログラムの質問で作ってくださいとかありえません。 自分で作りましょう。
それは送信したメールがアドレスが無くて戻ってきてしまうということでしょうか？ だとしたら、通称「キャッチオール」アカウントを作成し、そこからhoge.plを起動する必要があります。 qmail＋vpopmail＋qmailadminでそのような機能を作成したことがありますが、具体的な方法はだいぶ昔のことなので覚えておりません。 イメージとしては、 １．存在しないアドレス宛てのメールをすべて受信するアカウントを設定する ２．受信したらスクリプトを起動する ３．スクリプトで、Toを取得して引数へ格納する
macは使った事ないのでわからないですが、 ここのサイトに、 http://www.techsutram.com/2011/03/dbdmysql-and-can-exec-no-such-file-or.html libmysqlclient-devel-5.1.46-2.18.i586.rpm をインストールしたと書いてあります。 これで解決できますでしょうか？ そもそも、makeをする前で引っかかっているので、 makeをした所で上手く行かない事は予想されるのではないでしょうか？ 一つ一つ問題を解決していかないと難しいと思いますが。
> まずファイルを一行読みこんで、 > そこに入っている１～１０までの数字を$bに納めます。 > そしてsozaiディレクトリには b1.png～b10.png があります。 まったく的外れな回答かもしれませんが、ファイルから読み込んだ数字の末尾の改行は消したでしょうか？ $b = <FH>; chomp $b; # なければ追加する
エラーの内容だとDBD::mysqlがインストールされていないように見えますが、コマンドラインから「perldoc -l DBD::mysql」や「perl -e 'use DBD::mysql'」を実行してもエラーがでない状況でしょうか？
map { $_->[1] } @$_
如何やら解決している様ですので、文字化け等が起きないようにする方法や、見やすくするための方法を書いておきます。 #!/usr/local/bin/perl print "Cache-Control: no-cache\n"; print "Pragma: no-cache\n"; print "Content-Type: text/html;charset=Shift_JIS\n\n"; print <<"EOF"; <html> <head> <title>環境変数</title> <meta http-equiv="Content-type" content="text/html;charset=Shift_JIS;"> </head> <body> <h1>環境変数</h1> <hr> EOF foreach $key(keys %ENV){ print "$key: $ENV{$key}<br>\n"; } print <<"EOF"; <hr> </body> </html> EOF exit; 参考になれば、幸いです。
if($ENV{'REQUEST_METHOD'} eq "POST"){ 　　　　read(STDIN,$buffer,$ENV{'CONTENT_LENGTH'}); } else{ 　　　　$buffer=$ENV{'QUERY_STRING'}; } $i=0; @buffer=split(/&/,$buffer); foreach(@buffer){ ($name,$value)=split(/=/,$_); $value=~tr/+/ /; $value=~s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg; &jcode::convert(*value,"sjis","","z"); $value=~s/</&lt;/g; $value=~s/>/&gt;/g; $value=~s/"/&quot;/g; $value=~s/(\n|\r)//g; } あんまり変わってませんね＾＾；；； 自分の所は、これで出来てます。
一番簡単なのは、リダイレクトですね。 分岐用のページを作っておいて、そこで分岐処理をし、個別のページにジャンプします。 「Perl リダイレクト」で検索してみてください。 ただし、POSTされてきた情報は消えたと思うので、 そのあたりは、Cookieなどで受け渡さないといけないでしょう。
<input type="file"> に対しては、ブラウザ側のセキュリティの配慮により、valueの初期値を設定することができません。あとからJavaScriptでも操作できないようになっています。 もしこれが可能になってしまうと、ローカルファイルを勝手にアップロードさせることができるようになってしまいます。 JavaScriptを併用すれば「ページを見ただけでファイルをアップロードさせる」も可能ですよね。 Windowsのレジストリなど、パスやファイル名がほぼわかっているファイルであればなおさら危険性が高まります。 なので、一旦必ずファイル選択ダイアログを出すか、テキストボックスに手でファイル名を入力させてからでないとアップロードはできません。 hiddenでファイルをアップロードするのは現時点では無理ではないかと思います。
ご質問のカテゴリがPerlになってますので万が一ということで確認しますが そのWindows環境にWindows用のPerl処理系はインストールされていますでしょうか？ また、その処理系はなんでしょうか？ わたくしの場合はActivePerl5.8.8ですがDBD::SQLiteは標準で入っているようです（ppmコマンドで確認）。
厳しいですね。一番最初に出るエラーが解決のヒントになるかもしれないんですが、 でもlinuxインストールできるのならしたほうが断然早いと思いますよ。 何かパッケージが足りてないのかもしれないし、あんまり深みにはまるまえに。
まず、その方法では、$keyは「正規表現」として解釈されます。 例えば、 「.」(ピリオド)を検索しようとすると、全ての文字がマッチします。 また、明示的に設定したり、昔のJperlのような改造版でも無い限り、日本語は「複数のバイト列」です。 そのため、Shift_JISで顕著な、俗に「ダメ文字」と呼ばれる問題があります。 特に、正規表現では、通常「ダメ文字」と言われる\を含む文字の他にも、メタ文字として使われる文字(|等)も対象となるので、かなりの数の文字が誤判定されます。 単に文字列が含まれるかどうかだけなら、index関数を使う方が確実です。 または、\Q$key\Eとして$key中のメタ文字から特殊な意味を無くしてしまうか。 ただ、いずれの場合でも、漢字の途中から(あるいは途中まで)マッチするケースがあります。 Encodeを使ってUnicode文字列に変換して、漢字を1文字として扱うようにした方がよいかもしれせん。
補足の内容を見ていると、No.2さんがおっしゃるように、ブラウザが文字コード判別を失敗しているようにも思えますね。 UTF-8の文字列をShift-JISとして表示すると、補足にあるような文字化けが起きます。 ブラウザから手動で文字コードを選んでみるとわかるかもしれません。 ところで、LWP::Simple::getは最近仕様が変わり、文字コードを判別して、Perl内部表現文字列を返すようになってますね。 Perl内部表現はutf8なので、補足にあるような文字化けから推測して、質問者さんが利用しているLWP::Simple::getが、Perl内部表現文字列を返してる可能性はありますね。 その場合、print文等で外部に出力するときはencode関数を用いて適切な文字コードに変換してから出力する必要があります。 use Encode; $html = encode("cp932", $html); # ここでは、cp932（≒Shift-JIS）に変換 print "Content-type: text/html\n\n$html\n"; 従来のバイト文字列を返すLWP::Simple::getの場合でも、（必要であれば）適切な文字コードの変換をしてください。 use Encode; Encode::from_to($html, "utf8" => "cp932"); # ここでは、utf8 => cp932に変換 従来仕様のバイト文字列を取得したいのであれば、以下のようにLWP::UserAgentを利用すればいいと思います。 use LWP; my $res = LWP::UserAgent->new->get("http://jun.sakura.ne.jp/~dk3/result/result225.html"); if( $res->is_error ) { print "Content-type: text/html\n\n"; print $res->status_line; exit; } my $html = $res->content; #相対指定部分の置換 $mae = '\.\./'; $ato = 'http://jun.sakura.ne.jp/~dk3/'; $html =~ s|$mae|$ato|g; print "Content-type: text/html\n\n$html\n";
'' と比較する.
IEのクッキーが保存されているフォルダは C:/Documents and Settings/<ユーザー名>/Local Settings/Temporary Internet Files/ ではなく C:/Documents and Settings/<ユーザー名>/Cookies/ でしょう。
逆にお聞きします。 これのどこがわからないのでしょうか? 少なくとも、この中には基本の表現しかないので、正規表現をかじった程度の方でも落ちついて考えれば初心者でも理解できるはずです。 少し難しい点は ! です。 よく s/old/new/ と「参考書」には載っていますが、実は、 / は それ以外の記号でも利用できます。今回のは /の代りに!を使った例です。 記号を変えると次のようになります。 ・/ に「区切り」としての意味がなくなり、「/という文字にのみ一致する」表現となります。 ・逆に、指定した記号(今回は!)には「区切り」としての意味が付くので、その特殊な意味を消すには\でエスケープする必要があります。 これは、パスやURLのマッチング等、 / をたくさん使用するときに、いちいち\/と書かずに済む、という利点があります。 ここまでわかれば 置換対象: $var 検索パターン: /([^/]+|~(\.\.))/\.\./ 置換文字列: / オプション: g だということがわかります。あとは、/が正規表現の区切りではなく「/という文字に一致」ということに気をつければ、参考書を見ながら調べられるはずです
表題を見たときに「CGIからCGI」ということで、「そりゃ無理」だと思って内容を見たら普通の処理のことだったので遅まきながら回答させていただきます。 要するにひとつ目のCGIが出力したHTMLリンクから次のCGIを呼び出すということですね。 方法というか書き方はいくつかありますが、わかりやすい例をひとつ ひとつ目のCGIがリンクをはき出す際にリンク先をJavaScriptにしてJavaScriptからフォームにパラメータをセットしてサブミットする方法です。 お役に立てればさいわいです。 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ <script language="javascript"> <!-- 　function fCallNextCGI(P1,P2,P3,...Pn){ 　　// パラメータ設定 　　document.form.H1.value = P1; 　　document.form.H2.value = P2; 　　document.form.H3.value = P3; 　　　　: 　　document.form.Hn.value = Pn; 　　// 送信 　　focument.form.submit(); 　} //--> </script> <body> <!-- ここからフォーム --> <form name="form" method="POST" action="NextCGI.cgi"> 　<input type="hidden" name="H1" value=""> 　<input type="hidden" name="H2" value=""> 　<input type="hidden" name="H3" value=""> 　　　: 　<input type="hidden" name="Hn" value=""> </form> <!-- ここまでフォーム --> <!-- ここからリンクリスト --> <a href="#" onClick="fCallNextCGI('文字列１','文字列２','文字列３',...'文字列ｎ')">リンク１</a><br /> <a href="#" onClick="fCallNextCGI('文字列１','文字列２','文字列３',...'文字列ｎ')">リンク２</a><br /> <a href="#" onClick="fCallNextCGI('文字列１','文字列２','文字列３',...'文字列ｎ')">リンク３</a><br /> 　　　: <a href="#" onClick="fCallNextCGI('文字列１','文字列２','文字列３',...'文字列ｎ')">リンクｎ</a><br /> <!-- ここまでリンクリスト --> </body> ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ 蛇足 　１．「そりゃ無理」と思った理由：CGIがCGIを多重に呼び出せる機構があったら無限呼出でサーバを簡単にダウンさせることができるため、サーバサイドのスクリプトを多重に起動することはできないような仕組みになっています（例：CGIで出力されたHTML内にSSIを記述して動作を期待すること）。　ただしCGIから呼び出されたプログラムが別のプログラムを起動して処理を受け渡すことは可能です。 　２．上記例でリンクタグの「href=""」内に直接JavaScriptを書くことも可能ですが、対応していないブラウザがあるので要注意
何も指定せずに宣言された変数はそのファイル内でのみ有効なローカル変数のように扱われます。 なのでfile1.plでは$xが定義されていないためエラーとなります。 グローバル変数として宣言するには our を使います。 file1.pl で、まず our $x; を宣言しておいて、file2.pl で our $x = 12; とすればご希望の通りに動くと思います。 他の方法としては、file2.pl をテキストファイルとして読み込み、eval を実行すれば同じく動くと思います。（あまりおすすめしません）
<meta http-equiv="Pragma" content="no-cache"> が効かずキャッシュされる場合があったと思います。 キャシュコントロールならどうでしょう。 htmlヘッダではなくてhttpヘッダでの出力です。 Cache-control: no-cache, no-store, must-revalidate
半角カナのファイル名がついたファイルって今時あるんでしょうか？ そのアップロードが自動的なものでなく、人間によるアップロードが引き金となるのなら アップロードをされる際にファイル名をチェックして、「半角カナのファイル名では登録できません」的なメッセージを表示して拒否したほうが良いと思います。 半角カナを受け付けたいのならば、ファイルの可搬性を増すためにもファイル名は変換したほうがいいと思います。 でないとバックアップの時にバックアップ先によっては、また問題になるかもしれませんし、ファイル名をDBに突っ込むときなど、どこかで必ずまた同じ問題で悩みます。 とりあえず、全角カナに変換したり、ユニコードにしたりすればいいとは思いますが、プレフィクス＋番号にしてしまってもいいのではないかと思うのですが、どうでしょう。 元のファイル名を管理したければ、量にもよりますがファイルやDBにテーブルを１つ作って そこでその変換したファイル名と元のファイル名の対応表をつくるなどしたほうが良いのではないかと思います。 生のファイル名で中身が迅速に判断できないと困るといった場合には番号では困ってしまいますが ウェブベースで常にアクセスされるファイルなのであれば、一覧表示するときに、元のファイル名で表示すればいいだけの話ですので。 変換自体はネットにごろごろしてます。 「perl 半角カナ　変換」で検索してみてください。
実行環境はWindowsでしょうか？ dieで出力されるのは「標準エラー出力」といいます。 perl test.pl >test.log 2>error.log とすればエラー出力をファイルへ取得できます。 これをtest.logへ一緒にするには perl test.pl >test.log 2>&1 とします。 また、perl側で処理したい場合は、スクリプトの初めの方に次の行を追加して下さい。 open(STDERR, ">&STDOUT"); $| = 1; これでエラー出力を標準出力に振りかえることができます。
元のファイルの file1 と file2 の対応関係にズレはないということなので、１つの while ループで処理できると思います。 #!/usr/bin/perl use strict; use warnings; open IN_1, "file1" or die "Can't open file1: $!"; open IN_2, "file2" or die "Can't open file2: $!"; open OUT, ">output.txt" or die "Can't open output.txt: $!"; while (my $f1_line = <IN_1>) { $f1_line .= <IN_1>; my $f2_line = <IN_2>; $f2_line .= <IN_2>; next unless $f1_line =~ /\([\d.]+\)/; my ($num_1) = $f1_line =~ /\(([\d.]+)\)/; my ($num_2) = $f2_line =~ /\(([\d.]+)\)/; if (abs($num_1 - $num_2) >= 5) { # 5 とブロック内は適宜変更 print OUT $f1_line, $f2_line; } } close IN_1; close IN_2; close OUT;
あら、ORACLEは諦めて、ACCESSにしちゃうってことですか？ 僕の思い込みかもしれませんが、ACCESSってファイルをオープンするタイプのでDBで、直接ネットワーク接続できるものじゃないですよね？ なので、 > ホスト名やポート番号はあっています。 このポートを待ち受けているプログラムって何？ （実はACCESSってポートを開けて待ってたりするんですか？） ネットワークドライブ等で、ファイルとしてオープンして使うものじゃないのかな？
> 関数openが１カ所のディレクトリしか探さないという動作をすることが問題なのです。 問題ではなく、正しい動作です。 その参考書の書き方(『ハードディスクから探し出し』)が誤解を与えているかもしれません。 「openは『指定したファイルを』開こうと試みる」とした方が正確でしょう。 探したりしません。 指定したものが有るか無いかです。 指定した所に無いからといって、似たものや別の場所にあるものを、勝手に開いたりはしません。 その指定のルールとして ・ファイル名だけなら、カレントディレクトリにある同ファイル名のもの ・相対パスで指定されていたら、カレントディレクトリを起点として相対パスを辿る ・絶対パスで指定されたら、ルートディレクトリ(/)から辿る ということになっています。 ここで、どこにも「ホームディレクトリ」や「実行ファイルのあるディレクトリ」という言葉が出てこない事に注意してください。 > /Users/(myname)/Documents/test/test.pl　＃(myname)は私の名前のフォルダです。 > にあるコードをターミナル上で実行すると、 > /Users/(myname)/file.txt > に配置しているときしか、読み込んでくれません。 というのは ・スクリプトではファイル名だけしか指定していない→「カレントディレクトリにあるファイル」ルールが適用される。 ・ターミナルを起動したままでcdコマンドでカレントディレクトリを移動しないままに /Users/(myname)/Documents/test/test.pl などと実行している → ターミナル起動時のディレクトリ(/Users/(myname))がカレントディレクトリなので、/Users/(myname)/file.txtを指定したことになる ということだと思います。 例えば、ここで cd Documents としてから /Users/(myname)/Documents/test/test.pl としてみてください。今度は /Users/(myname)/file.txt は読み込まないはずです。cdコマンドでカレントディレクトリを /Users/(myname)/Documents へ移動したことで、 file.txtは /Users/(myname)/Documents/file.txt を指すようになります。 このあたりの概念は、ウィンドウでのGUI操作ばかりやってきた方には理解しずらいところはあるかもしれません。
> 直接ORACLEアクセスはあきらめて、ACCESS経由にしました。 > 自分のパソコンにｍｄｂを作成した場合には、成功しました。 ODBC 経由にするということですか？(Windows には明るくないので,違う接続方法があるのだとしたらごめんなさい） Oracle のODBCドライバをインストールし、コントロールパネルからODBCの接続設定をし、その際にインストールしたドライバを選択。 Oracle のサービスIDやらユーザ名やらを入力して完了。 上手くいっていれば ACCESS から該当のデータベースが見れるはず。 以降は、データソース名（DSN)をつかってPerlから操作できるようになります。 ODBCの接続設定で利用するパラメータは、DBI,DBDでの接続パラメータと変りないです。 ベンダーごとにことなる処理をラッピングして、共通的な処理にまとめ上げるのがODBCの役割でもあるので。 ですから、やっぱりうまくいかないってケースもありえます。 ＃Oracleのサービス名の解決が面倒なんで、よくハマるみたいです。 ＃基本的には、ホスト名,ポート名,SID,ユーザ名,パスワードなんですけど、デフォルトの接続ポートが 1521 なので、他の質問で 8080 とされていたことが少し気になります。 違いがあるとしたら、使っているドライバの差異じゃないかなと思います。 DBDの中身についてはよく知らないのですが、pure に Perl だけで作られているんでしょうかね？何かしら Oracle のライブラリ DLL とか使ってないんだろうか？ 実はOracleクライアントが必要だったってオチもあるんじゃないかと。 これって、配布するプログラムなんですか？配布先で動く環境を整えるのが面倒そうですね。
URLをご参考にどうぞ。
http://search.cpan.org/~pythian/DBD-Oracle-1.27/Oracle.pm ここらへんを見ると $dbh = DBI->connect("dbi:Oracle:host=xxx.xxx.xxx.xxx;sid=usrDB;port=8080",$user, $pass); みたいに書くようですよ。ただ、Oracleは使ったことないんで間違っているかもしれません。 ところで、8080ポートに接続しているということはWebプロキシに接続に行っているみたいなんですが、ポート番号は合っていますか？ ちなみに、SQLiteの例ですが、トレースを出したいときは以下のようにします。Oracleでも似たような出力を出すことができると思います。以下、表示がくずれすので空白2文字を全角空白で書いていることに注意。 use strict; use warnings; use DBI; # DB Name my $db_name = 'sqlite_test.db'; # Disable buffering $| = 1; # Connect to the database my $dbh = DBI->connect( 　　'dbi:SQLite:dbname=' . $db_name, 　　'', '', 　　{　 PrintError => 1,　　### Do report errors via warn() 　　　　RaiseError => 0,　　### Don't report errors via die() 　　　　TraceLevel => 5 　　} ) or print DBI->errstr; # Disconnect from the database $dbh->disconnect; これを実行すると以下のような出力が出てきます。 DBI::db=HASH(0x9dda3a8) trace level set to 0x0/5 (DBI @ 0x0/0) in DBI 1.605-ithread (pid 4982) <> FETCH= 5 ('TraceLevel' from cache) at /usr/lib/perl5/DBI.pm line 693 -> STORE for DBD::SQLite::db (DBI::db=HASH(0x9dda3a8)~INNER 'Username' '') thr#9c7d008 ....
No.1です。 MySQLの文字コードの確認を行ってください。 また、ソースコードの文字コードはどのようになっているでしょうか？ また、テーブル名などを英数字にすることは、不可能なのでしょうか？ テーブル名を日本語にしたことがないのですが、 いらぬところで、はまったりしそうなので。。。 ためしに、英数字のテーブルでスクリプトを試してみては いかがでしょうか？ ソースコード的には、動かないものではなさそうですので。
私のところでは、perldoc -f join , perldoc perlfunc で問題ありません。 > １、perldoc -f ～で出てこない私のパソコンは何か問題があるのでしょうか？ パソコンの問題というよりは、なにかの設定の問題か、インストールするべきものがされていない、ということかと思います。 こちらでは、 /System/Library/Perl/5.10.0/pods/ に ～.pod というマニュアル用の書類があります。perldocはここを参照しているようです。 OSのインストーラで追加インストールしたものか、Xcodeあたりでインストールしたものだったか、残念ながら記憶にありません。 > ２、単に関数を打った場合、これはどのような命令になっているのでしょうか？ 「Perlの関数」ではなく、「シェルのコマンド」として認識されます。 ls とか cp とか rm とかと同じです。 たまたま open (質問にあるメッセージはjoinのものでは無いようです) というコマンドがあるので、openが実行され、必要な引数が指定されてなかったためにエラーメッセージが表示されただけです。 例えば、 binmode と打てば、「bash: binmode: コマンドが見つかりません 」等と表示されると思います。
そのまま実装しました。 省略表現が初心者には難しいかもしれませんが、その分見やすいと思います。 インデントは全角スペースになっています。 #!/usr/bin/perl use strict; my($m1, $m2, $m3); open(IN, "in.csv") or die; open(OUT, "> out.csv") or die; while(<IN>){ 　my($n1, $n2, $n3) = split /,/; 　if($n1 eq $m1 && $n2 eq $m2 && $n3 eq $m3){ 　　next; 　}else{ 　　($m1, $m2, $m3) = ($n1, $n2, $n3); 　　print OUT; 　} }
＞今回は下記のエラーと… こちらの環境では問題なく動きますね…。 書き換えたりしませんでした？ whileとかはいらないですよ。
MacでCGIを動かす場合の設定 ＃あくまでも私の確認環境ですので、 ＃詳細についてはご自分で調べていただけると幸いです。 ＃ご存知かもしれませんが、最初から書いていきます。 ＃ご了承ください。 前提として、/Users/ユーザ名/Sites/以下でCGIを動かす場合です。 1.Apacheの設定を行う。 　/etc/apache2/users/ユーザ名.confをいじります。 　すでに書かれている内容は、以下のようになっていると思います。 　インデントのために、全角スペース使ってます。 　<Directory "/Users/ユーザ名/Sites/"> 　　Options Indexes MultiViews 　　AllowOverride None 　　Order allow,deny 　　Allow from all 　</Directory> 　 　追記していきます。 　<Directory "/Users/ユーザ名/Sites/"> 　　AddHandler cgi-script .cgi ←追加 　　AddHandler cgi-script .pl ←追加 　　Options Indexes MultiViews ExecCGI ←「ExecCGI」を追加 　　AllowOverride None 　　Order allow,deny 　　Allow from all 　</Directory> 　 2.Apacheの起動 　システム環境設定の「共有」-Web共有をチェックを入れるとApacheが起動します。 　すでに立ち上がっている場合は、再起動させて設定を読ませる必要があるので 　チェックを一度OFFして、もう一度ONにしてください。 　 3,確認 　ブラウザから「http://localhost/~ユーザ名/で初期設定されているindex.htmlが 　見えるか試してください。 　その後、簡単なCGIなどで動作確認してください。 　cgiファイルのパーミッションは、755で動作します。 このような形で動くと思います。 最後に、 ターミナルからいじれるようになると、何かと楽な気がします。 Finderでアプリケーション→ユーティリティの中にターミナルがあります。 慣れておいて損はないと思います。 Perlのデバックをターミナルから行って、 その後、ブラウザ経由で確認するのが常套手段です。
アドバイスになりますが。 CGIとHTMLとPerlは分けて勉強してください。 まずは、Perlそのものの使い方を一通り勉強してください。 ついでに、Unix 系OSの基本事項(ディレクトリ構成とか、権限とか)を勉強してください。 Perlで動作するものができれば、それまで単にprintしていたものを、一定の書式になるようにすればCGIとして動作するようになります。httpサーバーで違うディレクトリになっても、変更するべき箇所がすぐにわかるはずです。 > require 'cgi-lib.pl'; いまどき、cgi-lib.plは使わないでしょ。 少くともOSX 10.6にはperl 5.10が付いています。CGI.pmが使えます。 > 教科書通り、 > sudo cp ./Desktop/httpd.conf /private/etc/httpd/ > と打って、パスワードを打つと > デスクトップに/private/etc/httpd.conf ファイルがデスクトップにコピーされるとの記載があるのですが 本当ですか? もしそうなら、その教科書は間違いです。 ・sudo 管理者権限でコマンドを実行するためのコマンド なのでいったん置いておくと、 cp ./Desktop/httpd.conf /private/etc/httpd/ ってどんなコマンドになるか、理解していますか? この「./Desktop」の「.」 ってなんだかわかってますか?
状況によって問題点が変わってくるのですが、ソースは別に悪くないと思います。 見たところ、シェバング行があったり、表示にHTMLを出力しているようですので、CGIとして動作させているのではないでしょうか。 ローカルマシン上で動作させる場合と、ブラウザを通してWebサーバ上で動作させるのには権限による違いがあります（例外もありますが）。 すべてではありませんがマカーの方は結論を急ぐあまり基礎を無視して事を進めるため過程における要因の切り分けができない方が多い（わたくしの身の回りに）ので、まずは落ち着いて参考にしている本をよく読みましょう。 PerlのプログラムをOS上で動作させる場合と、WebサーバからCGIを介して動作させる場合とではそのマシンに対するアクセス権限が異なることを理解してください。 PCのオーナーや管理者、あるいは利用者などはそのマシンに対するアクセス権限を持って利用しているため権限の範囲内でファイルを作ったりするのは自由です。 Webからアクセスするユーザが、そのマシンに好き勝手にファイルをガンガン作れるようなら、サーバはあっという間にパンクしてしまいます。 もし、Webからアクセスするユーザに対してファイルを作らせたいのならそこに権限を与えなければなりません。 逆に危険ではありますが、Webからのアクセス権限をオーナーと同じにするという荒業もありますが・・・。 MacだからとかWindowsだからとかで物事が単純になるわけではなく、それを開発した企業努力が基本技術を隠蔽しているだけで、パソコンといえど立派なコンピューターです。オーナーすなわちシステム管理者が本当はあたりまえのように理解しなければならないことが結構あったりするのです（使ってるときにコンセント抜いちゃいけないよーとか）。 違いを体感する、具体的な方法として、ブラウザからの動作確認を止めて、ターミナルソフトを動かし、コマンドでPerlからそのプログラムを実行させて結果を見るとよいでしょう。 まずはファイルの属性（権限：パーミッション）とオーナー/グループについて調べてください。 ファイルといっても通常のファイルだけでなく、Macや近年のWindowsでフォルダと呼ばれるようになった「ディレクトリファイル（通称ディレクトリ）」も同じです。 まあ、ファイルを扱うプログラミングを勉強するなら、のちのちはデバイスファイル（キャラクタ型・ブロック型）やリンクファイル（シンボリック・ハード）についても知っておく必要があると思います。 プログラミングの勉強は障害が最高の先生かと思いますのでめげずに取り組んでください。
> open ( FH , "count.txt")) 「読み込みモード」のopenはファイルが無いと「失敗」するだけで「作成」はしませんよ。 これは、MacとかPerlとか関係無しに、ほぼ全てのOSと言語で同様です。
これは、サーバーの設定の関係ですね。 そのGIFファイルをCGIと同じディレクトリに置いていませんか? httpサーバーの設定によっては、URL上では一緒に見える CGIのディレクトリと 静的なファイルのディレクトリとが違います。Macのサーバーの初期設定では、まさにそのようになっているようです。 そのGIFファイルを WebServer > Documents に入れてみてください。 まとめると localhost/～.cgi はCGIのアクセスと解釈され、CGI-Executables にあるファイルが実行される。 その結果の出力として出てきた locahost/～.gif は静的なファイルなので Documents にファイルを探しにいく。
use LinguaJASortJIS; は use Lingua::JA::Sort::JIS; のタイプミスですね。 このモジュールの jsort は、utf8 フラグつきの文字列をソートするのではなく、 utf8 にエンコードしたバイト列を対象としているようです。 なので use Lingua::JA::Sort::JIS; use Encode qw( encode ); my $Jis = Lingua::JA::Sort::JIS->new( sub { encode('utf8', $_[0]); } ); としてやるとよいようです。
<form>タグに、ENCTYPE="application/x-www-form-urlencoded" が抜けているのでは。
(MS-DOS 風に書くと) c:\Perl\workdir にあるファイル名を使ってカレントディレクトリのファイルをオープンしようとしてるんだから, ディレクトリ c:\Perl\workdir が (このスクリプトを実行している) カレントディレクトリでなければ正しい動作をしないと判断できる. たとえば ・c:\Perl\workdir には test1.txt, test2.txt がある ・カレントディレクトリには test1.txt はあるが test2.txt はない というような状況であれば 「(カレントディレクトリにある) test1.txt は読み込めるが test2.txt は (カレントディレクトリにはないので) 読み込まない」 ということになる.
カテゴリ javascript で質問した方がよいですよ。 過去の質問だと http://okwave.jp/qa/q2551334.html が参考になると思います。
> 821 は obsolete だから参照しちゃダメですよぉ＞#2. 今なら少なくとも 2821 の方を参照しないと.... 2821 は obsolete だから 5321 を参照しないと。 ただし、UTF8 を使うかどうかの判断に RFC5321 や RFC5322 はあまり関係ない。 (8bit対応してないSMTPサーバーがいるかもしれないから7bitにencodeしてねとかそれくらい) 受け取る人が限られていてその人たちがUTF8で問題ないならUTF8で送れば良いと思います。 Amazon や Yahoo! は受け取る対象が不特定多数なので ISO-2022-JP が無難なわけですね。
れれ　もう一度見直してみると >if ($trm14 eq "●") {print "<font color='green'>";} > else {print "<font color='red'>";} >$trm14には間違いなく「●」が入っています この場合「真」ですよね？ これ以外の場合に「偽」にしたいということですよね(かくに～んｗ) ################################################# おっしゃるように、同じコードの中で #例1 $trm = '●'; print 'OK' if ($trm eq '●'); として、実行すると #例1実行結果 OK と出力されるはずです。(ここ確かめてみてください) 上記を踏まえて もしかして・・・　もしかしてですが if ($trm14 eq "●") の部分は、わかりやすくしたのではなくこのままの状態です？ というのも、このままだと「完全一致」ということになりますよね もし文の中にある●をさがしたいのであれば「正規表現」でマッチさせないといけないです。 if ($trm14 =~ /●/) だと、文中にある●をさがしてif文を真にさせることができます。 (もうしわけないどのていどのプログラミングレベルかわからないものでこちらもさぐりさぐりですｗ) #例2 $trm = 'ははは●ははは'; print 'OK' if ($trm =~ /●/); #例2実行結果 OK #---------------------------------------------------- わたしの経験上、Perlでの文字コードは入力も出力もUTF-8に統一したほうがいいです。 というのもSHIFT-JISだと他のコードとかぶる部分があるのでうまくいかないときがありますし、 Perl自体UTF-8よりにできていると聞いたので今までそうしてきました。 ファイルを読み込む際にUTF-8に変換して、プログラムコード自体もUTF-8にすると混乱を避けることができます。 実際にエンコードを変換する方法は以下参照 http://www.rwds.net/kuroita/program/Perl_unicode.html Perlバージョン5位からは以前のように、jcode.plを使わなくとも文字コードの取り扱いが楽になってますよ。 それとプログラムを書く場合、メモ帳ではなく文字コードを指定できる「秀丸」などを使ったほうがいいです。 さらに！ CGIということなのでHTMLの文字コードタグも同じにしないといけませんよー とりあえず、思いつく限りを羅列してみました。何かのヒントになればいいのですがいろいろな環境がありますので「これだ！」とは言い切れないのが・・・わたしも年食った証拠かな＞＜；
みた感じ、質問文内のスクリプトは、 (1)配列@csvから1行抽出。 (2)抽出したものを分割したものをinputコントロールとして出力。 ――としているので、全行出力するなら、@csvについてループさせる必要があります。 なので、$cntを操作しても、うまくいかないかと。 $cntは、1行を分割した個々の要素を数えるのに使っているので。 たとえば、質問文スクリプトをサブルーチン化して、@csvの各行に対してそれを呼び出すようにするとかいった方向でスクリプトを書き換えてみては。
@ranking がなぜそうなるのか説明してください. 特に最後の 10.
プロバイダのOP25B対策により、メールが送信できないのかもしれません。 http://e-words.jp/w/OP25B.html OP25B対策がされていた場合は、サブミッションポート(587番ポート)や、 SMTP-AUTHを設定する必要があります。
根本的には perl の問題ではありません。 「髙」や「﨑」といった文字は、JIS(ISO-2022-JP)では規定されていないため、 ISO-2022-JPのメールに入れることはできないのです。 文字コードがUnicodeであれば、「髙」や「﨑」を表現できますので、 ・perlのスクリプトを、Unicode(UTF-8)で記述するようにする ・メールのcharset を UTF-8で送信するようにする ・文字コードの変換を、perl4時代の古いライブラリ(Unicode非対応)である「mimew.pl」や「jcode.pl」ではなく、perl5世代の「Encode.pm」を使う という対応になるかと思います。 ---ここから--- #!/usr/bin/perl use strict; use utf8; use Encode; my $sendmail = '/usr/lib/sendmail'; print "Content-type: text/html\n\n test\n"; my $out; if (!(open($out,"| $sendmail -t -i -f xxxx\@hogehoge.co.jp"))) { ; } print $out "To: xxxx\@hogehoge.co.jp\n"; print $out "From: xxxx\@hogehoge.co.jp\n"; print $out "Reply-To: xxxx\@hogehoge.co.jp\n"; my $mail_subject = "サブジェクト 髙﨑"; $mail_subject = encode('MIME-Header', $mail_subject); print $out "Subject: $mail_subject\n"; print $out "Mime-version: 1.0\n"; print $out "Content-Type: text/plain\; charset=\"UTF-8\"\n"; print $out "Content-Transfer-Encoding: 8bit\n\n"; my $honbun = "メール本文 髙﨑"; $honbun = encode("UTF-8", $honbun); print $out "$honbun\n"; close($out); ---ここまで--- といった形でしょうか。 ただし、最近はまず大丈夫だと思いますが、 「日本語のメール」としては、ISO-2022-JPで送るのが主流であり、UTF-8で送った場合にはメールソフトによっては問題が出るかもしれないことは覚悟する必要があるかと思います。
0x0d→0x0d 0x0d0x0a→0x0d0x0a 0x0a→削除 なら binmode STDIN; binmode STDOUT; while(<STDIN>){ if ( /\r\n$/ ){ } elsif ( /\n$/ ){ chomp; } print $_; } として「foo.pl」 perl foo.pl < 入力ファイル > 出力ファイル
こういう入れ子構造のは正規表現でやりずらいところなんですよね。 1つの案として。漢字を文字として識別できるようにしておいて while( $data =~ s/（[^（）]*）//g ) {} と内側から消していくとか
CGI が HTTP サーバーから実行されるときの Owner が、実行ディレクトリに 対するファイル作成の権限(Permission)を持ってないのでは?
外から変数に代入して、その変数を処理する方法があると思います。次のコードは、先頭から１文字ずつ見ていきながら、全角文字に含まれない \ だけを変換しています。 use strict; my $path = <DATA>; chomp $path; $path .= '#'; while ($path !~ /^#/) { unless ($path =~ s/^([\x81-\x9F\xE0-\xEF][\x40-\xFC])(.*)/$2$1/) { $path =~ s/^\\/\//; $path =~ s/^(.)(.*)/$2$1/; } } $path =~ s/^#//; print "$path\n"; __DATA__ c:\申請表\能力検定\貼付け\十分.txt
CGI::Sessionは元々Cookieを使用することを想定しています。 一般的なシナリオは以下のとおりです。 1) パスワードなどで認証したあと、CGI::SessionでセッションIDを作る 2) 1) のセッションIDをファイルやDBに保存する 3) 認証後の初めの画面でセッションIDをCookieでユーザのブラウザにセットする 1)と2)はCGI:Sessionのnewメソッドで一度にまとめることができます。 3) の方法はCGI::Sessionのheaderメソッドを参照して下さい。
> プロバイダーの指定では、 > /use/local/www/htdocs/user-id/public_html/目的のディレクトリ > と在ります。 > .htaccessの説明を読んだ限りでは、 > 制限を掛けたいフォルダ（ディレクトリ）に置け、となっていました。 > であれば、このルート部分に置きたいのですが。 .htaccessの設定はサブディレクトリまで有効になるのでどちらでも構いません。 ただ、制限する場所を限定したいのであれば後者ということになります。 余談ですが、ロボット撃退にはもっとすっきりした方法としてrobots.txtがありますが、 既に検討されましたか？ http://www.tohoho-web.com/wwwxx079.htm
quotemeta ないし等価な \Q～\E
(1) については ・すべてのものを大文字 (か小文字) に統一する ・index を捨てて m//i くらいは思いつくかな. (2) は (どうしてそういうことをしたいのかちょっと分からないんだけど) キーに対して /[^[:alpha:]]/ でマッチさせるとか.
初心者とのことなので、とりあえず全部書いてしまいますが、業務で使うのであればちゃんとプロに依頼したほうがいいですよ。 SOHOサイトで依頼すれば3000円もかからないと思います。 #!C:/Perl/bin/perl use Net::FTP; use strict; my @ftp_data = ( ['ftp','192.168.0.0'], ['ftp2','192.168.0.10'], ); for(@ftp_data){ # ftpで処理 eval{ &get_ftp(@$_) }; # エラーがあればログに記録 &error($@) if $@; } exit; sub get_ftp { my($label, $host) = @_; $label = sprintf("%-8s", $label); # 整形 #FTPサーバーへの接続 my $ftp = Net::FTP->new($host) or die($label . $@); #ユーザー名とパスワードを指定してログイン $ftp->login('user','password') or die($label . $ftp->message); print "connect $host\n"; #接続終了 $ftp->quit; } sub error { my($message) = @_; chomp($message); open(OUT, ">> ERROR.csv") or die; print(OUT "$message\n"); close(OUT); }
Perlでなので・・・下記のように考えてコーディングして下さい。 　１．実行したい処理をコマンドで記述する。 　２．＃１のコマンド実行して、考えたとうりに実行されることを確認 　３．＃２で確認した、コマンドの文字列を出力するPerlのプログラムを考える >しかし、多次元配列の使い方やfor文を調べても良くわからず困っています。 綺麗なだけど動かないプログラムより、汚くても確実に動作するプログラムを書いてから、綺麗なプログラムになるように頑張りましょうね (^O^)/~~
当然できます. 実際にどうすればいいのかについては, その「FTPホストの設定名」とやらをどのように与えるかに依存します.
作ろうかなと調べているうちに、そのものがあったので http://developer.hatena.ne.jp/ja/documents/auth/apis/wsse
簡単なのはGDモジュールですかね。 #!/usr/bin/perl use strict; use LWP::Simple; use GD; my $buff = &get("http://okwave.jp/images/logo/logo.jpg"); die "取得に失敗" unless $buff; my $img = GD::Image->new($buff); printf("use GD::Image; width => %s; height %s\n", $img->width, $img->height);
rep::replace がどこにもないからよくわからんのだけど, この refidrep を見る限り受け取り方を勘違いしてる気がする. プロトタイプにおける \ の意味と, それに対応する引数をどのように受け取るかについて確認してください.
カテゴリーにも書いてありますが「Perl」です。 もし「Parl」という私の知らない言語なら、以下の話は無視してください。 少しだけ正しい、といったところでしょうか。 リファレンスは、機械語で例えれば、番地のようなものです。 ただ、もっと抽象的なものです。リファレンスを辿ると、参照先へアクセスできるような、なんらかの情報、くらいのものです。 実際に何が記録されているかは、ソースを読めば解るでしょうが、Perlの処理系自体を開発するのでなければ、考えなくてもいいものです。 あと、 > 配列@arrayの番地は、５個ぶんのメモリ領域が確保されるのでしょうか？ > そしてスカラー$ref_arrayに代入される番地は、 > その５個ぶんの番地の先頭番地でしょうか？ > （スカラー変数１つに、５個のデータは入らないですよね？） とか書いているのを見ると、機械語やC言語のような考えがあるようですが、Perlではもっと抽象的に考えてください。 順番にならんだ直線ではなく、大小関係のない面や立体的な空間の中に変数領域があるような。
こんな感じでしょうか。 動作確認はしていないのでバグがあるかもしれませんが…。 #!/usr/bin/perl use strict; use Net::FTP; chdir("保存先ディレクトリ") or die; my $ftp = Net::FTP->new("example.com") or die; $ftp->login("user", "pass") or die $ftp->message; $ftp->cwd("取得元ディレクトリ") or die $ftp->message; # すべてのログを取得 my @files = grep{ /^LOG_/ } $ftp->ls; # 12月分を取得 # my @files = grep{ /^LOG_12/ } $ftp->ls; # 最新の30日分を取得 # my @files = sort{ $b cmp $a }grep{ /^LOG_/ } $ftp->ls; # @files = splice(@files, 0, 30); # 11月20日から12月19日までを取得 # my @files = grep{ /^LOG_(\d+)/ && 1120 <= $1 && $1 <= 1219 } $ftp->ls; for(@files){ # 取得済みならスキップ next if -e $_; printf("get %s\n", $_); $ftp->get($_) or warn $ftp->message; }
分量が多くなったので、分けて書きます。 以下、連想配列を使った、全地域・全サイズ対応版です。 また、この変数%areaを県単位で書き下せば、 地域名ではなく県名から料金を計算させるようなことも可能です。 ---ここから--- #地域名から地帯番号への変換 my(%area) = ( "愛知" => 0, #県内は仮に第0地帯とする "関東" => 1, #第1地帯 "信越" => 1, "近畿" => 1, "東海" => 1, "北陸" => 1, "東北" => 2, #第2地帯 "中国" => 2, "四国" => 2, "九州" => 3, #第3地帯 "北海道" => 5, #第5地帯 "沖縄" => 6, ); #地帯番号から、サイズ・料金対応表への変換 my(%postage) = ( 0 => { 60=> 600, 80=> 800, 100=>1000, 120=>1200, 140=>1400, 160=>1600, 170=>1700 }, 1 => { 60=> 700, 80=> 900, 100=>1100, 120=>1300, 140=>1500, 160=>1700, 170=>1900 }, 2 => { 60=> 800, 80=>1000, 100=>1200, 120=>1400, 140=>1600, 160=>1800, 170=>2000 }, 3 => { 60=> 900, 80=>1100, 100=>1300, 120=>1500, 140=>1700, 160=>1900, 170=>2100 }, 5 => { 60=>1100, 80=>1300, 100=>1500, 120=>1700, 140=>1900, 160=>2100, 170=>2300 }, 6 => { 60=>1200, 80=>1400, 100=>1600, 120=>1800, 140=>2000, 160=>2200, 170=>2400 }, ); print"愛知県から小包の地方を入力してください。\n"; chomp($areaname=<>); my $areano = $area{$areaname}; if (!defined($areano)) { print "地域名「$areaname」は正しくありません\n"; exit; } print"小包のサイズを入力してください。\n"; chomp($size=<>); my $price = $postage{$areano}->{$size}; if (!defined($price)) { print "サイズ「$size」は正しくありません\n"; exit; } $price =~ s/(\d)(\d{3})$/$1,$2/; print "$areaname 地方は第 $areano 地帯です。\n$size サイズは $price 円になります\n"; ---ここまで---
> print "@inを"; ダブルクォートでくくると配列の値が展開されるので、 シングルクォートでくくるか、エスケープしましょう。 $ni_tallは、foreachブロック内でのみ有効な変数になります。 foreachブロック終了と同時に、なくなります（printしても何も表示されません）。 > $n *= $ni_tall; これは、変数$nに数値を代入することになります。 略さず書くと、 $n = $n * $ni_tall; 最終的に、$n = 7*10*20*40の値(1680000)が入ります。 > $ave = $n * @in; これは、$ave = 1680000 × 4(配列の個数）となります。 Perlは色々な書き方がありますので、以下のようにも書けます。 ご参考までにどうぞ。 my @in = qw(10 20 30 40); print '@inを何倍しますか？:'; chomp(my $n=<>); map { $_ *= $n } @in; print "結果:", join(',', @in);
ｘｐまでならともかくVistaでは動作確認には向いていないと思います。 Vistaのイレギュラーな環境にあわせてCGIが動作しても本番環境で通用するかどうか・・・。 悪いことは言わないので古いPCとかあったら軽いLinuxやBSDなどを入れて動作確認されることをお勧めします もしどうしてもWindows環境でないとと言うことでしたらXP前提で話をすると「xampp」あるいは「xampp-lite」+「ActivePerl」あたりで構築するといいかもしれません。一応Vistaでも動作しますが・・・。 どっちにしても「UNIX系」のPerlと「Windows系」のPerlとではOSが異なるので当たり前ですが「相違」があることを覚悟してください（特にファイルロック関連）。
CSSセレクタなので、div.ltxtは、class="ltxt"にもclass="ltxt brand"にもマッチすると思います。たぶんdiv.ltxtと指定したとき結果を複数返してきていて、最後に"ltxt brand"を返して来たんでしょう。 属性を取得したい場合はCSSセレクタでは属性を(たぶん)取得できないので、XPathで指定する必要があると思います。
ｐｅｒｌには詳しくありませんが普通は１００で割って切り捨てします。 例えば　　Ａ＝ＩＮＴ(Ｂ／１００)　みたいに。
申し訳ない, #2 も言葉がおかしかった. qq で作った文字列が「HEREDOC」のわけなかろうに. 言いたいことは #2 の通りですが, qq!～! が 1つの文字列だ, ってこと. このスクリプト自体はサーバじゃなくても (require 文を消して実行すれば) エラーになるはず.
ちと気になった点を突っ込ませてくださいな＞#4. my $html = join("", <IN>); よりは $/ = undef; my $html = <IN>; の方がよいかと. あと, printf(OUT "%s\n", join("\n", @src)); は $" = "\n"; print OUT "@src\n"; にした方がシンプルじゃないかな. あと open は (それなら) 3引数にするとか, そもそもリダイレクト (とコマンドライン引数) にまかせた方が簡単とかありますけどね.
遅くなって申し訳有りません 以下、Sjax版のサンプルです。 CGIからはきだすHTMLと思ってください -----------------------------------------------------------------------------ここから <html> <head> <meta http-equiv="Content-Language" content="ja"> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <title>SJAX</title> <script language="javascript"> <!-- // ------------------------------------- // ------------------------------------- function fCall(CODENUMBER){ var xObj = createHTTPRequest(); var fName = "http://www.hoge.jp/hoge.php?" + CODENUMBER; xObj.open("GET", fName, false); xObj.send(null); // setInterval ( "fCall()", 5000 ); var oText = document.getElementById("ShowData"); oText.innerHTML = xObj.responseText; } // ------------------------------------- function createHTTPRequest(){ if(window.ActiveXObject && !window.XMLHttpRequest){ try{ return (new ActiveXObject('Msxml2.XMLHTTP')); }catch (e) {} try{ retrurn (new ActiveXObject('Microsoft.XMLHTTP')); }catch (e) {} return (null); }else if(window.XMLHttpRequest){ return (new XMLHttpRequest); }else{ return null; } } //--> </script> </head> <body onload="fCall(ここにCGIが受け取ったコードを挿入)"> <span id="ShowData"></span> </body> </html> -----------------------------------------------------------------------------ここまで お役に立てるといいのですが
ファイルで表現する場合は、インデックスファイルとログファイルを分けます。 インデックスファイルの中のみを書き換えて、表示する時は両方を合成して用います。 -- idx -- 5.log,2010-12-18 2.log,2010-12-17 3.log,2010-12-16 1.log,2010-12-15 4.log,2010-12-14 -- 5.log -- 1,AAA,MESSAGE 2,BBB,MESSAGE 3,CCC,MESSAGE
s/// のオプションである e, g, i, o, x のそれぞれの意味は理解できていますか? まあ上の書き方が素直だとはあまり思えないが. 結果は $hoge = qq(hogehoge) if $hogehoge =~ s/<文字列>/hogehoge/egiox; $_ = $hoge; と同じじゃないかなぁ. 「hogehoge」が (2個じゃなく) 1個ですむってのが「利点」といえば利点だけど....
Perl初心者です。 WindowsとUNIXで同じPerlを動作させる時にファイルパスの区切り文字に苦労した経験があります。 \は特殊文字なので\\にしないと駄目じゃないかと思いますがどうでしょうか？ open(FH,"C:\\filename1.txt"); 見当違いな回答なら笑ってスルーして下さい。
sourceコマンドは、今実行しているシェルの環境でファイル中のコマンド群を実行するコマンドです。 なので、perlなどシェルでないものから実行する意味はありません。 なぜsourceコマンドを実行したいと思ったのかを書くと、良いアドバイスが得られるでしょう。 perlの実行時の環境変数を、あるファイル中のexportコマンドによって設定したいと言うことなら、 案１：実行前にシェルでsourceコマンドを実行する(#1さんの回答の通り） 案２：ファイルの中身をperlで解釈して$ENVを設定する（質問にお書きの通り)
サイトを見るとたしかに丁寧に書いてあるのですがUNIX環境が前提の操作になっています。 たぶんサーバで操作することが前提なのでしょう。 Windowsで行う場合はPerlがコマンドプロンプト(DOS窓)で実行可能な環境が必要です まずActivePerlをインストールしてください。 http://www.activestate.com/activeperl/downloads からダウンロードできます のちのちサーバ上のPerlとの互換性も考えて5.8系の古いものがお勧めです MSIインストーラ付の物でインストールすると設定が楽です インストールしたらコマンドプロンプトを開いて「perl -v」とでも打ってバージョン番号が帰ってきたら準備OKです 次に郵便番号データ２種を下記の郵便局サイトからブラウザでアクセスしてダウンロードします http://www.post.japanpost.jp/zipcode/dl/kogaki/lzh/ken_all.lzh http://www.post.japanpost.jp/zipcode/dl/jigyosyo/lzh/jigyosyo.lzh 各々のファイルを圧縮解凍ツールで解凍してCSVファイルにし、こちらのajaxzip2を展開したディレクトリ内のサブディレクトリ「work」にそれらを移動します コマンドプロンプトを開いて上記ディレクトリにカレントディレクトリ(作業用ディレクトリ)を移します 例：cd C:\Temp\Download\ajaxzip2\work そこにあるPerlスクリプトを実行すれば、一階層上の「data」ディレクトリに新しいJASONデータが生成されます 上記生成ファイルをサーバにアップロードしておしまい。 P.S. 前回は的外れな回答をしてすいませんでした。 郵便番号検索うんぬんでなくてメールフォームが必要でそれにこれを載せたかったんですね
@ARGV = ('datafile'); my %h; print grep { ! exists $h{$_} && ++$h{$_} && !(/^END$/ && undef %h) } <>;
> とそれぞれの()の最後の文字deuch beer zeroに,が残ってしまっています。これを消すにはどうしたらいいでしょうか？ じゃあ、思いっきり手を抜くとこんな感じかな・・・。 open(IN, "datafile.txt"); @xx = <IN>; close(IN); my $yy = join("\",\"",@xx); $yy =~ s/\r\n|\r|\n//g; $yy =~ s/,\"END\",/),c(/g; print "c(\"".$yy."\")"; exit; でも本気でちゃんとプログラミングの処理として動作させたいなら自分がPCになったつもりで手順を考えたほうがためになると思う。
言語以前の問題ですね。 どんな言語でも可能ですが、周辺をとりまく環境の把握が必要です。 以下のことが必要です。 [1]: マシンをサーバーとして起動するためにはそのためのプログラムが必要です。 　　 「サーバーをサーバーとするプログラムが定義する仕様を知ること」 　　 ただし通信法はおそらくhttpプロトコルだと思うのでその場合だと一般的な手段と同じです。 [2]: サーバー側は外部からのファイルの受付を許諾するのか。 　　 「その場合、そのようなプロセス(手順)によって許諾されるのか」 　　 掲示板とのことですので、通常は掲示板が掲示板として動作させるプログラムが定義してます。 　　 (その仕様を調査する必要があります)。 [3]: 上記を踏まえた上で、クライアント側でサーバーの意向に沿うプログラムを動作させる。 　　　「この時に使う言語は、通信が可能であればPerlでも何でも構いません」 　　　当然、実装の方法に関しては [3] を満たす動作をさせることです。
変数を設定して++してあげたらいいように思います。こんな感じです。 use strict; use warnings; my @array = ('aaa', 'b*b', 'ccc', 'dd*'); my $i=0; foreach (@array) { if ($_ =~/\*/) { print 'OK',",$i\n"; } else { print "NG\n"; } $i++; }
まず，何がしたいのかが分かりません。 フォームからの入力をしたいのですか？ または，ページ間での情報の共有をしたいのですか？ それとも，ログインシステムを作りたいのですか？ 別の何かについてきいているのですか？ それが分からないと，非常に回答がしにくいです。 Perl は分からないので，PHPでのサンプルを書いておきます。 # フォームからの入力 -- index.html --- START <html> <head><title>title</title></head> <body><form action="read.php" method="get"> <input type="text" name="hoge"><input type="submit"> </form></body> </html> -- index.html --- END -- read.php -- START <?php $data = $_GET['hoge']; print ("$data<br>\n"); ?> -- read.php -- END # ページ間での情報の共有 -- index.php -- START <?php session_start (); $_SESSION['data'] = "test data"; print ("<a href=\"hoge2.php\">hoge2</a>\n"); ?> -- hoge.php -- END -- hoge2.php -- START <?php session_start (); print ("$_SESSION['data']\n"); ?> -- hoge2.php -- END # ログインシステム -- index.php -- START <?php session_start (); if (!isset ($_SESSION['user']) || $_SESSION['user']=="") {$user = $_POST['user'];} else {$user = $_SESSION['user'];} if (!isset ($_SESSION['pass']) || $_SESSION['pass']=="") {$pass = $_POST['pass'];} else {$pass = $_SESSION['pass'];} if (ユーザID と パスワードの確認関数) { $_SESSION['user'] = $user; $_SESSION['pass'] = $pass; print ("<a href=\"hoge.php\">hoge</a>"); } else { print ("<form action=\"index.php\" action=\"post\">userid: <input type=\"text\" name=\"user\"><br>password: <input type=\"password\" name=\"pass\"><br><input type=\"submit\" value=\"ログイン\"><br></form>"); } ?> -- index.php -- END -- hoge.php -- START <?php session_start (); if (!isset ($_SESSION['user']) || $_SESSION['user']=="") {$user = $_POST['user'];} else {$user = $_SESSION['user'];} if (!isset ($_SESSION['pass']) || $_SESSION['pass']=="") {$pass = $_POST['pass'];} else {$pass = $_SESSION['pass'];} if (ユーザID と パスワードの確認関数) { print ("hoge page"); } else { print ("<form action=\"index.php\" action=\"post\">userid: <input type=\"text\" name=\"user\"><br>password: <input type=\"password\" name=\"pass\"><br><input type=\"submit\" value=\"ログイン\"><br></form>"); } ?> -- hoge.php -- END セキュリティも何もありませんので，その辺は考えてください
Data::Dumper とか DB に tie とか.
文字列を数値として比較しているので、そういった動作になります。 文字列として比較すれば望む通りの動作になると思います。 # if($tag =~ m/^tag$/ && $ref == 0){ if($tag =~ m/^tag$/ && $ref eq "0"){
