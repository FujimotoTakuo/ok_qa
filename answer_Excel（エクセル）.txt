シート名が異なっていると 「Worksheets(Target.Value).Visible = True」でエラーになります。 もう一度シート名を確認してみてください。 前後に半角スペースが入ってないか、とか。
こんにちは フォームボタンとして Sub ボタン1_Click() 　　On Error Resume Next 　　If ActiveSheet.ProtectContents = False Then 　　　　ActiveSheet.Protect "pass", UserInterfaceOnly:=True 　　Else 　　　　ActiveSheet.Unprotect InputBox("パスワードを入力する") 　　　　If Err.Number <> 0 Then 　　　　　　MsgBox "間違ってます" 　　　　End If 　　End If 　　On Error GoTo 0 End Sub とかでも。
Sub Example() With Sheets("Sheet1") .Cells.FormatConditions.Delete .PageSetup.PrintArea = Range("A1:K73").Address .PrintOut End With End Sub こんな感じでしょうか。
こんばんは Sub ReadTextFile() 　　 　　'タブ区切りファイルを全て文字列として読み込む 　　 　　Dim FileName As Variant 　　Dim i As Long 　　Dim Cnt As Long 　　Dim Buf As Variant 　　Dim FileNo As Integer 　　Dim SplitString As Variant 　　Dim v As Variant 　　 　　'ファイルダイアログを表示 　　FileName = Application.GetOpenFilename("テキストファイル,*.txt", , , , True) 　　 　　If IsArray(FileName) = False Then Exit Sub 　　 　　'全セル選択して書式を文字列にセットする 　　Cells.NumberFormatLocal = "@" 　　 　　'2行目から 　　Cnt = 1 　　 　　For Each v In FileName 　　　　'空いているファイル番号を取得 　　　　FileNo = FreeFile() 　　　　 　　　　'ファイルを開いてbufに1行読み込み 　　　　' → タブで配列に分割 　　　　' → セルに書き出し 　　　　Open v For Input As #FileNo 　　　　'1行目不要 　　　　Line Input #FileNo, Buf 　　　　 　　　　Do Until EOF(FileNo) 　　　　　　Line Input #FileNo, Buf 　　　　　　Cnt = Cnt + 1 　　　　　　SplitString = Split(Buf, vbTab) 　　　　　　For i = 0 To UBound(SplitString) 　　　　　　　　Cells(Cnt, i + 1) = SplitString(i) 　　　　　　Next i 　　　　Loop 　　　　 　　　　Close #FileNo 　　Next End Sub で。
"&R"を一個だけにしてみてください。2013だとこれでうまくいきました。 "&R" & fild1 & fild2 & vbCr & filename1 & "&A"
原本シートと同じものをひな形という名前で作成してください。 ボタンのマクロに以下のコードを割り当ててください。 Sub Example() Dim MySheetName As String MySheetName = InputBox("シート名を入力してください") Sheets("原本シート").Copy After:=Sheets(Worksheets.Count) ActiveSheet.Name = MySheetName Sheets("ひな形").Range("A1:G20").Copy Sheets("原本シート").Range("A1") End Sub Sheets("ひな形").Range("A1:G20") この範囲は実際にもとの原稿となる部分をA1基準で指定してください。
＞→★質問１ 値はりつけしただけなのに正しく集計されないのですがなぜでしょうか？式が誤っているのでしょうか？ 数値に端数があり、合計が合わないということなら、数値セルをROUND関数で数値の端数が無いように処理するだけです。 セルの書式設定でセルの書式を「標準」にして端数セルがないか確認してください。 その２：（1）(4)シートのSUMIFで金額が一部集計されないもの（端数ではない）がまれにある。 →★質問２ 例えば(1)シートの入力の際に手入力でなくて一部他データより値はりつけしたから（文字列になっている？）というのは考えられますか？ 対処方法や見つけ方はありますか？ 基本的に検索値が違っている、あるいは集計対象セルに文字列の数字が混ざっていることが考えられます。 検索値については、オートフィルタなどをかけて同じように見えて異なるデータがないか確認してください。 集計対象セルに文字列数字がある場合は、セルの数字が左寄せになっているので見分けることができますが、たとえば「=CELL("type",A2)」のような数式を入力してそのセルが「v」ではなく「l」が返るセルがないか調べてください。 ★質問３ VLOOKUPの式はそのまま残しておく（値はりつけせずに算式のまま）と正しく集計されないとか不便な点はありますか？注文番号を次々に追加して式は残しておきたいんですが…。 数式を残しておきたいなら、コピー元のシートを参照する数式にするだけでご希望の処理ができます。 ★質問４ （2）ファイルの(1)、(2)ファイルの全体の金額合計は見た目上検算（SUM）でも合っていたのですが、文字列はりつけ分があると、その金額を用いた他の時間集計とかで正しく集計されないとかあり得ますでしょうか？ 基本的に文字列貼り付けを行ったからといって正しく集計されないということはありません。 ただし、時間（小数点を含む数字）を演算すると丸め誤差が出て、集計方法（以下や以上などの条件）では正しく判定できないことがあります。 この場合は、手入力データと同じようになるように数式処理する必要があり８ます。 ★質問５ VLOOKUPを使う以外に同様の作業（注文番号だけ入力したら、他の情報を自動で出てくる）ができる単純な方法などがあれば教えてください。 基本的にVLOOKUP関数が最も簡単で分かりよい関数です。 ＃質問内容全体にいえることですが、数式の誤りなどがあるようなパターンに思われます。 このような質問では、１つのスレッドにいくつもの質問をするのではなく、ポイントを絞って、実際に期待しない集計値が出る数式を具体的に例示されたほうが解決が早いと思います。
>同じシートがエクセルでは作れなかったので >名前＋日付にしました という事は、例えば、 A列　　B列　　C列 1日　月曜日　Aさん8月1日 2日　火曜日　Aさん8月2日 3日　水曜日　Aさん8月3日 というデータが入力されていた場合、 Aさん8月1日 Aさん8月2日 Aさん8月3日 という「日付も含めたC列の値」と同じシート名を持つシートを(上記の例では3枚)新たに作成する様にしたいという事であって、 「『Aさん』という『C列の値から日付を除いた部分』と同じ名称のシート名を持つシートを『名前』部分の種類の数(上記の例では1枚)だけ作成する様にしたい」という事ではないと考えれば宜しいのでしょうか？ 　それでしたら下記のVBAマクロは如何でしょうか。 　下記のマクロはC2～C15のセル範囲に"表示"されている値と同じシート名を持つシートを新たに作成するマクロです。 　尚、C2～C15のセル範囲に表示されている値の中に、もし既に存在しているシート名と同じものがあった場合には、その値と同じシート名のシートを新たに設ける事はせず、代わりにその値が表示されているセルの値を、頭に青色の文字で「[既存] 」という文字列を付け加えた値に書き換える事で、その値と同じ名前のシートは既に存在しているという事が区別出来る様になっています。 　又、C2～C15のセル範囲に表示されている値の中に、もしシート名として使用する事が出来ない文字が含まれていた場合には、その値と同じシート名のシートを新たに設ける事はせず、代わりにその値が表示されているセルの値を、頭に赤色の文字で「[不可] 」という文字列を付け加えた値に書き換える事で、その値はシート名として使用する事が出来ないものであるという事が判る様になっています。 Sub QNo9220067_エクセル_シート自動作成() Dim mySheet As Worksheet, myRange As Range, Pseudonym As String _ , buf As Variant, c As Range Set myRange = Range("C2:C15") Pseudonym = String(30, 1) With WorksheetFunction If .Count(myRange) + .CountIf(myRange, "*?") = 0 Then MsgBox "シート名に反映するためのデータがありません。" & vbCrLf _ & "マクロを終了します。", vbExclamation, "データ無し" Exit Sub End If End With Set mySheet = ActiveSheet With Application .ScreenUpdating = False .Calculation = xlManual .DisplayAlerts = False End With For Each c In Range("C2:C15") buf = c.Value If Not (c.Value = "" Or _ Left(buf, 5) = "[不可] " Or Left(buf, 5) = "[既存] ") Then If IsError(Evaluate("ROW('" & buf & "'!A1)")) Then If IsError(Evaluate("ROW('" & Pseudonym & "'!A1)")) Then Sheets.Add After:=Sheets(Sheets.Count) Sheets(Sheets.Count).Name = Pseudonym End If '3 On Error Resume Next Sheets(Pseudonym).Name = buf On Error GoTo 0 If IsError(Evaluate("ROW('" & buf & "'!A1)")) Then c.Value = "[不可] " & Format(buf, c.NumberFormatLocal) With c.Characters(Start:=1, Length:=4).Font .FontStyle = "太字" .Color = RGB(255, 0, 0) End With End If Else c.Value = "[既存] " & Format(buf, c.NumberFormatLocal) With c.Characters(Start:=1, Length:=4).Font .FontStyle = "太字" .Color = RGB(0, 0, 255) End With End If End If Next c If Not IsError(Evaluate("ROW('" & Pseudonym & "'!A1)")) Then _ Sheets(Pseudonym).Delete mySheet.Activate With Application .Calculation = xlAutomatic .ScreenUpdating = True .DisplayAlerts = True End With End Sub 　尚、例え日付部分の桁数が一定でなかったとしましても、「名前」部分の末尾が数字になっているものがない場合には、「名前」部分と「日付」部分を分離する方法はありますので、もしも「『Aさん』という『C列の値から日付を除いた部分』と同じ名称のシート名を持つシートを『名前』部分の種類の数(上記の「Aさん」の例では1枚)だけ作成する様にしたいという場合には、補足欄かお礼欄を使用してその旨をお伝え下さい。 　後それから、 >年と月を入れた際に自動的にシート作成されるようにしたい という事をVBAのマクロを使って実現する方法も一応ありますが、ボタンを使わずに値を入力しただけでシートが作成される様にしてしまった場合、値を間違えて入力してしまったり、セルに入力している途中でうっかりEnterキーを押してしまったり、セルに入力している途中でうっかり別のセルをクリックしてしまったりするたびに、不要なシートが次々と作成されてしまう事になり、間違いの原因になりかねませんし、使い勝手も悪くなります。 　ですから、値を入力しただけで自動的にシート作成される様になる方法はお勧めしません。
同じような質問が他の方からも出てますがどこかの練習問題なのでしょうか・・・ Sub Example() Dim MyColumn As Long, MyLastRow As Long On Error Resume Next With Sheets("Sheet1") Range(Cells(4, "K"), Cells(100, "K")).Clear '↑100はデータが最大となるであろう最終行を指定 MyColumn = WorksheetFunction.Match(.Range("K1").Value2, .Range("3:3"), 0) '↑もしくはws2.Range("C1").Value2をws2.Range("C1")に MyLastRow = .Cells(Rows.Count, MyColumn).End(xlUp).Row .Range(Cells(MyLastRow, MyColumn), Cells(4, MyColumn)).Copy .Range("K4") End With End Sub
> 例えば、1月売上→2016/1/20　と直した場合 Sheet1,Sheet2のどちらを直したのかわからないので、3パターン記載しておきます。 'Sheet2もSheet1も2016/2/20など同じ日付 Sub Example() Dim MyColumn As Long Dim ws1 As Worksheet, ws2 As Worksheet On Error Resume Next Set ws1 = Sheets("Sheet1") Set ws2 = Sheets("Sheet2") MyColumn = WorksheetFunction.Match(ws2.Range("C1").Value2, ws1.Range("1:1"), 0) '↑もしくはws2.Range("C1").Value2をws2.Range("C1")に ws1.Cells(1, MyColumn).Resize(11, 1).Copy ws2.Range("B1") Set ws1 = Nothing Set ws2 = Nothing End Sub 'Sheet2が○月売上Sheet1が2016/2/20など日付 Sub Example2() Dim MyLastColumn As Long Dim ws1 As Worksheet, ws2 As Worksheet Dim SearchStr As String Dim c As Range Set ws1 = Sheets("Sheet1") Set ws2 = Sheets("Sheet2") SearchStr = Left(ws2.Range("C1").Value, InStr(ws2.Range("C1").Value, "月") - 1) 'Sheet2が2016/2/20など日付Sheet1が○月売上の場合は 'SearchStr = Month(ws2.Range("C1").Value) & "月売上" With ws1 MyLastColumn = .Cells(1, Columns.Count).End(xlToLeft).Column For Each c In .Range(.Cells(1, "B"), .Cells(1, MyLastColumn)) If Month(c.Value) = SearchStr Then 'Sheet2が2016/2/20など日付Sheet1が○月売上の場合は 'If c.Value = SearchStr Then .Cells(1, c.Column).Resize(11, 1).Copy ws2.Range("B1") Exit For End If Next End With Set ws1 = Nothing Set ws2 = Nothing End Sub
東京は必ず集計シートのA2から始まる 集計シートのA2以下にはデータがない それぞれのシートで各列の最終行はA列の最下行より下にはない という条件で 以下をすべてコピペして、ボタンのマクロに以下のExampleを関連付けてください。 Sub Example() Application.ScreenUpdating = False DataCopyPast ("東京") DataCopyPast ("大阪") DataCopyPast ("名古屋") Sheets("集計").Activate Application.CutCopyMode = False Application.ScreenUpdating = True End Sub Sub DataCopyPast(ByVal MyShName As String) Dim MyLastRow As Long With Sheets(MyShName) .Activate MyLastRow = .Cells(Rows.Count, "A").End(xlUp).Row .Range(.Cells(2, "A"), .Cells(MyLastRow, "BI")).Copy If MyShName = "東京" Then MyLastRow = 1 Else MyLastRow = Sheets("集計").Cells(Rows.Count, "A").End(xlUp).Row End If Sheets("集計").Cells(MyLastRow + 1, "A").PasteSpecial Paste:=xlPasteValues End With End Sub
>表示するコードを教えてもらい画像のように作成できることができたのですが マクロじゃないので「コード」ではなく「数式」です。 A2セルの数式内で使用している ROW($A$1:$A$31) を可変にすることで対応します。 ROW($A$1:$A$31) 　　　　↓ ROW(OFFSET($A$1,0,0,DAY(EOMONTH(($A$1&$B$1&"1日")*1,0)))) または ROW(INDIRECT("$a$1:$a$"&DAY(EOMONTH(($A$1&$B$1&"1日")*1,0)))) 従って、A2セルの数式を次のように修正します。 =IFERROR(INDEX(($A$1&$B$1&"1日")*1+ROW($A$1:$A$31)-1,SMALL(INDEX(MOD(WEEKDAY(($A$1&$B$1&"1日")*1+ROW(OFFSET($A$1,0,0,DAY(EOMONTH(($A$1&$B$1&"1日")*1,0))))-1,1),2)*50+ROW(OFFSET($A$1,0,0,DAY(EOMONTH(($A$1&$B$1&"1日")*1,0)))),0),ROW(A1))),"") または =IFERROR(INDEX(($A$1&$B$1&"1日")*1+ROW($A$1:$A$31)-1,SMALL(INDEX(MOD(WEEKDAY(($A$1&$B$1&"1日")*1+ROW(INDIRECT("$a$1:$a$"&DAY(EOMONTH(($A$1&$B$1&"1日")*1,0))))-1,1),2)*50+ROW(INDIRECT("$a$1:$a$"&DAY(EOMONTH(($A$1&$B$1&"1日")*1,0)))),0),ROW(A1))),"") 尚、外側のINDEX関数の範囲（($A$1&$B$1&"1日")*1+ROW($A$1:$A$31)-1）のROW関数については変更なしでも不都合は起らないはずです。
　御質問文中に添付されているURLのページの回答No.1の方法を試してみましたが、セルの選択範囲とは関係なく、(選択されていないセル範囲のものも含めて)シート内に引かれている全ての罫線の内、色の設定が[自動]となっている線の全てが、同色になってしまい、色を変更する線としない線を分けて色を変える事は出来ませんでした。 　その上、色が変わるのは罫線のみではなく、罫線が引かれていないセルの枠線(通常であれば薄い灰色で表示されている線)までもが罫線と同色の点線に変更されてしまい、モニター上で見た際の見た目が気持ち悪くなりました。 　ですから、御質問文中に添付されているURLのページの回答No.1の方法は、特定のセル範囲内の罫線のみを変更する事は出来ません。 　もし、太さや線種がそれぞれ異なっている罫線の色を"一気に"変更したいという事であれば、マクロを使うしかないのではないかと思います。
こんにちは、また間違えてしまいました。 .Offset(, -1).Resize(j - 6, 1).Value = ws.Name '←この列 に変更してみて下さい。
C4(C14)の式だけでなく、B4(B14)の式も変化してませんか？ =IF(B2="","",SUM(B2:B3))　⇒　=IF(C2="","",SUM(B2:B3)) それが答えです。セルの挿入・削除やドラッグ&ドロップによるセル移動は、 数式の中のセル座標も変化することがあります。 特に削除されたセルやドロップ先のセルは消滅したとして、#REF!という値に置換わります。 前の回答者も書いてますけど、コピーで値を移して、元の値をクリアしてください。
ハイパーリンクを設定した文字列に常にアンダーラインをつけないという 場合は、以下のように操作して設定し、テンプレートとして保存しておかれ たらよいでしょう。 1.[ホーム]タブ[スタイル]グループの[セルのスタイル]から[新しいセルの 　スタイル(N)]をクリックします。 2.表示される[スタイル]ダイアログで、スタイル名として「ハイパーリンク」 　と入力し、[書式設定]ボタンをクリックします。 3.新たに表示される[セルの書式設定]ダイアログの[フォント]タブを開いて、 　文字色を指定します。 　下線はデフォルトで"なし"になっていますので、そのまま[ＯＫ]します。 4.[ホーム]タブ[スタイル]グループの[セルのスタイル]に戻り、追加された 　"ハイパーリンク" を右クリックし、[適用]をクリックします。 5.再度、[ホーム]タブ[スタイル]グループ[セルのスタイル]の、"ハイパー 　リンク" を右クリックし、今度は[複製]をクリックします。 6.表示される[スタイル]ダイアログで、スタイル名として「表示済みのハイ 　パーリンク」と入力し、任意のフォント色を指定して[ＯＫ]します。
ActiveSheetのB1の値がBだと文字の色が赤になる という動作をしますが、何がうまくいかないのでしょう?
> ３列重複行の削除の方法（VBA,関数）はわかりませんか？ Excel2007以降でしたら以下のコードになります コピー貼り付け後、表ー2をアクティブな状態にして ActiveSheet.Range("$C$4:$E$15").RemoveDuplicates Columns:=Array(1, 2, 3), Header:=xlNo Excel2003まで含むと以下になります。こちらの場合、範囲は見出し行も操作対象になります。また、重複を除いたデータを貼り付けますので先にコピー貼り付けは不要です Sheets("表ー1").Range("$B$3:$D$15").AdvancedFilter _ Action:=xlFilterCopy, _ CopyToRange:=Sheets("表ー2").Range("$C$3"), _ Unique:=True
[縮小版を保存]　エクスプローラー上でアイコンの変わりに縮小版画像が表示されます。 [フォルダーの非表示]　ファイル名のパス（ファイルのあるフォルダ名）が非表示になります。 [タグの追加]　PC上で検索するときの項目の追加 [タイトルの追加]　ファイル名とは別に、タイトルを設定できます。 ※タイトル、タグ（キーワード）、他はファイルのプロパティに記録されます。 Excel2007以降だと[ファイル][情報]からプロパティの設定が出来ます。 それ以前は、[ファイル][プロパティの表示]で行ってました。
Sheet2のD3に =IFERROR(INDEX(Sheet1!$B$5:$Q$11,MATCH($B3,Sheet1!$B$5:$B$8,0),MATCH(LEFT($C3,FIND("度",$C3,1)),Sheet1!$F$3:$Q$3,0)+COLUMN(E:E)-1),"") Sheet３のB3に =IFERROR(IF(INDEX(Sheet1!$B$5:$Q$11,ROW(1:1),MATCH(LEFT($A$3,FIND("度",$A$3,1)),Sheet1!$F$3:$Q$3,0)+COLUMN(F:F)-1)>0,INDEX(Sheet1!$B$5:$B$11,ROW(1:1),1),""),"") として下方向に必要なだけコピーしてください。高校名は上から順に詰まっているものと考えています(歯抜けのようにとびとびで入力されていない状態)詰まっていないと間が空いて表示されます。 Sheet３のC3に =IFERROR(INDEX(Sheet1!$B$5:$Q$11,MATCH($B3,Sheet1!$B$5:$B$11,0),MATCH(LEFT($A$3,FIND("度",$A$3,1)),Sheet1!$F$3:$Q$3,0)+COLUMN(E:E)-1),"") としてF列までと下まで必要なだけコピーしてください。 なお、体験授業参加人数については3月4月5月のどれを表示するのか不明なので対応していません。
>ランダムに数値が入っていて、1行ごとに＋－4.0の範囲に入る数値について色を塗るか、 条件付き書式でセルの塗りつぶしを定義すれば可能です。 添付画像の範囲であれば条件を次の数式で指定すればよいでしょう。 選択範囲をA1:F6として =SUMPRODUCT((A1<=($A1:$F1+4))*(A1>=($A1:$F1-4)))>1 >関数で追加列に該当する個数を示すとか、 G列へ各行の条件合致セル数を算出するときは次の数式で良いでしょう。 G1へ次の数式を入力して下へG6セルまでコピーします。 =SUM((MMULT((A1:F1>=(TRANSPOSE(A1:F1)-4))*(A1:F1<=(TRANSPOSE(A1:F1)+4)),{1;1;1;1;1;1})>1)*1) この数式は配列計算が含まれていますので確定時にCtrl+Shift+Enterの打鍵が必要です。 添付画像はExcel 2013で検証した結果です。 正しく処理されているか否かを目視で確認してください。
＞エクセルのグラフを画像として保存する方法は無いのでしょうか？ 他の方の回答通り方法はいろいろあります。 フリーのキャプチャーソフトもたくさんあります。 ポイントは、保存した画像をどうするのかによります。 １．同じエクセルに貼り付けて利用する。→Ｎｏ２さんの方法が、簡単、ベスト。 ２．図として保存後、他のソフトで使用する。→Ｎｏ１さんの「Snipping Tool」を使った　　　キャプチャー方法」が、Windows標準で、簡単、安全、お薦め。 ３．図（ｊｐｅｇ、ｐｎｇ、ｇｉｆ等選べる）なのでキャプチャー後も編集できるし、　　　　ＵＳＢメモリに入れ　　て、他の方に活用してもらうこともできます。 ４．「Snipping Tool」を一押しします。 　　これを使いこなすと、ＰＣライフが楽しく、豊かになること請け合います。 　　画面に表示されているものすべてが、画像として保存できます。 ５．右クリックでの、サブウインドさえキャプチャーできます。 　　他のソフト、アプリではかなり困難ですよ。 詳しい説明はこちらで。http://nelog.jp/snipping-tool
こんにちは 元表の右側の空いている部分（例えばセルL1:O1）に 月　部　氏名　クラスと項目名をコピーして、フィルタオプションで重複なしの データを抽出して、ピボットテーブルのデータソースの変更でL:O列のデータ範囲 を指定すれば出来ます。
》 そのコラム内に含まれる全項目を列挙したリストを作成するには、 １．該当するコラム(列)全体を[コピー]して、何処かの空き列に[貼り付け] ２．[貼り付け]た列全体を選択 ３．[データ]⇒[データツール <重複の削除>] ４．“先頭行をデータの見出しとして使用する”にチェック入れて[OK]をパシーッ で如何かと。
Sheet2のB2に =SUMIF(Sheet1!B:B,A2,Sheet1!D:D) って書いて、下にコピー。
>グループ化した図は画像のような画面は出ないのでしょうか？ 対象の図を選択すれば出ますよ。 あなたが操作している状態をもう少し広い範囲で提示されると良いでしょう。 添付画像はRio2016とトーチのクリップアートをグループ化した状態です。 グループ化した個々のクリップアート選択でも「図ツール」の「書式」タブでサイズ変更ができます。 あなたのExcel 2010で出ないのであればOffice 2010の一部が損傷していると思いますので「コントロールパネル」の「プログラムのアンインストール」からOffice 2010の修復を実行してください。 それでも直らないときはOffice 2010をアンインストールしてWindowsを再起動後に再インストールされると良いでしょう。 Officeの再インストールで保存されたデータは影響を受けないはずです。
こんにちは Sub test1() 　　Dim q As Range 　　Dim d As Object 　　Dim r As Range 　　Dim w As String 　　Dim v() 　　 　　Set q = Range("A1").CurrentRegion.Columns(1).Cells 　　Set d = CreateObject("Scripting.Dictionary") 　　 　　If q.Count = 1 Then Exit Sub 　　　　 　　For Each r In q 　　　　If r.Row > 1 Then 　　　　　　w = r.Value & "," & r.Offset(, 1).Value 　　　　　　If Not d.exists(w) Then 　　　　　　　　d(w) = r.Offset(, 2).Value 　　　　　　Else 　　　　　　　　d(w) = d(w) & "," & r.Offset(, 2).Value 　　　　　　End If 　　　　End If 　　Next 　　Application.ScreenUpdating = False 　　Range("E2").Resize(d.Count, 1) = WorksheetFunction.Transpose(d.keys) 　　Range("E2").Resize(d.Count, 1).TextToColumns Destination:=Range("E2"), DataType:=xlDelimited, _ 　　　　TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=False, Tab:=True, _ 　　　　Semicolon:=False, Comma:=True, Space:=False, Other:=False, FieldInfo _ 　　　　:=Array(Array(1, 1), Array(2, 1)), TrailingMinusNumbers:=True 　　Range("G2").Resize(d.Count) = WorksheetFunction.Transpose(d.Items) 　　Application.ScreenUpdating = True End Sub こんな感じも。
>Excel 2013 では左下部に SCROLLLOCK は表示されますが、 そこにカーソルを合わせて右クリックしてください。 「ステータスバーのユーザー設定」というメニューが出て、 表示する内容をチェック（クリック）でOn/Offできます。 下記はEXCEL2010のものですが、2013でも同じです。 ・ステータスバーの表示項目を設定する方法　 http://kokodane.com/2010/status.htm
入力規則の元の値は1000,2000としておいて 書式の設定の表示形式で #,##0"円" として、表示を1,000円などにした方がいいのではないでしょうか。 規則などでデータそのものに円とかつけると計算ができなくなります。
#4です。 無駄な気もするが、興味のある他の人も見ておれば役に立つかもと思って、上げてみる。 ーー やり方として小生は、３つを思いついた。 （１）ＨｙｐｅｒＬｉｎｋ利用法ー＞　初めの質問には、この方法を指定あり。すでに締め切り済み。 （２）コマンドボタン利用法 （３）シートのセル選択イベント利用法。 ーー （３）でやってみる。ＶＢＡコードが一番少なそうなので。 ただ応用したり不都合が出たときの対処法はＶＢＡの経験が必要で、 誰でもできるわけではない。 ーー 例として、シートを４つ用意する。 １つは目次シートです。 他シートは、目次シートで選んだ項目の詳細データのある シートで、複数あるシートです。 ーー 「目」シートのセルの値は、あらかじめ 目次　　＜－Ｂ１セル 東京　　　　＜－Ａ３セル　 神奈川　　　　＜ーＡ５セル 千葉　　　　＜－Ａ７セル にします。「ボタン」風らしく、セルの塗りつぶし色を付けておくのも良いと思う。 ーー シートの名前を、「シート名」の変更操作で、ここでは東京、神奈川、千葉にします。 （ＶＢＡでもできなスが） 各シートのＡ１セルには「メニューへ戻る」とセル野値を入れます。 ボタン替わりです。 -- そして目次シート以外を非表示にします。(ＶＢＡでも、１回の手操作でもできます。 ーー ＶＢＡ関連 （１）Ｓｈｅｅｔ１（目次）のセル選択変更イベントに Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Address = "$A$3" Or Target.Address = "$A$5" Or Target.Address = "$A$7" Then Worksheets(Target.Value).Visible = True Worksheets(Target.Value).Select Else End If End Sub （２）Ｓｈｅｅｔ２（東京）のセル選択変更イベントに Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Address = "$A$1" Then ActiveSheet.Visible =False Worksheets("目次").Activate End If End Sub （３）Ｓｈｅｅｔ３（神奈川）のセル選択変更イベントに Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Target.Address = "$A$1" Then ActiveSheet.Visible = False Worksheets("目次").Activate End If End Sub （４）Ｓｈｅｅｔ３（千葉）のセル選択変更イベントに （３）と同様なのでここへ記述略。 同じコードをコピペすること。 ＝＝ このコードの欠点は、上記の東京などの選択肢が増えると、同じ（似た）コードを その数だけ作っておかないといけない。 これはＨｙｐｅｒＬｉｎｋ法でも、コマンドボタン法でも同じ。 これを１か所のコードですます方法はあるが、「クラス」というものなどの上級の 知識が要るので難しい。シコシコとシートの数だけコピー貼り付けをするほかない。
同じようなことを２度にわたって質問しているが、意味は分からない。 コード例も自分で挙げており、大筋間違っていないと思う。 見出し行を計算に加えていた凡ミスなを除き。 どういう点を疑問に思ったとか、失敗するのでしょうか？ （１）スタート（B、C列）、エンド（D,E列）とも日＋時刻を足して、日付つき時刻を作り、相互から引き算して、時間（間隔）を出す。 （２）For　Nextで各行の上記算出した時間を累積していく。 （３）累積したままの時間数（通常２４時間を超えるはず）でよければ、セルの書式は[h]:mmでよい。 時刻は普通は日付が決まってこその時刻なので、日付と組みあわせた時刻でしょう。 それが（１）の足す（結合する）理由で、単純に足してよいのは次の理由からです。 Excelは日付＋時刻を「日付・時刻シリアル値」という表し方で、日付・時刻計算を、引き算だけで、簡単にできるようにしたアイデアを採用している。日付は整数部分、時刻は小数点数（２４時間を１とした、に対する割合）で表される。筆算の場合の、日の単位から、１日２４時間を借りてくるようなことが必要な場合があるが、それがなくなる。 これをVBAまで使い始めた人でも、知らない人が多いようだが、Googleででも、「日付シリアル値で」照会し、記事をよく理解すべきです。
エクセルはごぞごぞしてるとたまに挙動がおかしくなることがあります。通常は再起動で直るのですが、直らない場合Officeの修復を実行してみると直ることがあります。 Office2010の修復 https://support.microsoft.com/ja-jp/kb/2179287
》 「13568」と連続で入力して、COUNTIFで「1」を指定すればいいか 》 と思ったら、ダメでした。セルの設定を文字列にしてもダメなの 》 ですね。 仰っていることがヨー分からんのだけど、文字列の数字列があったとき、１から９までの各数字が幾つ含まれるかが分かれば良いのなら、添付図に示した方法も一興かと。 B2: =LEN($A2)-LEN(SUBSTITUTE($A2,B$1,""))
VBでは、シフトJIS コードを使っております。 CHR(&H30) は"0" になり、 CHR(&H8940)は”院"になります。 シフトJIS コードは１バイト文字と２バイト文字を切り替えコートなしで混在させることを目的としております。 &H00～&7F,&HA0～&HDFが１バイト文字とみなされるので、これで始まる２バイト文字はありません。 また、他にも空きがあります。 シフトJIS コードで、文字の定義されていないところは出てきません。 また、UTF8に出てくる特殊文字も、VBでは使えません。 次のよなプログラムだとわかりやすいと思います。 ’ Sub Sample1() 　　Dim i As Long 　　Dim j As Integer 　　Dim myRow As Long 　　For i = -32768 To 32767 　　　　myRow = myRow + 1 　　　　j = i 　　　　Cells(myRow, 1) = Chr(i) 　　　　Cells(myRow, 2) = "'" & Hex(j) 　　Next i End Sub
こんにちは ドライブの直下だった場合を考慮すると、 Sub test() 　　Dim p As String 　　p = Dir(ThisWorkbook.Path, vbDirectory) 　　If InStr(1, ThisWorkbook.Path, p) = 0 Then 　　　　MsgBox ThisWorkbook.Path 　　Else 　　　　MsgBox p 　　End If End Sub の方がいいかも。
データ例が質問に載せてないので、簡略化した。 （この点が、回答者のテストをするために、時間がかかることを認識してくれてない質問がほとんどで、困る。） Ｅ，Ｈ列のみデータを入れて手抜き。 abcdefgh a2　0　本委託 a3　0　本委託 a4　1　仮委託 a5　0　本委託 a6　2　部門 a7　1　本委託 a8　0　本委託 １８列ーー＞８列、１５列ーー＞５列にしてやってみた。 Sub test01() Set ws1 = Worksheets("Sheet1") Set ws2 = Worksheets("Sheet2") ws1.Activate ws1.Cells.AutoFilter ws1.Rows("1:1").AutoFilter Field:=8, Criteria1:="=*委託*", Operator:=xlAnd ws1.Rows("1:1").AutoFilter Field:=5, Criteria1:="=0", Operator:=xlAnd If Cells(Rows.Count, 1).End(xlUp).Row = 1 Then MsgBox "0件です" '<--コピーしない Else MsgBox Range(Range("A2"), Cells(Rows.Count, 1).End(xlUp)) _ .SpecialCells(xlCellTypeVisible).Count & "件です" 'コピー j = 1 For Each c In ActiveSheet.AutoFilter.Range.Columns(1).SpecialCells(xlCellTypeVisible) MsgBox "表示されているデータの行番号は" & c.Row & "です。" ws1.Rows(c.Row).Copy ws2.Cells(j, "A") j = j + 1 Next c End If End Sub 該当件数はhttps://www.moug.net/tech/exvba/0150043.htmlなどに載っているよ。 条件を変えて２度目以降のフィルタを行い、Ｓｈｅｅｔ２に累積する場合は、ＷＳ１の見出し行を、ダブってＷＳ２に持って行かないようにコードに注意（今回略）。
正しい方法かどうか分かりませんが、 ユーザー定義の箇所で、 >・「100」と入力➡自動で「No.100」と表示 　　"No."G/標準 >・「1」と入力➡自動で「1回」と表示 　　G/標準 "回" ってやったら、うまく表示されました。 なので、才やkgも同様にやればよいかと思います。
数値でいけるのでしたら、書式設定の表示形式をユーザー設定にして00000000000000といった感じで必要な桁数だけ0で設定すると00000000000001というように表示上はなります。実際のデータは1です。
列Ａ～Ｆのデータが全て文字列なら G1: =OFFSET(A$1,(ROW(A1)-1)/6,MOD(ROW(A1)-1,6))&"" で、カンタン？ 【お願ひ】 「F１００」のデータは、セル G600 で終わっちゃうけど、貴方が「G１００００」としたのは出鱈目でしたか？ 真面目な回答者を惑わせないでください！
質問者はVBA熟達の人と思われないのに、FINDに ・２種類あること ・みつかったかどうか、の判定の仕方を、 解説書やWEBで勉強して質問していますか？ 安易に自分の気の向くままに他類似と思ったケースとのるいす類推などで、コードを書いていないか。この能力・態度も大切だが、役立たない場合も相当多い。 ーー エクセル関数のFIND関数は文字列の中でどの位置にあるかを探す関数です。 むしろ、BasicのINSTR関数と似ている．だからあまり使われないかもと思う。 エクセルの関数のFINDでは A1セルの値が「大阪市北区芝田町」の時、=FIND("芝田",A1)　　は6 を返します。 VBAで Sub test01() x = Application.WorksheetFunction.Find("芝田町", Range("A1")) MsgBox x End Sub でも　6 を返します。 ーー 一方エクセルVBAのFindメソッドは セルB1:B５に（すなわちセル群のどのセルにあるかを見る、ので前記とは違う） 柴田町 芝田町 稲荷町 門前 東田上 の時 Sub test02() x = Range("B1:B5").Find("芝田町").Row MsgBox x End Sub は(2)行目のセルを指します。 基本的な機能が違います。 ーー 下記のベストアンサーをよく読んでください http://oshiete.goo.ne.jp/qa/8008851.html ーー エラーの対処は （１）Ｆｉｎｄ関数 Sub test031() x = Application.WorksheetFunction.Find("芝田町", Range("A2")) MsgBox x End Sub でエラーが起こる場合は Sub test03() On Error GoTo err1 x = Application.WorksheetFunction.Find("芝田町", Range("A2")) MsgBox x err1: MsgBox "FIND関数で検索語が見つかりません" Exit Sub End Sub 状況上、回復続行はむつかしいと思うが、どう処理するかは場合による。 （２）Ｆｉｎｄメソッド 例は http://excel-ubara.com/excelvba1/EXCELVBA398.html Set rngFind = Range("A1:B100").Find(What:="A", _ 　　　　　　　　　　　　　　LookIn:=xlValues, _ 　　　　　　　　　　　　　　LookAt:=xlPart, _ 　　　　　　　　　　　　　　SearchOrder:=xlByColumns, _ 　　　　　　　　　　　　　　SearchDirection:=xlNext, _ 　　　　　　　　　　　　　　MatchCase:=False, _ 　　　　　　　　　　　　　　MatchByte:=False) If Not rngFind Is Nothing Then 　　MsgBox "見つかった" & vbLf & rngFind.Address Else MsgBox "見つかりません" & vbLf & ”次の検索語を検索します。」 End If のようなはんていをします。
こんばんは、No1です No2さんの回答を範囲を広げるだけで、 数式バーに =IF(MATCH("異常値",A2:A100000)=0,"異常なし",MAX(IF(A2:A100000="異常値",ROW(A2:A100000),""))&"行目") と入力して、Ctrl+Shift+Enter で確定（配列数式として入力）すればいいです。
A1=顧客名 B1=振込銀行 C1=請求金額 D1=振込金額（請求金額－銀行手数料） E1=銀行手数料 F1=手数料判定（判定用：口座や金額から手数料を決定。） となっているとして G1に判定用のセルを設けて当方負担と記載する場合 D1に =IF(G1="当方負担",C1,C1-E1) もしくは、当方負担顧客一覧表を作成し 顧客名を縦方向に A社 B社 C社 のように作成。完全一致なので少しでも違うと正しい結果が得られません。 D1に =IF(IF(ISERROR(VLOOKUP(A1,当方負担顧客一覧表範囲,1,FALSE)),FALSE,TRUE),C1,C1-E1) この場合、顧客が負担かどうかその場で見えないため、当方負担顧客一覧表の保守が大事になります。 また、冗長になりますが G1に =IF(ISERROR(VLOOKUP(A1,当方負担顧客一覧表範囲,1,FALSE)),"","当方負担") D1に =IF(G1="当方負担",C1,C1-E1) としておけば、当方負担顧客一覧表で抜けていないかどうかその場で確認できるようにはなります。
こんにちは。 > ... リンクをクリックして画面の一部の情報を更新 ... > ... 画面が更新されアドレスも末尾が変化したにもかかわらず ... ページの遷移が正しく実行され、 URLも変化する、ということでしたら、 Document.URLが更新されるまで、待機を掛けて、同期を図る、 という風にしてみては如何でしょう。 例えば、 　　h = objDocument.URL 　　' "リンクをクリック"する処理 　　Do 　　　　DoEvents　'　またはWin32 API のSleep関数 　　Loop While objDocument.URL = h 　　DoEvents 　　' "その部分からテキストを取得" みたいな。 HTMLDocumentオブジェクトの遷移後の更新（同期）に掛かる時間に差が出る、 という問題の原因については、 必ずしもOSやOfficeのバージョンの違いだけではなくて、 IEのバージョン、通信環境、PCのスペック、等の影響も受けます。 OSについていえば、Win7以前ではHTML5に非対応、 ということが問題になることも、最近話題に上ることが増えています。 勿論、詳しい状況を再現出来なければ、 確定的な断定を下せるものではありませんが。 上記のように、ループをさせながら待機する方法の他に、 　　Application.Wait DateAdd("s", 3, Now()) 一定の時間決め打ち的に（例では３秒）待機させることで、 済ますことを好む方もいます。 ここまで説明した方法でも、うまく同期がとれない場合は、 原因を特定する為の一時的な処置として、 現在お使いのソースそのまま、に対して、 　　「遷移後の」"その部分からテキストを取得" 処理の記述の直前行に 　　Debug.? objDocument.URL と書き込んで、 その行にブレークポイント（F9 キー）を設定してから 実行してみて下さい。 ブレークポイントの行でステップ（デバッグ）モードになって一時停止しますから、 そのまま数秒待って、F8 キーで、１行分だけステップ実行してみて下さい。 イミディエイトウィンドウ（Ctrl + G）に、 「遷移後のURL」が出力された場合は、 　　単にWaitが足りていないせいで同期がとれていなかった、 　　という現象を確認したことになります。 「遷移前のURL」が出力された場合は、 　　遷移後のHTMLDocumentを参照できていなかった、 　　つまり、オブジェクトの参照ミス、を確認したことになります。 　　（この場合、先に挙げたループは無限ループになります。 　　　いつまでも処理が終らない時はEsc キーで終了してください。） 　　IE上に「遷移前のページ」と「遷移後のページ」２つのタブ（またはウィンドウ） 　　が同時に表示されている筈ですから、 　　「遷移前のページ」を表示していたタブ（またはウィンドウ）に 　　「遷移後のページ」を表示するようにNavigete2等の処理を正すか、 　　「遷移後のページ」を表示するタブ（またはウィンドウ）配下のHTMLDocumentを 　　オブジェクトとして正しく捉え直すか、のどちらかの対応になります。 以上です。
No1です =SUMPRODUCT((C1:C100<=2)*(F1:T100=1)) C:Cといった書き方はできませんが、こちらだとこの式だけでいけます。
> "=COUNTIFS(wS2.Range("B7:B"&t),B5,wS2.Range("J5:J"&t),C5)" "=COUNTIFS(wS2.Range("が一個の文字列として認識されてその先に&もなしにB7:Bと続くのでエラーになります。 Formulaの場合、セルに書かれる式を文字列として渡さなければいけませんから、仮に途中に"がなかったとしても現状では上記の記述そのものがセルに書き込まれることになりますので、式としては成り立たなくなります。 以下のように変更でいかがでしょう。 Range(wS1.Cells(5, "D"), wS1.Cells(i, "D")).Formula = _ "=COUNTIFS(" & wS2.Name & "!B5:B" & t & ",B5," & wS2.Name & "!J5:J" & t & ",C5)" 直接計算結果をセルに表示してよろしければ、以下のようにCountIfs関数をVBAの中で利用する事もできます。 With wS2 wS1.Cells(i, "D") = _ WorksheetFunction.CountIfs(.Range(.Cells(5, "B"), .Cells(t, "B")), wS1.Cells(i, "B"), .Range(.Cells(5, "J"), .Cells(t, "J")), wS1.Cells(i, "C")) End With
SUSTITUTE関数は、特定の文字を別の文字に入れ替える関数です。 したがって、特定の文字を削除したいときは、""（長さゼロの文字列）に入れ替えることで可能です。 >例：仕事はサービス業（12350）　→　　仕事は12350 この例ですと、 　"サービス業（" 　"）" という二つの文字列を、"" に入れ替えることになります。 この場合は、 （「仕事はサービス業（12350）」という文字列がA1セルに入力されている場合） =SUBSTITUTE(SUBSTITUTE(A1,"サービス業（",""),"）","") という式で可能です。 ですが、他の例でも同じ文字列を削除したいのでしょうか？ 「ある3つの文字」というのが何を指しているのか、質問でははっきり分かりませんでした。 削除したい文字列が何なのか、具体例を示してもらえれば、もっと適切な回答が付くかも知れません。 例えば、SUBSTITUTE関数にこだわらず、MID関数やFIND関数などを組み合わせる方法も考えられます。
アップルユーザーなら、先ずはFileMakerを使って、できないところをExcelで、なんじゃない？ Keynoteを使っている人はよく見るけど、Numberを使っている人って私は見たことありません。 パソコンで、一太郎ユーザーが三四郎を使わないのと同じかも。 ただ、MacのNumberだと、書かれたことはできたと思うのですが、iPhoneでは違うのかな？ 例えば http://softhako.com/numbers/table-and-cell/background-cell/
VBAの話だよね。 またエクセルのはなしだよね。 基本は http://excelwork.info/excel/cellreplace/ などを読めばわかる。 Replaceはメソッドで、「１つのセルの値」についての機能。 セル単位に見つかったかどうか（Ｗｈａｔの方の指定）を調べるときに使える。 ワイルドカードにある文字そのものを１文字の文字として見てほしいときは （エスケープするという。ＳＱＬの処理系では￥を付けて区別するのが多いが） エクセルＶＢＡでは http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1240159837 のような記事がある。 http://stabucky.com/wp/archives/1841 チルダを使うようだ。 Findの例で、やってみた。 取り急ぎ、で第２該当分以降を探索するコードは省略している。 例データ　 Sheet1にＡ１：Ａ６　 aa asd a?tr af*dfg dd?kio ad*fkl ーー Sub test01() Worksheets("Sheet1").Select Dim x As Object Set x = Cells.Find("~?k") MsgBox x.Address End Sub Find("~?k")の、チルダの直後のところを、*や?など、直前や後続文字など いろいろ変えてやってみてください。 Replaceでもうまく行くかやってみてください。 質問していることが解決すればよいが。
Excelは表計算が主であり、印刷は二の次なのです。 図形に限らず、表そのものも印刷してみると、実寸は設定値には合致しません。 因みに、Excelの初期設定値が、用紙サイズがA4、上下余白が各19mm、フォントサイズが11ptの場合で高さ方向を考えてみましょう。 印刷可能範囲＝297－(19×2)＝259mm 11ptの場合の表示される行高さ＝13.5pt＝4.7625mm (1pt＝1/72インチ　1インチ＝25.4mmでの計算結果) よって、理論印刷可能行＝259÷4.7625＝54.3832行になります。 処が、プレビュー後の印刷可能範囲を点線表示させてみると、58行まで印刷可能になり、実際に印刷しても58行まで印刷されます。 そして、58行まで印刷された表全体の実高さは私のプリンタでは約255mmになります。 逆に、58行の表全体の理論高さは 13.5pt×58行÷72pt×25.4mm＝276.225mm になり、印刷可能範囲259mmをはみだしてしまいます。 上述のごとく、Excelでは上下余白を取ると、理論上54行しか入らないものを58行も入るようにして縮小しているのです。 従って、Excelにおいてどうしても実寸通りに印刷したければ、 概略108.3%（276.225÷255）位にしておかないとダメということになります。 実寸は、あなたのプリンターで確認してください。 なお、Wordにおいてはこのようなことはないようです。 Excelで100mm×100mmのものをWordにコピペして印刷すると実寸は 100mm×100mmになります。
マクロで、という指定している人には、言っても無駄だと思うが、この質問を読む他の人に宣伝したい。 ピボットテーブルの機能を使えと。 何日もＯＫＷＡＶＥで回答を待つより、数分でできる。 例データ コード品名数量販売額記号 ET1010りんご21331382184ET AK8000みかん164106272AK GK2010キウイ8253136GK GN1020たまご7951192GN 記号の列は　=LEFT(A2,2)で出す。 ーー 挿入ーピボットテーブル 行に「記号」フィールドの▢部分をＤ＆Ｄ Σ値に「販売額」フィールドをＤ＆Ｄ 結果 行ラベル合計 / 販売額 AK6272 ET82184 GK3136 GN1192 総計92784 それかＳＱＬでやればやさしくできるかもしれない。しかし条件に、在るフィールドに対し関数ＭＩＤやＳＵＢＳＴＲＩＮＧをかぶせて指定できるかとなるとむつかしそうなので、新しく作業列を作る必要があるだろう。
できません。 どうしてもというのなら，マクロを外部ファイルにエクスポートしてからxlsxで保存してください。これなら一応はマクロの内容を残せます。
下記では余分な列Ｅ列（使わないどの列でもよい）を使う欠点があるが、とりあえず上げてみます。 ーー 条件付き書式の応用です。 例データ Ａ列　　Ｂ列 日付　勤務者氏名 2016/8/5山田 2016/8/5木村 2016/8/5佐藤 2016/8/6山田 2016/8/6木村 2016/8/6木村 2016/8/6山田 2016/8/7横山 2016/8/7横山 2016/8/9横井 2016/8/10横山 2016/8/10横井 以下今回は空白 第３０行まで対象。 Ｅ列を作業列として使う。 Ｅ２に　=IF(A2="","",TEXT(A2,"yyyy/mm/dd")& B2) 第３０行まで式複写。 条件付き書式の設定 Ａ１：Ｂ３０を範囲指定 ホーム　条件付き書式ー新しいルール 数式を使用して書式設定をするセルを決定 関数のような数式として =AND(A2<>"",COUNTIF($E$2:E2,E2)>1) 書式を「セルの塗りつぶし色」を黄色指定 ーー 結果 2016/8/6木村 2016/8/6山田 2016/8/7横山 のセルが黄色になった。 さらに、上記例の第１４行以下に重複データを入れてみて、セル色が黄色になるかテストしてみて下さい。 思い違いをしている箇所がないことを念じつつ。 エクセルでは、セルに現実にあるデータでしか判別に使えない場合が多い。データを結合して、Ｅ列に、２条件で使うデータを具体化したもの。 ＶＢＡでダブり判定をする方法もある。
(2) 日付から曜日を表示する方法 =TEXT(A1,"aaa") ※曜日の書式 aaa 月,火,水,木,金,土,日 ※漢字一字 aaaa 月曜日,火曜日,水曜日,木曜日,金曜日,土曜日,日曜日 ※漢字三文字 ddd Mon,Tue,Wed,Thu,Fri,Sat,Sun ※英字3文字 dddd Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday ※英字フル (3)担当者の氏名 曜日の担当者が固定(月曜が○○、それ以外が××)なら =IF(WEEKDAY(A1)=2,"○○","××") または =IF(B1="月","○○","××") のようにすればいい
>この、「2003/1/10」の部分（表示形式は「標準」）、元が何だったか、直す方法はあるでしょうか？ 表示形式が「標準」と言うのは変ですね、「日付」になっていると思います。 キー入力で「3-1-10」と入力すると「2003/1/10」のように変化して値は日付のシリアル値になります。 表示形式を「標準」に戻すと「37631」になるはずです。 これはExcelの仕様なので入力する前にC列の表示形式を「文字列」に変更して置けば防げます。 >複数ありますので、また、これからのこともありますので、「2003/1/10」だけでなく、直し方を教えて頂きたいのですが・・・ 未使用の列へ次の数式を入力して下へコピーすれば元の番地になると思います。 =IF(ISNUMBER(C2),YEAR(C2)-2000&"-"&MONTH(C2)&"-"&DAY(C2),IF(C2="","",C2)) 結果をコピーして、C列へ「形式を選択して貼り付け」で「値」を指定すれば良いでしょう。
例えばA2セルに入力されたテキストをD列までの範囲で自動的に文字を割り付けたいならフィルの機能を利用します。 A2セルからD2セル(2行以上のデータならその行まで）を選択し、ホームタブのフィル」「文字の割り付け」すると添付画像のようにD列までで文字列が自動的に割り付けられます。 この文字を修正して、各行のデータがデコボコになった場合は、A列からD列のデータ範囲（添付画像ならA2:D8)を選択して、もう一度文字の割り付けを行います。
検索実行ボタンのマクロに以下のコードを 画像のシートが画像の通り並んでいて当選者検索シートが左端だと考えています。 Sub ボタン1_Click() Dim i As Integer Dim c As Range Dim firstAddress As String For i = 2 To Sheets.Count Worksheets(i).Activate With Worksheets(i).Range(Cells(4, "C"), Cells(Rows.Count, "C").End(xlUp)) Set c = .Find(Worksheets(1).Cells(5, "B").Value, LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then firstAddress = c.Address Do If c.Offset(0, 2).Value = Worksheets(1).Cells(5, "D").Value Then c.Resize(1, 4).Select MsgBox "該当", vbInformation Exit Sub End If Set c = .FindNext(c) If c Is Nothing Then Exit Do End If If c.Address = firstAddress Then Exit Do End If Loop End If End With Next i Worksheets(1).Activate MsgBox "該当なし", vbInformation End Sub
＝VLOOKUP（＄Ｃ＄２：＄Ｃ＄４，Ａ２：Ｂ５，２，ＦＡＬＳＥ） は =VLOOKUP($C$2:$C$4,$A$2:$B$5,2,FALSE) だと思いますが 単純にE2に =$C$2:$C$4 としてE4までコピーするとそれぞれの行のC列の同じ行のデータがセルに表示されます。 そういう仕様なのだと思われますので、値指定を範囲にすると同一行の指定列のデータを指定したのと同じになるということですね。 上記の場合は、2行目から4行目までの指定なので、それ以外の行で利用させないという意思があるのかもしれません。 ちなみに =VLOOKUP($C:$C,$A$2:$B$5,2,FALSE) でも動作します。 欠点は同じ行の検索値データでないと利用できないということです。 $C$2:$C$4,だとD5にコピーするとエラーになりますよね。
こんにちは =SUM(INDIRECT(B2&"h")) で。 括弧の括りが間違ってます。
#5です。 例と目的を勝手に作ってＶＢＡで、やってみた。参考に。 ＶＢＡに興味がなければスルーしてください。 データ例 商品コードカテゴリ Ａ１０１Ｘ Ａ１０２Ａ Ａ１０１Ｙ Ａ１０１Ｚ Ａ１０２Ｂ Ａ１０１Ｙ Ａ１０２Ｃ Ａ１０１Ｗ Ａ１０２Ｂ Ａ１０１Ｚ A１０３Ｕ ソートして、Ｓｈｅｅｔ１に 商品コードカテゴリ Ａ１０１Ｗ Ａ１０１Ｘ Ａ１０１Ｙ Ａ１０１Ｙ Ａ１０１Ｚ Ａ１０１Ｚ Ａ１０２Ａ Ａ１０２Ｂ Ａ１０２Ｂ Ａ１０２Ｃ A１０３Ｕ このデータを対象にして下記ＶＢＡうお実行。 標準モジュールに Sub test01() 'データはＡ，Ｂ列でソートしておく '--最終行番号取得 lr = Worksheets("Sheet1").Range("A100000").End(xlUp).Row MsgBox lr '--第２行目データで初期値設定 i = 2 'Sheet1最初処理行　第１行目は見出し行 j = 2 'Sheet2へのアウトプット最初行　第１行目は見出し行 K = 2 'Sheet2へのアウトプット最初列　第１列目は商品コード列 '--第２行目＝データの最初、を特別扱い　sheet2へ Worksheets("Sheet2").Cells(j, "A") = Worksheets("Sheet1").Cells(i, "A") Worksheets("Sheet2").Cells(j, "B") = Worksheets("Sheet1").Cells(i, "B") K = K + 1 m = Worksheets("Sheet1").Cells(i, "A") '次行では第２行を直前行とする（商品コード） m2 = Worksheets("Sheet1").Cells(i, "B") '次行では第２行を直前行とする(カテゴリ） '--第３行目以降繰り返し For i = 3 To lr '直前行と商品コードが同じか If Worksheets("Sheet1").Cells(i, "A") = m Then '同じなららば 'カテゴリが同じで無ければ If Worksheets("Sheet1").Cells(i, "B") <> m2 Then Worksheets("Sheet2").Cells(j, K) = Worksheets("Sheet1").Cells(i, "B") K = K + 1 End If Else '直前行と商品コードが同字でなければ j = j + 1 Worksheets("Sheet2").Cells(j, "A") = Worksheets("Sheet1").Cells(i, "A") K = 2 '新出の商品コードは第２列へ Worksheets("Sheet2").Cells(j, K) = Worksheets("Sheet1").Cells(i, "B") K = K + 1 '次行では次列へ End If m = Worksheets("Sheet1").Cells(i, "A") '直前行のデータ（商品コード）として次行へ引き継ぎ m2 = Worksheets("Sheet1").Cells(i, "B") '直前行のデータ(カテゴリ）として次行へ引き継ぎ Next i End Sub をコピペ ーー 実行（Ｆ５キーを押す）処理結果 Ｓｈｅｅｔ２の第２行以下 商品コード　カテゴリーー＞今回はこの見出し（第１行目）は手入力 Ａ１０１ＷＸＹＺ Ａ１０２ＡＢＣ A１０３Ｕ
=IF(A1<300000,"",IF(A1<400000,5000,IF(A1<6000000,7500,IF(A1<8000000,10000,IF(A1<1000000,12500,15000))))) または =IF(A1<300000,"",CHOOSE(MIN(A1/100000-2,8),5000,7500,7500,10000,10000,12500,12500,15000)) または =IF(A1<300000,"",LOOKUP(A1/100000,{3,4,6,8,10},{5000,7500,10000,12500,15000}))
自分で書いたコードを読む気がないのですか？ If Intersect(Target, Range("F6:F35")) Is Nothing Then Exit Sub というコードでF6:F35以外は処理をしないようにしているのだから，ここをなんとかしなければいけませんよね。例えば If not Intersect(Target, Range("F6:F35")) Is Nothing Then 'F6:F35に対する処理 elseIf not Intersect(Target, Range("H6:J35")) Is Nothing Then 'H6:J35に対する処理 end if のようにすれば必要な処理はどちらかになって，それ以外の場合は何もしないようになります。 そして「F6:F35に対する処理」は今までと同じです。 　Application.EnableEvents = False 　For Each r In Target 　　r.Value = StrConv(r.Value, vbWide) 　Next r 　Application.EnableEvents = True でいいでしょう。 それから「H6:J35に対する処理」は全角を半角にするのだから，vbNarrowを使って 　Application.EnableEvents = False 　For Each r In Target 　　r.Value = StrConv(r.Value, vbNarrow) 　Next r 　Application.EnableEvents = True でいいでしょう。
>ですかね？ >此で如何でしょうか？ 空白や改行が数式内に含まれると正しい数式と認められませんので、Excelの数式バーからコピーした文字列を直接貼り付けてください。 OFFSET関数の参照セルを$B$0としていますがそれは認められませんので$B$1にしてください。従って、行位置の隔たりを調整する必要があるでしょう。（ご自身でチェックしてください） また、前回の回答でMATCH関数の照合の種類と並び順を説明しましたが、ご理解いただけていないようです。 照合の種類が-1の時は検索範囲の値が降順（大きい順）にソートされていなければなりませんが、提示の模擬データでは昇順（小さい順）になっています。 >あと、MINの話ですが前はINDEX文を介在させるとEnterでの通常確定で結果が出た >今回は何故此が出来無いのでしょうか？ 複数の関数を組み合わせた数式で引数が関数の演算結果であり、然も、配列値となる場合は基本的にCtrl+Alt+Enterキーで確定することになるようです。 =MIN(INDEX(IFERROR(VALUE([文字列]),[数値]),0)) 上記の数式モデルでVALUE([文字列])がエラーを含む配列値であるため、IFERROR関数を経由してINDEX関数へ配列値を引き渡すことになり、暗黙の了解事項が成立しないようです。 INDEX関数は配列を引数として扱うことは暗黙の了解事項であり、四則演算や論理演算の結果を配列として扱うことは暗黙の了解事項とされていることのようです。 関数の演算結果も暗黙の了解事項で処理されるケースもありますが、暗黙の了解事項が認められないことも多くあります。（例示は調査が必要なので省略します） トライ&エラーで対処してください。
少し手間がかかりますがD2に =IF(COUNTIF(B:B,B2)>1,B2,"") と式を入力して下方向にコピーします。D2セルを選択右角にカーソルを持っていくと＋になるのでダブルクリックするとデータのある最下行までコピーされます。 D列に重複しているエージェント名がそれぞれの行に表示されますので、D列をコピーしてE列に形式を選択して貼り付けの値貼り付けをします。 E列を選択してデータタブのデータツールにある重複の削除を実行すると、重複したエージェント名がそれぞれ1個ずつ表示されます。
[表示]タブの[改ページプレビュー]でどのようなページ構成になっているか 確認してみてはいかがでしょうか。 1ページ、2ページ、3ページなどページ番号が振られていると思います。 空白のページがあるのであれば、その余分に設定されている行だか列だかを 削除すれば単純に空白ページが無くなります。 データの最終行・列を確認してみるのも手です。 [Ctrl]＋[End]で、Excelが認識している最終行・列のセルまで飛びます。 もし空白だったとしても、以前何かが入力されていたセルであれば、 何かの情報がそのセルに残っていて最終行・列と認識されている可能性もあります。 その場合もやはり、データが入っている最終行・列まで 不要な列や行を削除する必要があります。 お試しください。
No1の追加です。 モジュールのコードを記載する画面の一番上に Option Base 1 を追加してください。
表示形式の条件付き書式という機能を使います。 ただし，今回ヤリタイことの操作は，「具体的にどこのセル範囲を選んだときにどのように操作する」をゲンミツにしないと出来ないので，必ず，回答したとおりに操作してください。 まず，自動で色づけをしたい範囲を選択します。 でもご相談は例えばで書いてあるのでしょうから実際は違うのかもしれませんが，いまはご相談で書かれたとおりにＡ列とＢ列を見て，Ａ列とＢ列に色を付けたいとしてお話しします。 手順： Ａ列とＢ列を列選択する 条件付き書式を開始する セルの書式設定の条件で「カスタム数式」を選択する 値または数式と書かれている欄に =COUNTIFS($A:$A,$A1,$B:$B,$B1)>1 と記入する 書式設定のスタイルで希望の塗りつぶしを設定する 以上です。
Excelのブックの共有は，元来そこまで信頼度の高い機能ではありません。昔からしょっちゅうブックが破損する事でも知られていましたし，Excelのバージョンが上がっても，信頼性の向上や機能の改善はほとんど行われてきませんでした。 まぁ100名からの関係者に作業させていながら，「固まってみられなくなる」で済んでいるなら，それはそれで平和なのかもしれません？ それとも「見るだけ」が目的で，100名が編集を行う必要が無い(いつも固まって，100名の作業が失われてもかまわない状況)なら，わざわざ「共有」を使う必要もありません。ふつーに「読み取り専用」で開いて見てください。 あるいは限定的に編集を行うユーザーと，見るだけユーザーに分けてブックの運用を行うのが良いかもしれませんね。
こんにちは セルG1に、数式に=$A1="○" とセットして、書式で塗りつぶしを設定してから、 条件付き書式のルールの管理で適用先を、=$G$1:$R$100 とかに適宜範囲を 修正してあげればいいのでは？
こんにちは、No2です スタートボタンのすべてのプログラムからMicrosoft Office、Microsoft Excel と 辿って起動しても立ち上がりませんか？
最後が IF(C3<=15000000,ROUNDDOWN(C3*0.95-1700000,0)*C3-2450000) になっていますが =IF(C3<=15000000,ROUNDDOWN(C3*0.95-1700000,0),C3-2450000) ではないでしょうか。
No4の追加です。 シートコピーはシートをコピーして貼り付けではなくて、シートの移動またはコピーの機能を使います。 Sheets(得意先サブマスタ作成のシート名).Copy After:=Workbooks(得意先変換マスタ.xlsx).Sheets(Workbooks(得意先変換マスタ.xlsx).Sheets.Count) ふと思ったのですが > マクロでこの後に続く箇所で上記の得意先変換マスタ.xlsxを使用する際にエラーが出て しまい こちらのエラーがどのようなものか不明なのでふれませんでしたが、こちらの部分を修正変更したほうが流れとしていいのかもしれませんね。
質問の条件のみを満たす数式は下記のとおりで良いでしょう。 D2=SUM(B2,(C2="当方負担")*(B2<50000)*100,(C2="当方負担")*(B2>=50000)*150) D2セルを下へコピーしてください。
VLOOKUP関数でできます。 エクセルでカレンダー【祝日を表示編】 http://kokoro.kir.jp/know/calendar3.html VLOOKUP(検索値, 範囲, 列番号, FALSE) と、４番目の引数にFALSE(または0)を指定すると、順不同の場合でも合致する場合は対象の値、合致しない場合は#N/Aを返します。 なので、#N/Aならば休日でない、それ以外の数値ならば休日と判定とか。
式を変更して計算される値を変えてもいいのなら =IF(E4="","",MAX(E4*0.0458,0)) 式はそのままにして，表示を変えたいだけなら，セルの書式設定で表示形式をユーザー定義の [<0]0;[>=0]G/標準 にしてください。
こんにちは。 まず、 「マクロが書かれたブック」 つまり、 「クイックアクセスツールバーを登録したい唯一のブック」 を開いておいてから、 ◆手順１ 　[オプション][クイック アクセス ツール バー] 　を開く ◆手順２ 　[クイック アクセス ツール バー のユーザー設定] にて 　登録済の　クイック アクセス ツール バー　 を、 　選択状態にしてから 一旦 　[<< 削除] して ◆手順３ 　[OK] でオプションを確定、一旦終了。 ◆手順４ 　再度、 　[オプション][クイック アクセス ツール バー] 　を開く ◆手順５ 　[コマンドの選択] のドロップダウンにて 　[マクロ] を選び 　ブックに登録したいマクロ を 　選択状態にしてから 　[追加 >>] ◆手順６ 　[クイック アクセス ツール バー のユーザー設定] のドロップダウンにて 　[すべてのドキュメントに適用（既定）]　←これじゃダメ★ の次にある 　[ブック名.xlsm に適用]　←ここがポイント★★ を選択して ◆手順７ 　[OK] でオプションを確定。 以上が◆手順、です。 ★や★★でマークアップした所を注意して下さい。 因みにマクロの保存先がどこであるかは関係なくて、 クイックアクセスツールバーの適用先の設定を 望んだ通りに出来ていない、ということになります。
こんにちは どうせADOを使うのなら、 Sub test1() 　　Dim CN As ADODB.Connection 　　Dim RS As ADODB.Recordset 　　Dim 最終行 As Long 　　Dim sSql As String 　　Dim i　　 As Long 　　 　　Set CN = New ADODB.Connection 　　 　　With CN 　　　　.Provider = "Microsoft.Jet.OLEDB.4.0" 　　　　.Properties("Extended Properties") = "Text;HDR=Yes;FMT=Delimited;" 　　　　.Open CreateObject("Wscript.Shell").SpecialFolders("Desktop") & "\" 　　End With 　　 　　Set RS = New ADODB.Recordset 　　 　　sSql = "" 　　sSql = sSql & "SELECT " 　　sSql = sSql & "LEFT(a.会社＠店舗, 4) AS 会社コード, " 　　sSql = sSql & "RIGHT(a.会社＠店舗, 4) AS 店舗コード, " 　　sSql = sSql & "a.会社＠店舗, " 　　sSql = sSql & "a.得意先コード, " 　　sSql = sSql & "a.店舗名, " 　　sSql = sSql & "b.電話番号, " 　　sSql = sSql & "b.FAX番号 " 　　sSql = sSql & "FROM 得意先サブマスタ.csv AS a " 　　sSql = sSql & "LEFT JOIN " 　　sSql = sSql & "　　 得意先マスタ.csv AS b " 　　sSql = sSql & "ON a.得意先コード = b.得意先コード " 　　 　　RS.Open sSql, CN　　 　　For i = 1 To RS.Fields.Count 　　　　Cells(1, i) = RS.Fields(i - 1).Name 　　Next　　 　　Range("A2").CopyFromRecordset RS　　　　 　　RS.Close End Sub のようにしてはどうですか？
テストのため、同一ブック内に３シート作った。 標準モジュールに Sub test01() Sheets(Array("Sheet1", "Sheet2", "Sheet3")).PrintOut End Sub を入れて、VBE画面で実行すると、VBE画面からさえ動かず、印刷されたが。 質問者は、何かシート名.SELECTなどやってますか。 >ワークシートを複数印刷する際・・ 複数ワークシートを印刷する際のこと、ではないの。本件は印刷部数の問題ではないよね。 質問における、表現は十分注意すること。 もし多ブックにまたがるシートの一括印刷などなら、断り書きが必要だろう。
Microsoft 直販より、こちらのほうが安価 \14,920 ポイント10％ http://www.yodobashi.com/ec/product/100000086580110039/index.html?gad1=&gad2=g&gad3=&gad4=56278881131&gad5=2034205281691597349&gad6=1o1&xfr=pla&gclid=CJnJ98KQ_c0CFdcmvQodRbYB2g インストールの際問題が発生することはありません。 Excel 2007 からのアップグレードではなく、Excel 2016 のインストールになります。 インストールするとき、Excel 2007 を残すかどうか選択することができます。 Excel 2007 を残せば両方のエクセルを使うことができます。 ただし、Microsoft は古いバージョンを残すことを推奨していないようです。何か問題があるからだと思いますが、私はOffice 2016 をインストールした時、Office 2003、2010 を残してあります。私が使用している範囲では、問題はありません。(Office を100% 使いこなしているわけではありませんので、問題が潜んでいるのに気がつかないだけかもしれません。） しかし、Excel 2007 で機能不足などの問題がなければアップグレードの必要は無いと思います。 Excel 2007 で作ったファイルは上位のバージョン(Excel 2010, 2013, 2016) で開くことができます。上位のバージョンで作ったファイルをExcel 2007 で開くことはできますが、Excel 2007 にない機能は当然、Excel 2007 で開いても機能しません。 無料のMicrosoft Office 互換ソフトがあります。有限のお金を有効に使うための究極のソフトです。 インストーラ版 http://forest.watch.impress.co.jp/library/software/libreoffice/ ポータブル版 http://portableapps.com/apps/office/libreoffice_portable ポータブル版は、自己解凍ファイルになっています。ダブルクリックして、解凍先を指定します。
ぜんぜんメモリの使いすぎではありません。 おそらくExcelでこれまでいくつも確認されているバグの一つと思います。 Office2007ならサービスパックの適用を https://www.microsoft.com/ja-jp/download/details.aspx?id=27838 Excel2010なら修正プログラムの適用を https://support.microsoft.com/ja-jp/kb/842231 とにかくWIndowsとOfficeの更新を全て適用して最新の状態にしてみてください。
> 今現在「台帳」が保存されている同じフォルダ内の「ブック」というフォルダをブックの保存先として指定できる マクロを実行しているブックのフォルダは ThisWorkbook.Path で求めることができますので 標準モジュールに作っていただいた Function MacroX内にあるC:\testフォルダを指定している部分2か所を以下のように変更してください。 これと↓ ActiveWorkbook.SaveAs Filename:=ThisWorkbook.Path & "\ブック\" & MyFileName, FileFormat:=xlOpenXMLWorkbookMacroEnabled ↓こちらです Workbooks(MyFileName).BreakLink Name:=ThisWorkbook.Path & "\Book1.xlsm", Type:=xlExcelLinks 上記は、Vlookupのリンク先がこのマクロを実行しているファイルでしたら Workbooks(MyFileName).BreakLink Name:=ThisWorkbook.FullName, Type:=xlExcelLinks でいけます。 ただ、あいまいで古い記憶なのですが、あまりに階層が深い場合、エラーになったような気がします。ドライブからそれぞれのフォルダ名の文字とフォルダ間の\も含めて半角文字は1文字全角文字は2文字と数えて256文字以内という規定があって、たぶん今はいけると思いますが、そのあたりがちょっと不明です。
＞続くときに、該当するB列の数字を合計する =SUMPRODUCT((A2:A10=A1:A9)*B2:B10) とかで。
そのときだけ対症療法で入れ替えたグラフにしたい、 というときは、手作業で、棒グラフを右クリックしてデータ系列に指定されているセルの範囲を、別の色で描かれている範囲と入れ替えて、系列１から順に望む順番で描かせています。
>実際に求めたいのは、例えば算数と国語のテストを行い、それぞれにあるボーダー点数（算数と国語で異なる）に到達する回数を求め（例えば算数ではA君4回目、B君5回目、C君5回目、D君6回目、E君2回目。国語ではA君1回目、B君6回目、C君3回目、D君7回目、E君1回目）、国語での到達回数が速かった生徒の数を求めるというものなのです。 >このイメージとしては、各科目での各生徒の到達回数が得られれば =SUMPRODUCT(({4;5;5;6;2}>={1;6;3;7;1})*1) → 3 みたいな感じでした。 今回の提示で目的が見えてきました。しかし、A君からE君までの最初に閾値越えたのは何回目かを配列で返す数式は見当たりませんので組み込み関数では解決できないでしょう。 MMULT関数では閾値越えが何回有ったかを各自について配列で返せますが質問の内容では初回の閾値越えは何回目のテストかを求めるので目的が異なります。 MATCH関数では1行または1列に対して1つの値で検索しますので、配列で戻す値はありません。 MIN関数は配列全体を対象に最小値を抽出してしまいますので、行毎または列毎の個別に求める必要があります。 従って、作業用に算数と国語の閾値越えを生徒毎に算出してから最終の求める値の算出にSUMPRODUCT関数等を使えば良いでしょう。
B列をワークエリアに使ってよろしいでしょうか。 B列に番号を振って並べ替え、同じものを削除して、もとにもどす方法です。 ' Sub Macro1() ' ' Macro1 Macro ' Dim iy1 As Integer Dim iye As Integer ' Aplication.ScreenUpdating = False '実行速度を上げる ' iye = [A1].End(xlDown).Row ' For iy1 = 1 To iye Cells(iy1, "B") = iy1 Next iy1 ' [A:B].Sort Key1:=[A1] ' For iy1 = iye - 1 To 1 Step -1 If Cells(iy1, "A") = Cells(iy1 + 1, "A") Then Cells(iy1 + 1, "A").Range("A1:B1").Delete Shift:=xlUp End If Next iy1 ' [A:B].Sort Key1:=[B1] [B:B].ClearContents ' End Sub ’ B列か使えないならご記入ください。（方法はありますが、実行速度は下がります） また、ダブりを削除できたら、並び順はどうでもいいのならもご記入ください。B列が必要なくなり、実行速度が上がります。 また、このプログラムはデータが２件以上ないと、誤動作をします。その可能性がある場合ご記入ください。
B列をワークエリアに使ってよろしいでしょうか。 B列に番号を振って並べ替え、同じものを削除して、もとにもどす方法です。 ' Sub Macro1() ' ' Macro1 Macro ' Dim iy1 As Integer Dim iye As Integer ' Aplication.ScreenUpdating = False '実行速度を上げる ' iye = [A1].End(xlDown).Row ' For iy1 = 1 To iye Cells(iy1, "B") = iy1 Next iy1 ' [A:B].Sort Key1:=[A1] ' For iy1 = iye - 1 To 1 Step -1 If Cells(iy1, "A") = Cells(iy1 + 1, "A") Then Cells(iy1 + 1, "A").Range("A1:B1").Delete Shift:=xlUp End If Next iy1 ' [A:B].Sort Key1:=[B1] [B:B].ClearContents ' End Sub ’ B列か使えないならご記入ください。（方法はありますが、実行速度は下がります） また、ダブりを削除できたら、並び順はどうでもいいのならもご記入ください。B列が必要なくなり、実行速度が上がります。 また、このプログラムはデータが２件以上ないと、誤動作をします。その可能性がある場合ご記入ください。
回答No.3の追加です。 INDEX関数の時は次の数式で右と下へコピーできます。 Sheet2!B3=INDEX(Sheet1!$B$4:$O$5,INT((COLUMN()-2)/3)+1,MOD((COLUMN()-2),3)+1+(ROW()-3)*7) 元のデータは1つのグループが2行×7列（B4:H5）として、提示された2行×3列が内包しているものと考えれば良いでしょう。 OFFSET関数の場合はSheet1!$A$1からの隔たりを上記数式を参考に行位置と列位置を算出してください。（あなたの応用力で解決することをお勧めします）
古いEXCELの場合 =IF(ISERROR(FIND("virus",C3)),"",MID(C3,FIND("virus",C3),FIND("virus",C3)+4)) 2007以降の新しいEXCELの場合 =IFERROR(MID(C3,FIND("virus",C3),FIND("virus",C3)+4),"") ※IFERROR関数は、IF関数とISERROR関数を合体させた関数で、EXCEL2007以降で使用できます。
SELECT * FROM (SELECT * FROM 当年度データ.csv UNION all SELECT * FROM 前年度以前データ.csv) AS 元帳 WHERE 諸条件 では？ UNION ALL （重複を排除しない分高速）のような気がします。
>数値が同じはずなのに色が赤になっている所が多々出てしまいました。 たぶんですが、 For i = 17 To 26 For r = 30 To 39 がおかしいのでしょう。 これだと、Cell(17,9)とCell(30,9)を比較した後に、Cell(17,9)とCell(31,9)を比較します。 最終的にCell(17,9)の色は、Cell(39,9)との比較の結果になります。 17行と30行、18行と31行・・・26行と39行の比較であれば Sub オニオン判定() Dim i As Integer, j As Integer, r As Integer Dim k As Double Range(Cells(17, 9), Cells(26, 14)).Interior.ColorIndex = 0 Range(Cells(30, 9), Cells(39, 14)).Interior.ColorIndex = 0 k = Cells(5, 2) 'B5セルの値 For j = 9 To 14 For i = 17 To 26 　r = i +13 Select Case Abs(Cells(i, j).Value - Cells(r, j).Value) Case 0 Cells(r, j).Interior.Color = vbBlue Cells(i, j).Interior.Color = vbBlue Case Is <= 0.05 Cells(r, j).Interior.Color = vbYellow Cells(i, j).Interior.Color = vbYellow Case Else Cells(r, j).Interior.Color = vbRed Cells(i, j).Interior.Color = vbRed End Select Next Next End Sub
http://answers.microsoft.com/ja-jp/office/forum/office_2010-excel/excel2010/4912a4bd-a9c3-400b-af23-c296175d968d?auth=1 質問者の言う ＞Excelでなくコントロールパネルで設定するなんて、全然気付きませんでした！ は参考になりませんか。
こんにちは。 > これでは、異なるブックのExcelファイルであっても、ウィンドウが分かれ > てしまっていては、削除の対象になりません。 　異なるExcel.ApplicationのExcel.Workbookが、 　自ブックとは別インスタンスのアプリケーションである為に、 　閉じる方法が解りません。 ってことでしょうか？ > 今、サーバで常にマクロが動き続けているExcelファイル(ファイルAとします)があります。 > 今回はそのファイルを閉じ、マクロにてシートの更新をしたのち、また開きなおしてマクロを実行させたいです。 > for each wb in Workbooks > if wb.Name <> ThisWorkbook.Name then > wb.Close SaveChanges:=false いまひとつニーズが読めていませんが、 　すべてのExcelアプリケーションに渡って 　すべてExcelブックを上書き保存せずに閉じて、 　すべてのExcelアプリケーションを終了する ということ？だとして、 先達の知恵を頼りに、Excel VBA で書いてみました。 リンク：MREXCEL.COM > Forum > Question Forums > Excel Questions > GetObject and HWND 私のが解り難いようでしたら、リンクを参考になさってみて下さい。 もっと簡単に出来たような気もしますが、たぶん私の記憶違い？かなぁと。 ↓Excelのバージョンの問題で構文エラーやコンパイルエラーになる場合は、 　PtrSafeを全削除、LongPtrをLongに全置換、してみてください。 > ... 別のブックにファイルAを閉じる処理を行うマクロを仕込んでおき ... Callの仕方はお任せします。 ' ' // Option Explicit Private Type GUID 　　lData1 As Long 　　iData2 As Integer 　　iData3 As Integer 　　aBData4(0 To 7) As Byte End Type Private Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" ( _ 　　ByVal hWnd1 As LongPtr, ByVal hWnd2 As LongPtr, _ 　　ByVal lpsz1 As String, ByVal lpsz2 As String _ 　　) As LongPtr Private Declare PtrSafe Sub AccessibleObjectFromWindow Lib "OLEACC.DLL" ( _ 　　ByVal hwnd As LongPtr, ByVal dwId As Long, _ 　　riid As GUID, ppvObject As Any) Private Const OBJID_NATIVEOM = &HFFFFFFF0 Private Sub SetIDispatch(ByRef ID As GUID) 　　With ID 　　　　.lData1 = &H20400 　　　　.iData2 = &H0 　　　　.iData3 = &H0 　　　　.aBData4(0) = &HC0 　　　　.aBData4(1) = &H0 　　　　.aBData4(2) = &H0 　　　　.aBData4(3) = &H0 　　　　.aBData4(4) = &H0 　　　　.aBData4(5) = &H0 　　　　.aBData4(6) = &H0 　　　　.aBData4(7) = &H46 　　End With End Sub Sub ReW9196890() Dim IDispatch As GUID Dim oWnd As Object Dim xlApp As Excel.Application Dim wb As Excel.Workbook Dim sThisWbName As String Dim nHwndThisApp As LongPtr Dim nHWnd As LongPtr Dim lXLDESKhwnd As LongPtr Dim lWBhwnd As LongPtr 　　sThisWbName = ThisWorkbook.Name 　　nHwndThisApp = Application.hwnd ' ' 別インスタンスのブック（個人用マクロブック以外）をすべて閉じる 　　Do 　　　　nHWnd = FindWindowEx(0, nHWnd, "XLMAIN", vbNullString) Debug.Print nHWnd 　　　　If nHWnd = 0 Then Exit Do 　　　　If nHWnd <> nHwndThisApp Then 　　　　　　lXLDESKhwnd = FindWindowEx(nHWnd, 0&, "XLDESK", vbNullString) 　　　　　　lWBhwnd = FindWindowEx(lXLDESKhwnd, 0&, "EXCEL7", vbNullString) 　　　　　　If lWBhwnd Then 　　　　　　　　SetIDispatch IDispatch 　　　　　　　　Call AccessibleObjectFromWindow(lWBhwnd, OBJID_NATIVEOM, IDispatch, oWnd) 　　　　　　　　Set xlApp = oWnd.Application 　　　　　　　　For Each wb In xlApp.Workbooks 　　　　　　　　　　If UCase(wb.Name) Like "PERSONAL.XLS*" Then 　　　　　　　　　　　　wb.Saved = True 　　　　　　　　　　Else 　　　　　　　　　　　　wb.Close SaveChanges:=False 　　　　　　　　　　End If 　　　　　　　　Next wb 　　　　　　　　xlApp.Quit 　　　　　　End If 　　　　End If 　　Loop While nHWnd 　　 ' ' このExcel.Application　で開かれたブックの内、 ' ' 自ブック（+ 個人用マクロブック）以外をすべて閉じる 　　For Each wb In Workbooks 　　　　If UCase(wb.Name) Like "PERSONAL.XLS*" Then 　　　　　　wb.Saved = True 　　　　ElseIf wb.Name <> sThisWbName Then 　　　　　　wb.Close SaveChanges:=False 　　　　End If 　　Next wb '' ' このExcel.Application を閉じる　？ 　　Application.Quit '' ' 自ブック を閉じる　？ 　　ThisWorkbook.Close SaveChanges:=False End Sub ' ' // ' ' オマケ'　テスト環境作り Private Sub prep() 　　Workbooks.Add.Sheets(1).Cells(1) = 0 　　With CreateObject("Excel.Application") 　　　　.Visible = True 　　　　.Workbooks.Add.Sheets(1).Cells(1) = 11 　　　　.Workbooks.Add.Sheets(1).Cells(1) = 12 　　End With 　　With CreateObject("Excel.Application") 　　　　.Visible = True 　　　　.Workbooks.Add.Sheets(1).Cells(1) = 21 　　　　.Workbooks.Add.Sheets(1).Cells(1) = 22 　　End With 　　AppActivate Application.Caption 　　ThisWorkbook.Activate End Sub
http://www.fksekiguchi.sakura.ne.jp/04/0403_8.html の説明を読めば、成り立ちがわかるのでは。 ・フィルター設定なし ・フィルター設定あり 質問は後者の方のケースでしょうか。 With　EndWith間は追加でソート条件を叙述している。 ＞どれが並べ替えのコードなのでしょうか 　強いて言えば、.Apply といえるのかも。
>G8:G38には計算式が既に入力されており、保護ありで手を加えることが出来ません。 保護を解除して数式を修正してください。 それができないと問題が解決しません。 但し、新たにExcelブックを作成するのであれば解決できるでしょう。 しかし、あなたの応用力では新たに作成することは困難でしょう。 >B9セルが"日"または"祝"の時にG9（時間内）が0時間になるようです。（目的通りです） >この意味は、祝日の一覧表が作成出来ないと現段階では見れないのでしょうか。 「見れない」ではなく「解決しない」です。 祝日は毎年同じ月日のものと年によって変化するものがありますので、対象となる年の一覧表が必要です。 >ダウンロード先を、表の構成の関係で”L8”としました。 提示のサイトから直接L8セル以下へダウンロードできませんので、ファイルをダウンロードして目的のセル範囲をコピペで値のみをL8以下へ貼り付けます。 各祝日が連続していなくてもB列へ設定する数式で"祝"を代入できます。 >「月間スケジュール表」が表示され、シートが「予定表」と「祝日表」と「sheet1」があります。 >ここから先の操作が判りませんので、よろしくお願い致します。 祝日表のB3:B82をコピーコマンドでクリップボードに記憶させ、値の貼り付けでL8へ貼り付けコマンドを実行してください。 結果が数値（5ケタの整数）のときは表示形式を日付にすると分かり易いでしょう。 あなたの知識では問題解決に長期間が必要になるでしょう。
もちろん作れますけど マクロでやる意味は無いのでは？ アスキーアートのデータ自体をマクロが作ってくれるわけではありませんので。 極端な話、print文でパーツを並べれば完成です。 ＞ピクセルをセルと考えれば、 1セル１文字ということ？
こんにちは。お邪魔します。 > 検索ボタンをクリックしたら検索場所がsheet、検索対象が値に設定された状態でCtrl+Fの検索ボックスを開きたいと思っています。 　【検索場所がsheet】 　【検索対象が値】 　【Ctrl+Fの検索ボックス】 実現するのは簡単そうに見えて、意外と解り難いですよね。 マクロの記録で得られるレベルのものではないですから安心してください。 > 若しくは上記の条件で検索できる検索窓とボタンがあればそちらでも構いません。 その方がいい場合もある、とは思うのですが、 これはこれで、仕様をより明確に確定しなければなりませんから、 どんな仕様にするのか、をご自身で決めるまでに、 色々手を動かして試す必要があるような、、、。 なので今回は【Ctrl+F】で表示される[検索と置換]ダイアログでお応えします。 【検索対象が値】という点については二通りの解釈を持っています。 　a　[検索と置換]ダイアログのオプションとしての[検索場所(シート|ブック)] 　　　　に、シート、を指定する 　b　a の状況に加えて 　　　　検索範囲をシート全体にする（拡げる）（複数セル範囲選択中の範囲に限定しない） a　を意図したものかも知れませんが、とりあえず、b という解釈で書いています。 その必要がないようでしたらば、★でマークした行を削除してください。 【検索場所がsheet】【検索対象が値】 以外の検索オプション（※【詳細】は下記）については、 （直近の検索・置換の際に指定変更があってもなくても） Excel起動時の初期設定になる（強制される）ように書いています。 他のオプションを別途指定変更したい場合は、 VBE画面に記入したコードの 　Find の部分にカーソル（キャレット）を当て F1キーでVBAヘルプを表示して、 [Findメソッド]の各名前付き引数に[指定できる定数]の中から、 お望みのオプションを選んで指定を書き換えてください。 お求めに十分でなかった場合は遠慮なく、補足欄にでも書いてみて下さい。 ' ' /// Private Sub CommandButton1_Click() ' ' [書式の検索]を（設定中であってもなくても）クリア Application.FindFormat.Clear ' ' [検索場所]:シート ' ' [検索対象]:値 ' ' これ以外のオプション（※【詳細】は下記）をすべてデフォルトに設定して ' ' バックグラウンド（VBAのメソッド）で、空（ダミー）の検索を実行 ActiveCell.Find _ What:=ActiveCell, _ LookIn:=xlValues, _ LookAt:=xlPart, _ SearchOrder:=xlByRows, _ MatchCase:=False, _ MatchByte:=False, _ SearchFormat:=False ' ' 複数セル範囲を選択中の場合は、 ' ' 検索範囲を（限定せずに）シート全体にする為に アクティブセルを選択 If ActiveCell.MergeArea.Address <> Selection.Address Then ActiveCell.Select　'　★ ' ' 以上の処理による設定 を 反映した形で、、、 ' ' [検索と置換]ダイアログを表示 Application.CommandBars.FindControl(ID:=1849).Execute End Sub ' ' // ' ※【詳細】 ' ■ Find メソッドをダミー実行することで ' →　[検索場所(シート|ブック)]　＝（お望みの設定）シート ' を指定（強制）したことになります。 ' ▼ 以下、名前付き引数 と [検索と置換]ダイアログ上のオプション との 対照　＝指定値 ' What　　　　:　[検索する文字列]　＝（仮の表示として）アクティブセルの値 ' SearchOrder :　[検索方向(行|列)]　＝（起動時の初期値）行 ' LookIn　　　:　[検索対象(数式|値|コメント)]　＝（お望みの設定）値 ' MatchCase　 :　[大文字と小文字を区別する(T|F)]　＝（起動時の初期値）False ' LookAt　　　:　[セル内容が完全に同一であるものを検索する(T|F)]　＝（起動時の初期値）False ' MatchByte　 :　[半角と全角を区別する(T|F)]　＝（起動時の初期値）False ' ◆ ボタンの種類と運用方法 ' ▼ 挿入した[図形]などのシェープや[ボタン(フォームコントロール)] の場合 ' 　上記プロシージャ記入先は標準モジュール ' 　上記プロシージャ宣言（先頭）行の Private を削除 ' 　[図形]などのシェープや[ボタン] の[マクロの登録]にて ' 　　　上記プロシージャの名前を登録 ' ▼ [コマンドボタン(ActiveXコントロール)] の場合 ' 　上記プロシージャ記入先はコ[コマンドボタン]を配置したシートのシートモジュール ' 　上記プロシージャはそのまま記入 ' 　[コマンドボタン]のオブジェクト名がCommandButton1以外の場合は ' 　　　上記プロシージャ宣言（先頭）行の CommandButton1 を書き換え ' ' ///
アメリカと日本で違うでしょうね。 アメリカのホワイトカラーは基本仕事場は個室ですから、そこで作業を効率化すればいくらでもできます。先日、入社当日に自分の作業を全部プログラムして自動化して、１０年以上出社して遊んでいた人がバレて解雇されましたが、ご質問の状況といえるかもです。 日本の場合、作業が速く終わったら、次の仕事が来るだけです。そして多くの場合、パソコンでの自動化作業って、１人で数十人分の仕事をしても、１人分以下とみなされます。で、ある日、突然その人が辞めるといっても、よく人がやめる職場なのでそんなひとりとしてみなされすぐやめることができるでしょう。で、会社自体が立ちゆかなくなり、潰れるって、正直、中小企業なら会社として、大企業でも部署としてよくあることです。 よく分かっているなぁ、と思ったのが、なれるSE　ってラノベシリーズで、スーパーバイドが会社を潰す話が出ています。真面目な人、真面目な会社、真面目な同僚のほど、追い込まれる罠ってあります。
以下のように設定します tmp="""aaa、bbb、ccc"",""2016/07/01"",""2016/07/01""" 最初の"""は"が文字列開始の”で次の""が文字列中の"になります 同様にその後も文字列中の"を""に変更します
似たようなことを、セルの式だけでやったことあります。 vlookupみたいな、検索する関数を多用しました。 私でしたらこんな感じにします。 取引先一覧シート 商品(？)一覧シート 案件を記録するシート 担当者情報を記録するシート 報酬を集計するシート 案件を処理するシートには、入力規制で、 取引先、商品、担当者、これらが選択できるようにします。 (別のシートのデータは、そのまま使えないので、案件シート内のどこかで参照する) 集計シートでは、vlookupを使って、 単価や担当者への報酬割合をひっぱってきて計算します。 でも、集計では月毎など期間を区切ったり、 案件毎に計算したりと色々と予想されます。 そういった場合、 担当者＆年月とか、担当者＆案件名とか、 集計しやすくするための列を、案件シートに入れて、 処理しやすくしてた記憶があります。 (できはしたけど、メンテナンス性とか、引き継ぎしやすさとかは、それなりなものだったと考えます) 式にしろ、vbaにしろ、データ構造をきちんと設計できれば、 ちゃんとしたもの出来ると思います。 頑張ってください。
あらかじめyから固定の切片を引いておいて、原点を通るモデルで分析すればよい。
>A君～E君の5×5の行列にF列として1列×5行の有効無効フラグ列を追加して、そこの対応する行のセルが1である行の数のみをカウントするというようにする必要がある事がわかりました。 その条件は質問の文言の下記要件と食い違いがあります。 「例えばテーブルの行数（可変）がF1セルに入っていたとして、{}部分を置き換える表記はあるのでしょうか。」 COUNTIF(OFFSET(A1:E1,{1,2,3,4,5},0),">=50")の結果は5列×1行の配列値になります。 従って、F2:F6のフラグ（0と1の数列？）は1列×5行なので1つのCOUNTIFS関数で纏めることはできません。 SUM関数の配列内でIF(COUNTIF(OFFSET([省略]),[条件])>0,1,0)の戻り値とTRANSPOSE(F2:F6)の積を求めれば良いでしょう。 =SUM(IF(COUNTIF(OFFSET(A1:E1,TRANSPOSE(ROW(A1:A5)),0),">=50")>0,1,0)*TRANSPOSE(F2:F6)) 数式の確定時にShift+Ctrl+Enterの打鍵が必要です。 添付画像は5列×10行を対象に50以上の値でF列のFlagはA列からE列に10未満が無い行に1を立てたものです。 解1=SUM(IF(COUNTIF(OFFSET(A1:E1,TRANSPOSE(ROW(A1:A10)),0),">=50")>0,1,0)*TRANSPOSE(F2:F11)) 解2=SUM((MMULT(INDEX((A2:E11>=50)*1,0),TRANSPOSE(COLUMN(A1:E1)/COLUMN(A1:E1)))>0)*(F2:F11)) 解3=SUM(IF(COUNTIFS(OFFSET(A1:E1,TRANSPOSE(ROW(A1:A10)),0),">=50")>0,1,0)*TRANSPOSE(F2:F11)) 解4=SUMPRODUCT((MMULT(INDEX((A2:E11>=50)*1,0),ROW(A2:A6)/ROW(A2:A6))>0)*F2:F11) 解1、解2、解3の確定時にはShift+Ctrl+Enterキーの打鍵が必要です。 解4のみEnterキーで確定可能です。
>この設定では、例えば<40としたとき40歳未満から10歳代までのすべての数が反映されてしまいます。 そうならないように提示の数式で条件を定義しています。 =COUNTIFS([条件範囲1],[条件1],[条件範囲2],[条件2],[条件範囲3],[条件3]) 条件範囲1と条件1ではC2:C15の範囲から男女の性別を、条件範囲2と条件2ではD2:D15の範囲からC19へ入力された条件の年齢を、条件範囲3と条件3ではD2:D15の範囲からC19に入力された条件を元に〇〇歳以上の条件を算出した結果で絞り込んでいます。 [条件3]=">="&IF(C19=">=100",100,SUBSTITUTE(C19,"<","")-10) C19に"<40"を代入すると次のようになります。 [条件3]=">="&IF("<40"=">=100",100,SUBSTITUTE("<40","<","")-10) 　　　　↓　SUBSTITUTE関数の結果を置き換える [条件3]=">="&IF("<40"=">=100",100,40-10) 　　　　↓　IF関数の結果を置き換える [条件3]=">="&30 　　　　↓　&演算子の結果を置き換える [条件3]=">=30" 従って、条件2と条件3を合わせると30以上40未満になります。
元データ　B列に年齢、C列に性別があり 検索条件　H列に以上の数値、I列に未満の数値、J1に男、K1に女となってるとして J2の数式は =COUNTIFS($B:$B,">="&$H2,$B:$B,"<"&$I2,$C:$C,J$1) これをJ:K列の必要なセルにコピーしてください。
例として A2:A32が範囲として、選択 ホーム＞条件付き書式＞新しいルール＞数式を使用して、書式設定をするセルを決定 「次の数式を満たす場合に値を書式設定」蘭に =AND($B2<>"",$B2>=0) [書式(F)...]をクリックして、塗りつぶしで色を選択
言ってしまえば、その関数についてどれだけ知っているのかが問われることになるでしょう。例えば三角関数で正弦波のグラフを書きたいと思った場合、三角関数について知らなければ、グラフの元データを求める式が書けませんよね。 なので関数について理解していさえすれば、後は単純にExcelのグラフ機能について調べれば良いので、それこそ　excel グラフ　とかでググれば答えはいくらでも出てきますよ。 逆に関数を理解していない場合は、必要なのはExcelではなく数学の知識です。
切片は１に固定なんでしょうか？ 1) x,yの範囲を選択。 2) 「挿入」リボン、グラフ、散布図を挿入。 　　グラフが表示される。 3) グラフを右クリック-[近似曲線の追加] 4) 「近似曲線の書式設定」で近似または回帰の種類に「多項式近似」、次数「2」を選択。 　　切片に「1.0」を指定。 　　グラフに数式を表示するをＯＮ。 では。
そういう風に近似できるのは nの値が十分に大きい場合であって、 nが小さいときに誤差が大きいのは当然でありましょう。
こんにちは、No1です。 Book1のセルB5に =VLOOKUP(A5,INDIRECT("Book2.xlsx!第"&$A$1&"シーズン"),3,FALSE) です。 但し、前記した通り、Book2を開いてないとエラーになります。 Book2を開いておけないなら、マクロでの処理になるかと思います。
VLOOLKとなにの関係があるのかわかりませんが =if(E4="","",E4*0.2772) もし、E4にデータが入っていなければデータなし、入っていなければE4*0.2772という意味です。 ""は何もデータが入っていないという意味になります。 > ＝Ｅ8＊2」の式）は > =IF(E8="","",E8*2) 単純に＝Ｅ8＊2だとE8にデータがない場合0が表示されるのでそれを抑制したい場合は =IF(E8="","",E8*2)にします。 また、E8に数値以外が入った場合#VALUE!になるので 2007以降 =IFERROR(E8*2,"") 2007まで =IF(ISERROR(E8*2),"",E8*2) にします。
今思い出したのですが > １　アイコンをクリックするとPC画面の左上に写真１のような画面が出てきます このときに□をクリックしないで、その小さな左上の部分の端にカーソルをもっていくと矢印カーソルに変化して大きさが変更できないでしょうか。また、□の左のエクセルのアイコンをクリックしたらメニューが出てサイズ変更とか出てこないでしょうか。 また、 > ３の方は右上のー、どちらを押しても全画面か画面が見えなくなるかのどちらかしか選べません。 二重□の時に押すと見えなくなるのでしたら、画面の外に出ている可能性がありますので以下のページの操作をしてみてください。 https://digitalfan.jp/37822
一度、循環参照ツールを使用して、 どのセルがどのセルを参照しているか確認してみてはいかがでしょうか。 もし、エラーが見つからないようであれば、 ファイルそのものが部分的に壊れている可能性があるので 新しいファイルを作成して、再度書き起こしてみてはいかがでしょうか。
世の中の並べ替えルールは細かなところまで考えるといろいろとバリエーションがあり，統一されていません。その中で最も権威があるのはJIS X4061でしょう。 JIS X4061を要約すると 1.仮名をすべて基底文字に置き換える。たとえば，あ，ぁ，ア，ァはすべて「あ」に置き換えます。 2.長音記号はすべて直前の基底文字の母音に置き換えます。たとえば，「ー」は「あかさたなはまやらわ」の次にある場合には「あ」になります。 3.1文字目から前後関係を決定していきます。文字がない場合は文字がある場合よりも前になります。 4.同順位の場合には，置き換えた文字を元に戻して前後関係を決定します。このとき清音＜濁音＜半濁音，長音記号＜小文字＜繰返し記号＜大文字，平仮名＜片仮名とします。 なお，エクセルは完全にJIS X4061と同一ではないと思われますが，詳細はよくわかりません。
例えば、 ・マクロの記録開始をクリック。 ・C列を選択。 ・右クリック-[セルの書式設定] ・「表示形式」の「分類」を数値に、「桁区切り(,)を使用する」をＯＮでＯＫ。 ・マクロの記録終了 すると、 Columns("C:C").Select Selection.NumberFormatLocal = "#,##0_ " ってマクロが記録されます。
1行でも複数のセル範囲を配列に代入すると2次元配列になり、配列添字の初期値は1になります。 myarray = Range("A1:A3").Value For i = 1 To UBound(myarray, 1) MsgBox myarray(i, 1) Next 横方向のデータの場合は myarray = Range("A1:C1").Value For i = 1 To UBound(myarray, 2) MsgBox myarray(1, i) Next myarray = Range("C1").Value は myarray = "1,2,3" と同じですのでmyarrayは配列ではなく文字列として扱われます。 Debug.Print TypeName(myarray) で確認できます。 myarray = Split(Range("C1").Value, ",") For i = 0 To UBound(myarray) MsgBox myarray(i) Next
>COUNTIFS関数でいろいろやってみたのですがうまくいきませんでした。 あなたが失敗した原因を見つけるには使った数式を提示された方が良いでしょう。 =COUNTIFS([条件範囲1],[条件1],[条件範囲2],[条件2]) 提示されたSheetでは[条件範囲1]と[条件範囲2]はA3:F4となり、[条件1]は"<="&H3、[条件2]は">="&H4とすればよいでしょう。 尚、「H3～H4の間に入る数値の個数」とは「H3以上でH4以下のセル数」ですか？ 提示の数表ではA3:F4の中にH3とH4の値と一致するセルがないので条件で"<="と"<"を厳密に区別する必要はありませんが同じ値があるときはどちらにするかを明確にする必要があります。 添付画像はExcel 2013で検証したものですがExcel 2007でも再現できるはずです。 I3=COUNTIFS(A3:F4,"<="&H3,A3:F4,">="&H4)
(1) どのように入手されたものかわかりませんが日本マイクロソフトが販売しているリテール版の日本語版Excelなら2台のPCにインストールできます。但し使用できるのは同一人物のみです(2台のPCにインストールして2人で使用する事はできません)。 (2) 次のurlを参照してください。 https://support.office.com/ja-jp/article/Office-%e3%82%92-PC-%e3%81%be%e3%81%9f%e3%81%af-Mac-%e3%81%ab%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab%e3%81%99%e3%82%8b-4414eaaf-0478-48be-9c42-23adc4716658?ui=ja-JP&rs=ja-JP&ad=JP
こんにちは、No1です。 ごめんなさい、ちょっと意味が分からないです。 普通にShapeを選択して右クリックでテキストの編集や切り取り って出来ないのですか？ また、「ある関数を動かす」というのはマクロの実行とは違うのでしょうか？
DIR関数を利用してみてはいかがでしょう。 Dir関数でサブフォルダを取得する http://officetanaka.net/excel/vba/tips/tips95.htm
解決策 https://www.google.co.jp/search?q=excel+%E6%97%A5%E4%BB%98+%E6%9B%B8%E5%BC%8F+%E5%A4%89%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84&oq=Excel+%E6%97%A5%E4%BB%98+%E6%9B%B8%E5%BC%8F+%E3%81%8B%E3%82%8F%E3%82%89&aqs=chrome.1.69i57j0.13964j0j4&client=ms-android-sonymobile&sourceid=chrome-mobile&ie=UTF-8 上記のURLを開いて、上から順に確認してください。 解決出来ない場合、上記の確認で質問に足りないと気づいたものを捕捉してください。
条件付き書式の対象がC16:H16ということなので、夫々のセルのが対象範囲のセルの値の小さい順で2番目と同じ値のとき塗りつぶしの色を他のセルと違う色にするのでしたら、条件の数式を次のようにします。 =C16=SMALL($C$16:$H$16,2) この数式でSMALL関数の第1引数$C$16:$H$16は範囲を固定しなければならないのでセルの番地を絶対番地とします。 塗りつぶしの要否を判定するセルのC16は1つだけではなくC16からH16までの6個であり、相対位置として夫々セルを評価しますので相対番地を指定します。 添付画像はExcel 2013での検証ですがExcel 2010でも再現できるはずです。
>求めたかったのは「1回でもXX点以上をとった人の数」なのです。例えばB12は、A君～E君全員が10点以上を1回でもとっているので5。B13の20点も全員が1回でもとっているので5。B14ではA君、C君、E君の3人が30点以上を1回でもとっているので3。という数式を求めたいのです。 自分が考えていることを第三者に伝えることは難しいですね。 B12へ次の数式を設定して、下へオートフィルコピーしてください。 =SUMPRODUCT((MMULT(($B$4:$F$8>=A12)*1,ROW(A$4:A$8)/ROW(A$4:A$8))>0)*1) 添付画像はExcel 2013で検証した結果です。
表示する項目列が右にある場合はVLOOKUP関数が使えますが、左の場合は使えません。 完全一致でく、比較対象（基準値）が数値の昇順なら下記の方法が楽でしょう。 =LOOKUP(E2,B2:B6,A2:A6) ※上記では、数値が0の時はエラー、51以上は5が表示されます。 ※それらを除外するならIF文で制御するなり、E2に入力規則で整数の範囲を1～50にしてください
No3です 表の例のレイアウトが崩れたので再掲 B列　　　C列 1000　　1500 3000　　3000 5000　　5000
こんにちは。お邪魔します。 ＃原稿書いている内に同趣旨、類似のご回答が先着していますが、 　拙稿後段に重みを置いて書いているつもりなので、 　以下原文ままあげてみます。 > If InStr(.Cells(Line, 10), "test1") > 0 And InStr(.Cells(Line, 10), "test2") > 0 Then '(1) > If InStr(.Cells(Line, 10), "test1") And InStr(.Cells(Line, 10), "test2") Then '(4) この２つは同じ結果を返すと思っていたら 期待した結果と違う場合が多い、 その理由は？ というお話としてお応えします。 解り易くする為に、Instr関数の戻り値をそれぞれ、 　InStr(.Cells(Line, 10), "test1")　→　1 　InStr(.Cells(Line, 10), "test1")　→　6 とした例で、書き換えてみます。 　If 1 > 0 And 6 > 0 Then '(1)n 　　　　1 > 0 　　　の演算結果は、論理値　True　です。 　　　　6 > 0 　　　の演算結果は、論理値　True　です。 　　　したがって、 　　　　True And True 　　　の演算結果として、論理値　True　が返ります。 　 If 1 And 6 Then '(4)n 　　　　1 And 6 　　　の演算結果は、長整数型　0　です。 　　　したがって、If文の内側の論理式は結果として 　　　　False　を返します。 　　数値1 And 数値2 のように書くと、数値1と数値2を 　　ビット演算 した結果を返します。 ビット演算について詳しいことはご自身で調べてみて下さい。 簡単にいうと、数値を二進数として扱うとして、 ２進数の各桁ごと共通して 1 である桁、 の数値を返すのがAnd演算子です。 例えば、 　　1 And 2 は、二進数では、0001 0010 ですから、 各桁ごと共通して 1 である桁がないので、結果は　0 　　3 And 2 は、二進数では、0011 0010 ですから、 各桁ごと共通して 1 である桁は、二の位なので、結果は　2 　　7 And 6 は、二進数では、0111 0110 ですから、 各桁ごと共通して 1 である桁は、二の位と四の位なので、結果は　6 そして例示に戻って、 　　1 And 6 は、二進数では、0001 0110 ですから、 各桁ごと共通して 1 である桁がないので、結果は　0 になります。 　 If 1 And 6 Then '(4)n は、 　 If 0 Then '(4)nn と同じ意味で、論理値へキャストされた結果 　 If False Then '(4)b という意味になります。 恐らく、Or演算子では問題にならなかったものが、 何故And演算子では問題になるのか、という疑問が、 ご質問の本質なのだと思いますが、 Or演算子は二進数として扱った場合の、 各桁のどちらかが 1 であるならば、 その桁は 1 という風に、各桁の重複を無視した和を求めます。 和を求める以上、 　　数値1 Or 数値2 数値1または数値2のどちらかが 0 でない数値ならば、 結果が 0 になることはないのです。 例えば、 　　1 Or 2 　→ 0001 Or 0010 → 0011 → 3 　　3 Or 2 　→ 0011 Or 0010 → 0011 → 3 　　7 Or 6 　→ 0111 Or 0110 → 0111 → 7 　　1 Or 6 　→ 0001 Or 0110 → 0111 → 7 　　0 Or 0 　→ 0000 Or 0000 → 0000 → 0 といった具合。 0 以外の数値を論理式に渡した場合は、 　 If True Then '(4)b という意味になります。 And演算子を使う場合は、 > If InStr(.Cells(Line, 10), "test1") > 0 And InStr(.Cells(Line, 10), "test2") > 0 Then '(1) のように、論理値同士を演算させるのが必須です。 > If InStr(.Cells(Line, 10), "test1") And InStr(.Cells(Line, 10), "test2") Then '(4) のようにビット演算を用いるのは間違いです。 Or演算子については、（数値同士を演算させる場合は） If InStr(.Cells(Line, 10), "test1") Or InStr(.Cells(Line, 10), "test2") Then If InStr(.Cells(Line, 10), "test1") > 0 Or InStr(.Cells(Line, 10), "test2") > 0 Then どちらも同じ結果を返します。 この場合に不等号を使うべきか使わないでいいのか、 意見は分かれるところでしょうけれど、 私は、不等号省略する派、ですが、 And、Or、両方使う場合は、論理演算なのかビット演算なのか明示する意味 で、不等号で統一する場合も少なくないです。 Orの場合に限っては、どちらでも書ける、と覚えておけば、 人様のコードを読む時に困らないで済む、ということだけは ハッキリと言えることです。 以上、ご参考まで。
EXCEL2007以降であれば、COUNTIFS関数が便利です。 シート1!A1=IF(COUNTIFS(シート2!B:B,B1,シート2!C:C,C1),"☆","")
多分ですがAE10ガ空白なのでは？列の最終はAEで固定でしょうか？ 固定でいいなら Range("AA1", "AE & RANGE("AA1").End(xlDown).Row).Select でいいのでは？
https://www.kingsoft.jp/office の惹句を読めば、貴方への回答はＹＥＳになろうかと。 人に聞くより、体験版を無料ＤＬして、ご自身で確かめませう！
エクセルに限らず、この手の製品には表のサンプル（テンプレート）があるので参考にしてみては？ https://templates.office.com/ja-jp/templates-for-Excel http://www.bizocean.jp/doc/search/all/xls/ http://www.juno-e.com/ http://www.all-excel.net/ あと、印刷の有無というのもあります。 印刷しないで見せるだけの場合と、印刷しての配布が必要な場合です。 配色によっては、印刷されたものは見づらい組み合わせもあります。
D2に =IF(A2="",D1+1,0) として下方にコピーすれば、D4に0が入るけど、後はお望みのように数値が入ります。
良く使うものは覚えられます。 人によって良く使うものは異なるでしょう。 私が覚えいているのは Ctrl＋C　コピー Ctrl＋X　切り取り Ctrl＋V　貼り付け Ctrl＋Z　直前の操作を元に戻す Ctrl＋D　上のセルをコピー Ctrl＋S　上書き保存 ぐらいです。 ついでに ツールバーをカスタマイズして良く使うコマンドを並べています。 コマンドの近道（ショートカット）ですね。 http://allabout.co.jp/gm/gc/297722/2/ ２００３以前なら http://www.wanichan.com/pc/excel/2003/12/483.html 私は２００３以前のエクセルを使っています。 印字範囲設定・入力規則・=・入力規則・整列などを追加しています。 入力規則で列・行・セルを オフ（英語モード）・ひらがな に設定しておくと入力が楽になります。 http://www.atmarkit.co.jp/ait/articles/0709/14/news139.html
=ROWS(A1:A5)-COUNTBLANK(A1:A5) まあ、行数が5とわかってるなら =5-COUNTBLANK(A1:A5) でOKですけど。。。
すでにエクセルで多くの作業を行ってきているからです。 エクセルを終了させたあとも同じようになる場合は、終了できないプロセスが残っている可能性があります。タスクマネージャーを起動して、プロセスでExcelを終了してください。 これをやると作業途中のものも全部落ちるので注意してください。
以下で問題があるようならば、もう一度確認してみます。 ADOを使用してExcelのデータを操作する場合は いろいろ制約がありますね。 Accessならばほとんど問題はないのですが。 一応、補足の T_登録者名 No,登録者名 1,佐藤 2,鈴木 T_訪問者 No,日付,摘要,訪問者名 1,0601,訪問者,鈴木 1,0601,利用料,300 の場合に動く方法は以下のようです。 すべてを確認していないのでその点はご容赦を。 なお、レジストリをいじくる方法もあるかもしれませんが、 確認はしていません。 DAOは何の制約も無くデータを取り出すようです。 (1) ADOでExcuteを使用する場合。 IMEX=1をExtended Propertiesに追加。 Sub test1() Dim cn As ADODB.Connection Dim strSQL As String Dim rs As ADODB.Recordset strSQL = "SELECT * FROM [T_訪問者$] WHERE (NOT EXISTS " & _ "( SELECT * FROM [T_名簿$] WHERE [T_名簿$].登録者名 = [T_訪問者$].訪問者名) " & _ " AND [T_訪問者$].摘要='訪問者');" Set cn = New ADODB.Connection cn.Open "Provider=Microsoft.Jet.OLEDB.4.0;" & _ "Data Source=" & ThisWorkbook.FullName & ";" & _ "Extended Properties='Excel 8.0;HDR=YES;IMEX=1'" cn.CursorLocation = adUseClient Set rs = cn.Execute(strSQL) MsgBox rs.RecordCount rs.Close: Set rs = Nothing cn.Close: Set cn = Nothing End Sub (2) DAOを使用する場合。 IMEX=1をExtended Propertiesに追加。 Sub test4() Dim db As DAO.Database Dim rs As DAO.Recordset Dim strSQL As String strSQL = "SELECT * FROM [T_訪問者$] WHERE (NOT EXISTS " & _ "( SELECT * FROM [T_名簿$] WHERE [T_名簿$].登録者名 = [T_訪問者$].訪問者名) " & _ " AND [T_訪問者$].摘要='訪問者');" Set db = OpenDatabase(ThisWorkbook.FullName, False, False, "Excel 8.0;HDR=YES;IMEX=1") Set rs = db.OpenRecordset(strSQL) If rs.RecordCount > 0 Then rs.MoveLast rs.MoveFirst End If MsgBox rs.RecordCount rs.Close: Set rs = Nothing db.Close: Set db = Nothing End Sub
> 写真のようにPとVが空白セルなのに〇がついていまいました。 画像が不鮮明で見えなかったですし、現在は画像がありません。 =IF(OR(I1="",AND(P1="",V1="")),"",IF(OR(P1="",V1=""),IF(OR(V1>I1,P1>I1),"○",""),IF(AND(V1>I1,P1>I1),"○",""))) この式でですか。実際に空白(データがない状態)ですか、もしかしてスペースキーで空白のスペースを入れて見た目が何もないようにしていませんか(もしそうなら、余程の理由がない限りそのようなことはやめましょう)
数式でやる場合は =INDIRECT("A"&COLUMN(A1)) とか =INDEX($A:$A,COLUMN(A1)) とか =OFFSET($A$1,,,COLUMN(A1)-1,0) ですね。 さもなければ縦方向に連続データ作成後に、コピーして 形式を選択して貼り付けで行列を入れ替えるでOKですね。
こんにちは フィールドのプロパティの設定で出来るのかどうかが今は分からない のですが、マクロでも良ければ、シートタブを右クリックしてコードペインを 表示して、 Private Sub Worksheet_Calculate() 　 Columns("B:C").ColumnWidth = 15 End Sub とかでも出来ますけど、ダメでしょうか？
この質問には、２つの問題点があるのだろうと思う （１）飛び離れた２列の入力規則設定があるものの（入力規則だけの）コピー （２）複数シート（かつ多数シートに対し）に入力規則だけ貼り付け やってみると A列とC列に入力規則設定してみる。 A列からC列まで範囲指定して コピー （貼り付け先シート指定として） 複数シート選択（SHIFTキーを押しながら、はじめびシートタブと終りのシートタブをクリック。From-To連続位置のシート） (SHIFTキーを押して任意のシートタブを選択。個々のタブ指定） 形式を選択して貼り付けー入力規則 これでうまく行ったが、中間のB列に張り付けたくない入力規則がある場合は、上策ではない。 A列とC列をCTRLキーを押しながらコピーして（B列の範囲指定は避けて）貼りつけると、A,B列に貼りついてしまった。 飛び離れた列をそのままコピーし貼り付けの方法が、あるのかどうか、思い出せない。 http://oshiete.goo.ne.jp/qa/6755608.html にあるように方法がないようだ。 しかし、A列とC列を別単位の操作として２回やれば問題ないだろうとは思う。 ーー VBAなど使い、シート単位の繰り返し法（For　Eachを使い)を使えば疑問はないとは思うが、質問者にはお呼びでないだろう。
単純に =MIN(I2,P2,V2) でできませんか？ セルが数値以外（空白or論理値or文字列）の場合は無視されます。
エラートラップ自体が無効になっているように思えます。 VBEからツール→オプションでオプション画面を開き「全般」タブを見てください。 「エラートラップ」の項目が『エラー発生時に中断』になっていませんか？ 『エラー処理対象外のエラーで中断』を選択するとエラートラップが有効になります。 なお、Math自体は変数：strTimeが文字列でWS_data.Range("G:G")のデータが日付のシリアル値なのでエラーが発生しているように思えます。
> 定番の　　Range("E" & Cells.Rows.Count).End(xlUp).Row + 1 > を使用するため、何とかマクロで行いたいと思いました。 E1にデータが入っていない場合(一番最初の実行時)にはE2からデータが入りますので、その処理をIF文で分けてみました(他に方法があるかもしれませんがちょっとわからないので) 取り敢えず参考までに(極力セルにアクセスせずに変数にデータを入れてループ処理し、その後一括でセルにデータを代入しています) Sub Example() Dim Mydata() As Double Dim Divisor As Double Dim x As Long Dim i As Long x = Range("A1").Value / Range("B1").Value - 1 ReDim Mydata(x, 0) Divisor = Range("B1").Value For i = 0 To x Mydata(i, 0) = Divisor * i Next If Range("E1").Value <> "" Then Range("E" & Cells.Rows.Count).End(xlUp).Offset(1, 0).Resize(x + 1) = Mydata Else Range("E1").Resize(x + 1) = Mydata End If End Sub
こういうのはVBAでやるべし。仕事にエクセルを使うならVBAができなければ、困難に出くわすのは必至。 ーー 質問者は、関数しかできないのか、関数が好きなのか、他に理由があるのか、下記に関数でやってみるが苦労した。原理的に面白味はないが、位置調節のための式の部分の書き方に 時間がかかるだけ。VBAなら、番地を間違えないように代入式を書くだけなんだが。 例データ Sheet1の A1:D5 品名サイズ数量単位単価 a中12個2 b小3袋3 c大5本5 d中10ｍ7 Sheet2のA4の式 =OFFSET(Sheet1!$A$2,INT((ROW()-3)/3),0) B4の式 =OFFSET(Sheet1!$A$2,INT((ROW()-3)/3),1) C5の式 =OFFSET(Sheet1!$A$2,INT((ROW()-5)/3)+0,2) D6の式 =OFFSET(Sheet1!$A$2,INT((ROW()-5)/3)+0,3) E5の式 =OFFSET(Sheet1!$A$2,INT((ROW()-5)/3)+0,4) A4:E6をコピー A7:E15に貼り付け 結果 A7:：E15　列的に乱れるかもしれないのでシート上でやって結果を見てください。 a中 122 個 b小 34 袋 c大 56 本 d中 107 ｍ
なお「5月」のように、数字を「半角のまま」にしたい場合は =MONTH(A2) で構いませんが、そのセルの「表示形式」を「ユーザー定義」にして、形式を「0"月"」にして下さい。 また「月だけ表示したい」という場合は、素直に式を =A2 にして、そのセルの「表示形式」を「ユーザー定義」にして、形式を「m"月"」にする、でも構いません。
それでは PC から Office 2016、Office 2013、または Office 365 をアンインストールする https://support.office.com/ja-jp/article/PC-%E3%81%8B%E3%82%89-Office-2016%E3%80%81Office-2013%E3%80%81%E3%81%BE%E3%81%9F%E3%81%AF-Office-365-%E3%82%92%E3%82%A2%E3%83%B3%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B-9dd49b83-264a-477a-8fcc-2fdf5dbf61d8 から　オプション２　の中の Easy Fix ツールを使用して、Office を完全にアンインストールする を使用して完全アンインストールしてください。 再起動後、Office2013を再インストールしてください。 再インストール時にはプロダクトキーが必要です事前に準備してください。
こんにちは。 自分では試したことがないのですが、検索したところ下記のページが見つかりました。 ■色付きセルのみを合計する　［SumColor] http://excel-magic.com/post-41/ ■色付きセルの合計 http://hamachan.info/win7/Excel/iro_count.html 前者はマクロ、後者はフィルターを使う方法のようです。 ご参考まで。
添付の表をエクセルに入れて、お勧めグラフをクリックしてみてください。
[No.1お礼]へのコメント、 》 こういう風に、変更を強制するMSが嫌いです 「強制」か「強行」かは知らないけど、同感です。 ライバルの Lotus社を駆逐するまでは、他ソフトとの互換性を重視するためとか何とか言って、幻の閏日やヘルプなしの DATEDIF関数を踏襲して来た癖に、ライバルがいなくなると唯我独尊的な振る舞いになっているかも。
マクロを作成する必要はありません。 https://www.microsoft.com/ja-jp/atlife/tips/archive/office/tips/002.aspx マクロと言うよりはＶＢＡで記述したいならば、単純にA列の値を一つ一つ比較して重複していたらその行を削除すれば良いです。
RAND関数を使うのでよければ C列に氏名、B列に=RAND()　としてB2:B91に乱数を発生させます。 A列で =RANK($B2,$B$2:$B$91) とすればA2:A91に1～90の順列ができます。 後はVLOOKUP関数で1～3,4～6・・・88～90でC列の氏名を抽出すればいいでしょう。 ※RAND関数は再計算ごとに変化します。 ※抽出後の結果を固定するなら、VLOOKUPの結果をコピーして値として貼り付けを行ってください。
こんにちは。 GetObject(mydoc).Application.Quit 0　　'　　0 = wdDoNotSaveChanges みたいなことでしょうか。 この場合、.DisplayAlerts には触らなくていいです。 余談ですが、 やりたい内容によっては、 　そのドキュメントが開いているなら、 　　　そのまま名前を付けて保存する 　開いていないなら、 　　　ご提示のようにリネームしてから開く というような分岐をする手もあるかもです。 閉じて、即開く、という処理が、必ず同期が取れるものなのかどうか、 私には確信が持てないので、どうしても閉じて開くなら、 ある程度のWaitを挟んだ方が安心なのかも知れません。 また、 On Error GoTo ErrorHandler と対になる On Error GoTo 0　等の　次のエラーステートメント が見当たりませんし、 Name mydoc As mydoc の行で起こりうる実行時エラーは、 「mydoc編集中」以外にも想定できる筈ですから、 そこら辺の事は十分に手当てしてあげて下さいませ。
時間がA列として、B2に =IF(A2>0,TEXT(FLOOR(A2,"0:0:20"),"[SS]")&"-"&TEXT(CEILING(A2,"0:0:20"),"[SS]"),"")
環境によっては期待した結果にならない場合もあります。 Windows7 & Excel2010(32bit) の場合です。 #2 の回答にあるようにフルパスで指定 （パス中にスペースがあるのでダブルクォートで囲む必要があります。） "C:\Program Files (x86)\Microsoft Office2010\Office14\EXCEL.EXE" その他には start excel.exe や start d:\tmp\abc.xlsx で開きたいファイルを指定。 ファイルのパス中にスペースがある場合は start "" "d:\tmp p\abc.xlsx" とか・・・。
こんにちは シートを表示して実行するとして、 Sub test() 　　Dim r As Range 　　Dim c As Long 　　Dim d As Long 　　Dim h As Variant 　　Dim i As Variant 　　Dim w As Variant 　　Dim l As Variant 　　Dim j As Variant 　　 　　l = Range("B1").Left - 6 　　w = 5 　　i = 1 　　 　　Set r = Range("A1") 　　 　　For c = 1 To Range("A1", Range("A" & Rows.Count).End(xlUp)).Cells.Count 　　　　d = 1 　　　　i = r(c, 1).Top + 1 　　　　Do While r(c, 1).Value = r(c + d, 1).Value 　　　　　　d = d + 1 　　　　Loop 　　　　h = r(c + d, 1).Top - i 　　　　 　　　　If d > 1 Then c = c + d - 1 　　　　If d > 1 Then ActiveSheet.Shapes.AddShape(msoShapeLeftBracket, l, i, w, h). _ 　　　　　　Select 　　Next End Sub こんな感じで出来ますか？
「あいう＊えお」の場合、「あいう」と「えお」に分ける、すなわち、分割する文字は、必ず全角の「＊」である、という条件で（「＊」がなくても問題ありません）、以下のマクロを組みました。 Option Explicit Sub Test() Dim c, i, j, ra, rb As Integer Dim sa, sb, s1, s2 As String ra = Worksheets("SA").Range("C1").End(xlDown).Row rb = Worksheets("SB").Range("B1").End(xlDown).Row For i = 1 To ra sa = Worksheets("SA").Cells(i, 3).Value c = InStr(sa, "＊") If c > 0 Then s1 = Left(sa, c - 1) s2 = Right(sa, Len(sa) - c) End If For j = 1 To rb sb = Worksheets("SB").Cells(j, 2).Value If c = 0 And InStr(sb, sa) > 0 Then Worksheets("SB").Cells(j, 3).Value = sa End If If c > 0 And InStr(sb, s1) > 0 And InStr(sb, s2) Then Worksheets("SB").Cells(j, 3).Value = sa End If Next j Next i End Sub
こんにちは、No1です。 ＞ただ問題がありまして、Sheet2のA列はマクロにて別bookからコピー =COUNTIF(INDIRECT("Sheet2!A:A"),Sheet1!C6) とするとどうですか？
こんにちは。 シンプルに、 　　 MsgBox Evaluate("起動Path").Value または 　　 MsgBox Application.Range("起動Path").Value という風に、参照先をExcelアプリケーション経由で取得します。 ブックレベルで定義した名前でしたらば、 Evaluateメソッドとの組み合わせが親和性が高いですね。 > Sheet1モジュール で > MsgBox Range("起動Path").Value がエラーになるのは、 　Sheet1.Range("起動Path") のように親オブジェクトを省略しないで書けば、 解るのではないでしょうか。 標準モジュールに書いた場合は 　Application.Range("起動Path") の省略形になりますから、エラーにはなりません。 以上です。
＞下記のように1が2つになってしまいました。 よく見かける初心者さんの失敗としては ＞数式で出された値1 この「数式」の具体的な中身が不明ですが，たとえば =IF(条件,"1","") などのように「文字列の”１”」を計算するような数式を書いています。 こういうときは =IF(条件,1,"") などのようにして「数値の１」を計算する数式にします。 もしもこのようなケースの場合は，あなたが記入している具体的な数式の内容を，たとえばじゃなく実際のエクセルからコピーして掲示してみると，具体的にその数式をどのように直せばよいのか適切な回答も寄せられます。 また同様の理由で ＞手動で入力した値1 このセルにたまさか「文字列の１」が記入されていたような場合も，同じようになります。 この場合，いくつかの１は数値で記入され，どれかの１は文字列で記入されているといった具合に混在している可能性もあります。 「文字列で記入された数字の１」と「数字で記入されている１」を見分けるのは，初心者さんには意外と難しい場合が多い（自分流で確認してみたけど確認できませんでした，という方が多い）です。 もしもこのようなケースの場合は，「自分流で確認してみた」じゃなく １．全部のセルの書式設定を標準に設定する ２．手入力で１が記入されているセルに，改めて１を記入し直す のように必ずしっかり手を動かして操作してから，改めてピボットテーブルレポートの更新をしっかりやり直してみます。
こんにちは。 > B列に契約先の種類を1と2で区別して、1か2の値を返したいです。 よくある話として、括弧の【全角/半角】の不統一や混在、という問題があります。 基データに対して、 括弧の【全角/半角】を統一する形で置換処理をしても構わないないなら、 より簡素な数式に出来ますけれど、取り敢えず、ASC()関数で半角統一してみます。 後はOR()関数と組み合わせて、左３文字の一致にて判別します。 　{"(株)","(有)","(同)"}の何れかで始まるならば、"1"、それ以外は"2"、を返す。 　=IF(OR(ASC(LEFT(A1,3))="("&{"株","有","同"}&")"),"1","2") 因みに、数値の1、または2を返したい場合は、 　=IF(OR(ASC(LEFT(A1,3))="("&{"株","有","同"}&")"),1,2) のようになります。 （配列を扱いますが配列数式ではないので、普通に扱えます。） こんな感じが扱い易くて簡単そうですけれど如何でしょう？
=SMALL((C8,C13,C18,C23,C28,C33,C38),FREQUENCY((C8,C13,C18,C23,C28,C33,C38),0)+1) でいかがでしょうか。
こんにちは。お邪魔します。 > ... 上手い やり方 ... "上手い"かどうかは主観的で相対的ですから、ピタリとした答えは難しいですけれど、 提案として、３例書いてみます。 まず、直接的な解として、ユーザー定義関数（ＵＤＦ）をお薦めします。 普通のExcel関数のように、 =CountIfAcross(Sheet1!B2,Sheet31!B2,"×") =CountIfAcross('#1'!B2,'#31'!B2,"×") 等の様に シート区間先頭セル、シート区間後尾セル、検索条件 を指定してカウントした数を返します。 こちらで用意したユーザー定義関数（多少汎用性を加味したもの）を この投稿の最後に掲げておきます。 現状の設計には手を加えずに数式一本で解決できるのがメリットですが、 ユーザー定義関数を使うには マクロ有効ブック（*.xlsm, *.xls）として保存する等、 基本的な扱い方が色々ありますので、 とりあえず後述する関数を[標準モジュール]に貼り付けてから、 実際のシート名を指定した数式をセルに書いて、実際に試してみて、 その上で、うまく出来ないようでしたら補足欄にでも書いてみて下さい。 次に、 > 31枚のシートの○と×を数値に 変換し、それを串刺し集計した いのです。 例示されたサンプルデータの"○"や"×"というのは、 「直接入力されたもの」なのか「数式の計算結果」なのか判りませんが、 もし後者なら、また違った可能性があるのかも、です。 何れにしても、 　　全シート上に作業セル範囲を設けて、 　　=FIND(B2,"○×")-1 　　または 　　=--(B2="×") 　　のような数式で一旦数値化して、この（作業セル範囲の計算）結果を 　　SUM関数で串刺しにする という風にするのが現状からはもっとも解り易く簡易なやり方かと思います。 第３の提案として、 > countifは串刺し集計 で使えないようですし、 入力作業の有り様によって、許されるなら、入力の時点で、 "○","×"の代りに、0,1を入力しておく方が何かと扱い易いです。 　　[セルの書式設定]>[表示形式]>[ユーザー定義]>[種類]　の入力欄に 　　[=1]"×";[=0]"○";G/標準 　　と入力して[ＯＫ] のように事前に（事後でも可）設定しておけば、 入力の時点で、0,1の数値を"○","×"に替えて表示、それ以外の値は普通に表示します。 表計算ソフトでの設計の仕方という点からすれば、 寧ろお奨めしたい方法です。勿論、そちらの条件として可能ならば、ですが、、、。 蛇足ですが、 [データ] ユーザー定義関数（ＵＤＦ） ▼この下から▼ ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ' ' // CountIfAcross()関数 - Excel.COUNTIF関数のシート串刺し版 のようなもの Public Function CountIfAcross(シート区間先頭セル As Range, シート区間後尾セル As Range, 検索条件 As String) Dim sRef As String, sRefE As String, c As Range, cnt As Long, i As Long 　　sRef = シート区間先頭セル.Address(0, 0) 　　sRefE = シート区間後尾セル.Address(0, 0) 　　If sRefE <> sRef Then sRef = sRef & ":" & sRefE 　　For i = シート区間先頭セル.Worksheet.Index To シート区間後尾セル.Worksheet.Index 　　　　For Each c In Sheets(i).Range(sRef) 　　　　　　If c.Text Like 検索条件 Then cnt = cnt + 1 　　　　Next 　　Next i 　　CountIfAcross = cnt End Function ' ' // ' ' 【CountIfAcross()関数 - シート上での数式使用例】（兼 動作仕様概略） ' ' ◆シート参照の注意点 ' ' 　・ノーマルなシート名である場合 ' '　=CountIfAcross(Sheet1!B2,Sheet31!B2,"×") ' ' 　・そのままではExcel数式に使えないシート名である場合（→ 'シングルクオート' で括る） ' '　=CountIfAcross('#1'!B2,'#31'!B2,"×") ' ' ※シート区間は、「再計算時の」実際の「シートの並び」として ' ' 　[シート区間先頭セル]シートと、[シート区間後尾セル]シートの間に並んでいるシート範囲です。 ' ' 　シート名の連続性を解釈して区間を採るようなことはしません。 ' ' ◆セル参照の例 ' '　 ・Sheet1:Sheet31 シート区間 の B2:F5 セル範囲 (総セル数 = シート数 * 20)を対象に "×"の数を数えます。 ' '　=CountIfAcross(Sheet1!B2,Sheet31!F5,"×") ' ' ※[シート区間先頭セル]は　「シートの先頭」　と　「セル範囲の先頭」　を ' ' 　[シート区間後尾セル]は　「シートの後尾」　と　「セル範囲の後尾」　を ' ' 　それぞれ指し示します。 ' ' ◆検索条件　ワイルドカードの使用例 ' ' 　・「～を含む」　ex.) "×"を含む ' '　=CountIfAcross(Sheet1!B2,Sheet31!B2,"*×*") ' ' 　・「～で始まる」　ex.) "×"で始まる ' '　=CountIfAcross(Sheet1!B2,Sheet31!B2,"×*") ' ' 　・「～で終る」　ex.) "×"で終る ' '　=CountIfAcross(Sheet1!B2,Sheet31!B2,"*×") ' ' 　・「[]の中の何れかと一致する」　ex.) "×"または"△" ' '　=CountIfAcross(Sheet1!B2,Sheet31!B2,"[×△]") ' ' ※ワイルドカードに相当する文字等、検索条件として、そのまま使えない文字もあります。 ' ' 　文字列"*"を検索する場合は、 ' '　=CountIfAcross(Sheet1!B2,Sheet31!B2,"[*]") ' ' 　等の様に、とりあえず角括弧で括れば、大抵は検索可能になります。 ' ' 　詳細に関しては、以下を参考に。 ' ' 　msdn >>> Office VBA 言語リファレンス > Visual Basic 言語リファレンス > 演算子 > 『Like 演算子』 ' ' 　https://msdn.microsoft.com/ja-jp/library/office/gg251796.aspx。 ' ' ◆注意点 ' ' 　・循環参照にならないように！！（シート区間、セル範囲の参照、両方に注意） ' ' 　・外部ブックへの参照は想定していません。（正しく機能しません） ' ' 　・エラー値を含む範囲を参照した場合はエラー値をカウント対象外にしたカウントを返します。 ' ' 　・「シートの並び」を変更した時は、新しい区間に対する自動計算は行いません。手動で再計算を。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
TRIMMEAN関数を使ってみては？ データ全体の上限、下限から一定の割合を除いた平均を出す関数です。 例えばA列にデータが入っているならこんな感じです =TRIMMEAN(A:A,20/COUNT(A:A)) 除外する割合を20/COUNT(A:A)とする事で上下10個を除外します。
Excel 2007 以降でしたら、「COUNTIFS」という複数条件の判定ができるカウント関数で、参考URLのように実行できます。 COUNTIFの複数条件 COUNTIFS関数【Excel・エクセル】 http://www.becoolusers.com/excel/countifs.html
こんにちは。 マクロを教わるのは、 翻訳や清書を頼むようなものですから、 <どんなことを書き表したいのか> <何をしたいのか> という、 自分しか知らないことを十分に伝えること をもっと意識するようにしてください。 画像を添付するにしても、 直接目にしたことのない者にとって、 どこまで読み取れるだろう、という想像力を持って、 見やすい画像にすることも大事ですね。 　デジタルライフ > Windows > その他(Windows) > 『EXCEL マクロの指定の仕方』 　http://okwave.jp/qa/q9181693.html あちら↑の説明も読んでみて、類推した内容でお応えします。 ひとまずは、 [実行マクロ単一セル用]の行指定を書き換えるなどして、 試してみて下さい。 試した結果が、お望みと違うようでしたら、 　何が伝わっていなくて、何が誤解されているのか、 　想像した上で説明を尽くすようにするか、 　求める結果と実行結果の相違を明らかにするなど、 補足してみて下さい。 [実行マクロ複数セル用forループ版]の方は、 応用的な使用例、ということになります。 設問への理解が至っていませんから、 こちらからは、特に説明を加えません。 まず、そちらで確認してみた上で、 解らない部分についてご質問あれば、またお応えします。 ' ' // Sub 実行マクロ単一セル用() 　　LetLineColor 行:=2 End Sub ' ' // Sub 実行マクロ複数セル用forループ版() Dim i As Long 　　For i = 2 To Sheets("Sheet1").Cells(Rows.Count, "D").End(xlUp).Row 　　　　LetLineColor 行:=i 　　Next i End Sub ' ' // Sub LetLineColor(行 As Long) Dim wks1 As Worksheet Dim rngStart As Range Dim rngEnd As Range Dim TargetValueS, TargetValueE, nColor As Long Dim BX As Single, BY As Single, EX As Single, EY As Single 　　With Sheets("Sheet1") 　　　　TargetValueS = .Cells(行, "D") 　　　　TargetValueE = .Cells(行, "E") 　　　　If TargetValueS = "" Or TargetValueE = "" Then Debug.Print 行; "行", "EmptyParam!!": Exit Sub 　　　　 　　　　If IsError(.Cells(行, "F")) Then Debug.Print 行; "行", "Color'sError": Exit Sub 　　　　nColor = -1 　　　　Select Case UCase(.Cells(行, "F"))　'　大文字に直してから判別 　　　　Case "RED": nColor = RGB(255, 0, 0) 　　　　Case "GREEN": nColor = RGB(0, 255, 0) 　　　　Case "BLUE": nColor = RGB(0, 0, 255)　'　以下、適宜追加可 　　　　End Select 　　　　If nColor = -1 Then Debug.Print 行; "行", "Color??": Exit Sub 　　End With 　　With Sheets("Sheet2") 　　　　Set rngStart = .Cells.Find( _ 　　　　　　　　　　What:=TargetValueS, _ 　　　　　　　　　　LookIn:=xlValues, LookAt:=xlWhole, _ 　　　　　　　　　　SearchOrder:=xlByRows, SearchDirection:=xlNext, _ 　　　　　　　　　　MatchCase:=False, MatchByte:=False) 　　　　If rngStart Is Nothing Then Debug.Print 行; "行", "NotFound!! ""Start"":" & TargetValueS: Exit Sub 　　　　Set rngEnd = .Cells.Find( _ 　　　　　　　　　　What:=TargetValueE, _ 　　　　　　　　　　LookIn:=xlValues, LookAt:=xlWhole, _ 　　　　　　　　　　SearchOrder:=xlByRows, SearchDirection:=xlNext, _ 　　　　　　　　　　MatchCase:=False, MatchByte:=False) 　　　　If rngEnd Is Nothing Then Debug.Print "NotFound!! ""End"":" & TargetValueE: Exit Sub 　　　　BX = rngStart.Left + 10 　　　　BY = rngStart.Top 　　　　EX = rngEnd.Left + rngEnd.Width 　　　　EY = rngEnd.Top + 10 　　　　With .Shapes.AddLine(BX, BY, EX, EY).Line 　　　　　　.ForeColor.RGB = nColor 　　　　　　.Weight = 3 　　　　　　.EndArrowheadStyle = msoArrowheadTriangle 　　　　End With 　　End With End Sub ' ' //
RemoveDuplicates　メソッドに、削除の優先（指定）順序を記述するパラメータ（引数）がない以上）、あれこれ考えても、ここに質問しても、無駄でしょう。RemoveDuplicatesメソッドでは、あとに残る１データは、最初行か最終行のどちらかにちがいないのだから、逆手に取ってデータを残すほうにデータ順序を持って行っておく（変えておく）しかないだろう。 その方法を取るかまたは、このメソッドを使わず、優先キー（重複を考えている項目）＋日付でソートして、 （１）ＣｏｕｎｔＩＦ的な判別法で２になった行は削除 （２）重複を考える項目で、ソートしておいて、直前との同一を見る方法（第２以後の出現は削除）ー最初が残る などで重複を判定して、削除すればよい。 （１）では、ソートしておかないと、新しいものを残すロジックはむつかしい。 後者の２者比較で重複がわかったとき、日付を比較して、新しい（日付シリアル値的に大）法を残す手もある。（ＭＡＸやＭＩＮのレコードを見つけるロジックと同じ。） ーー 重複しているかどうかは最後のレコードまで読まないと判定できないのだから、ソートしておく方法（そこに処理時間を押しつける）が一番ロジック的に考えやすい。其の後は処理は一直線（レコード１読）で終わる。 この方法は昔からオフラインバッチ処理の常道なんだ。
途中から失礼いたします。 問題の解決方法はわかりませんが、代替案としてマクロ（VBA）で行っては？ もし試してみる気がありましたら、 マクロの経験の有無とシート上のレイアウトを教えてもらえますか？ PS. #1さんのレジストリの変更の件ですが エクスプローラでjpgファイルをダブルクリックしても開けなくなる可能性はありますが、 余程の誤操作をしない限り起動しなくなることはありません。
こんにちは。 もしかしてSheet 1 で「形式を選択して貼り付け」を選ぼうとしていませんか？ Sheet 1ではセルをコピーするだけでOKです。 Sheet 1 →　計算結果を選択して「コピー」 Sheet 2 →　貼り付けるセルを選択して右クリック→形式を選択して貼り付け→「値」を選択→OK の手順で出来るはずです。 試してみてください。
セルを右クリック→セルの書式設定→表示形式→ユーザー定義を選び、 種類のボックスに「@"君"」と入力して下さい(^^)
>左側は「文字列を左にそろえる」に設定されているようですが、スペースキーで右にずらすことができます。ヘッダーの右側は、左に位置をずらすことはできないのでしょうか。 ヘッダーの右側の文字列の右側へ空白文字を入力できますので入力した文字数だけ左に寄せられます。 入力時は表示されませんが、印刷プレビューでは寄っていることが確認できます。 「表示」タブで「標準」から「ページレイアウト」に切り替えると編集中でもヘッダー、フッターが表示されますので確認できます。 他の方法としては右側にアンダースコア（"＿"）を入力し、その部分のみ選択して文字の色を白にすれば表示されませんので同等になるでしょう。
こんにちは 説明通りの状態なら、フォームボタンに下記マクロを登録して試して下さい。 Sub test() 　　Dim i As Long 　　With ThisWorkbook.Worksheets 　　　　For i = 2 To .Count 　　　　　　.Item(1).Cells(1, i) = .Item(i).Cells(1, 1) 　　　　　　.Item(1).Cells(2, i) = .Item(i).Cells(1, 2) 　　　　　　.Item(1).Cells(3, i) = .Item(i).Cells(1, 3) 　　　　Next 　　End With End Sub
=IFERROR(INDEX(INDIRECT("$A$" & MATCH($H2,$A$2:$A$13,0)+1 & ":$F$13"),MATCH(I$1,INDIRECT("B"&MATCH($H2,$A$2:$A$13,0)+1&":$B$13"),0),MATCH($H$1,$A$1:$F$1,0)),"") I2に上記の式でいかがでしょう。
Month関数は、「年月日時分秒」の日付時刻から「月」を取り出す関数です。 > 例えば2016年3月1(木)を関数で曜日を無くす最善の方法はなんでしょうか？ Month関数を使うと、3月の「3」が取り出されるだけです。 曜日はなくなりますが、年とか日とかも無くなったら意味無いのでは？ > 2016年3月1日が1月3日になってしまいます。 上のように3が取り出されるので、数値の3を日付に直したときの1900年1月1日を1として3日目の1900年1月3日になります。 -- セルにシリアル値(1900/1/1とかからの経過日数)で2016年3月1日(木)が入ってるなら、 セルを右クリック-[セルの書式設定] 「セルの書式設定」ダイアログ、「表示形式」タブで、 分類：日付 種類：2016年3月1日 を選択。 別のセルにそういう日付文字列を作成したいなら、A1に上のシリアル値が入ってるとして、 B1:=TEXT(A1,"yyyy年m月d日") と入力。 セルに文字列として"2016年3月1日(木)"が入ってるなら、上と同じ式でTEXT関数がいい塩梅に処理してくれるので、 B1:=TEXT(A1,"yyyy年m月d日") と入力。 セルに文字列として"2016年3月1(木)"が入ってるって事なら、ちょっと面倒です…。 右の3文字切り取って"日"を付け足すなら、 B1:=LEFT(LEN(A1-3))&"日" とか。
何かの拍子に間違ってページサイズを触ってしまったのでしょう。A5」サイズで開くには、もう一度「ページレイアウト」→「サイズ」→「A5」に設定してみてください。
既定の保存場所を変更するなら、下記のリンクを参照下さい。 Excel 2013でファイルの保存先を既定の場所から変更する方法 https://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=016349
=SUMPRODUCT((記入シート!A1:A1000<>"")*(記入シート!B1:B1000="")) でいかがですか。
差にすることは出来ません。 列ラベルの差を総計に表示することは出来ます。 A列からD列までを選んでから、挿入でピボットテーブルを選んでみて下さい。
整数だけにするなら下記数式 =INT(ROUNDDOWN(ROUNDDOWN(AI3,-3)*0.0545,0)*0.4) 40602のセルがA3の場合で、他のセルに数式入力する場合は下記のような数式でも可能です。 =INT(ROUNDDOWN(A3*0.4)
》 振込金額以外の項目は、…簡単に出来ますが… そうですか、貴方のレベルを把握するために、示すべきでした。 》 連続データになっているため、金額だけが上手く転記できません。 「連続データ」だとなぜ転記できないか理解できません。 添付図参照 C6: =VLOOKUP(B$5,一覧表!A:K,2,FALSE) ＿＿ 書式: @" 御中" C7: =VLOOKUP(B$5,一覧表!A:K,MATCH(J4,一覧表!$1:$1,0),FALSE) ＿＿ 書式: #,##0_ "円" ちなみに、セル J4 の書式は、G/標準"月"
=ROUNDDOWN(ROUNDDOWN(AI5,-3)*0.109/5,0) でいかがでしょうか？
１．セル F1 に次式を入力して、此れを下方にズズーッとオート ＿＿フィル(→添付図左から２列目) ＿＿ =OFFSET(A$1,(ROW(A1)-1)/5,MOD(ROW(A1)-1,5)) ２．列Ｆ全体を選択 ３．[コピー]→[値の貼り付け] ４．列Ｆ全体を選択 ５．[ジャンプ]→[セル選択] ６．“定数”に目玉入れ、その下の“数値”以外のチェック外し ７．[OK]をツン(→添付図右から２列目) ８．[編集]→[削除]→“上方向にシフト”に目玉入れ ９．Enterキーを「エイヤッ！」と叩き付け！(→添付図右端)
インストールしたのが「Excel 365」というバージョンなのかもしれません。 サブスクリプションとは、定額で一定期間の使用（またはサポート）権を持つソフトウェアのライセンス形態です。
カメラボタンは「図のリンク貼り付け」を簡単にするものという認識で、どこかに通常のセル幅とは異なる部分がないか探すくらいしか思いつかないですね。 こういう使われ方 http://www.sophia3.com/school/chie/ex06.htm スマホ上のExcelだといろいろ制限があって、マクロを含むワークシートも扱えないし、あくまで簡易的なものにすぎない、マイクロソフト純正だから同じと思って期待してると裏切られるという印象です。
「２００個」どころか百万個以上でもヘッチャラです。 Sheet2!A1: =OFFSET(Sheet1!A$1,(ROW(A1)-1)/3,MOD(ROW(A1)-1,3))
No1訂正です。 こちらにしてください。 =IFERROR(VLOOKUP($C$2, INDIRECT("シート2!A" & MATCH($C$2,シート2!$A$2:$A$1000,0)+ROW(A1)&":$D$1000"),COLUMN(C1),FALSE),"") また、データがない場合0と表示されるのが駄目な場合以下の式にしてください。 =IFERROR(IF(VLOOKUP($C$2, INDIRECT("シート2!A" & MATCH($C$2,シート2!$A$2:$A$1000,0)+ROW(A1)&":$D$1000"),COLUMN(C1),FALSE)=0,"",VLOOKUP($C$2, INDIRECT("シート2!A" & MATCH($C$2,シート2!$A$2:$A$1000,0)+ROW(A1)&":$D$1000"),COLUMN(C1),FALSE)),"")
>さて、私自身は難なく Excel 使用できておりますが、私がログオフしている状態で、私以外の家族が各自のアカウントでログインして Excel を操作(使用)することは可能(許されるの)でしょうか？ 可能のはずです。 >ＹＥＳなら、そのための設定方法等を教えてください。 何の設定も必要ないはずです。 各自のアカウントでサインインし、スタートメニューからExcel 2013を起動できるはずです。 但し、作成したファイルを保存する場合は各自専用のマイ ドキュメントフォルダーがデフォルトになっています。 共用で使用するファイルはパブリックのドキュメントフォルダーに保存しないと他のアカウントからは読み書きできないようになっています。
・ドロップダウンリストの▼も表示されない場合。 　貼り付け時に「形式を選択して貼り付け」で「入力規則」を除外して貼り付けていませんか？ ・ドロップダウンリストの▼は表示されるがリストが空の場合。 　コピー元のファイルでは、ドロップダウンリストの「元の値」がコピー元のシートのセル範囲になっていると思います。 　この場合、そのままコピーしただけではセル範囲の設定のみがコピーされるだけですので、コピー先のファイルでもコピー元と同じようにドロップダウンリスト用のデータを設定する必要があります。
AC2に=AC1として書式設定で表示形式をaaaとしていた場合 AC3に =IF(INDEX($I3:$O3,1,MATCH(TEXT(AC$2,"aaa"),$I$2:$O$2,0))="〇",1,"") 単に月火水・・・と入力していた場合 AC3に =IF(INDEX($I3:$O3,1,MATCH(AC$2,$I$2:$O$2,0))="〇",1,"") として必要なだけ右と下にコピーして下さい。
質問の意味を勘違いしていたようです。 1行目が空白でない列に○を入れるということですね？ 以下のサンプルはA～F列の1行目が空白で無い場合、2行目に○を入れています。 チェックを外した場合は入れた○を消します。 Private Sub CheckBox1_Click() 　　sData = "" 　　If CheckBox1 = True Then sData = "○" 　　For i = 1 To 6 　　　　If Cells(1, i) <> "" Then 　　　　　　Cells(2, i) = sData 　　　　End If 　　Next i End Sub
先ほどの回答は、あくまでも例で、CheckBox2_Click にも同様の処理が必要ですがそれでも変わりませんか？ チェックを外した時に変数「OK」「NO」をクリアする処理で駄目ですと、根本的に見直しが必要になるかもしれません。 今のコードでは情報が足りません。 ・CheckBoxとTextBoxの関連性が不明 ・変数「OK」「NO」は何に使用している？ ・「チェックしていないのに、値が入る」のはそもそもどこの話？
基本的に散布図で、3系列のデータを描かせるために、横軸データの１列（A列）、縦軸データを３列（B,C,D列）にして、 B 列に 横軸範囲は70～110、のデータを A列に横軸の値、B列に縦軸の値、を羅列した下に、 C 列に 横軸範囲は110～170、のデータを A列に横軸の値、C列に縦軸の値、を羅列した下に、 D 列に 横軸範囲は170～290、のデータを A列に横軸の値、D列に縦軸の値、を羅列 にして、３系列まとめて散布図で描く。
エクセルアドイン　TEXTCALCまたはTEXTCALC2を使用する方法もあります。 http://hp.vector.co.jp/authors/VA029807/TEXTCALC2.html
>エラーの種類は「#N/A」となります。 >また、B9を含むB10以下、B列全てエラーとなります。 >CSVデータの範囲に合わせる形で、INDEXの参照範囲を変更致しました。 変更した参照範囲に誤りがあると思います。 >B1が（1）となり、右へ連続して、（1600）まであります。 >320行目まであります。 データ量が多すぎるので自動再計算をOFFにしないと作業が滞るでしょう。 データ量を1600列×10行で検証してみました。 貼付画像でSheet1は模擬データですがF列からBIM列を非表示にしてあります。 Sheet2は希望の配列で計算結果は途中までです。 また、中間を非表示にしています。 Sheet2の数式は下記のようにしました。 A2=IF(AND(E1>1,ISNUMBER(E1)),"",IF(MAX(Sheet1!A$2:A$11)=MAX(A$1:A1),"",MAX(A$1:A1)+1)) B2=IF(E2="","",INDEX(Sheet1!B$1:BIO$1,LARGE(INDEX((INDEX(Sheet1!B$2:BIO$11,MATCH(MAX(A$2:A2),Sheet1!A$2:A$11,0),0)<>0)*COLUMN(A2:BIN2),0),E2))) C2=IF(B2="","",INDEX(Sheet1!B$2:BIO$11,MATCH(MAX(A$2:A2),Sheet1!A$2:A$11,0),MATCH(B2,Sheet1!B$1:BIO$1,0))) E2=IF(A2="",IF(SUM(E1)>1,SUM(E1,-1),""),COUNTIF(INDEX(Sheet1!B$2:BIO$11,MATCH(A2,Sheet1!A$2:A$11,0),0),">0")) E2の数式はSUMPRODUCT関数をCOUNTIF関数に置き換えてみました。 再計算の負荷状況を確かめてください。
セルA1にガス使用量、B1にガス単価を入力して、、 セルC1に数式「=A1*B1」でいかがでしょう。
色を付けたい範囲のセルを指定して、条件を数式にして =COUNTIF($A:$A,$A2)>=3 でよさそうですけど。。。
>O86セルに直接数式を入力しようと、 >　='調整'!I16　とキー入力しますと、入力後にセルには >・='調整'!I16　と　　・　が前につきます。 Excel 2016の試用版で再現テストを行いましたが上記のような結果が得られませんでした。 尚、シート名はシングルクォーティションで括る必要が無く下記のように入力します。 =調整!I16 シート名をシングルクォーティションで括って入力してもEnterキーで確定するとシングルクォーティションが削除されて =調整!I16 のようになりました。 Excel 2016の修復またはアンインストールして、PCの再起動後に再インストールしてみることをお勧めします。 それでも直らないときはファイルの作り直しが必要かと思います。
こんにちは。 > 文字列から"(1234)"というIDを切り出してセルに文字として書き込みたいのですが、 > 警告(数値が文字列として書かれている)が出てしまいます。 > 処理は問題ないのですが、全体に挙動が重たくなってしまいます。 "(1234)"を文字列値として書き込むことは出来ている、ということですよね。 その上で、 　[エラーチェック]の警告アイコンを非表示にしたい、 　但し、Excelの設定は変更したくない ということだとすると、 【文字列書き込み処理後】 のお話でしょうか？ [エラーチェック]の対象が 「文字列形式の数値、またはアポストロフィで始まる数値」 である場合は、 手順として、 ●まず、 　[エラーチェック]（数値文字列）の警告アイコンが表示されている 　　連続したセル範囲全体を選択 　　（一連の単矩形範囲を 　　　同種の警告アイコンが表示されているセル以外は含まないように 　　　選択しないとヤバイ（落ちるかも）です） 　　（行数・列数が多い時は選択後にEnter Shift+Enterの順にキーを押せば 　　　警告アイコンのある先頭セルにスクロールできます。） ●次に、 　[エラーチェック]（数値文字列）の警告（プップアップ）アイコン 　　をクリック→ポップアップ（メニュー）が表示されたら ●最後に、 　[エラーを無視する] 　　をクリック のように手当てしておけば、 （Excelのオプション[エラーチェック]を変更せずに） 警告アイコンを消すことが出来ます。 そのまま保存すれば、警告アイコンなしで保存できます。 しかし、再度数値文字列を書き込んだ場合は、 再び、[エラーチェック]に掛かります。 > 全体に挙動が重たくなってしまいます。 この一文の意味する所が、ちょっと気に掛かっているのですが、 【文字列書き込みをＶＢＡで行うループ処理が重たい】 ということを問題にされているのであれば、 For文やFor Each文でセル値を書き換える場合には、 確かにビックリするぐらい重くなります。 　[エラーチェック]（数値文字列） 　Application.ErrorCheckingOptions.NumberAsText = True が設定されている場合は、 単セル毎にXMLソースのNodeを書き直すことになる筈ですから 時間が掛かったりハングするのも避けようがないかな、と思います。 ただ、問題の本質は、表計算アプリで数値文字列を扱うこと であって、[エラーチェック]は福次的なものでしょうね。 "(1234)"というのは、表計算アプリでは数値文字列として扱うよりありませんから、 内部的なエラーを無視することは出来ても、 エラーを消せる訳ではないです。 [エラーチェック]を切ったとしてもそれは、 喩えるならVBAでプロシージャ丸ごと On Error Resume Next で強引に実行するみたいな？ 可能なら数値文字列以外のフォーマットを検討なさった方が、 保守の面で安心できるとは思います。 重さ（処理が遅くなる原因）を回避する意味では、 なるべく配列で出力するのが最も効果あります。 後は、上書きする時は、一旦.ClearContentsしてから出力するとか。 以下、テスト用のソース挙げておきます。 ★マークしたところは、遅さを回避する為の工夫です。 Forループ版（数十秒）と配列変数版（コンマ数秒）と 新規のブックで試してみると'重さ'の違いが感じられると思いますので、 参考になることが少しでもあれば、と。 ' ' /// 数値文字列出力　Forループ版 Sub Re9173129a() Dim i As Long Dim t As Single: t = Timer 　　With Application 　　　　.ScreenUpdating = False　'　★ 　　　　.EnableEvents = False　'　★ 　　　　.Calculation = xlCalculationManual　'　★ 　　End With 　　With Range("B2:B65536") 　　　　.NumberFormat = "@"　'　★ 　　　　.ClearContents　'　★ 　　　　For i = 1 To 65535 　　　　　　.Cells(i, 1) = Format(i, "!(0000!)") 　　　　Next i 　　　　Call IgnErr(.Cells)　'　[エラーチェック]（を無視して）アイコンを消す 　　End With 　　With Application 　　　　.Calculation = xlCalculationAutomatic　'　★ 　　　　.EnableEvents = True　'　★ 　　　　.ScreenUpdating = True　'　★ 　　End With Debug.Print "testB:"; Timer - t; ".Sec" End Sub ' ' /// 数値文字列出力　配列版 Sub Re9173129c() Dim v() As String　'　★ Dim i As Long Dim t As Single: t = Timer Dim def As Boolean 　　def = Application.ErrorCheckingOptions.NumberAsText　'　★ 　　If def Then Application.ErrorCheckingOptions.NumberAsText = False　'　★ 　　With Range("D2:D65536") 　　　　ReDim v(1 To .Rows.Count, 1 To 1)　'　★ 　　　　.NumberFormat = "@"　'　★ 　　　　.ClearContents　'　★ 　　　　For i = 1 To 65535 　　　　　　v(i, 1) = Format(i, "!(0000!)")　'　★ 　　　　Next i 　　　　.Value = v　'　★ 　　　　Call IgnErr(.Cells)　'　[エラーチェック]（を無視して）アイコンを消す 　　End With 　　If def Then Application.ErrorCheckingOptions.NumberAsText = True　'　★ Debug.Print "testD:"; Timer - t; ".Sec" End Sub ' ' /// [エラーチェック]（を無視して）アイコンを消す Private Sub IgnErr(Target As Range) Dim c As Range 　　For Each c In Target 　　　　With c.Errors(xlNumberAsText) 　　　　　　If .Value Then .Ignore = True 　　　　End With 　　Next End Sub ' ' ///
""での囲みの問題ですね。書式は文字列として扱うので全体を""で閉じる必要があります。 そして、内部の文字に使っている""は、結果として表示しない場合は不要です。 B1を=TEXT(A1,"0;▲ 0") にしてください。
こんにちは。お邪魔します。 > A1 : F10 を「テーブルとして書式設定」し、この範囲のセルを右クリックしたとき、 > ショートカットメニューが表示されてしまいます。 > CommandBars([Index]) の Index が違うのかと思い、試してみましたが、直りませんでした。 この部分にだけお応えすると、 　　CommandBars("List Range Popup") です。 テーブルとして定義した場合は、通常のExcelスプレッドシートとは別物になりますから、 ポップアップメニューも別物（機能も異なります）になります。 必要なら、CommandBars("Cell")、CommandBars("List Range Popup")、 両方それぞれ操作することになります。 直接の回答としては以上です。 <目的>がぼやけているようにも思えて全体として何が正解か悩みますが、 【設定した範囲（1～10行）を右クリックした時だけ、ポップアップメニューを表示させたくない】 というのと、 【設定した範囲（1～10行）を選択中であれば常に、ポップアップメニューを無効にしたい】 というのと、 前者であれば確かに回答No.1のようなやり方で十分と思いますが、 後者であるならば、 　キーボードのアプリケーションキーを押下げる など、右クリック以外の方法でもポップアップメニューを表示させない為に ポップアップメニューを無効にするのが、やはり正解ということになりますけれど、 　Application.CommandBars([Index]).Enabled = False 　Application.CommandBars([Index]).Enabled = True を切り替える契機については、ご提示の方法が<目的>に適うものか、 も少し検討が必要な気もします。 私なら（既に書いてテストしてますが）、 　Worksheet_BeforeRight Clickイベントには一切触らずに、 ThisWorkbook モジュールにて、 　Workbook_SheetSelectionChange　【選択範囲が変更された】 　Workbook_SheetActivate　【対象のシートが選択された】 　Workbook_SheetDeactivate　【対象のシートが選択が解放された】 　Workbook_WindowActivate　【ブックがアクティブになった】 　Workbook_WindowDeactivate　【ブックがアクティブでなくなった】 ５つのタイミングをベースに設計します。 　シートはひとつだけ！ 　ブックもひとつ、他のブックは絶対開かない！ とか、 　右クリックする時は必ず単一セルを選択するのが絶対的な決め事！ とか、 　ポップアップメニューが表示されない状態のまま 　　他のシートやブックを選択して操作することは絶対にしない！ とか、 　ポップアップメニューが表示されなくなっても 　　どうせExcelを閉じれば元に戻るから、適当でいい！ というような許された状況であれば、そのままで構わないのですが、 > 右クリック禁止 というのは、<目的>ではなくて、 そちらで想定された<目的>の為の<手段>である筈です。 ご提示のマクロは【ポップアップメニューを無効にする】もの、 ご説明では【右クリック禁止】 この似て非なる喰い違いが、やっぱり気になりますから、 全体の動作仕様（設計）について、再検証することをお勧めしておきます。 ご不明な点やこちらの応答に不足があるようでしたら、補足欄にでも書いてみて下さい。 主題から外れない課題については再度こちらで検討します。
両端揃えなのだから，両端を揃えたいときに使います。 セル幅とフォント幅の関係で，セル幅が少しだけ余ってしまうことがあるときには違いがよくわかります。
>※元の表の曜日はA列の日付に依存して、aaaで表記しています。 これが問題です。表示は曜日ですが、値は日付のままなので。。。 B列の数式を =A1 から =TEXT(A1,"aaa") にして実行してみてください。
一番最後(resume nextの次)にEnd Functionを追加すればいいんじゃないの？
一番最後に「End Function」を追加して下さい。
=IF(SUMIF(火!$C$2:$G$86,$B6,火!$E$2:$E$86)=0,"",SUMIF(火!$C$2:$G$86,$B6,火!$E$2:$E$86)) ではなく =IF(COUNTIF(火!$C$2:$G$86,$B6)=0,"",SUMIF(火!$C$2:$G$86,$B6,火!$E$2:$E$86)) として下さい。 元の式は「条件に合う物の合計が0であれば、空白にする。さもなければ、条件に合う物の合計を表示する」になってしまっています。 これでは「条件に合う物が存在しても、合計したら0になってしまう場合」も空白になってしまいます。 例えば「条件に合うけども0を入力した場合」とか「条件に合うけど、5と-5を入力した場合」とかも、空白になってしまいます。 やりたいのは「条件に合う物が存在しなければ空白にする。さもなければ、条件に合う物の合計を表示する」の筈です。 なので「COUNTIF」で「条件に合う物の個数」を数えて、その個数が0個の場合だけ空白にして、そうでなければ、SUMIFで条件に合う物のみの合計を求めます。 そのように変更したのが =IF(COUNTIF(火!$C$2:$G$86,$B6)=0,"",SUMIF(火!$C$2:$G$86,$B6,火!$E$2:$E$86)) の式です。
=COUNTA(A2:A6)-COUNTIF(A2:A6,"NIL") でいかがですか。NULLではないのですね。
書式は標準に戻して、 B1=If(A1="","","***"&A1&"***") としたらどうでしょう。 " はダブルクオーテーションです。
Excelには表示桁数で演算するオプションがあります。 > ツール→オプションをみてもよくわかりません。 と、あるのでお使いのExcelは2003ですかね？ 2003は手元に無いので多少操作が違うかもしれませんが…… ［ツール］→［オプション］→［計算方法］→［ブック オプション］→［表示桁数で計算する］のチェックボックスをオンにしてみてください。 ただし、これはブック全体の設定になりますので、これにより別な箇所で逆に演算値が期待と異なる問題が出る可能性もあります。 それよりは、ANo.6のように演算式を変えるほうが良いと思います。
=IF(A1=1,"リンゴ",IF(A1=2,"みかん",IF(A1=3,"いちご",""))) 下記のサイトを参照してください。 http://hep.eiz.jp/201201/excel-if/
どうやったところで徒労に終わると思います。 というのも あなたの環境でいくら調整したところで クライアント側 のPCで開くと「ピクセル→ミリ」の変換誤差が異なるので値が必ず ずれます。 Excelのデータをそのまま出力するのであれば 印刷精度は求めるだけ 無駄になるでしょう。もちろん出力する場所で直接調整するなら別で すが 環境が少しでも変われば随時調整が必要になりますよ。 これはページレイアウトモードを使っても同じ話です。
＞あるセルに数値を入力する ご相談のサンプルで「金額」列に，「生数字を入力している」のか実は他のセルの数字で「計算する数式が記入されている」のかで，具体的なヤリ方は違ってきます。 ご相談ではあなたの実際のエクセルの状況に基づいて，情報提供してください。 一応ご相談は正しくて，Ｂ列に「実際に生数字を記入している」とすると。 手順： シート名タブを右クリックしてコードの表示を選ぶ 現れたシートに下記をコピー貼り付ける private sub Worksheet_Change(byval Target as excel.range) 　dim h as range 　on error resume next 　for each h in application.intersect(target, range("B:B")) 　　h.offset(0, 1).resize(1, 2).borders(xldiagonalup).linestyle = iif(h.value = 0, xlcontinuous, xlnone) 　next end sub ファイルメニューから終了してエクセルに戻る Ｂ列に実際に数字を記入したり削除したりすると，その行のＣ，Ｄ列に斜線が入ったり消えたりする。 ＃参考 上述の手順はこれからＢ列に数字を書いたり消したりする用です。 既に記入済みのＢ列に対して斜線を入れたいときは，オートフィルタで絞ってＣ，Ｄ列に斜線を設定した方がカンタンです。
フィルタオプションで”重複するレコードは無視する”で抽出すれば簡単です。 エクセル2010基本講座：重複データを削除する http://www4.synapse.ne.jp/yone/excel2010/excel2010_filter24.html
質問課題の、直接の原因究明ですが Ｇｏｏｇｌｅで「プロジェクトまたはライブラリが見つかりません 」 で照会し https://www.moug.net/tech/exvba/0150128.html のようなものを出して、該当と対策をチェックしてください。 エクセルやＶＢＡのエラーの場合、エラーコメントそのものの文章（1字1句同じにする）でＷＥＢ照会すると、余分な記事がでるのが少ないので、エラー究明に有効です。 この要領をぜひ活用すべきです。 ーーー もう元のＶＢＡのコードの中身に、踏み込んでいるようだから、 Function ＸＶＬＯＯＫＵＰの部分（XVLOOKUP　を呼び出している部分は） たとえば Sub test01() i = 2 Range("B" & i) = WorksheetFunction.VLookup(Range("A" & i), Range("E1:F19"), 2, False) End Sub のように、置き換えてはどうですか？（もちろんSub test01()、End Subは除く。そしてFunction ＸＶＬＯＯＫＵＰは除く） ワークシート関数にあるものを、またＶＢＡの中で関数化するのは、ややこしくするだけではないですか。
此れ便利！です。 貼り付けたあとに貼り付け先の書式に合わせたり、値の貼り付けに変更したり。。 表示しないようにするにはオプションで[貼り付けオプションボタンを表示する]のチェックを外します。
サンプルの通りに配置すると B12: =SUMIF(OFFSET($1:$1,MATCH(B$11,$A:$A,0)-1,0),$A12,INDEX($A:$A,MATCH(B$11,$A:$A,0)+1)) 右に下にコピー ぐらいで。 サンプルのりんごばななの表範囲に，計算範囲を限定するのは実用上得策じゃありません。 ＞集計用の Ａ列に追加しても全然役に立ちません。 敢えて集計用に追加をするなら，たとえば３行目に Ｃ３：　りんご山田 Ｄ３：　りんご田中 Ｅ３：　りんご山田 Ｆ３：　りんご久保田 Ｇ３：　りんご山田 ６行目に一行挿入してばななの表は７：８行に下げ Ｃ６：　ばなな田中 Ｄ６：　ばなな田中 Ｅ６：　ばなな久保田 Ｆ６：　ばなな田中 Ｇ６：　ばなな山田 となるよう計算式を追加すれば，集計表は単純なSUMIF関数だけで一発計算できますが，たぶんこんなレイアウトでは使いたくないでしょうから回答は割愛します。
>１回１回印刷ボタンを押さないといけないんですね。 まさか ActiveSheet.PrintPreview '<<--プレビュー画面が不要ならこの行を削除。 'ActiveSheet.PrintOut '<<--直接印刷するなら「'」を消去。 このままですか？ 'ActiveSheet.PrintPreview '<<--プレビュー画面が不要ならこの行を削除。 ActiveSheet.PrintOut '<<--直接印刷するなら「'」を消去。 に変えてください。
一括で昇順を降順に変えたい場合は、A列に1列追加して、A1セルに”番号”、A2セルに”1”、A3セル以下に、”3”,”4”,”5”,”6”...と順に入力し、A1セルを右クリックし、並べ替えをクリックし、降順をクリックしてみてください。
No9の訂正です。 エラーの表示はなくした方がよかったですね。 =IFERROR(VALUE(RIGHT(FORMULATEXT(A1),LEN(FORMULATEXT(A1))-FIND("-",FORMULATEXT(A1),1))),"") 式が2013用でした以下の式で =IFERROR(VALUE(RIGHT(FM_TEXT(A1),LEN(FM_TEXT(A1))-FIND("-",FM_TEXT(A1),1))),"")
No.1お礼欄への返信です。 > アウトルックに貼り付けて ... メール送信ということをしたいのです > ... 一番早いのはクリップボードかなあ、と ... HTML形式のメールであれば、画質はともかく、No.1の方法からでも図としての貼付けは出来ますね。 添付ファイルとして送るとかなら、クリップボードに画像ファイルのパスを送っておけば、 メール作成画面で、[ファイルの添付]で表示される[ファイルの挿入]ダイアログにて、 そのままCtrl+Vを押せば、[ファイル名]欄に対象の画像のパスが表示されるので、 [挿入]ボタンを押すとか。 要は文字列としてのファイルパス（aryPict(i)）をコピーした状態を作るという感じ。 原本を送ることにはなりますが、メールですから原画質で送受信されるかは環境次第です。 ' ' /// ' ' Image1を右クリックしたら ' ' 現在表示中の画像（aryPict(i)）のファイルパスを ' ' クリップボードに送る Private Sub Image1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single) Dim oDTO As New MSForms.DataObject 　' ' Image1を右クリックしたら 　　If Button = 2 Then 　　　' ' Image1に現在表示中の画像（aryPict(i)）のファイルパスをクリップボードに 　　　　With oDTO 　　　　　　.Clear 　　　　　　.SetText aryPict(i), 1 　　　　　　.PutInClipboard 　　　　End With 　　End If End Sub ' ' /// No.1の回答趣旨に副えば、ExcelからOutlook VBAを操作する、 ということになりますが、複数の写真を貼ることもあるのでしょうし、 セキュリティ的な面からみても、メール作成は手作業の方が 自分で作成内容が解って良いかもですね。 VBAで操作出来なくもないですけれど、 殆どの作業が自分好みのメール作成の仕方みたいな感じなので、 こちらからレクチャーするものでもないのかな、と。 Outlook VBAは長いこと触っていない私だったりもしますが、それは置いても、 このケースはクリップボードの方が扱い易くて安心なのだと思います。 話を整理しますと、 HTML形式のメールに図として貼付ける場合は、今質問への回答No.1の２つ目のやり方で、 添付ファイルとして送る場合は、この回答に書いたやり方で、 ということになります。 念の為ですが、前回の回答No.1で >> ※　一応、LoadPictureした後は、Me.Repaint、した方が無難かと。 と書いていましたが、クリップボードを扱う関係で必須になります。 　　Me.Image1.Picture = LoadPicture(aryPict(i)) の次の行に 　　Me.Repaint をお忘れなく。 それから、今質問への回答No.1のように画像（図）をコピーした場合は、 クリップボードに連続してコピー→貼付けすることが出来るのですが、 クリップボード画面にすべての画像のプレビューが表示されないかも知れませんが、 （プレビューはありません）と表示されていれば、貼付けは出来ますので。 以上になります。
＞4分50秒と4分94秒の平均 EXCELでやってみました。結論は、「94秒」が60秒をオーバーしているので、時間入力と認識出来ていないためです。 素直に94秒であれば、分の桁を+1分して再入力して下さい。
Cells(3, 2).Value = Application.VLookup(Cells(1, 2).Value2, Worksheets("担当").Range("A1:C5"), 2, False) Value→Value2 最後に Falseを追加 にしてください。
　回答No.3です。 >ただ、年齢のところで計算式を貼り付け、[誕生日が入力されているセル]をセル番号に変えてたのですが、エラーが出てしまいました。 >引数が足りないとか多いとかです。 　申し訳御座いません。 =IF([誕生日が入力されているセル]="","",IFERROR(DATEDIF([誕生日が入力されているセル],TODAY(),"Y"),"(入力値無効)")) とすべきところを「)」が1つ抜けておりました。 >また、この場合、退院した時点で年齢は止まりますでしょうか？ 　いいえ、患者の「現在の年齢」を表示させる事が目的だと思って考えた関数ですので、止まりません。 　退院した時点で年齢のカウントを止めるのでしたら、次の様な形式の関数として下さい。 =IF([誕生日が入力されているセル]="","",IFERROR(DATEDIF([誕生日が入力されているセル],IF(OR(SUM([C列のセル])<1,[C列のセル]>"9999/12/31"+0),TODAY(),[C列のセル]),"Y"),"(入力値無効)")) >お願いなのですが、 >＞「DATEDIF関数の『後ろの方の日付』の所で参照する値を、『C列に日付が入力されている場合』にはその日付を、『C列に日付以外の値が入力されている場合や、何も入力されていない場合』には、TODAY関数の結果を、それぞれ参照する様にする」という関数にしてしまった方が良いと思います。 >の部分の考え方は良くわかりましたが計算式のどの部分にあたるのか、教えていただけませんでしょうか？ 　「DATEDIF関数の『後ろの方の日付』の所で参照する値」とは、 DATEDIF(B174,C174,"Ｄ") の中で「C174」と記述されている箇所の事です。 　一方、「『C列に日付が入力されている場合』にはその日付を、『C列に日付以外の値が入力されている場合や、何も入力されていない場合』には、TODAY関数の結果を、それぞれ参照する様にする」というのは、前述の「C174」と記述されている箇所を、次の様な形式のIF関数に差し替えるという事です。 IF([C列に日付が入力されている場合にTRUEを返す判定式],[C列のセル],TODAY()) 或いは IF([C列に日付が入力されていない場合にTRUEを返す判定式],TODAY(),[C列のセル]) 　回答No.3で提示させて頂いた関数 =IF($B174="","",IFERROR(DATEDIF($B174,IF(OR(SUM($C174)<1,$C174>"9999/12/31"+0),TODAY(),$C174),"Ｄ")+1,"(入力値無効)")) の中で上記の「『C列に日付が入力されている場合』にはその日付を、『C列に日付以外の値が入力されている場合や、何も入力されていない場合』には、TODAY関数の結果を、それぞれ参照する様にする」に該当するのは IF(OR(SUM($C174)<1,$C174>"9999/12/31"+0),TODAY(),$C174) という箇所です。 　このIF関数の判定式は OR(SUM($C174)<1,$C174>"9999/12/31"+0) というものになっております。 C174セルに何も入力されていない場合や、「入院中」などの様な何らかの文字列データが入力されている場合には、SUM($C174)の部分の計算結果は0になりますから、 SUM($C174)<1 の判定結果はTRUE(「条件に合う」という結果)になりますので、OR(　)の部分の判定結果もTRUEとなるため、IF関数の[真の場合]の所に記述されている TODAY() の結果が返されます。 　又、Excelでは日付を扱う際にはシリアル値という概念が用いられており、通常では整数値の1を日付の1900年1月1日として扱い、1900年1月2日は数値の2、1900年1月3日は数値の3・・・という具合に日付や時刻のデータを1899年12月31日の午前0時から経過した日数に対応させた数値を使って処理しております。(例えば2016年5月1日の午前6時のシリアル値は42491.25になります) 　マイナスの数値や西暦9999年よりも後の日付はExcelでは日付として扱う事が出来ません。 　そこでその様な日付として扱う事が出来ない様な数値がC174セルに入力された場合には、 SUM($C174)<1 か $C174>"9999/12/31"+0 のどちらかの判定結果がTRUEとなりますから、その様な場合にはOR(　)の部分の判定結果もTRUEとなるため、IF関数の[真の場合]の所に記述されている TODAY() の結果が返されます。 　一方、C174セルに日付が入力されている場合とは、C174セルに1以上で「西暦9999年12月31日に該当するシリアル値」以下の数値が入力されている場合なのですから、 OR(SUM($C174)<1,$C174>"9999/12/31"+0) の判定結果はFALSE(「条件に合わない」という結果)になりますので、IF関数の[偽の場合]の所に記述されている $C174 の結果が返されます。
> 何か考えることがありましたら、引き続きよろしくお願いします。 こちらの環境ではうまくいかないことがないので、これで直りますという実証が出来ないのですが AppActivate "Book5.xlsm - Excel" や VBA.AppActivate Excel.Application.Caption などのコードを Workbooks("Book5.xlsm").Activate の前に入れるという方法があるようです。 他のアプリからエクセルに戻す場合には DoEvents を前に入れておくというのもありました。 このあたりのコードを入れてみてはいかがでしょう。
誤：cells(activecell.row-4,activecell.colum).value 正：cells(activecell.row-4,activecell.column).value ではありませんか？ あとはrow位置が4以下の場合もエラーになります。
　使用しているExcelのバージョンがExcel2007以降(Excel2007自体も含む)のものである場合には、作業列は1列だけでOKです。 　今仮に、○や×がA2以下に入力されているものとします。 　又、C列を作業列として使用するものとします。 　まず、C2セルに次の関数を入力して下さい。 =IF(OR($A2="",$A2=$A3),"",COUNTIF($A$1:$A2,$A2)-SUMIF($A$1:$A1,$A2,C$1:C1)) 　次に、C2セルをコピーして、C3以下に貼り付けて下さい。 　その上で「○の平均連続回数を表示させたいセル」には次の関数を入力して下さい。 =AVERAGEIFS($C:$C,$A:$A,"○",$C:$C,">0") 　同様に、「×の平均連続回数を表示させたいセル」には次の関数を入力して下さい。 =AVERAGEIFS($C:$C,$A:$A,"×",$C:$C,">0") 　以上です。
異なるシートを両面印刷することはできます。 あと、手元に印刷機がないなら、エクセルの印刷機能で紙へではなく、PDFやXPSに出力することもできます。 https://www.microsoft.com/ja-jp/office/2010/business/training/tips/office05.aspx あと、念のため。 シートをコントロールキーを押しながらマウスで選択すると複数選べるので、その状態で印刷メニューに行くと、複数のシートを続けて印刷できます。 ご質問の内容からご質問者さんはご存知だと思いますが。。。
　各契約更新日が丁度6ヶ月ごとにやって来る様になっている事から、次の様な方法を使う事が出来ます。 　今仮に、A3セルに「氏名」、B3セルに「契約日」、C3セルに「更新回数」と入力されていて、B1セルに退職日を入力するものとします。 　その場合、まずC4セルに次の関数を入力して下さい。 =IF(OR($B$1="",$B4=""),"",IF(OR(SUM($B$1)<SUM($B4),SUM($B4)<"1904/6/1"+0),"(入力値無効)",INT(DATEDIF(DATE(YEAR($B4),LOOKUP(MONTH($B4),{0,6,12}),1),$B$1,"m")/6))) 　そして、C4セルをコピーして、C5以下に貼り付けて下さい。 　以上です。
＃４　です。 質問は、単なる最終行を取得だけらしい。 今気づいたが、最終行を求める方法よりも、もっと基礎的なことは Range("A1:A & i ").Select この　i　 は変数として使うもので、”　”の中にi 含めてはだめです。””は文字列を定義する（リテラル用法）なのでプログラム実行中は変わらない。基礎的なこと。 Range("A1:A " & i ).Select という使い方になる。これもＲａｎｇｅの（）内は、文字列を指定するのだが、エクセルＶＢＡでは、i は数値なのに１という文字列に直してＡ１：Ａ２００　という文字列にして（解釈して、扱って）くれる。 ーー ＃４に加えて、最終行は （４）「セル選択」（ＣＴＲＬ＋Ｇ）の「最後のセル」の行を求める、でも取得できる。 Sub Macro1() Selection.SpecialCells(xlCellTypeLastCell).Select MsgBox Selection.Row End Sub でもできる。 ほかに （５）「Ａ列で空白セル行が現れるまで繰り返す」、という方法でもできる。 最終行は、とりあえず求めずに（行の繰り返し）処理を始める方法。
データの範囲の左端から左端も含めて10列目に該当のデータがあるでしょうか、たとえば非表示にしていて見逃しているとかはありませんか。 試しに =IF(ISERROR(VLOOKUP($H$1,データ,10,0)),"",VLOOKUP($H$1,データ,10,0)) ではどうなるでしょう。
ご利用のエクセルのバージョンが不明のご相談ですが，最近のエクセルを使っているなら，添付図のように「表示」タブで「ページレイアウト」表示に切り替えることで，列の幅や行の高さをｍｍ単位などで確認しながら調整することができます。この表示モードでは，ホームタブの書式▼から「列幅」を開始し，狙ったmmの数字を記入して設定することも出来ます。 ただし調整はあくまで「ピクセル」単位なので，ぴったり「20mm」などのようにすることは出来ません。 ご利用のソフトのバージョンに応じて，出来ること出来ないこと具体的な操作の手順などは変わります。ご相談投稿では，普段あなたがご利用のソフトのバージョンまで明記することを憶えてください。 と，ここまでがカンタンな一般論で，以下は少し詳しいお話になります。 元々エクセルは「印刷の性能を保証していません」。つまりパソコンのモニタ画面上で例えば「２０ｍｍ」を設定したとしても，エクセルとウィンドウズの性能の問題で，実際の印刷物は２０ｍｍにはなりません。 またアナタのパソコンで印刷結果が２０ｍｍになるよう苦労して調整したエクセル表を作っても，それを別のパソコンに持って行って印刷すると，また違う寸法で印刷されます。（画面の解像度や印刷に使うプリンタなどの各種設定を完全に同じにすれば，再現は出来ます） 最終的な印刷精度を必要とする(WYSIWYGと言います）場合，エクセルではなく，例えばWORDやMac版Excelなどのように，画面がきちんと印刷に再現できるよう作られているソフトをご利用ください。
　下記の様なVBAのマクロになります。 Sub QNo9164037_エクセル_選択したセル間_赤斜線を引く() If TypeName(Selection) = "Range" Then With Selection With ActiveSheet.Shapes.AddConnector(msoConnectorStraight, _ .Left, .Top, .Left + .Width, .Top + .Height).Line .Visible = msoTrue .ForeColor.RGB = RGB(255, 0, 0) .Transparency = 0 End With End With Else MsgBox "現在選択されているものはセル範囲ではありません。" _ & vbCrLf & "マクロの実行を中止致しますので、" _ & "セル範囲を選択しなおしてから再度当マクロを実行してください。" _ , vbExclamation, "無効な選択" End If End Sub
こんにちは =IF(ISERROR(VLOOKUP(J4,INDIRECT("給与一覧"&MONTH(L2)&"月!A1:Q26"),6,FALSE)),"",VLOOKUP(J4,INDIRECT("給与一覧"&MONTH(L2)&"月!A1:Q26"),6,FALSE)) でしょうか？
No.1お礼欄への返信です。 大体は私が試していたのと同じなのですが、 ポイントは、フォルダを定義しておいて、「フルパスを格納する」ことと、 「i を 0 に戻す」ところぐらいです。★参考まで。 Option Explicit Dim i As Long Dim aryPict() As String Private Sub UserForm_Initialize() Dim ShashinName As String Const S_DIR = "C:\Users\user1\Desktop\FolderName\"　'　★ 　　ShashinName = Dir(S_DIR & "*.jpg")　'　★ 　　' ' ★ 　　Do While ShashinName <> "" 　　　　ReDim Preserve aryPict(i) 　　　　aryPict(i) = S_DIR & ShashinName　'　★ 　　　　i = i + 1　'　★ 　　　　ShashinName = Dir() 　　Loop 　　i = 0　'　★ 　　Me.Image1.Picture = LoadPicture(aryPict(i)) End Sub
列の名前として、丸括弧を使うなら全角のものにした「金額（外税）」にするか、括弧を使わず「金額・外税」のような全角文字のみにするほうが得策かと思います。 Excel が式とかで使う半角記号が混じっていると、誤動作防止でこういう制限をしてくるかもしれないので。
＞WindowクラスのTopプロパティを設定できません←と、出てデバックを開くと このエラーは「ウィンドウが最小化または最大化されている時にTopプロパティを変更しようとした際」に発生します。 ＞With ActiveWindow ＞ .WindowState = xlNormal の行で「最小化でも最大化でもない、通常状態にしている」ので、このエラーは出ない筈です。にも関わらず、このエラーが出ているのであれば .WindowState = xlNormal に失敗して、この行が無視されているとしか思えません。
こんにちは リストの参照先のセルが削除されたとかではないのですか？
こんにちは。 Excel数式における「定義されたテーブルとフィールド」の参照の仕方 としては、基本的に間違っていませんので、安心してください。 差し当たり、テーブル名、フィールド名、共に、 全角／半角を区別しますので、 　フィールド名：　数量2 　数式上の記入：　数量２ のような相違であっても、 ご指摘のようなダイアログが表示されて、数式の入力が中断されます。 テーブル名、フィールド名、どちらも、数式編集時に候補が表示されますので、 候補の中から選ぶようにしてみては如何でしょう？ 英字以外で始まる名前の場合は、 =SUM(お) までタイプしてから、 =SUM(お のようにBACKSPACEで一文字戻るようにすれば、 "お"で始まる、[関数]や[定義された名前][定義されたテーブル]等が ドロップダウンに一覧表示されますので、その中から、 [お買い物]をダブルクリックして、 =SUM(お買い物 まで進んだら、続けて"["をタイプ =SUM(お買い物[ この時も、[お買い物]で定義されている[フィールド名]等が、 ドロップダウンに一覧表示されますので、その中から、 [数量2]をダブルクリックして、 =SUM(お買い物[[数量2 "])"を書き加えて =SUM(お買い物[[数量2]) と数式が整った所で、確定（Enter）。 のような要領で入力するようにすれば、 見た目で判別付き難い名前の相違に煩わされることが少なくて済みます。 勿論、[テーブル]機能の恩恵が不要だとお考えなら、 A1形式のセル参照を使うのでも構いません。 原因が掴めず、お急ぎということなら、一時凌ぎとして、 最悪、A1形式で逃げておく手もありますね。
　回答No.1、4です。 　「Mc」、「Mac」、「O'」以外にも「FitzGerald」の「Fitz」というパターンがある事が判りました。 【参考URL】 　フィッツジェラルド - Wikipedia 　　https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%83%E3%83%84%E3%82%B8%E3%82%A7%E3%83%A9%E3%83%AB%E3%83%89 　ですから、回答No.4の関数を次の様なものに修正して下さい。 =TRIM(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A1,"A"," A"),"B"," B"),"C"," C"),"D"," D"),"E"," E"),"F"," F"),"G"," G"),"H"," H"),"I"," I"),"J"," J"),"K"," K"),"L"," L"),"M"," M"),"N"," N"),"O"," O"),"P"," P"),"Q"," Q"),"R"," R"),"S"," S"),"T"," T"),"U"," U"),"V"," V"),"W"," W"),"X"," X"),"Y"," Y"),"Z"," Z"),"Mc ","Mc"),"Mac ","Mac"),"O' ","O'"),"Fitz ","Fitz")) 　後それから、 >》 という条件はあまり重視しなくても宜しいのでしょうか？ >と仰った意味が理解できずに、少々戸惑っております。 の件ですが、これは私の述べ方が少々悪かったかも知れません。 　要するに、「(別のやり方としてマクロを使った方法もあるので)他の回答者の方の様に、マクロを使った方法を回答しても宜しいでしょうか？」という事を言いたかった訳です。 　例えば、以下の様なVBAの構文を、回答No.2様の御回答と同様にVBEの画面の標準モジュールに貼り付けてからそのVBAを保存しておきますと、そのVBAを貼り付けたファイル内限定でSPACEINSERT関数という新たな関数(ユーザー定義関数)が使用可能になり、他の関数と同様にセル内に =SPACEINSERT(A1) と入力しますと、A1セルに入っている文字列に含まれている大文字の前に半角スペースが挿入された文字列が表示されます。(「A1」の代わりに他のセルを参照する事や、セルの代わりに文字列データを使う事も出来ます) 【参考URL】 　ユーザー定義関数 　　http://www.konomiti.com/Ex_kan_05.html 　但し、文頭にある大文字や、「Mc」、「Mac」、「O'」、「Fitz」の直後にある大文字の直前にはスペースが挿入されない様になっております。 　又、大文字が3文字以上連続していて、尚且つ、その連続箇所の直後に「空白スペースや数字、或いは『.』、『+』、『-』、『/』、『=』」以外の文字が続いている箇所は何かの略称として扱い、大文字が連続している箇所の前後にのみ半角スペースを挿入し、連続している箇所の途中には空白の挿入は行われません。 　又、大文字が2文字以上連続していて、尚且つ、その連続箇所の直後に「空白スペースや数字、或いは『.』、『+』、『-』、『/』、『=』」の内の何れかの文字が続いている箇所は何かの略称として扱い、大文字が連続している箇所の直前にのみ半角スペースを挿入し、連続している箇所の途中には空白の挿入は行われません。 Function SPACEINSERT(元の文字列 As Variant) As String Dim buf As Variant, i As Long, Mc As Variant Mc = Array("Mc", "Mac", "O'", "Fitz") buf = 元の文字列 If buf & "" <> "" Or Not IsError(buf) Then buf = Replace(Replace(buf, Chr(28), ""), Chr(29), "") & Chr(28) For i = 65 To 90 buf = Replace(buf, Chr(i), Chr(28) & Chr(i)) Next i For i = 0 To UBound(Mc) buf = Replace(buf, Mc(i) & Chr(28), Mc(i)) Next i For i = Len(buf) To 3 Step -1 If Mid(buf, i, 1) = Chr(28) _ And Mid(buf, i - 2, 1) = Chr(28) _ And (Mid(buf & " ", i + 2, 1) Like _ "[ ,　," & Chr(29) & ",.,+,-,/,=,0-9]" _ Or Mid(" " & buf, i - 2, 1) = Chr(28)) Then buf = WorksheetFunction.Replace(buf, i, 1, Chr(29)) If Not Mid(buf, i + 2, 1) Like "[" & Chr(29) & ".,+,-,/,=,0-9]" Then _ buf = WorksheetFunction.Replace(buf, i + 2, 0, Chr(28)) End If Next i buf = WorksheetFunction.Trim(Replace(Replace(buf, Chr(29), ""), Chr(28), " ")) End If SPACEINSERT = buf End Function Private Sub Workbook_Open() Application.MacroOptions Macro:="SPACEINSERT", _ Description:="文字列の途中または末尾に含まれているアルファベットの大文字" _ & "の前に半角スペースが挿入された文字列を返すユーザー定義関数です。" _ & vbCrLf & "但し、何かの略称や、特定の苗字と考えられるものの途中には" _ & "空白の挿入は行われない事があります。" End Sub
> 「学習した番号については、うまくいく」 変換候補の一番上にあるものを表示するようになっていますので、そのような結果になります。 VBAを使わずに A2に =PHONETIC(B2) としておいて B2に郵便番号を入力して変換して住所を出す というのはいかがですか。 B列の入力規則でIMEがオンになるようにしておけば多くても初回だけ変換キーを3回押せば住所が出てきます。
「初期設定」「４月」「５月」のシートを非表示にしているということでしょうか でしたら以下のようにしてください。 Private Sub Label1_Click() Sheets("初期設定").Visible = True Sheets("４月").Visible = False Sheets("５月").Visible = False Sheets("初期設定").Activate Unload Me End Sub ラベル2が４月のシートなら Private Sub Label2_Click() Sheets("初期設定").Visible = False Sheets("４月").Visible = True Sheets("５月").Visible = False Sheets("４月").Activate Unload Me End Sub .Visible = True が表示で .Visible = False で非表示です。
フィルタで空欄のみチェックをはずして、 すべてコピー、別シートに貼り付け というのはどうですか？ マクロでエンドレスにならないようにするためには、最後の行を一番最後から調べればよいです。 「VBA 最後の行を調べる」で検索するといろいろ出てきます。 MaxRow = Range("A1").End(xlDown).Row
こんにちは Sub test1() 　　Dim a As String 　　Dim p As String 　　Dim f As Long 　　Dim o As Object 　　Dim pa As Object 　　Dim s As Object 　　Dim i As Long 　　 　　a = ThisWorkbook.Path & "\test.pptx" 　　Set o = CreateObject("PowerPoint.Application") 　　o.Visible = True 　　 　　Set pa = o.Presentations.Open(a) 　　 　　p = Range("A1") & "--" & Range("B1") & "--" & Range("C1") 　　 　　i = pa.Slides.Count 　　 　　For Each s In pa.Slides 　　　　With s.HeadersFooters 　　　　　　If s.Slideindex = 1 Then 　　　　　　　　o.Presentations(1).Slides(1).Shapes.AddTextbox(msoTextOrientationHorizontal _ 　　　　　　　　　　, 280, 250, 200, 50).TextFrame.TextRange.Text = p 　　　　　　ElseIf s.Slideindex <> i Then 　　　　　　　　With .Footer 　　　　　　　　　　.Visible = True 　　　　　　　　　　.Text = p 　　　　　　　　End With 　　　　　　End If 　　　　End With 　　Next 　　pa.Save 　　pa.Close 　　o.Quit 　　 　　Set o = Nothing End Sub 「表紙のみ中央に配置」はテキストボックスとかになりますね。 位置は適当です。
貼付画像から推測してB列へA列の値が其々の検索値として検索値を除くセルの個数をカウントしたいとの意向のようです。 B2セルへ次の数式を入力してオートフィルでB12セルまでコピーし、B2セルをB1セルへコピーすれば質問の処理になります。 =IF(ROW()=1,COUNTIF(A$2:A$12,A2),IF(ROW()=12,COUNTIF(A$1:A$11,A2),COUNTIF(A$1:A1,A2)+COUNTIF(A3:A$12,A2))) しかし、他の回答者からの下記数式と等価になりますので、何故無理な数式を使わなければならないのですか？ =COUNTIF(A$1:A$12,A1)-1
こんにちは。私もカレンダー等数多く参考にさせていただいてます。 エクセルでお仕事のリンク先 http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub05_800_050.html シートの例がありますので以下のとおりでダウンロードができます。 (この画像をクリックすると、zip圧縮されたExcelワークブックがダウンロードができます)
>原因はA1に「（ 」があるので文字列だからだと思うのですが 　その通りです。 >「IF　条件文」が成立しないことは満たすのでElse以下を実行されるのを期待していたのですが。 　それは無理です。 If Cells(1, 1) - Cells(2, 1) = 1 Then という構文でIfの判定を行わせているという事は、 「まず実際に Cells(1, 1) - Cells(2, 1) という計算を行ってから、その値が =1 であるかどうかを判定しなさい」 という指示をしている事になります。 　Cells(1, 1) の値が数値には変換出来ない種類の文字列である以上、 Cells(1, 1) - Cells(2, 1) という計算を行おうにも、「Cells(1, 1) の値が計算に使用可能な値ではない」、即ち「型が一致しない」のでエラーとなってしまいます。 　ですから、まず先にCells(1, 1)とCells(2, 1)の値が「数値」或いは「数値に変換可能な文字列」であるかどうかを判定して、もし「数値」或いは「数値に変換可能な文字列」であった場合に初めて If Cells(1, 1) - Cells(2, 1) = 1 Then という処理を行う様にしなければなりません。 　幸い、本件の場合は Cells(1, 1) - Cells(2, 1) = 1 である場合も、そうではない場合でも、どちらの場合においてもCells(3, 1)の値を変更する事に変わりはありませんから、まず先に Cells(3, 1)="c" としてしまってから、 >Cells(1, 1)とCells(2, 1)の値が「数値」或いは「数値に変換可能な文字列」であるかどうかを判定 と If Cells(1, 1) - Cells(2, 1) = 1 Then という処理へと進み、両方のIf文の判定が共にTrueだった場合にのみ、 Cells(3, 1) = 1 としてしまい、Elseは使用しなければ良い事になります。 Cells(3, 1) = "c" If IsNumeric(Cells(1, 1)) And IsNumeric(Cells(2, 1)) Then If Cells(1, 1) - Cells(2, 1) = 1 Then Cells(3, 1) = 1 End If
　今仮に、Sheet2のB列に祝日の日の一覧表が作成されているものとします。 　まず、A3セル(日付のセル)には次の様な関数を入力して下さい。 =IF(ISERROR(1/(COLUMNS($A:A)<=DAY(EOMONTH($A$4&"年"&$D$4&"月",0)))),"",DATE($A$4,$D$4,COLUMNS($A:A)+15)) 　次に、A3セルの書式設定の表示形式を[ユーザー定義]の d に設定して下さい。 　次に、A3セルをコピーして、B3～AE3のセル範囲に貼り付けて下さい。 　次に、A1セル(曜日のセル)には次の様な関数を入力して下さい。 =A$3 　次に、A1セルの書式設定の表示形式を[ユーザー定義]の aaa に設定して下さい。 　次に、A1セルをコピーして、B1～AE1のセル範囲に貼り付けて下さい。 　次に、以下の様な操作を行って条件付き書式を設定して下さい。 A1セルを選択 　　↓ Excelウィンドウの[ホーム]タブをクリック 　　↓ 現れた「スタイル」グループの中にある[条件付き書式]ボタンをクリック 　　↓ 現れた選択肢の中にある[ルールの管理]をクリック 　　↓ 現れた「条件付き書式ルールの管理」ダイアログボックスの中にある[新規ルール]ボタンをクリック 　　↓ 現れた「新しい書式ルール」ダイアログボックスの「ルールの種類を選択して下さい」欄の中にある[数式を使用して、書式設定するセルを決定]をクリック 　　↓ 現れた「次の数式を満たす場合に値を書式設定」欄の中に次の数式を入力 =WEEKDAY(A$1)=1 　　↓ 「新しい書式ルール」ダイアログボックスの[書式]ボタンをクリック 　　↓ 「セルの書式設定」ダイアログボックスの[フォント]タブをクリック 　　↓ 現れた「色」欄をクリック 　　↓ 現れた色のサンプルの中にある赤色(日曜日の文字色)の四角形をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「新しい書式ルール」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの中にある[新規ルール]ボタンをクリック 　　↓ 現れた「新しい書式ルール」ダイアログボックスの「ルールの種類を選択して下さい」欄の中にある[数式を使用して、書式設定するセルを決定]をクリック 　　↓ 現れた「次の数式を満たす場合に値を書式設定」欄の中に次の数式を入力 =WEEKDAY(A$1)=7 　　↓ 「新しい書式ルール」ダイアログボックスの[書式]ボタンをクリック 　　↓ 「セルの書式設定」ダイアログボックスの[フォント]タブをクリック 　　↓ 現れた「色」欄をクリック 　　↓ 現れた色のサンプルの中にある青色(土曜日の文字色)の四角形をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「新しい書式ルール」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの中にある[新規ルール]ボタンをクリック 　　↓ 現れた「新しい書式ルール」ダイアログボックスの「ルールの種類を選択して下さい」欄の中にある[数式を使用して、書式設定するセルを決定]をクリック 　　↓ 現れた「次の数式を満たす場合に値を書式設定」欄の中に次の数式を入力 =ISNUMBER(A$1)*COUNTIF(Sheet2!$B:$B,A$1) 　　↓ 「新しい書式ルール」ダイアログボックスの[書式]ボタンをクリック 　　↓ 現れた「セルの書式設定」ダイアログボックスの[塗りつぶし]タブをクリック 　　↓ 現れた背景色のサンプルの中にある桃赤色(祝日の背景色)の四角形をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「新しい書式ルール」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの「適用先」欄を3箇所とも =$A$1:$AE$3 に変更（カーソルとマウスの左ボタンによる範囲選択が使えます） 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[適用]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[OK]ボタンをクリック 　そして、「平日で尚且つ〇が付いている日の日数」を表示させるセルには次の様な関数を入力して下さい。 =SUMPRODUCT(($A$2:$AE$2="〇")*(WEEKDAY(0&$A$1:$AE$1,2)<6)*(COUNTIF(Sheet2!$B:$B,$A$1:$AE$1)=0)) 　又、「土曜日で尚且つ〇が付いている日の日数」を表示させるセルには次の様な関数を入力して下さい。 =SUMPRODUCT(($A$2:$AE$2="〇")*(WEEKDAY(0&$A$1:$AE$1)=7)*(COUNTIF(Sheet2!$B:$B,$A$1:$AE$1)=0)) 　又、「『日曜日か祝日の日』で尚且つ〇が付いている日の日数」を表示させるセルには次の様な関数を入力して下さい。 =SUMPRODUCT(($A$2:$AE$2="〇")*((WEEKDAY(0&$A$1:$AE$1)=1)+COUNTIF(Sheet2!$B:$B,$A$1:$AE$1)>0))
売上には季節性、月別に波（例よく言われる、２，８ニッパチ）がある業種が多い。 貴社の売り上げにその周期があれば、１２か月を３か月、６か月とかで折り返して（次の３か月や６か月は下部分に配置して）、できるだけ横スクロールを少なくしてはどうだろう。 全年同月を並べるのが一番良いように思うが、（１年分ならできないが）。 社長もパソコンのディスプレで見るのですか。印刷した紙で見るのではないのですか。 Ａ４印刷なら用紙横や用紙縦しか選択肢はなく 月ごとに考えて、次のページに行って、元のページに戻るのはよくない。３か月程度で Ｚ字型に並べるのはどうだろう。幅も相当取ると思うので、２横Ｘ６縦（月）、３Ｘ４ぐらいになるかも。 ーー 直接質問と関係ないが、最近、小生は下記のようなことを感じている。 エクセルのシートで、データを横方向に展開する人の質問もあるが、やはり上下縦行と左右横列を考えた場合、Ｅｘｃｅｌは縦方向重視のようだ。最大行数と代々列数に違いがあるせいもある。「リスト」「テーブル」機能は縦方向に考えている。関数などでも一部縦方向オンリーがあったように思う。
回答No.1に追加です 「オブジェクトの選択」モードになったところで、[Ctrl]を押しながら[A] キー(Ctrl+A…すべて選択)を押すと、1シート上のすべての図形を選択することができます。 その後[Delete]キーを押せば、画面外のものも含め、すべて消去できます。
》 …一箇所だけでなく、同じ関数を入れてた全てのセルで… 「ほんのの少しの可能性でも結構です」とのことなので、私の迷推理を開陳しませう(^_^) 添付図を見るだけで「あッ！」と理解できるでしょ？ 私が何を言わんとしているかを当ててください。
次のサイトはどうですか？ 経理業務向けのエクセルに特化したサイトで、かなり詳しく載ってますよ。
今の義務教育ではExcelはやらないでしょう。 大学生でもなってはじめてやるかなと思います。 Excel関数やVBAは底なしの領域と言うのが 私の実感ですが。
その現象がイヤなら、iPhoneやAndroidは使わずに、Windows Phoneにしましょう(^o^)。 AndroidやiOSは、裏に回ったアプリはメモリが足らなくなった時点で終了されます。このため、ほとんどのアプリは保存をしなくても操作時に自動的に保存され、いつ終了されても困らないようになっています。 対応策としては2つかと。 動作用のメモリの大きなスマホを使う。 ルート化して画面分割アプリを入れて表示を裏に回さない。
エクセルＶＢＡを初めて扱うとのことだが、そういうレベルでは無理な課題だろう。 それに仕事の関連をそんな初心者がやってよいものか? もう少しＶＢＡ（特にコントロールとフォーム）の勉強と経験を積んで、のち取り組んだらどうですか。 ＶＢＡでも、コントロールを使う部分は、中・上級に当たると思う。ＶＢＡの本でも、詳しい解説は、コントロールの種類が多いこともあって、VBA本体の解説と別冊になっている例が多い。 数冊（数社）ながら、エクセルＶＢＡのコントロールの（独立１冊の）解説書も出ているが、最近ブームも去って大型書店でないと見られないようだ。 本質問は、コードを作ってくださいと、丸投げもいいところ。 そういうムードと、質問の例から、どうしたい（する）のかがわかりにくいので、１日経っても回答がないのだろうと思う。 ーー （１）コントロールを使うなら、コントロールのイベントの仕組みを使うことになるが、 その痕跡が、質問からは見えない。 （２）アイテム（エントリ、Item）は、選択してもらう候補を、コントトールに表示する中身だが、セットの仕方は 　　A.プログラムの中のコードで定義から 　　B.エクセルの場合セル範囲から（エクセルでコントロールを使いやすくする仕組み） 例 Private Sub UserForm_Initialize() UserForm1.ComboBox1.RowSource = "sheet1!a1:a10" End Sub 　　C。データベースから（SQLなどで検索後の結果からなど）DataSource 　　　　または配列に下データから などがあると思うが、本件はその区別がはっきりしない。アイテム数はどれぐらいあるのか、他項目と合わせて考える（複数条件の場合）べきなのか。　 ーー また質問の意図を（データ例を挙げるだけでなく）文章で説明すべきと思う。 最終的に、どういう風に（アイテムを）したいのか例示するべき。 データ例を挙げているが、だいたい縦１列に並んだデータがあると都合よい。 ２次元のデータは、扱いがむつかしい。データ例そのままでは多分むつかしい（常識外）。 もっと本質がわかる（形と中身データを変えた）少数例を挙げて、説明文章を添えて説明できないか。その後回答を見て自社の例に復元するのは、質問者の仕事で、これができないなら、回答をもらっても生かせない。 ＞No,　物質名　規格1・・・規格10　商品名1-1・・・商品名1-50　商品名2-1・・・商品2-50・・　 1　　　鉄　　　　1　 ・・・ の部分は、貴社独自のことだろう。常識的に、社員以外のものには、意味がわかるわけがない。 これをどうしようというのか。 なお Ｃｏｍｂｏｂｏｘでは複数行（項目）選択できないようだ。 ＬｉｓｔＢｏｘは項目を複数選択できる。 ーー 「鉄」の行で、横に列方向を見て、１のある、規格１と商品名１－５？などをコンボのアイテムとして設ければよいのか。 こういうのは、文章で１，２例説明すべきでしょう。 基本的な、コントロールの使い方など勉強して、どう応用したらよいか（多分アイテムをどう定義したらよいか）、考えることだ。 ーー 文句言うばかりでは、と思い、本質問と直接関係ないがコード例を挙げてみる。 ニオイぐらいは嗅げるかもしれない。 ーー 下記イベントプロシージュアーの書くところは判るかな。 下記例は、ユーザーフォームには２つのコンボと１つのコマンドボタンを設けている。コマンドボタンは、選択をおわえましたという、トリガーになる。 またパブリック変数について調べて。 Public con1, con2 Private Sub ComboBox1_Click() 'コンボ１で条件１設定 con1 = UserForm1.ComboBox1.Text MsgBox con1 End Sub Private Sub ComboBox2_Click() 'コンボ２で条件２設定 con2 = UserForm1.ComboBox2.Text End Sub Private Sub CommandButton1_Click() 'コマンドボタンをクリックでフィルター実行 'シートに条件があったものが残る。 Worksheets("Sheet1").Range("$A$1:$C16").AutoFilter field:=1, Criteria1:=con1, Operator:=xlOr, field:=2, Criteria2:=con2 End Sub Private Sub UserForm_Initialize() 'ユーザーフォームが最初に表示されるとき行われる作業 ComboBox1.AddItem "aa" ComboBox1.AddItem "bb" ComboBox1.AddItem "cc" ComboBox1.AddItem "dd" ComboBox1.AddItem "ee" ComboBox1.AddItem "ff" '--- ComboBox2.AddItem "x" ComboBox2.AddItem "y" ComboBox2.AddItem "z" ComboBox2.AddItem "u" ComboBox2.AddItem "v" ComboBox2.AddItem "z" ComboBox2.AddItem "k" ComboBox2.AddItem "l" ComboBox2.AddItem "m" End Sub データ例　Ｓｈｅｅｔ１　のＡ１：Ｃ１６ 品物属性数値 aax1 aay2 aaz3 bbu4 bbv5 cck6 ccl7 ddh8 ddi9 ddj10 eek11 ffs12 fft13 ffw14 aay15 ーーー ユーザーフォームの実行で ユーザーフォームが表示される。２個のコンボをそれぞれ選択肢、ボタンをクリック。 主たるフィルタ処理が実行されて、シートに表示される。 品物属性数値 aax1 aay2 aaz3 aay15
こんにちは。 > ワードアートの文字の輪郭を ... どうすれば、消せますか。 ワードアートの３D効果はそのままに、ただ文字の輪郭を消す、ということでしたら、 ご提示のマクロの２行めを Selection.ShapeRange.TextFrame2.TextRange.Font.Line.Transparency = 1 のように置き換えれば、見た目上、消すことができます。 Selection.ShapeRange.TextFrame2.TextRange.Font.Line.Visible = msoFalse この記述を実行しても何も起こりません。理由はわかりません。 .Font.Line.Visible プロパティを変更する、他の方法については、 今と処必要を感じていないので、探していませんが、 もしも、お求めでしたら、その理由を補足として書いてください。 ワードアートの文字の輪郭を消す、他の方法については、 最初に示した通りです。 以上です。
　セルに入力して使用する様な形式の「普通の」関数の中にはその様な関数はありません。 　VBAのマクロで使う関数であれば、その様な用途に使う事も可能な関数も無い訳ではありませんが、こちらの関数はセルに入力して使う事は出来ません。 　又、VBAには自分でオリジナルの関数(セルに入力して使う関数)を作る事も出来、その様なオリジナルの関数は「ユーザー定義関数」と呼ばれます。 　ですから、前述の「VBAのマクロで使う関数」を利用して「セルの色付き、色なしを判断する」ためのオリジナルの関数を作ってしまう事も不可能ではありません。 　但し、その「ユーザー定義関数」は、その関数のためのVBAのマクロを設定したファイルでしか使う事が出来ませんので、別のファイルで同じ「ユーザー定義関数」を使う場合には、ファイルごとにVBAの設定を行う必要があります。 【参考】 　　＠IT > Windows Server Insider > Tech TIPS：Excelでユーザー定義のワークシート関数を追加する 　　http://www.atmarkit.co.jp/ait/articles/0406/12/news017.html
こんにちは Excelなのに表計算ソフトとしての使用を考慮していない国税庁の月額表 のせいですね。 =ROUNDDOWN( IF(B9<88000,0, IF(B9>1740000,VLOOKUP("1,740,000円",所得税!$B:$L,B14+3)+(B9-1740000)*40.84%, IF(B9>1250000,VLOOKUP(" 1,250,000円",所得税!$B:$L,B14+3,0)+(B9-1250000)*33.693%, IF(B9>1010000,VLOOKUP("1,010,000円",所得税!$B:$L,B14+3,0)+(B9-1010000)*32.1615%, VLOOKUP(B9,所得税!$B:$L,B14+3))))),0) と、数式を直すか、国税庁の月額表のB列の金額を数値に直すかですね。 3,570,000円超えは考慮されていないようですが、いいのでしょうか？
すでにお気づきだとは思いますが、先にNo7で間違いがありましたので訂正しておきます その時に10行以降にデータが表示されたときに黄色で反転しているコードの部分が不要(もしくは何かの間違い)な部分ですので を その時に10行以降にデータが表示されたときに黄色で反転しているコードの「一行上の」部分が不要(もしくは何かの間違い)な部分ですので に訂正します。 さて、 > の「("$W$1:$X$53")」の53の部分が怪しいと思います。 質問の画像の10行目以降にあるものは、実際54行目以降にあったものを表示上の理由で10行目に手入力で持って行ったということでしょうか?　よく見るとみかんの合計もおかしいですし。 Q列R列の54行目以降にデータがあると、W列X列の54行目以降にデータが貼り付けられて「Q列とR列の重複を削除」の操作からは外れますので、結果54行目以降にデータは残ります。 Q列R列のすべてのデータを対象とするのでしたら ActiveSheet.Range("$W:$X").RemoveDuplicates Columns:=1, Header:=xlYes としてやれば済みますが、何かの都度Q列R列のデータを消して再度記入し実行するという操作をする場合、下の方を消し忘れた場合、その不要なデータも集計に入ってしまいます。 消し忘れを削除する場合 Columns("Q:R").Select の前に With Cells(2, "Q").End(xlDown) Range(Cells(.Row + 1, "Q"), Cells(Rows.Count, "Q")).ClearContents Range(Cells(.Row + 1, "S"), Cells(Rows.Count, "S")).ClearContents End With としておけば1行目から連続してデータが入っている最終行の次の行から最終行までのデータを削除できます。
>B30からL30までの最小数を求めるときにM30に　=MIN(B30:L30)としますが結果が「0」の時にM30に「{0」を表示しないで「空白」にしたい というのは、そのままの意味で捉えますと、例えばB30:L30の範囲に0,1,2,3,4,5,6,7,8,9,10,11と数字が入力されている場合には、最小の数が0なので何も表示しない様にするという事になりますが、本当にそれで宜しいのでしょうか？ 　もしかしますと質問者様がおやりになりたい事は、 >結果が「0」の時にM30に「{0」を表示しないで「空白」にしたい という事ではなく、「B30:L30の範囲に数値が1つも入力されていない場合にまでM30セルに『0』が表示されてしまうのを無くしたい」という事なのではないでしょうか？ 　もしそうである場合には、次の様な関数となります。 =IF(COUNT(B30:L30),MIN(B30:L30),"")
　(1)のVBAの一例としては以下の様なVBAとなります。 Sub QNo9157101_VBA_アクティブセルに対しての作業に関して1() Const OffsetValueCell = "O1991" Dim buf As Variant, myOffset As Long buf = Range(OffsetValueCell).Value If buf <> "" And IsNumeric(buf) Then _ myOffset = Int(buf) With Application .ScreenUpdating = False .Calculation = xlManual End With If buf = myOffset And myOffset + ActiveCell.Row >= 1 _ And myOffset + ActiveCell.Row <= Rows.Count Then ActiveCell.Offset(myOffset).Value = ActiveCell.Value Else MsgBox OffsetValueCell _ & "セルに入力された値が、現在選択されている" _ & "セルの行番号に対して有効な範囲にありません" End If With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub 　(2)のVBAの一例としては以下の様なVBAとなります。 Sub QNo9157101_VBA_アクティブセルに対しての作業に関して2() Const OffsetValueCell = "O1991" Dim buf As Variant, myOffset As Long buf = Range(OffsetValueCell).Value If buf <> "" And IsNumeric(buf) Then _ myOffset = Int(buf) With Application .ScreenUpdating = False .Calculation = xlManual End With If buf = myOffset And myOffset + ActiveCell.Row >= 1 _ And myOffset + ActiveCell.Row <= Rows.Count Then Range(ActiveCell, ActiveCell.Offset(myOffset)).Value = ActiveCell.Value Else MsgBox OffsetValueCell _ & "セルに入力された値が、現在選択されている" _ & "セルの行番号に対して有効な範囲にありません" End If With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
修復インストールなど、レジストリなどに過去の残骸が残っているときには、それらの中に記録されているプロダクトキーが読みだせることもあります。 プロダクトキー 表示 ツール - Google 検索 https://www.google.co.jp/search?q=%E3%83%97%E3%83%AD%E3%83%80%E3%82%AF%E3%83%88%E3%82%AD%E3%83%BC+%E8%A1%A8%E7%A4%BA+%E3%83%84%E3%83%BC%E3%83%AB
B2 は販売単価ですかね。ならば、 D2=A2*(1-C2) 原価率、％じゃないですよね。0.75% だったらぼったくりです。
No3一部訂正です 標準モジュール以外のモジュール(シートモジュールなど)のプロシージャの外でPublic宣言された変数 (プロシージャの外でDim宣言、Private宣言でも同じ) そのモジュール内のすべてのプロシージャで共有され、他のモジュールのプロシージャから共有されません。 上記を以下に訂正 標準モジュール以外のモジュール(シートモジュールなど)のプロシージャの外で Public宣言された変数 そのモジュール内のすべてのプロシージャで共有され、他のモジュールのプロシージャから共有する場合は「モジュール名.変数名」で共有されます。 Dim宣言、Private宣言された変数 そのモジュール内のすべてのプロシージャで共有され、他のモジュールのプロシージャから共有されません。
>クリップボードへ記憶とはどうやるのでしょうか。 コピー&ペーストの動作はコピーコマンド実行で選択されたデータをクリップボードへ記憶し、貼り付け先でペーストコマンドを実行することでクリップボードのデータが貼りつきます。 この操作はOS上の機能なので「クリップボードへ記憶」や「クリップボードから貼り付け」と言う表現を省略されることが多いようです。 貼付画像はExcel 2010で罫線とオートシェイプを利用した図形をコピー&ペーストのオプション機能で図形として貼り付けたものを右に90度回転させたものです。 文字列を書き加えたいときはテキストボックスを使うと良いでしょう。
>条件付き書式設定で行毎に上位1位は緑色で表示するよう設定してあります。 $C$3:$H$3の上位1位のセルを緑色に塗りつぶすように設定してあるのですよね？ >この書式Ｃ3：Ｈ３を行4以降にコピーしたいのですが範囲をマウスで指定してコピーするとＣ3：H14とかの範囲になってしまいます。 上位1位の比較範囲が$C$4:$H$14になってしまいますよね？ >行毎にコピーする方法を教えてください。 1行ずつ書式のみコピーしなければなりません。 代案としては「数式を使用して、書式設定するセルを決定する」を利用して次の数式を使います。 C3セルへ次のように設定し、C3セルをコピーでクリップボードへ記憶させた上で、C3:H14を選択して書式のみを貼り付けます。 =C3=MAX($C3:$H3) または =RANK(C3,$C3:$H3)=1 貼付画像は貼り付け後の状態です。 数式の中で評価対象のC3は相対番地であり、MAX関数の引数の$C3:$H3は列に対して絶対番地とし、行は相対番地となっています。 3行目の色付きセルのE3は$C3:$H3の範囲で最大の値になっています。 4行目の色付きセルのF4は$C4:$H4の範囲で最大の値になっています。 以下5行目以降も同様に評価されその行の最大の値のセルに色が付きます。
C18セル：=MIN(C3:H3) D18セル：=INDEX(C$2:H$2,MATCH(C18,C3:H3,0)) E18セル：=MAX(C3:H3) F18セル：=INDEX(C$2:H$2,MATCH(E18,C3:H3,0)) 上記の各４セルを下へドラッグコピーしてください。
例データ Ａ１にハイパーリンク　http://google.co.jp Ａ２に１（質問ではＢ１） Ａ３に　=IF(A2=1,HYPERLINK(TEXT(A1,"@"),"グーグル"),"") でうまく行くようです。ハイパーリンク色も出る。 ーー =IF(A2=1,HYPERLINK(A1),"")だとある点でうまく行かない。
こんにちは 30種類位なら、 　　Dim c() 　　Dim s　　 As String 　　Dim r　　 As Range 　　Dim t　　 As Range 　　 　　On Error Resume Next 　　Set t = Worksheets("抽出リスト").Range("A:A").SpecialCells(xlCellTypeConstants) 　　If t Is Nothing Then Exit Sub 　　On Error GoTo 0 　　ReDim c(1 To t.Count) 　　For Each r In t 　　　　i = i + 1 　　　　c(i) = "'" & r.Value & "'" 　　Next 　　s = Join(c, ",") と、IN句に指定するリストを作成して、 　 stSQL = stSQL & "WHERE ITM150 IN (" & s & ")" のように指定してはどうですか？
　確認したいのですが、もしも年月と商品名がどちらも同じになっているデータが複数存在していた場合には、表Bに表示させる実績の値は、表Aにおいて年月と商品名の双方が同じとなっている実績のデータの合計を表示させる様にすれば宜しいのでしょうか？ 　もしそれで宜しいのであれば、以下の様なやり方となります。 　まず、H4セルに次の関数を入力して下さい。 =IF(OR(H$3="",$G4=""),"",SUMIFS($D:$D,$A:$A,H$3,$C:$C,$G4)) 　そして、H4セルをコピーして、H4～J8のセル範囲に貼り付けて下さい。 　以上です。
こんにちは >エクセルで行と列が表示されていなかったので右クリックで表示を選択しましたが表示されません。全選択して、書式から表示をしたのですが何も表示されません。行と列を表示しないようにする方法はどのようなものがありますか？ 　上記のメッセージには「A1セルから N6セルまでが表示されない」という状況が含まれるのですね(^^) 　状況からA1セルからN6セルは「ウィンドウ枠の固定」の内側に入っているのだと思います。 　表示メニューにある「ウィンドウ枠固定の解除」をしてスクロールしてみて下さいねm(__)m
UWSCなどの、複数アプリをまたいでの自動運転が可能なツールを使うのが簡単でしょう。 公式サイト（ダウンロードでFree版を選ぶ） http://www.uwsc.info/ Free版でもExcelを操作できますが、VBAのようにCellsやRangeでセル位置を直接指定するような関数はないので、Ctrl+Homeを押した後にカーソルキーxx回押して目的位置に移動する、的な工夫は必要になりますが、そこさえ注意していればできます。
フィルタ（オートフィルタ）で抽出できます。 Excel 2013ですが下記URLを参考に http://www4.synapse.ne.jp/yone/excel2013/excel2013_filter.html http://www4.synapse.ne.jp/yone/index_filter.html 複数条件で並び替えなら 関連項目を複数作ってはいかがでしょう。 名前　　　住所　　　関連１　　　関連２　　 山田太郎　東京　　　写真仲間　　家庭用 木村次郎　埼玉　　　　友人　　　家庭用 太田三郎　埼玉　　　　業務用　 複数条件で並び替えを行い 「最優先されるキー」に　「関連１」 「次に優先されるキー」に「関連２」 を設定します。 複数条件で並び替えの方法は　下記URLを参考に https://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=016326
　画像の文字が潰れていて、どこにどんなデータが入力されているのか良く解りませんので、取りあえず仮の話として、A1セルに「2016」や「平成28」等の年の値が入力されていて、AA3セルに「当番氏名」、AB3セルに「開始位置」と入力されていて、AA4～AA99のセル範囲が当番の氏名の入力欄として使用されていて、尚且つ、その当番の氏名は途中に空欄が挟まっている事無く連続したセル範囲に入力されているものとします。 　又、A3～Y3のセル範囲には4月～3月の月が1列おきに入力されていて、その下の4行目～34行目の範囲には各月の日付が自動的に表示される様にし、各日付の右隣のセルには、その日の当番の氏名が自動的に表示される様にするものとします。 　又、A1セルに年を示す値が入力されていない場合や、当番の氏名が1人も入力されていない場合、当番の氏名が並んでいる途中に空欄のセルが挟まっている場合、AB列に「新年スタート」と入力されているセルが存在しない場合、及びAB列に「新年スタート」と入力されているのと同じ行内のAA列のセルに当番の氏名が入力されていない場合には、A4～X34のセル範囲には何も表示されないものとします。 　まず、A3セルの書式設定の表示形式を[ユーザー定義]の "4月" として下さい。 　次に、A3セルに次の関数を入力して下さい。 =IF(ISERROR(($A$1&"年4月7日")/(INDEX($AA:$AA,MATCH("新年度スタート",$AB:$AB,0))<>"")/(COUNTIF($AA$3:$AA$99,"*?")=ROWS($AA$3:INDEX($AA$3:$AA$99,MATCH("*?",$AA$3:$AA$99,-1))))),0,($A$1&"年4月7日")-WEEKDAY($A$1&"年4月7日",2)) 　次に、A4セルの書式設定の表示形式を[ユーザー定義]の daaa として下さい。 　次に、A4セルに次の関数を入力して下さい。 =IF(SUM($A$3),IF(MONTH(DATE(YEAR($A$3),INT(COLUMNS($A:A)/2+4),ROWS(A$4:A4)))=MOD(INT(COLUMNS($A:A)/2+3),12)+1,DATE(YEAR($A$3),INT(COLUMNS($A:A)/2+4),ROWS(A$4:A4)),""),"") 　次に、B4セルに次の関数を入力して下さい。 =IF(SUM(A4)<1,"",IF(WEEKDAY(A4)=2,INDEX($AA$3:$AA$99,MOD(INT((A4-$A$3)/7)+MATCH("新年度スタート",$AB:$AB,0)-ROW($AB$3)-1,COUNTIF($AA$3:$AA$99,"*?")-1)+2),"")) 　次に、A4～B4のセル範囲をコピーして、C4～X4のセル範囲に貼り付けて下さい。 　次に、A4～X4のセル範囲をコピーして、A5～X34のセル範囲に貼り付けて下さい。 　以上です。
FoundCellという変数に「見つかったセル」が入る，というリクツさえ理解すればあとはカンタンです。 ヤリタイ事の要件： １．目的のセル範囲に探したいものがあったら確保する ２．そのセルの左隣のセルの内容を持って行きたいセルに転記・コピー・参照させる ２’無かった時は終了する sub macro1() 　dim FoundCell as range 　set foundcell = range("B55:B63").find(what:=1, lookin:=xlvalues, lookat:=xlwhole) 　if foundcell is nothing then exit sub 　range("E17") = foundcell.offset(0, -1).value end sub
　回答No.2です。 　もし表1の日付が順不同ではなく日付順(昇順でも、降順でもどちらでも可)に並んでいる場合には、作業列を使用しない以下の様な方法を使う事が出来ます。 　まず、Sheet2のA2セルに次の関数を入力して下さい。 =IF(A1="","",IF(COUNTIF(Sheet1!$A:$A,">"&SUM(A1)),LARGE(Sheet1!$A:$A,COUNTIF(Sheet1!$A:$A,">"&SUM(A1))),"")) 　次に、Sheet2のA2セルの書式の表示形式を[日付]に設定して下さい。 　次に、Sheet2のB2セルに次の関数を入力して下さい。 =IF(OR($A2="",B$1=""),"",IFERROR(VLOOKUP("*?",OFFSET(INDEX(Sheet1!$B:$D,MATCH($A2,Sheet1!$A:$A,0),MATCH(B$1,Sheet1!$B$1:$D$1,0)),,,COUNTIF(Sheet1!$A:$A,$A2)),1,FALSE),"")) 　次に、Sheet2のB2セルをコピーして、Sheet2のC2～D2のセル範囲に貼り付けて下さい。 　次に、Sheet2のA2～D2のセル範囲をコピーして、Sheet2のA列～D列の3行目以下に貼り付けて下さい。 　以上です。
No3です。訂正です。 それぞれのシートのコードペインに記載すると、あとあと訂正などがあると同じところを何か所も訂正しないといけなくなり面倒なので、左にあるThisWorkbookをダブルクリックして出たコードペインだけに以下のコードを記載してください。 Private Sub Workbook_SheetActivate(ByVal Sh As Object) Dim mSheet As Worksheet Dim DefaultSheetName As Variant Dim i As Long If Sh.Name = "売り上げ表" Or Sh.Name = "売り上げ内容" Or Sh.Name = "関連業者" Then DefaultSheetName = Array("売り上げ表", "売り上げ内容", "関連業者") For Each mSheet In ThisWorkbook.Worksheets If mSheet.Name Like Sh.Name & "*" Then Sheets(mSheet.Name).Visible = True Else Sheets(mSheet.Name).Visible = False End If Next mSheet For i = 0 To UBound(DefaultSheetName) Sheets(DefaultSheetName(i)).Visible = True Next End If End Sub
=INDEX($A$1:$A$20,(ROW(A1)*2-1),1) でいかがですか。
例えば、3月は31なので、15日目の場合、15/31とするのか、 それとも月は一律30日で計算するのかで違ってきますが、 前者の場合、 =DATEDIF(A1,B1,"YM")+DATEDIF(A1,B1,"MD")/DAY(DATE(YEAR(B1),MONTH(B1)+1,0)) 後者の場合、 =DATEDIF(A1,B1,"YM")+DATEDIF(A1,B1,"MD")/30
配置表になぜ2名書かれているのか、配置表のどこに3月30日と書かれているのか不明ですが一応配置表のB2に3月30日と書かれているとして、ファイル名も分からないのでシフト表がシフト表.xlsxとして、シート名も分からないのでSheet1として、一郎などの名前がA2から始まり下方向に並び、日付が1行目にあるとした場合、配置表の定休の横の一郎と記載されているセルに =INDIRECT("[シフト表.xlsx]Sheet1!$A" & MATCH("休",OFFSET([シフト表.xlsx]Sheet1!$A$1,0,MATCH(B2,[シフト表.xlsx]Sheet1!$1:$1,0)-1,100),0)) と入力してください。仮定が一致していれば一郎と表示されます。 ただ、多分一致しないと思いますので適宜ご自身のファイル名シート名セル番地に変更してください。
以下でいかがでしょう Sub 判定仮本物() Dim i As Integer, j As Integer Dim k As Double Range(Cells(3, "L"), Cells(32, "L")).ClearContents Range(Cells(3, "E"), Cells(32, "K")).Interior.ColorIndex = 0 k = Cells(4, 2) 'B4セルの値 For i = 3 To 32 If Abs(Cells(i, "E") - Cells(i, "H")) <= k And Abs(Cells(i, "E") - Cells(i, "K")) <= k Then If i Mod 2 = 1 Then Union(Cells(i, "E"), Cells(i, "H"), Cells(i, "K")).Interior.ColorIndex = 6 Cells(i, "L") = "OK" Else Union(Cells(i, "E"), Cells(i, "H"), Cells(i, "K")).Interior.ColorIndex = 40 Cells(i, "L") = "OK" End If Else If Abs(Cells(i, "E") - Cells(i, "H")) > k Then Cells(i, "H").Interior.Color = vbRed End If If Abs(Cells(i, "E") - Cells(i, "K")) > k Then Cells(i, "K").Interior.Color = vbRed End If End If Next If WorksheetFunction.CountIf(Range("L3:L32"), "OK") > 29 Then MsgBox "データチェックOK(^O^)b" End If End Sub
B1セルに以下の式を入れてみてください。 =LEFT(A1,FIND("か",A1)-1)+MID(A1,FIND("月",A1)+1,2)*1/30
フロッピーディスクが保存のシンボルマークになったのでしょう。 フラグ (Flag)は鉄道の信号の旗から、boot　log　の語源はかなり古めかしいものですね。 http://wedder.net/kotoba/computer.html コンピューターの歴史的にはフロッピーディスクの出現は最近の出来事ですね。 そう言えば 英語で「電源を入れる」「明かりを付ける」は [turn on power][turn on the light] が一般的で初期の電気製品のスイッチがダイヤル式だったからだと聞いたことがあります。 余談 初めて触ったパーソナル・パソコンはmacでした。 電源スイッチをAppleのリンゴのマークと思い込んでいたらWindowsPCも同じマーク 2進法の[0][1]で[Off][on}を表していることを知るのにかなりの期間が有りました。 IME2010を使っていますが「でんわ」で変換すると「(黒電話)」がでてきます。 黒電話もほとんど見かけませんね。
シフト表がどのように作成されているのかまったく不明ですし、配置表も同じように不明ですので雲をつかむような話になっています。 たとえば シフト表 　A　　　B　　　C　　 1　　　　3/1　　　3/2 2田中　　休 3吉田　　　　　　休 ↑このようになっているとか 配置表も定休と設けた箇所に順番とありますが、縦に順番なのか横に順番なのか不明ですので、配置表でこのように記載したいとか具体的に上記の感じで記載してみてはいかがでしょう。 また、３月３０日の配置表というのがその日専用のシートなのか(専用シートならどこに日付があるのか)、同じシートに日付ごとに配置の氏名が並んでるのかとかもわかりません。
　もし、 >Sheet1にある複数の文字列 と >Sheet2の文字列 の双方が一列に並んでいる場合には、配列数式の様な処理が重くなりがちな方法を使うまでもなく、通常の関数を使って「Sheet1にある文字列」を含んでいる文字列が入力されているSheet2のセルの行番号を全て表示させる事が出来ます。 　今仮に、 >Sheet1にある複数の文字列 が、Sheet1のA列に入力されていて、Sheet1のA1セルは「氏名」等の項目名を入力するためのセルとして使用されていて、実際の氏名データはSheet1のA2以下に入力されているものとします。 　又、 >Sheet2の文字列 はSheet2のA列に入力されていて、Sheet2のA1セルは「検索対象文字」等の項目名を入力するためのセルとして使用されていて、実際の文字のデータはSheet2のA2以下に入力されていて、その右隣のSheet2のB列のセルには「検索対象文字」を含んでいる文字列データが入力されているセルの個数を表示させ、Sheet2のC列から右側にある列のセルには「検索対象文字を含んでいる文字列が入力されているSheet2のセル」の行番号を順番に表示させるものとします。 　まず、Sheet2のB2セルに次の関数を入力して下さい。 =IF($A2="","",IF(COUNTIF(Sheet2!$A:$A,"*"&$A2&"*"),COUNTIF(Sheet2!$A:$A,"*"&$A2&"*")&"箇所","無")) 　次に、Sheet2のC2セルに次の関数を入力して下さい。 =IF(RIGHT($B2,2)="箇所",IF(ISERROR(1/(SUBSTITUTE($B2,"箇所",)-COLUMNS($C:C)>=0)),"",MATCH("*"&$A2&"*",INDEX(Sheet2!$A:$A,IF(COLUMNS($C:C)=1,ROW(Sheet2!$A$1),B2)+1):INDEX(Sheet2!$A:$A,ROWS(Sheet2!$A:$A)),0)+IF(COLUMNS($C:C)=1,ROW(Sheet2!$A$1),B2)),"") 　次に、Sheet2のC2セルをコピーして、Sheet2の2行目において、C列よりも右側にある列のセルに貼り付けて下さい。 　次に、Sheet2の2行目において、B列よりも右側にある列のセル範囲をコピーして、同じ列範囲の3行目以下に貼り付けて下さい。 　以上です。
こんにちは。 > コンパイルエラー：型が一致しません。 容易に再現できるエラーですが、 コンパイルエラーの原因は、引数の渡し方、です。 オブジェクト型のまま「参照渡し」として 　　sub1 ie または 　　 Call sub1(ie) のようにするのが正しのですが、 　　 sub1 (ie) などのように余分な括弧を付けてしまうと、 オブジェクト型では「値渡し」できませんので、 「型が一致しません。 」というエラーになります。 こういうのは、ベテランでも見落とすことのあるミスですが、 何か問題にあった時に、「不必要な括弧」が残っていないか、 「不必要」や「余分」を探すようにデバッグすると、 あっけない程簡単に解決できることが結構ありますね。
>質問が説明不足で他の方にはご迷惑をお掛けしてしまいました。 >「下にコピー」する方法では意図と違ってしまうのです。 A列の1行目から順に下のセルへ追加の数値データが入力されるものとして最新データの下のセルはすべて未入力であるとすれば次の数式で目的の範囲が指定できます。 INDEX(OFFSET($A$1,MAX(INDEX((A:A<>"")*ROW(A:A),0))-2,0,-50,1),0) または INDEX(A:A,MATCH(MAX(A:A),A:A)-50):INDEX(A:A,MATCH(MAX(A:A),A:A)-1) これを使用して平均を求めるには次の数式になります。 =AVERAGE(INDEX(OFFSET($A$1,MAX(INDEX((A:A<>"")*ROW(A:A),0))-2,0,-50,1),0)) または =AVERAGE(INDEX(A:A,MATCH(MAX(A:A),A:A)-50):INDEX(A:A,MATCH(MAX(A:A),A:A)-1)) 貼付画像はExcel 2010で検証した結果です。 C1は前者の数式で、C2が後者の数式です。 8行目～50行目は非表示にしてありますがA列のセルには数値を入力してあります。 標準偏差については幾つかの組込み関数がありますので、あなたの目的に合う関数で応用してください。
Sub 判定仮() Dim i As Integer, j As Integer Dim k As Double Range(Cells(3, "L"), Cells(32, "L")).ClearContents Range(Cells(3, "E"), Cells(32, "K")).Interior.ColorIndex = 0 k = Cells(4, 2) ’B4セルの値 For i = 3 To 32 If Abs(Cells(i, "E") - Cells(i, "H")) <= k And Abs(Cells(i, "E") - Cells(i, "K")) <= k Then If i Mod 2 = 1 Then Union(Cells(i, "E"), Cells(i, "H"), Cells(i, "K")).Interior.ColorIndex = 6 Cells(i, "L") = "OK" Else Union(Cells(i, "E"), Cells(i, "H"), Cells(i, "K")).Interior.ColorIndex = 40 Cells(i, "L") = "OK" End If End If Next If WorksheetFunction.CountIf(Range("L3:L32"), "OK") > 29 Then MsgBox "データチェックOK(^O^)b" End If End Sub 無意味な式、無意味な判定文は削除しました。 例えば Cells(i, "E").Row は、常に i と同じ値を返すので If Cells(i, "E").Row Mod 2 = 1 Then は If i Mod 2 = 1 Then で構いません。 また、 If i Mod 2 = 1 Then でElseに来た時は If Cells(i, "E").Row Mod 2 = 0 Then は「常に成り立つ」ので、まったく無意味です。
> もう少し簡単な方法ではないでしょうか…？ 残念ながらありません。この中で一番簡単な方法はNo4さんの方法になります。 シートの名前の入ったタブを右クリックして出るメニューの「コードの表示」を選択すると新しく画面が開きますので(添付画像のような画面です)そこの右側のOption Explicitと書かれているところの下にNo4さんの Private Sub Worksheet_SelectionChange(ByVal Target As Range) から End Sub までをコピーして貼り付けてください。 その後、新しく名前を付けて保存で ファイルの種類(T): Excelマクロ有効ブック(*.xlsm) にして保存してください。 次回起動時には セキュリティの警告　マクロが無効にされました が出るので　コンテンツの有効化　を押してください。 ただ、「カーソルを乗せたら一覧が表示される」って実際やってみると意外と鬱陶しかったりすると思いますよ。
エクスプローラーで検索してみてはどうですか？ やり方は下記が参考になるでしょう。 https://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=013418 検索するファイル名が分からなかったら「*.xlsx」でもいいでしょう。 あるいはファイル名の一部でも覚えているなら「*ファイル名の一部*.xlsx」として検索してみてください。
「=開始日セル-終了日セル+1-COUNTIFS(休日リストにある日付範囲絶対参照,">="&開始日,休日リストにある日付範囲絶対参照,"<="&終了日)」
WorksheetFunction.EoMonth(dt, 1) ではないでしょうか。
　回答No.4です。 >もし良ければ考え方を教えてもらえないでしょうか >これは難しいです 　いえ、長いだけで構造自体はさほど複雑なものでは御座いません。 　まず、SUBSTITUTE関数とは、 SUBSTITUTE(元の文字列, 検索文字列, 置換文字列, [置換対象]) という形式で記述する関数で、「元の文字列」の中に含まれている「検索文字列」と同じ文字列を、「置換文字列」に置き換える関数です。 　回答No.4の関数の中には SUBSTITUTE(A2," ","　") という箇所が2回出て来ますが、これは「元の文字列」の所にA2が指定されていて、「検索文字列」の所に半角スペースが指定されていて、「置換文字列」の所に全角スペースが指定されていますから、、「A2セルに入力されている文字列の中に含まれている全ての半角スペースを全角スペースに置換する関数」という事になります。 　何故、半角スペースを全角スペースに置換するのかと申しますと、料理名と金額の間に挟まっているスペースの位置から金額がどこから始まっているのかを判断する際に、「料理名と金額の間に挟まっているスペース」が半角スペースなのか全角スペースなのかが不明であったため、そのままではFIND関数でスペースの位置を求める際に、半角スペースの位置を求めれば良いのか、それとも全角スペースの位置を求めれば良いのか判りませんから、どちらであったとしてもスペースの位置を求める事が出来る様にするために、半角スペースを全角スペースに置換してから全角スペースの位置を求める様にしている訳です。 　処で、 >メニューには >コーヒー ブラック 300円 >と空白が二つあるものがありました。 という問題を解決し、金額が始まる正しい位置を求めるためには、「『スペース』+『数字以外の文字』」という組み合わせとなっている箇所のスペースは無視して、「『スペース』+『(1～9の)数字』」という組み合わせとなっている箇所のスペースの位置を求める必要があります。 　料理の価格なのですから、スペースの次に来る数字が「0」やマイナスである事はあり得ませんので、「0」や「-」に関しては処理対象とする必要が無く、 SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9),2,9),3,9),4,9),5,9),6,9),7,9),8,9) という部分の中の、 SUBSTITUTE(A2," ","　") の部分でまず半角スペースを全角スペースに置換し、 SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9) の部分で「1」を「9」に置換し、 SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9),2,9) の部分で「2」を「9」に置換し、 SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9),2,9),3,9) の部分で「3」を「9」に置換し、・・・という具合に1～8の数字を順次数字の「9」に置換して行く事によって、金額の先頭に来る数字をが必ず9になる様にしている訳です。 　例えば、A2セルに入力されている文字列が「コーヒー アメリカン 305円」というものだった場合には、 SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9),2,9),3,9),4,9),5,9),6,9),7,9),8,9) の部分が返す値は「コーヒー　アメリカン　909円」になる訳です。 　そこで FIND("　9",SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9),2,9),3,9),4,9),5,9),6,9),7,9),8,9)) という具合にFIND関数を使用して「　9」という文字列が現れている位置を求めれば、その1文字後ろの所からが金額という事になる訳です。 　尚、後で説明する際に解り易くするために、この FIND("　9",SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A2," ","　"),1,9),2,9),3,9),4,9),5,9),6,9),7,9),8,9)) という部分の事を、これ以降は 「『スペース』+『数字』の位置を求める関数」 と仮称して表現する事に致します。 　この様にすれば金額が始まっている位置は求める事が出来ますが、「うどん　400円（通常450円）」の様な例もある以上、「『スペース』+『数字』」より後ろの部分を全て取り出してしまったのでは金額を求めた事になりません。 　そのため、LEFT関数を使用して「円」が現れている位置の1文字前の所までだけを取り出す必要がありますが、「円」の文字が付くのは金額の後だけとは限らず、例えば「高円寺メタルめし」などの様にもしかしますと料理名の中に「円」の文字が含まれているものもあるかも知れませんので、単純に FIND("円",A2) などの様にして最初に現れる「円」位置を求めたのでは、金額部分よりも前の位置を求めてしまう恐れがあり、その「円」の位置よりも前の部分を取り出したのでは、金額の部分が含まれなくなってしまう恐れがあります。 　そのため、FIND関数を使う際に FIND("円",A2,「『スペース』+『数字』の位置を求める関数) などの様にして、 FIND(検索文字列, 対象, [開始位置]) の中の「開始位置」(文字の検索を開始し始める位置)の所に、前述の「『スペース』+『数字』の位置を求める関数」を入れ子にして使用する事で、「『スペース』+『数字』」の所よりも後の所に現れる「円」のみをFIND関数の検索対象とする事で、金額の後ろに付く「円」の文字位置を求めている訳です。 　「円」の位置は金額を表している数字よりも1つ後ろの位置にあるのですから、「円」の文字自体は必要ありませんので、 LEFT(A2,FIND("円",A2,「『スペース』+『数字』の位置を求める関数)-1) とする事で、「円」の1つ前の所までの文字列を取り出している訳です。 　ここでもこの LEFT(A2,FIND("円",A2,「『スペース』+『数字』の位置を求める関数)-1) という部分の事を、これ以降は 「『円』の1つ前の所までの文字列を求める関数」 と仮称して表現する事に致します。 　さて、こうして取り出した「『円』の1つ前の所までの文字列」には、料理名やスペース等の金額ではない部分が含まれています。 　この余計な部分を除去するのに用いているのがREPLACE関数で、REPLACE関数は REPLACE(元の文字列, 開始位置, 文字数, 置換文字列) という形式で記述される関数で、「元の文字列」の中の「開始位置」番目の文字列から「文字数」分の長さの文字列を、「置換文字列」の所で指定した文字列に置換する関数です。 　例えば、 REPLACE("ABCDE",2,3,"FGHI") とした場合には、「ABCDE」の中の先頭から2文字目である「B」から3文字分の長さの文字列である「BCD」を置換対象として、「FGHI」に置き換えた「AFGHIE」が返されます。 　そこで、 REPLACE(「『円』の1つ前の所までの文字列を求める関数」,1,「『スペース』+『数字』の位置を求める関数」,) とする事で、「『円』の1つ前の所までの文字列」の1文字目から「『スペース』+『数字』の位置」と同じ長さの文字列の部分を消去(「置換文字列」の所に何も指定していないため置換後には何もなくなる)している訳です。 　只、このままでは得られる結果は、数字のみからなるデータではあっても、数字のみからなる文字列データに過ぎず、数値データとはなりませんから、上記の数式に　+0　を付け足す事によってExcelに計算処理を行わせる事で数値データに変換しています。 　後は、例えば「刺身定食　時価」などの様に金額に変換できないデータがあった場合にもエラーとならない様にするために、上記の部分をIFERROR関数で囲い、金額に変換できない場合には「(不明)」と表示させるようにした上で、元データのセルが空欄の場合にまで「(不明)」と表示されてしまう事を防ぐために、IF関数で囲って =IF(A2="","",IFERROR関数) としている訳です。
　「メロン２」ではなく例えば「メロン×２」の様に表示させるのでしたら次の様な方法を使う事が出来ます。 　まず、F1セルに次の関数を入力して下さい。 =IFERROR(HLOOKUP("*?",$A2:$F2,1,FALSE)&"×"&COUNTIF($A2:$F2,HLOOKUP("*?",$A2:$F2,1,FALSE)),"") 　次に、G1セルに次の関数を入力して下さい。 =IF(F1="","",IF(LEFT(F1,FIND("×",F1)-1)=$E2,"",IFERROR(HLOOKUP("*?",INDEX(2:2,SUMPRODUCT(MAX(($A2:$E2=LEFT(F1,FIND("×",F1)-1))*COLUMN($A2:$E2))*1)+1):$E2,1,FALSE)&"×"&COUNTIF($A2:$F2,HLOOKUP("*?",INDEX(2:2,SUMPRODUCT(MAX(($A2:$E2=LEFT(F1,FIND("×",F1)-1))*COLUMN($A2:$E2))*1)+1),1,FALSE)),""))) 　次に、G1セルをコピーして、H1～J1のセル範囲に貼り付けて下さい。 　以上です。
偶数行と奇数行で色分けを忘れてました。たびたび訂正ですみません。 Sub example() Dim i As Integer Range(Cells(3, "O"), Cells(102, "O")).ClearContents Range(Cells(3, "E"), Cells(102, "N")).Interior.ColorIndex = 0 For i = 3 To 102 If WorksheetFunction.CountIf(Range(Cells(i, "E"), Cells(i, "N")), Cells(i, "E")) > 3 Then With Union(Cells(i, "E"), Cells(i, "H"), Cells(i, "K"), Cells(i, "N")) If i Mod 2 = 1 Then .Interior.ColorIndex = 6 Else .Interior.ColorIndex = 40 End If End With Cells(i, "O") = "OK" End If Next If WorksheetFunction.CountIf(Range("O3:O102"), "OK") > 99 Then MsgBox "データチェックOK(^O^)b" End If End Sub
ワークシートは Excel が計算し易いレイアウトで使いませう！ 添付図上段のレイアウトは愚の骨頂です。 せめて、添付図下段のようにしませう。それが出来ない理由は何ですか？
A1: =IF(B1,COUNTIF(B$1:B1,">0"),"")
　回答No.2です。 　もしワークシート関数ではなくVBAで行う場合には、一例としては次の様なVBAとなります。 Sub QNo9148287_エクセルマクロで出来れば() Const DataSheetName = "Sheet1" '元データが入力されているシートのシート名 Const OutputSheetName = "Sheet2" '出力先のシートのシート名 Const ProductColumn = "Y" '商品名が入力されている列の列番号 Const CodeColumn = "N:X" '商品コードが入力されている列の列番号 Const FirstRow = 1 '(項目名欄以外で)元データが入力されている行の中で最も上にある行 Const OutputCell = "A1" '出力先となるセル範囲の中で左上の隅に当たるセルのセル番号 Dim DataSheet As Worksheet, OutputSheet As Worksheet _ , LastRow As Long, myRange As Range, c As Range, i As Long If IsError(Evaluate("ROW('" & DataSheetName & "'!A1)")) Then MsgBox "元データが入力されているシートとして設定されている" _ & vbCrLf & vbCrLf & DataSheetName & vbCrLf & vbCrLf & _ "というシート名のシートが見つかりません。" & vbCrLf _ & "マクロを終了します。", vbExclamation, "存在しないシート" Exit Sub End If Set DataSheet = Sheets(DataSheetName) LastRow = DataSheet.Range(ProductColumn & Rows.Count).End(xlUp).row If LastRow < FirstRow Then MsgBox "処理すべきデータが見当たりませんません。" & vbCrLf _ & "マクロを終了します。", vbExclamation, "データ無し" Exit Sub End If If IsError(Evaluate("ROW('" & OutputSheetName & "'!A1)")) Then Set OutputSheet = Worksheets.Add() OutputSheet.Name = OutputSheetName Else Set OutputSheet = Sheets(OutputSheetName) End If With Application .ScreenUpdating = False .Calculation = xlManual End With i = -1 With OutputSheet.Range(OutputCell) .Resize(Rows.Count - .row + 1, 2).ClearContents For Each c In Intersect( _ DataSheet.Range(CodeColumn), _ DataSheet.Range(FirstRow & ":" & LastRow)) If c.Value <> "" Then i = i + 1 .Offset(i).Value = c.Value .Offset(i, 1).Value = DataSheet.Range(ProductColumn & c.row).Value End If Next c End With With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
>Excel2010で図のように、隣のセルから移動させて、1行にしたいのですが、 「1行」は「1列」の誤りかと思います。 用語を誤ると質問の内容を取り違えることになります。 A列からC列の値をE列の1列へ纏めたいと言うことでしょうか？ E1=SUM(A1:C1) E1セルを必要数だけ下へコピーすれば目的通りになります。
こんにちは。 > 「実行時エラー13　型が一致しません」というものが出て，デバックというところをクリックすると，If Target.Value = "" Thenのところが黄色くなり矢印が出ていたのでここが問題 問題点の切り分けとしては、正しいです。 原因としては、 　Targetが単一セルではない →Target.Valueが配列になる →配列値をイコール演算することによって →「実行時エラー13　型が一致しません」が返る といった状態が考えられます。 以下、対策として。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Const rng As String = "A1:B3" '処理対象のセル範囲 　　' ' 処理対象のセル範囲に掛からない範囲であれば、処理を抜ける 　　If Application.Intersect(Target, Range(rng)) Is Nothing Then Exit Sub 　　Cancel = True　'　ダブルクリックによる[入力（編集）モード]移行をキャンセル 　　With Target(1)　'　ダブルクリックが結合セルである場合に備えて先頭セルだけを対象にする。 　　　　If IsEmpty(.Value) Then　'　セルの値が空ならば、 　　　　　　.Value = "○"　'　セルの値を"○"にする。 　　　　Else　'　セルの値が空でなければ、 　　　　　　.Value = Empty　'　セルの値を空にする。 　　　　End If 　　End With End Sub
3行目の日付を予め手入力してあることを前提にすれば2行目に条件付き書式でフォントの色を指定すれば可能です。（フォントの色を塗りつぶしの色と同じにする） 条件式は下記の通りとします。 =A3>TODAY() 貼付画像はA2～D2を選択して条件の数式を指定した状態です。 3行目の日付が今日（TODAY()）より小さいときはフォントの色を塗りつぶしの色と同色（白）を指定してあります。 C2には9、D2には23が入力されています。 3行目の日付は検証用なので連続日付としました。 尚、3行目に当月の最終平日（最終営業日）を算出するには週休日（土日？）以外に祝祭日や振替休日を織り込む必要がありますので条件を提示してください。 数式を組むと難解になると思います。
VBScriptで作ってみました。 「VBA」との違いですが、「VBA」では、いちいち、ファイルごとにマクロをコピー＆ペーストして実行する必要がありますが、「VBScript」では、外部から操作するので、分割したいエクセルファイルのあるフォルダにプログラムファイルを放り込んで、ダブルクリック（もしくは「シングルクリック」→「Enter」の方が確実）、すれば実行してくれ、同じフォルダ内にある、すべてのエクセルファイルを分割してくれます。 したがって、同じフォルダ内には、分割したくないエクセルファイルを入れてはいけません。 以下のプログラムを、メモ帳などにコピー＆ペーストして、ファイル名を「～.vbs」と拡張子を必ず「vbs」とします（「～」の部分は何でも構いません）。 あとは、そのプログラムファイルを分割したいエクセルファイルのあるフォルダに放り込んでダブルクリックするだけです。 Option Explicit Dim a, b, c, i, t, u, v, w, x, y, z Set t = CreateObject("Scripting.FileSystemObject") Set u = t.GetFolder(".") Set v = CreateObject("Excel.Application") v.Application.DisplayAlerts = False For Each a In u.Files b = LCase(t.GetExtensionName(a.Name)) If b = "xls" or b = "xlsx" Then Set w = v.Workbooks.Open(u & "\" & a.Name) For i = 1 to w.Sheets.Count Set x = w.WorkSheets(i) Set y = v.Workbooks.Add() Set z = y.Worksheets(1) x.Copy z y.Worksheets(2).Delete y.Worksheets(1).Name = x.Name y.SaveAs(u & "\" & a.Name & "＋" & x.Name & "." & b) y.Close Set z = Nothing Set y = Nothing Next w.Close Set x = Nothing Set w = Nothing End If Next v.Quit Set v = Nothing Set u = Nothing Set t = Nothing 私の勉強不足で、一部、鈍くさいところがありますが、目的は達成できています。
ご自身のようなプロフェッショナルが、職場に一人でもいてくれれば、一日でも助けに来てマクロやVBAで自動化してくれれば、と有料でも呼びたい人は多いとおもいますので、ぜひその能力で起業していただければと存じます。
serch関数を使用するとエラー処理が必要になるので、今回ではcountif関数をワイルドカードでJPYを含んでいるか、right、left関数でUSDであるかを判断する事で対応可能だと思います。 ＄B7とJ列が数値であるかの判定はcount関数で可能です。 （画像はB7、I列にダミーデータとして１を入力しています） 添付画像の結果で良ければ下記数式 I5式 =IF(COUNT($B$7,J5)<>2,"",IF(COUNTIF(D5,"*JPY*"),"USDJPY",IF(RIGHT(D5,3)="USD","不要",IF(LEFT(D5,3)="USD",D5,VLOOKUP("*" & RIGHT($D5,3) & "*",A$15:A$21,1,FALSE))))) 下方へオートフィル
> エクセルオンラインはwifi環境では使えないのでしょうか 基本的には使えます。 しかしWiFi側で規制が入っていたり、または著しく混雑している等の事情がある場合は、使えない場合もあるかと思います。 もう一つは、セキュリティソフト側がWiFiを危険なパブリック環境とみなして干渉している可能性も考えられなくはないです。
　次の様な関数をC1セルに入力してから、C1セルをコピーして、C2～C4のセル範囲に貼り付けると良いと思います。 =IF(LEN($B1)<3,"",IFERROR(VLOOKUP("*"&RIGHT($B1,3)&"*",$A1:$A6,1,FALSE)))
>しかし、B列の何行目まで入力するのかわからないので 　その様な場合には、関数を事前に入力するのではなく、B列に新たに入力しなければならない箇所を一通り入力し終えてから、C列の中の関数が入力済みとなっているセルをコピーして、新たに消費税等を表示させなければならなくなったセル範囲に貼り付ければ済む話です。 　または、C2セルに入力する関数を ＝B2＊8％ などではなく、 ＝IF(ISNUMBER($B2),$B2＊0.08,"") などの様にしておく事で、B列に数値が入力されていない場合には何も表示されない様にしておいた上で、適当な行まで大目にコピーしておけば済む話です。 　その程度の事にまでマクロを使って行ったのでは返って面倒な事になると思います。 　とは言え、質問者様以外の閲覧者の中には「職場の決まりで関数の使用が禁じられている」という事情を抱えている方もおられるかも知れませんから、念のためにVBAのマクロによるやり方も併記しておきます。 　まず、Excelウィンドウの上の方にある[開発]タブをクリックし、現れた[Visual Basic]ボタンをクリックして下さい。 　すると「Microsoft Visual Basic for Applications」ウィンドウが開きますので、そのウィンドウの左側の「プロジェクト - VBAProject」欄内にある「御質問の様な処理を行いたいシート」に該当するシートモジュールをダブルクリックしてから、ウィンドウの右側の欄に下記の構文を入力して保存して下さい。 Private Sub Worksheet_Change(ByVal Target As Range) Const AmountColumn = "B" Const TaxColumn = "C" Const ItemRow = 1 Dim c As Range, myRange As Range Set myRange = Intersect(Target, Columns(AmountColumn), Range(ItemRow + 1 & ":" & Rows.Count)) If myRange Is Nothing Then Exit Sub With Application .ScreenUpdating = False .Calculation = xlManual End With For Each c In myRange If c.Value <> "" And IsNumeric(c.Value) Then Range(TaxColumn & c.row).Value = c.Value * 0.08 Else Range(TaxColumn & c.row).ClearContents End If Next c With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
　回答No.1です。 　済みません、前回の回答には入力ミスが御座いました。 ×　「検索する文字列」欄には2016、「置換後の文字列」欄には2016と入力してから 　　　　　　　　↓ ○　「検索する文字列」欄には2016、「置換後の文字列」欄には2015と入力してから
　今仮に、Sheet4のA2～A9の範囲にグループ番号が入力されていて、Sheet5のA列を作業列として使用して、Sheet1のH3セルに入力されているグループ番号に該当する「Sheet4のI列の値」を、Sheet1のI3セルに表示させるものとします。 　まず、Sheet5のA2セルに次の関数を入力して下さい。 =IF(INDEX(Sheet4!$A:$A,ROW())="","",IF(COUNTIF(Sheet4!$A$1:INDEX(Sheet4!$A:$A,ROW()),INDEX(Sheet4!$A:$A,ROW()))=COUNTIF(Sheet4!$A:$A,INDEX(Sheet4!$A:$A,ROW())),INDEX(Sheet4!$A:$A,ROW()),"")) 　次に、Sheet5のA2セルをコピーして、Sheet5のA3～A9のセル範囲に貼り付けて下さい。 　その上で、Sheet1のI3セルには次の関数を入力して下さい。 =IF(AND($H3<>"",COUNTIF(Sheet5!$A:$A,$H3)),INDEX(Sheet4!$I:$I,MATCH($H3,Sheet5!$A:$A,0)),"") 　尚、もしも作業列を使用したくない場合には、Sheet5は使用せずに、Sheet1のI3セルに入力する関数を次の様にして下さい。 =IF(AND($H3<>"",COUNTIF(Sheet5!$A:$A,$H3)),INDEX(Sheet4!$I:$I,SUMPRODUCT(MAX((Sheet4!$A$2:$A$9=$H3)*ROW(Sheet4!$A$2:$A$9)))),"") 　又、もしSheet4の最終行が何行目になるのか不明な場合には、Sheet1のI3セルに入力する関数を次の様な関数として下さい。(但し、Excel2007以前のバージョンのExcelではこの関数を使えません) =IF(AND($H3<>"",COUNTIF(Sheet5!$A:$A,$H3)),INDEX(Sheet4!$I:$I,SUMPRODUCT(MAX((Sheet4!$A:$A=$H3)*ROW(Sheet4!$A:$A)))),"") 　又、もしSheet4のA列に入力されているグループ番号が必ず数値データとなっている事が保障されている場合には、Sheet1のI3セルに入力する関数を次の様な関数とする事も出来ます。 =IF(AND($H3<>"",COUNTIF(Sheet5!$A:$A,$H3)),INDEX(Sheet4!$I:$I,SUMPRODUCT(MAX((Sheet4!$A$1:INDEX(Sheet4!$A:$A,MATCH(9E+307,Sheet4!$A:$A))=$H3)*ROW(Sheet4!$A$1:INDEX(Sheet4!$A:$A,MATCH(9E+307,Sheet4!$A:$A)))))),"") 　但し、SUMPRODUCT関数を使った方法や、(今回は提示しておりませんが)配列式を使用した方法では、元データの行数が多くなれば多くなる程処理が重くなりますので、元データの行数が万単位になる様な場合には作業列を用いる方法を使った方が実用的です。
こんにちは。 > 下のバーからエクセルの「最近使ったもの」から該当のファイルを開くと > シフトキーを押しながらそのファイルを起動しても > Workbook_Openイベントが起動してしまいます。 まず、イメージとしては、 「シフトキーを押しながら」 と言うよりも、 「ブックがデザインモードで開かれるのを確認できるまで（ぐらい）は 　Shiftキーを押しっぱなしにする」 という表現の方が近いです。 今一度、手順を確認されてみては如何でしょう？ 「シフトキーを押しながら」ブックを開いても、 Shiftキーを離すのが早過ぎれば、 デザインモードでは開かれずに、Workbook_Openイベントが実行されます。 また、逆に、 Shiftキーを押さずに普通にブックを（Excelと共に）開く操作をしてから、 直後（コンマ数秒後）にShiftキーを押し、離さずにそのまま待った場合にも、 ブックはデザインモードで開かれて、Workbook_Openイベントが実行されない、 ことも（コンマ数秒の度合いによっては）あります。 つまり、Shiftキーを押し続けるべきタイミングは、 Excelアプリケーションが開いた後の、 ブックを開く時にある、 ということです。 win8.1環境では試せませんが、Win7 xl2010 では、 　タスクバーのポップアップ 　エクスプローラー 　デスクトップ（以上はExcelが開いていない場合） 　Excelメニューの[最近使用したブック]（この場合は「シフトキーを押しながら」のみ） いずれの場合でも、 ブックはデザインモードで開かれて、Workbook_Openイベントが実行されないこと を確認しています。 単純に環境因である可能性については、こちらからは何とも言えませんが、 過去の質問例を思い出してみると、指を離すのが早過ぎたケースが実際にありましたので、 ひとつの可能性の話としての暫定解答です。 Excelアプリケーションの起動に要する時間にはムラがありますから、 そのつもりがなくても、 Excelアプリケーションの起動が終りブックを開き始めるよりも前に、 Shiftキーを離してしまっている可能性について、 確認した上で、もしその可能性を排除出来るのならば、 それはそれで解決に向けて重要な情報になると思います。 手順を確認した上で、うまく行かない場合は、その旨補足して貰えれば、 同等の環境で動作確認できる方からの情報にも期待できるのでは、と。 私からは以上です。
月は10進から16進なので下記方法で如何でしょう B1式 =RIGHT(YEAR(A1),1)&DEC2HEX(MONTH(A1))
　私なら、そもそもデータベースのデータに、更新（追加）日時を入れておくかな・・・ 　そうしておけば、ｅｘｃｅｌの方はぐっと簡単になります。 　どこかのセルに、最後にメールを送信したデータの更新（追加）日時を保存して置いて、そのセルの日時より新しい行全部をメールの送信処理の対象にすればＯＫになりますね。 　データベースの設計もあなたがやっていないと無理なので、今回は使えないかもしれませんが・・・
>その場合入れ子のやり方はどうしたら良いのでしょうか？ 入れ子にする必要はありません。 =IF(D1=1,C1,"") C列の文字列から左側の2文字まで返す時は次のようにしてください。 =IF(D1=1,LEFT(C1,2),"") 尚、提示の数式は配列を含む数式であり、提示の模擬データと論理に合わない状態です。 =IF(D5:D9=1,LEFT(C:C,2)) 　　　　↓ =IF(D$1:D$5=1,LEFT(C$1:C$5,2),"")
A1に0.332、B1に0.668として =(int(A1*100)+0.9)/100 =(int(B1*100)+0.1)/100 でどうでしょうか。
文字列は”+”ではなく"&"でつなげて下さい。 =IF(A3<>"","4月","") & IF(B3<>"","5月","") & IF(…+IF(F3<>"""9月","")
ファイルの種別から「*.pdf」を選択すると、その下に[オプション]ボタンが表示されますよね。その中で、”ブック全体”や”選択したシート”、”選択した部分”等から選択できるので、ブック全体を指定しなければ大丈夫ですよ。
数式タブの名前の管理で一元管理されていますのでそこで削除できます。
＞なぜか#NAMEと表示されてしまいます。 それは、「CutStr()が見つからないよ！」という意味だと思います。 多分！ そのように推量してテストしてみました。 標準モジュールに登録していない関数を指示。 すると、私も#NAMEと表示されました。 添付図のように CutStr()を標準モジュールに登録してみて下さい。
こんな感じ。 =LEFT(A1,FIND(" - ",A1)-1)
チャック？？？
こんにちは 前提条件 Sheet2の名前と地域の間の「－」は統一された全角ハイフン 希望は第一から第五 Sheet3を作業用に使用 Sheet3 A2セルに、=IF(C1="","",SUM(C$1:C1,1))　下方にフィルコピー B2セルに、=Sheet2!A2　下方にフィルコピー C2セルに、=LEN(Sheet2!B2&Sheet2!C2&Sheet2!D2&Sheet2!E2&Sheet2!F2)-LEN(SUBSTITUTE(Sheet2!B2&Sheet2!C2&Sheet2!D2&Sheet2!E2&Sheet2!F2,"－",""))　下方にフィルコピー D2セルに=IF(Sheet2!B2="","",Sheet2!B2&CHAR(10))&IF(Sheet2!C2="","",Sheet2!C2&CHAR(10))&IF(Sheet2!D2="","",Sheet2!D2&CHAR(10))&IF(Sheet2!E2="","",Sheet2!E2&CHAR(10))&IF(Sheet2!F2="","",Sheet2!F2&CHAR(10))　下方にフィルコピー F2セルに、=IFERROR(IF(E2="",LEFT($D2,FIND(CHAR(10),$D2)-1),MID($D2,FIND(E2&CHAR(10),$D2,1)+LEN(E2&CHAR(10))+1,100)),"")　下方にフィルコピー G2セルに、=IF(COUNTA($E2:F2)<=$C2,IFERROR(MID($D2,FIND(F2,$D2,1)+LEN(F2),(FIND(CHAR(10),$D2,FIND(F2,$D2,1)+LEN(F2)+1))-(FIND(F2,$D2,1)+LEN(F2))),""),"")　右方！にフィルコピー F2から右方にフィルコピーした範囲を選択して下方にフィルコピー Sheet1 A2セルに、=IF(ROW()-1>SUM(Sheet3!C:C),"",LOOKUP(ROW()-1,Sheet3!A:B)&"")　下方にフィルコピー B2セルに、=IFERROR(VLOOKUP(A2,Sheet3!B:C,2,0),"")　下方にフィルコピー C2セルに、=IFERROR(SUBSTITUTE(OFFSET(Sheet3!$E$1,MATCH(Sheet1!$A2,Sheet3!$B:$B,0)-1,IF(A2="","",COUNTIF($A$1:A2,A2))),D2&"－",""),"")　下方にフィルコピー D2セルに、=CLEAN(IFERROR(LEFT(OFFSET(Sheet3!$E$1,MATCH(Sheet1!$A2,Sheet3!$B:$B,0)-1,IF(A2="","",COUNTIF($A$1:A2,A2))),FIND("－",OFFSET(Sheet3!$E$1,MATCH(Sheet1!$A2,Sheet3!$B:$B,0)-1,IF(A2="","",COUNTIF($A$1:A2,A2))),1)-1),""))　下方にフィルコピー E2セルに、=IF(D2="","",IF(ISERROR(FIND(Sheet1!$D2,INDEX(Sheet2!$B:$B,MATCH($A2,Sheet2!$A:$A,0)))),0,1)+IF(ISERROR(FIND(Sheet1!$D2,INDEX(Sheet2!$C:$C,MATCH($A2,Sheet2!$A:$A,0)))),0,2)+IF(ISERROR(FIND(Sheet1!$D2,INDEX(Sheet2!$D:$D,MATCH($A2,Sheet2!$A:$A,0)))),0,3)+IF(ISERROR(FIND(Sheet1!$D2,INDEX(Sheet2!$E:$E,MATCH($A2,Sheet2!$A:$A,0)))),0,4)+IF(ISERROR(FIND(Sheet1!$D2,INDEX(Sheet2!$F:$F,MATCH($A2,Sheet2!$A:$A,0)))),0,5))　下方にフィルコピー
こんにちは Alt+F11でVBE画面を出して、イミディエイトウィンドウに （無ければ、メニューの表示で表示する） Range("A1").ColumnWidth=9 と入力してEnterしてみて下さい。
例えば、A点: +14.33、B点: +2.07、C点: -10.02　のとき、 それぞれ赤、緑、青として図示すると、添付画像のようになります。 普通にベクトル合成すると、+6.38の黄色になります。 > あるソフトでは+8.56という結果になるようですが、 そのソフトが非線形な計算してるのか？それぞれのベクトルに重みを付加してるのか？分からないどころか、ソフト名すら分からないと、類推のしようも無いです。 方法はどうでもいいから+8.56にしたいってのなら、例えばCのベクトルにだけ重み付けして、 A1:+14.33 A2:+2.07 A3:-10.02 のときに、 A4:=A1+A2+A3*0.78243512974 　　=+8.56 だとか。
No1です。 iは、1、2、3と増えていきます。 なので、i + 2 は 3、4、5 と増えて いきます。 i ＊ 5 ― 2 は 3、8、13 と増えていきます。 これで列番を指定します。 C列、H列、M列は 3列目、5列目、13列目 ですよね。 一定の間隔の行列を求める数式 は色々考えられます。
マクロ使えません、とは言ってもコードをイチから書くのが無理なんですよね？ であれば、賢い人の書いたプログラムを引用してしまいましょう。 ■セルの色を取得するユーザー定義関数 http://kokodane.com/mini_macro-55.htm セルの色をカラーインデックス番号で取得するマクロなんですが、 ここでサンプルを拾ってModule1をエクスポートして sum036さんが利用したいExcelファイルにインポートすれば、まんま使えると思いますよ。 あとは、フラグ列を作って「=セルの色(任意のセル)」の数式を入れて フラグ列から条件付き書式で行の色を指定してあげたらいかがでしょうか。 ※フラグ列を見せたくなければ非表示にしてもいいと思います。 エクスポートとインポートの方法が分からなければ、 こちらでどうぞ～　↓ ■Excel VBA 初心者入門講座 http://exvba.officehp.com/article/134480599.html
A1に0 A2に50 A3に120 を入力したとして、 単位円上の対応する角度の点の、中心からの位置ベクトルは、 x座標 B1:=COS(RADIANS($A1) y座標 C1:=SIN(RADIANS($A1) B2～C3はB1:C1をコピペ。 合成したベクトルは、 x座標 B4:=B1+B2+B3 y座標 C4:=C1+C2+C3 合成したベクトルの角度は、 D4:=DEGREES(ATAN2($B4,$C4)) 質問の場合は55度。
こんばんは、No1です。 イミディエイトウィンドウに結果 が表示されませんか？ メッセージボックスがいいなら、 Debug.Print のところを MsgBox に変更して下さい。
NO1の方の回答の手順を説明します。 セルに下記をコピー '22 数式バーで後ろの2をドラッグ マウス右クリック→セルの書式設定→文字飾りの「上付き」にチェックしてOKボタン
同じような処理を色んなところで書く場合には・・・。私なら、【標準モジュール】に次のような関数を用意します。 =Comparison(Range1, Range2, "未満,等しい,超える,空値") Comparison()は、Range1とRange2のどちらかが変更されると呼ばれます。そして、二つのセルの値を比較して呼応する値を戻します。同関数を用いれば =IF(H34<G34,"",IF(H34=G34,"同","★")) 　↓ =Comparison(H34, G34, "★,同,★", "同") と書く事ができます。音楽は戻り値が"同"の場合のみ鳴ります。 Option Explicit Public Function Comparison(ByVal R1 As Range, ByVal R2 As Range, ByVal returnText As String, ByVal isMusic As String) As String 　　Dim returnValue As String 　　 　　'string1はstring2未満 -1 　　'string1とstring2は等しい 0 　　'string1はstring2を超える 1 　　'String1またはstring2はNull値　Null値 　　If Len(R1 & "") * Len(R2 & "") = 0 Then 　　　　returnValue = CutStr(returnText, ",", 4) 　　Else 　　　　Select Case StrComp(R1, R2, vbTextCompare) 　　　　　　Case -1 　　　　　　　　returnValue = CutStr(returnText, ",", 1) 　　　　　　Case 0 　　　　　　　　returnValue = CutStr(returnText, ",", 2) 　　　　　　Case 1 　　　　　　　　returnValue = CutStr(returnText, ",", 3) 　　　　　　Case Else 　　　　　　　　returnValue = "" 　　　　End Select 　　End If 　　If returnValue = isMusic Then 　　　　' 音楽 End If 　　Comparison = returnValue End Function Public Function CutStr(ByVal Text As String, _ 　　　　　　　　　　　　ByVal Separator As String, _ 　　　　　　　　　　　　ByVal N As Integer) As String 　　Dim strDatas() As String 　　 　　strDatas = Split("" & Separator & Text, Separator, , 0) 　　CutStr = strDatas(N * Abs(N <= UBound(strDatas))) End Function
これでいかがでしょう？ グラフのデータ範囲を変更したい https://121ware.com/spsearch/public/app/servlet/qadoc?QID=012209 枠線のドラッグができない、ということでしたら、 グラフ上で右クリックしてメニューから[データの選択]をクリック、 軸ラベルの部分で[編集]ボタンをクリックして、新しい範囲を選択し直す。
一例です。 Sub test() Dim strSerch1 As String Dim strSerch2 As String Dim LastRow As Long Dim i, j, k, m, n As Long Dim Myday As Integer Dim ws As Worksheet '検索する文字を以下の二つの変数に代入 strSerch1 = "早番" strSerch2 = "遅番" 'Sheet1に「早番」の人をリスト化するための変数を設定 '最初に入れるのが3行目なのでjに3を代入 With Worksheets("勤務表マスタ") '月の最終日を取得（１行目の最終列-1が月の最終日) Myday = .Cells(1, Columns.Count).End(xlToLeft).Column - 1 '.Cells(.Rows.Count, 1).End(xlUp).Rowで最後の行がどこなのか調べて 'LastRow変数に代入する。 LastRow = .Cells(.Rows.Count, 1).End(xlUp).Row For i = 1 To Myday '日付シート名を変数に格納 Set ws = Worksheets("sheet" & i) '日付シートのB1に日付入力 ws.Range("B1") = Format(.Cells(1, i + 1), "m月d日") j = 3 k = 8 For m = 2 To LastRow '早番の場合は日付シートの３行目から順に入力 If .Cells(m, i + 1).Value = strSerch1 Then ws.Cells(j, 2).Value = .Cells(m, 1).Value ws.Cells(j, 3).Value = .Cells(m, i + 1).Value j = j + 1 End If '遅番の場合は日付シートの８行目から順に入力 If .Cells(m, i + 1).Value = strSerch2 Then ws.Cells(k, 2).Value = .Cells(m, 1).Value ws.Cells(k, 3).Value = .Cells(m, i + 1).Value k = k + 1 End If Next m Next i End With End Sub 日付シートのデータをクリアする事を追加しています。本ブックを翌月使用すると前月データが残る為。B3~C10を設定していますので修正下さい。
DoEventsを記述されてはいかがでしょうか。 (参考) http://d.hatena.ne.jp/umonist/20130826/p1 http://officetanaka.net/excel/vba/function/DoEvents.htm
行を削除する場合はループで毎回削除する場合は最終行からしないといけません。理由は２行目を削除したら次の３行目が２行目になるので３行目を削除する事が出来ないからです。若い行からループ処理で行を削除する方法はありますが割愛します。ネット上にコードはありますので検索下さい。 又、２行目から削除するのに削除する為のデータをF2に設定してはまずいですね。２行目も削除される事があり得ます。F2をG1に変更しました。 Sub test() Dim i As Long For i = Cells(Rows.Count, 1).End(xlUp).Row To 2 Step -1 If Cells(i, 2) = Range("F1").Value And Cells(i, 3) = Range("G1").Value Then Rows(i).Delete End If Next i End Sub
Dim Kekka As Boolean Kekka = False On Error Goto xxxxx Open ファイル名 For Output As #1 Kekka = True Close #1 Kill ファイル名 xxxxx: On Error Goto 0 If Kekka = True Then MsgBox "ファイルが作成できます" Else MsgBox "ファイルが作成できません" End If ファイル名は「パス付き」で「存在しないファイル」を指定します。 もし「既存ファイル」を指定すると、実行時に「削除される」ので注意して下さい。
こんばんは Sheet1のシートタブを右クリックしてコードの表示でVBEペインを 表示して下記コードを貼り付けて下さい。 Private Sub Worksheet_Change(ByVal Target As Range) 　　Dim i As Long 　　Dim r As Range 　　Const 指定文字 As String = "X" 　　Set r = Range("E6:E30") 　　If Target.Count > 1 Then Exit Sub 　　If Intersect(r, Target) Is Nothing Then 　　　　Exit Sub 　　End If 　　If Target.Value <> 指定文字 Then 　　　　Exit Sub 　　Else 　　　　'大文字小文字を区別する場合 　　　　i = ActiveSheet.Evaluate( _ 　　　　　　"SumProduct(EXACT(" & r.Address & ",""" & 指定文字 & """)*1)") 　　　　'大文字小文字を区別しない場合 　　　　i = WorksheetFunction.CountIf(r, 指定文字) 　　　　 　　　　Application.EnableEvents = False 　　　　Worksheets("Sheet3").Cells(6, i + 2) = _ 　　　　　　Target.Offset(, -3) 　　　　Application.EnableEvents = True 　　End If End Sub
A列が木曜と日曜限定なら B2式 =IF(A2="","",IF(WEEKDAY(A2)=5,A2-6,IF(WEEKDAY(A2)=1,A2-4))) 下方へオートフィル A列に木、日以外の日付が入力されてた場合は、B列はfalseが表示されます。 A、B列共に日付と曜日が表示されるようにユーザー定義書式を設定された方が視認性は良くなるのではないでしょうか。 ユーザー定義書式　 m"月"d"日"(aaa)
>発行日の曜日で締切日が違うのですが、曜日に関連づけて締切日を自動で表示させるにはどのような関数を使えばいいでしょうか。 >3月17日(木)→3月11日(金)・・・木曜日であれば6日前 >3月20日(日)→3月16日(水)・・・日曜日であれば4日前 他の曜日の情報が無いと適切な数式を提言できません。 発行日が木曜日と日曜日だけであればIF関数で条件分岐すれば解決できるでしょう。 月曜日から金曜日までが営業日で土曜日と日曜日が休業日とすれば営業日の2日間に休業日を含む2日間を加算した条件と言う規則があるときは次の数式で良いと思います。（貼付画像参照） =発行日-NETWORKDAYS.INTL(発行日-3,A18,1)-2
「WorkSheets("Sheet1")」を「ActiveSheet」に変えるか「WorkSheets("Sheet1").」を削る。 例えば WorkSheets("Sheet1").Range("A1") は ActiveSheet.Range("A1") または Range("A1") に書き換える。
　 =if(a1="りんご","果物",if(a1="レタス","野菜","")) これをB1に入力
次の数式でカウントできます。 =SUMPRODUCT((COUNTIFS(A:A,"2016/2/15",B:B,{"a";"b";"c";"d"},C:C,"X")>0)*1) B列の比較対象データを作業用のセルへ抽出すればセル範囲を対象にできます。 =SUMPRODUCT((COUNTIFS(A:A,G2,B:B,H2:H5,C:C,I2)>0)*1) 但し、G2="2016/2/15"　H2:H5={"a";"b";"c";"d"}　I2="X"　とします。
　回答No.2です。 >[変更(M)]ボタンとやらを見付け出せないのですが、そのボタンは何処にあるのですか？ 　当方は、回答No.2でこう述べた筈です。 >御質問の件の様に既存のコマンドで「●座布団」の様に既存のボタンイメージが存在しているものに関しては、[変更(M）]ボタンを押す事が出来ない様になっています。 　つまり、[連続データ]や[文字の割付]のボタンイメージを変更する際に、[変更(M)]ボタンが存在している場所を開いたとしても[変更(M)]ボタンは押せない状態となっていますから、[変更(M)]ボタンは「[連続データ]や[文字の割付]のボタンイメージを変更する事」のためには役に立たないと申し上げている訳です。 　まあ、「それでも気になるので教えて欲しい」という事かも知れませんので、一応お伝えしておく事に致します。 　まず、クイックアクセルツールバーの右端を見て下さい。黒い逆三角形の上に横線が付いているボタン([クイックアクセルツールバーのユーザー設定]ボタン)がある筈ですので、そのボタンをクリックして下さい。 　すると、「クイックアクセルツールバーのユーザー設定」というボックスが開きますので、その中にある[その他のコマンド(M)]を選択してクリックして下さい。 　すると、「Excelのオプション」ダイアログボックスの[クイックアクセルツールバー]の設定画面が開きますが、その画面の右下の辺り、「ユーザー設定:」と記されている箇所のすぐ上の所に[変更(M)]ボタンがあります。 　因みに、「Excelのオプション」ダイアログボックスの[クイックアクセルツールバー]の設定画面は、[ファイル]タブ→[オプション]→[クイックアクセルツールバー]の順にクリックしていく事でも開く事が出来ます。 【参考URL】 　よく使うコマンドは、クイック アクセス ツール バーで簡単に実行 | Microsoft Office 2010 活用 TIPS | Microsoft Office 2010 　　https://www.microsoft.com/ja-jp/office/2010/business/training/tips/office01.aspx
No1です。 「BOOK1のそれぞれセルE10～29に文字入力後、マクロが起動するように」 という事は、BOOK1にマクロを設定していいのですか？ BOOK1のSheet1のタブを右クリックしてコードの表示でコードペインを 表示しそこへ Private Sub Worksheet_Change(ByVal Target As Range) 　　Dim bk2 As Workbook 　　Dim r　　 As Range 　　Dim e　　 As Range 　　Const bk2Path As String = "C:\temp\BOOK2.xlsx" 　　 　　If Target.Count > 1 Then Exit Sub 　　Set r = Intersect(Me.Range("C10:C29,E10:E29"), Target) 　　If r Is Nothing Then 　　　　Exit Sub 　　Else 　　　　Set e = Target.EntireRow.Cells(1, 1) 　　　　If e(1, 3) <> "" And e(1, 5) <> "" Then 　　　　　　Application.EnableEvents = False 　　　　　　Application.DisplayAlerts = False 　　　　　　Set bk2 = Workbooks.Open(bk2Path) 　　　　　　bk2.Worksheets("Sheet1").Range("C4").Value = e(1, 3) 　　　　　　bk2.Worksheets("Sheet1").Range("H4").Value = e(1, 5) 　　　　　　bk2.SaveAs _ 　　　　　　　　bk2.Path & "\（秘）" & e(1, 3) & _ 　　　　　　　　"+（" & e(1, 5) & "）.xlsx", xlWorkbookDefault 　　　　　　bk2.Close 　　　　　　Set bk2 = Nothing 　　　　　　Application.DisplayAlerts = True 　　　　　　Application.EnableEvents = True 　　　　End If 　　End If End Sub
エクセルを互換モードで使用すると、そのようになることがあります。
　回答No.2様の関数は、その関数を1行目から入力して行く場合に対応する関数ですが、もし、関数を最初に入力するセルが(1)「値表示」シートのA1セルではなく、検索範囲がB1:D4、B5:D8、B9:D12となっているVLOOKUP関数をA2セルから入力して行くという場合には、次の様な関数をA2セルに入力してから、A2セルをコピーして、A3以下に貼り付けて下さい。 =VLOOKUP($B2,OFFSET(データ!$B$1:$D$4,(ROWS(A$2:A2)-1)*4,0),2,FALSE) 　或いは =VLOOKUP($B2,OFFSET(データ!$B$1:$D$4,(ROW()-ROW(A$2))*4,0),2,FALSE) 　上記はA2セルのVLOOKUP関数の検索範囲がB1:D4となる様にする場合の例ですが、これと同じ考え方で、A1セルのVLOOKUP関数の検索範囲がB1:D4となる様にする場合には、A1セルに入力する関数を次の様にして下さい。 =VLOOKUP($B1,OFFSET(データ!$B$1:$D$4,(ROWS(A$2:A2)-1)*4,0),2,FALSE) 　或いは =VLOOKUP($B1,OFFSET(データ!$B$1:$D$4,(ROW()-ROW(A$2))*4,0),2,FALSE)
Excel関数では、赤字で９ポイントで入れることはできません。 A1セルの５日後の月日、３月６日を入れるには、A2セルに以下の式を入れて、A2セルの書式を赤字で９ポイントにした後、A2セルを下にドラッグコピーします。 =A1+5
　条件が >数値が５．０以下の場合 という1つだけである場合には、AVERAGEIFS関数ではなく、AVERAGEIF関数を使った方が良いと思います。 =AVERAGEIF(D35:D42,">5")
>A2のセルに4桁の数値が600程あって、数値の最初の数は15から10までの6種類です。 「A2のセルに4桁の数値が600程あって」は誤りかと思います。 「A列の2行目以下に4桁の数値が600程あって」なら話が分かります。 >10なら「6年」11なら2年」「1年」としたいのですがIFとLEFTを組み合わせてもうまくいきません。 「6年」、「5年」のように自動入力と言うのは例えばB列の2行目以下に数式を設定してA列の値に対する年数をB列の同じ行に表示させれば良いのですか？ B2=IF(A2="","",CHOOSE(MID(A2,2,1)+1,6,5,4,3,2,1)&"年") B2セルを下へ必要数コピーします。
こんにちは こんな感じでしょうか？ Sub test() 　　Dim c As String 　　Dim r As Range 　　Dim t As Range 　　Dim s As Object 　　Dim e As Object 　　 　　Set s = CreateObject("WScript.Shell") 　　Set t = Range("A1").CurrentRegion.Columns(1) 　　For Each r In t.Cells 　　　　c = "XCopy " & r.Value & " " & r.Offset(, 1).Value _ 　　　　　　& " /s /e /c /h /r /k " 　　　　Set e = s.Exec("%ComSpec% /c " & c) 　　Next End Sub
「Microsoft Office 診断プログラムの実行」を行ってみてください。 １．エクセルの左上の丸いボタン（Officeボタン）を押す ２．「Excelのオプション(I)」を押す ３．「リソース」を押す ４．「診断(D)」を押す 後はダイアログの指示に従ってください。
＞もしかしたらなにかソフトが邪魔しているのかもしれません。 今、自己紹介を拝見しました。 PCを何台か所有されているようですが、もしかするとキーボードとマウスを 他のPCと共有するUSBケーブルかソフトを使っていませんか？ 使っているのであれば、それが影響している可能性があります。 うろ覚えですが、以前私も同じような経験があったような気がしましたので。 余談ですが メインPCの性能が高いのでメモリをもう少し積んで、その中へ仮想環境を 構築すると更に快適になりそうな感じがしました。 オフライン専用PCが含まれていると全PCを仮想化は無理ですが。 （マルチブートは再起動の必要があるため。。。完全に蛇足でした失礼）
[15]がA1セルで、[10]がB1、[30]がC1として =MAX(MIN(A1,C1)-B1,0) だけど本当は、15自体を含むのなら10,11,12,13,14,15で答えは6になるように調整するべきだと思うけど。。。
I3セルに下記を入力して、 下にコピーをすれば計算できます。 =IF(AND(SUMPRODUCT(SIGN(COUNTIF(A3:H3,{1,2,3,4,5,6})))>=3,SUM(A3:D3)>0,SUM(E3:H3)>0),"○","×") 配列数式を使っているので、 ちょっとわかりにくいのが欠点ですが。
横入り失礼 > このＶＢＡでエクセルファイルを開いた時に自動で時刻を更新する様に作動させるＶＢＡはどの様にすれば良いでしょうか？ ブックを開いたときに「更新」マクロを動かしたいなら、標準モジュールに以下を追加してみてください。 Sub Auto_Open() 　　Call 更新 End Sub
画面の最右最下の「ページに合わせる」という四角のアイコンをクリックしてみてください。
作成した表がA2～A100セルの場合 =COUNTBLANK(A2:A100)
http://hp.vector.co.jp/authors/VA016119/hajimete/udf1.html
　今仮に、Sheet2のA列のセルには「A1」～「A3」等の希望の種類が最初から入力されていて、Sheet3のA列～C列を作業列として使用するものとします。 　まず、Sheet3のA2セルに次の様な関数を入力して下さい。 =IF(INDEX(Sheet1!$D:$F,ROW(),COLUMNS($A:A))="","",INDEX(Sheet1!$B:$B,ROW())&" - "&INDEX(Sheet1!$C:$C,ROW())&IFERROR(CHAR(10)&INDEX(A3:INDEX(A:A,ROWS(A:A)),MATCH(INDEX(Sheet1!$D:$F,ROW(),COLUMNS($A:A)),INDEX(Sheet1!$D:$F,ROW()+1,COLUMNS($A:A)):INDEX(Sheet1!$D:$F,ROWS(A:A),COLUMNS($A:A)),0)),"")) 　次に、Sheet3のA2セルをコピーして、Sheet3のB2～C2のセル範囲に貼り付けて下さい。 　次に、Sheet3のA2～C2のセル範囲をコピーして、Sheet3のA列～C列の3行目以下に貼り付けて下さい。 　次に、Sheet2のB2セルに次の様な関数を入力して下さい。 =IF(COUNTIF(INDEX(Sheet1!$D:$F,,COLUMNS($B:B)),$A2),INDEX(Sheet3!A:A,MATCH($A2,INDEX(Sheet1!$D:$F,,COLUMNS($B:B)),0)),"") 　次に、Sheet2のB2セルをコピーして、Sheet2のC2～D2のセル範囲に貼り付けて下さい。 　次に、Sheet2のB2～D2のセル範囲をコピーして、Sheet3のB列～D列の3行目～4行目に貼り付けて下さい。 　以上です。
質問者さんはNo.1の回答のような =TEXT(A1,"ggge""年""ｍ""月""ｄ""日""") =TEXT(A2,"ge.m.d") =TEXT(A3,"@") みたいな答えは望んでいないと思います。 「元のセルの表示形式が変更されたら、自動的に、関数が返す値も変えたい」のだと思います。 ですが、こういう事は「簡単には出来ない」です。 一応 Function GetDisplayString(ByRef target As Range) As String GetDisplayString = target.Text End Function という自作関数を作れば、セルに =GetDisplayString(A1) と書いて自作関数を呼び出せば「表示されたままの文字列」が返って来ます。 が、この関数には問題があって「元のセルの表示形式を変更しても、再計算されない」のです。 そこで、ちょっと細工をします。 自作関数を Function GetDisplayString(ByRef target As Range,Byval dummy As Variant) As String GetDisplayString = target.Text End Function に変更し、呼び出しているセルの式を =GetDisplayString(A1,RAND()) に変えます。 RAND()関数は「毎回、常に再評価される」ので「シート内のどこかのセルに何らかの変更が加えられた瞬間に値が反映される」ようになります。 但し「シート内のどこかのセルに何らかの変更が加えられた」ですから「A1の表示書式を変えただけ」では再評価されません。「A1の表示書式を変えたあと、どこかのセルに何らかの変更が加えられた瞬間」に再評価されます。
＞そのようにするには、どのような計算式が必要ですか？ スコア(売上・満足度)の優先順位をどのようにするのか、その中で満足度の数値にどれだけ重みを与えるのか。 あなたの頭の中にボンヤリとあるものを、きちんと条件付けして書き下せなければ、式は作れません。 逆にいうと、その評価方式が決まれば、Excelの式は出来てしまうんです。 例えば、満足度の重みを2倍にして考えるとします。 そうすると、「(評価セル)＝(売上セル)+(満足度セル)*2」と言うような列を作り、評価セルの値で並べ替えてみます。 Aさんの評価値＝100+80*2＝260 Bさんの評価値＝90+90*2＝270 Cさんの評価値＝80+100*2＝280 この評価式では、Cさんが一番の優秀者である、と言うことになりました。 どちらも同じぐらい重要だが、低いものがあると大きく下がる、と考えるなら、双方をかけ合わせてみます。 「(評価セル)＝(売上セル)*(満足度セル)」 これに従うと、 Aさんの評価値＝100*80＝8000 Bさんの評価値＝90*90＝8100 Cさんの評価値＝80*100＝8000 こういうことになり、Bさんがトップ、Aさん・Cさんは同ランクと言うことになります。 でもこの式ではたとえば、満足度は60だが、売り上げは150もあった、と言う人(仮にDさんとする)は、150*60＝9000ということになり、満足度が低くてもやはり売り上げた人が一番、という結果を受け入れなければなりません。 それでは満足度にさらに重みを与えるため、2乗してみます。 「(評価セル)＝(売上セル)*(満足度セル)^2」 Aさんの評価値＝100*80^2＝640000 Bさんの評価値＝90*90^2＝729000 Cさんの評価値＝80*100^2＝800000 Dさんの評価値＝150*60^2＝540000 これならば、Bさんの評価はDさんを上回り、ランキングが上と言うことになりました。 しかしそれよりも、Cさんの満足度100が強く評価され、Cさんが一位と言うことになります。 結局、あなたが何を重視して順位を付けたいか、と言うことにかかわってくるわけです。(冒頭の命題) 公平な評価をしている、と言うためには、全員に同じ評価式を適用しなければなりませんしね。 それを決めるのは、もうExcelの質問ではなく、あなたの評価意図、ひいては会社の経営方針をどう決めるかという話になってしまいます。 -- ご質問に書かれた、たった3パターンでは、あなたの考えを図るのにちょっと少なすぎますね。 例えば、売上10刻みで10～100、満足度10刻みで10～100の、10x10のマスを書いてみます。(※売上が100以上も考えられるなら、まず考えられないような上限まで伸ばして) その中で、10段階に色分けして評価を付けるなら、どんなパターンの色分けになるか。 その図ができれば、それに合致する評価式(近似式)を作ることができるでしょう。
一度 Office セーフ モードで作業する https://support.office.com/ja-jp/article/Office-%E3%82%BB%E3%83%BC%E3%83%95-%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E4%BD%9C%E6%A5%AD%E3%81%99%E3%82%8B-dedf944a-5f4b-4afb-a453-528af4f7ac72 Office アプリケーションを修復する https://support.office.com/ja-jp/article/Office-%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BF%AE%E5%BE%A9%E3%81%99%E3%82%8B-7821d4b6-7c1d-4205-aa0e-a6b40c5bb88b ページ内で 3.修復する Office 製品をクリック とありますが 3.修復する Office 製品を右クリック の間違いだと思います。 を試してみてはいかがでしょう。
>文字列でお伝えするのって、なかなか難しいですね（笑） 最近の傾向としては言葉を省略する傾向にあるので仲間内でも意味が通じないことがあります。 >という風に、正しく累計を表示させていきたいのですが、 当初の回答で良いことになります。 B2=IF(A1="","",SUM(A$1:A1)) B2セルを下へ必要数コピーすれば貼付画像のようになります。 尚、B10は400ではなく500になります。
　パターン１は縦横に区切られた箱の中に何が入っているのかを気にせずに、箱そのものをそのまま配列として扱うため、入っていたデータはそのまま同じ場所だけに収まっていて、データの処理や移動は行われません。 　それに対してパターン２の方は、箱に入っているデータを1個ずつ取り出しては、そのコピーを作り、コピーの方を別の所に設けた別の箱の中に格納してから、コピーしたデータと元のデータを見比べて、間違いなくコピーされている事を確認してから、次の1個を取り出すという事を繰り返します。 　元の箱から、データを取り出したり、取り出したもののコピーを作ったり、コピーを別の所に格納したり、格納したデータと元のデータが同じデーターとなっている事を確認したり、等々のデータ処理を1つずつ繰り返しているため時間がかかります。
ちゃんと検証してませんが =IF(OR(MMULT(COUNTIF(A2:D2,{1;2;3})*COUNTIF(E2:H2,{2,3;1,3;1,2}),{1;1})),"○","×")
こんにちは テストブックで、 Sub test() 　　Dim t As Range 　　With Worksheets("Sheet2") 　　　　.Cells.Clear 　　　　.Range("A1").Value = "受注ID" 　　　　.Range("B1").Value = "名前" 　　　　.Range("C1").Value = "住所" 　　　　.Range("D1").Value = "電話1" 　　　　.Range("E1").Value = "電話2" 　　　　.Range("F1").Value = "電話3" 　　　　.Range("G1").Value = "電話1" 　　　　With Worksheets("Sheet1") 　　　　　　.Range("A1").CurrentRegion.AdvancedFilter Action:=xlFilterCopy, _ 　　　　　　　　CopyToRange:=Worksheets("Sheet2").Range("A1:G1"), Unique:=True 　　　　End With 　　　　Set t = Intersect(.UsedRange.Offset(1), .Range("A1").CurrentRegion) 　　　　With t.Columns(7) 　　　　　　.FormulaR1C1 = "=""0""&RC[-3]&""-""&RC[-2]&""-""&RC[-1]" 　　　　　　.Value = .Value 　　　　End With 　　　　With t.Columns(1) 　　　　　　.FormulaR1C1 = "=""'""&SUBSTITUTE(RC[6],""-"","""")" 　　　　　　.Value = .Value 　　　　End With 　　　　.Range("D:F").Delete 　　　　.Range("A1").Value = "ID" 　　　　.Range("D1").Value = "電話" 　　End With End Sub とか、色々。
置換をした結果、 日付っぽい見た目になったデータが、勝手に日付に変わってしまうのは、 エクセルの仕様です。 ですから、 置換を使う限りはどうしようもありません。 VBAを使わない前提であれば、 下記のような感じで、 =substitute(substitute(A1,”丁目”,”-”),”番地”,”-”) 関数を使うといいですよ。 VBAを使っても、もちろんできると思います。
・セルA1からA5に対して（ユーザーが任意に選んだ範囲で、その都度変わります） 現在選択中の物を取得するselectionを使ってください。 Dim r as Range Set r=Selection ・各セルの文字に”あ”が含まれていたら、削除します（”いあう”⇒”いう”） rangeオブジェクトのreplaceメソッドを使ってください。 Dim r as Range Set r=Selection Call r.Replace("あ", "") ・各セルに対して処理した結果をC（1,1）～C（5,1）の配列に入れたい Option Base 1 を最初に宣言すると、配列の始まりは1になりますので、あとはVariantの配列変数に代入すれば配列で取得できます。ただ、選択セルが1セルの場合はエラーになりますのでエラー処理が必要です。 Dim r as Range Dim c() As Variant Set r=Selection Call r.Replace("あ", "") On Error Resume Next c = r.Value If Err.Number <> 0 Then ReDim c(1, 1) c(1, 1) = r.Value End If On Error GoTo 0
こんにちは 切り取るとダメなんですね。 Sub test2() 　　Dim f As Range 　　Dim a As String 　　 　　On Error Resume Next 　　Set f = Cells.Find(What:="花", After:=ActiveCell, LookIn:=xlFormulas, LookAt:= _ 　　　　xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchCase:=False _ 　　　　, MatchByte:=False, SearchFormat:=False) 　　On Error GoTo 0 　　If f Is Nothing Then 　　　　MsgBox "該当セル無し" 　　　　Exit Sub 　　Else 　　　　a = f.Address 　　End If 　　 　　f.Cut 　　f.Offset(1).Select 　　ActiveSheet.Paste 　　Range(a).Value = "海" End Sub これで、どうですか？
=DEC2HEX(LEN(C50)+1,4) 　　　　　↓ =DEC2HEX(LEN(C50)+1,4)&"000000" Excelでは文字列連結演算子の&を使えば希望通りになります。 他に下記のような数式でも良いでしょう。 =CONCATENATE(DEC2HEX(LEN(C50)+1,4),REPT("0",6))
一般的には、グラフの書式をテンプレートとして保存とか。 グラフ テンプレートを作成、適用、削除する - Office のサポート https://support.office.com/ja-jp/article/%E3%82%B0%E3%83%A9%E3%83%95-%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%80%81%E9%81%A9%E7%94%A8%E3%80%81%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B-505ba53b-41b1-49af-9886-5179640a14ae 他の方法だと、グラフをコピーして、元のデータの範囲だけ変更するとかが手っ取り早いのでは。
こんにちは Sub test1() 　　Dim r As Range 　　Const c1 As String = "C:C" 　　Const c2 As String = "D:D" 　　Const k As Long = 2 　　Const i As Long = 3 　　Const g As Long = 4 　　 　　For Each r In Range(c2).Cells(2, 1).Resize(Range(c1) _ 　　　　　　　　　　.SpecialCells(xlCellTypeConstants).Cells.Count - 1) 　　　　If r.Value <> "" Then 　　　　　　r.Offset(, k).Formula = _ 　　　　　　　　"=COUNTIFS(" & c1 & "," & Intersect(r.EntireRow, Range(c1)).Address & _ 　　　　　　　　　　"," & c2 & "," & r.Address & ")" 　　　　ElseIf r.Offset(, -1).Value <> r.Offset(1, -1) Then 　　　　　　r.Offset(, i).Formula = _ 　　　　　　　　"=COUNTIFS(" & c1 & "," & Intersect(r.EntireRow, Range(c1)).Address & _ 　　　　　　　　　　"," & c2 & ","""")" 　　　　　　r.Offset(, g).Formula = _ 　　　　　　　　"=COUNTIF(" & c1 & "," & Intersect(r.EntireRow, Range(c1)).Address & ")" 　　　　End If 　　　　 　　Next End Sub で。
一般的には、Excelなどを使っている人が多いと思いますが、ほとんど同じような事がGoogleドライブの「スプレッドシート」という機能を使う事で実現することが出来ます。 つまり、エクセルがパソコンにインストールされていなくてもほとんど同じような事ができるというWEB上の無料ソフトです。処理スピードが遅くても問題ないのでしたら、お勧めします。
>どこが間違っているのでしょうか？ =IF(0<E33<19,B33-E33,B33+24-E33) 　　　　　　↓ =IF(AND(0<E33,E33<19),B33-E33,B33+24-E33) または =IF((0<E33)*(E33<19),B33-E33,B33+24-E33) ExcelのIF関数では2つの条件を1つの不等式で判定すると正しい結果が得られません。 提示の数式でエラーは起りませんが条件分岐の処理が不適正になります。
X=時刻（時）ということでしょうか？ 残業での深夜時間帯を00～04は24～28として計算したいということですよね。 計算するセルの数式のE10の部分を ((E10=<4)*24+E10) とか IF(E10<=4,E10+24,E10) のようにする方法もあるけど E10の入力自体を24～28とした方が間違いないと思います。
各シートで「Picture 4」の有無を手がかりにします。 sub macro1() 　dim myTop as single, myLeft as single 　dim w as worksheet 　mytop = worksheets("FACE").shapes("Picture 4").top 　myleft = worksheets("FACE").shapes("Picture 4").left 　worksheets("FACE").shapes("Picture 4").copy 　on error goto errhandle 　for each w in worksheets 　　w.shapes("Picture 4").top = mytop 　　w.shapes("Picture 4").left = myleft 　next 　exit sub errhandle: ’Picture 4の無いシートにPicture 4を貼り付ける 　w.paste 　resume end sub コツが掴めたら，印画像を「Picture 4」よりもっと分かりやすい名前にしておくと良いかもしれませんね。
　回答No.3です。 >セルについてはＡ１～Ａ１５０位までを予定しています。上記にあるマクロをそのまま使うことが出来るでしょうか。 　はい、そのまま使用する事が出来ます。 　尚、色を変更する事が出来るのは、セルに直接打ち込まれた文字列だけであり、数値データや関数を使って表示された文字列に関しては色を変える方法はおそらく存在しないのではないかと思いますので、その点は注意して下さい。
Excel だと、「散布図」形式でグラフにして、軸の数字のところをクリックして「軸のオプション」を出したときに、「軸を反転する(V)」というチェックボックスが出てきます。 散布図で折れ線にすると、大小の順番が行ったり来たりしていると右上がりにならないので、事前に生データを横軸にあたるデータが入っている列・行の順に整列させます。
　回答No.3です。 >B8はリストになっており数値しか入力できないようになっています。 との事ですが、数値データの中にも1や99999999などと言った「1000,10000,100000以外の値」も存在します。 　とは言えおそらく質問者様が仰りたい事は「B8セルには1000,10000,100000の3つの内の何れか1つの値しか入力される事は無い」という事なのではないかと推測致します。 　その場合は、 $B$8/IF($B$8=100000,10000,IF($B$8=10000,1000,IF($B$8=1000,100,))) の部分の計算結果は必ず10になるのですから、 $B$8/IF($B$8=100000,10000,IF($B$8=10000,1000,IF($B$8=1000,100,))) の部分を単に数値の 10 に差し替えてしまっても問題は無いという事になりますので、御質問の件の関数を次の様に修正されると宜しいかと思います。 =IF(COUNT($B$5,$B$8,$G5,$I5,$K5)=5,IF($B$5<ROUNDDOWN($I5*IFERROR(VLOOKUP(MID($D5,IF(ISERROR(1/(SEARCH("USD",$D5)<>4)),1,4),3)&"JPY",$A$12:$B$18,2,FALSE),100)*$G5*$B$8/10,0),"超過",ROUNDDOWN(IF(ISNUMBER($P5),-$P5,-$I5)*IFERROR(VLOOKUP(MID($D5,IF(ISERROR(1/(SEARCH("USD",$D5)<>4)),1,4),3)&"JPY",$A$12:$B$18,2,FALSE),100)*$G5*$B$8/10,0)),"")
セルの書式が日付になっています。 そのセルで、右クリック セルの書式設定―表示形式―標準ーOK
> この表示形式コードはもしかして[ ]内で指定できる数字が2つまでなのでしょうか？ セルの書式設定のユーザー定義の書式だと、「;」で指定できるセクションが４つまで(セミコロンは３つまで)です。 　<正>;<負>;<ゼロ>;<テキスト> グラフの軸の書式だと、テキストじゃグラフ描けないので３つまでとか？ 　<正>;<負>;<ゼロ> ユーザー定義の表示形式を作成または削除する - Excel https://support.office.com/ja-jp/article/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E5%AE%9A%E7%BE%A9%E3%81%AE%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E3%82%92%E4%BD%9C%E6%88%90%E3%81%BE%E3%81%9F%E3%81%AF%E5%89%8A%E9%99%A4%E3%81%99%E3%82%8B-83657ca7-9dbe-4ee5-9c89-d8bf836e028e
以下のマクロは「見た目が空白の、ブランクじゃないセル」をクリアして、ブランクのセルにします。 Sub Macro1() Dim Target As Range For Each Target In ActiveSheet.UsedRange If Not IsNull(Target) And Target.Formula = "" Then Target.ClearContents End If Next End Sub なお「半角スペースや、全角スペースなど、見えない文字が入っている場合」はブランクにしません。
　もしかしますとその入力規則を設定しようとしたシートが存在しいるファイルを保存される際に、ファイルの拡張子が「.xlsx」ではなく「.xls」となっている「Excel 97-2003 ブック」の互換モードの形式で保存されたのではないでしょうか？ 　拡張子が「.xls」となっているファイルには、「元の値」の所に別シートのセル範囲を直接指定する事は出来ませんので、「.xls」形式で保存した際に無効な指定範囲である事から、保存する事が出来なかったのだと思います。 　「.xls」形式で保存される場合には、別シートのセル範囲をリストの範囲として指定するためには、INDIRECT関数を使用してセル範囲を指定されるか、もしくはリストが設けられているセル範囲に名前を付けた上で、その付けた名前を使ってセル範囲を指定する様にしなければなりません。 【参考URL】 　インストラクターのネタ帳 > Excel(エクセル)の使い方 > 入力規則 > 入力規則のリスト用データを別シートにまとめる 　　http://www.relief.jp/itnote/archives/000210.php 　インストラクターのネタ帳 > Excel(エクセル)の使い方 > 入力規則 > ドロップダウンリストを別シートを参照して作成－INDIRECT関数 　　http://www.relief.jp/itnote/archives/002264.php
　下記のマクロは、マクロを起動させた時点において、複数のセルを選択中であったり、図形などのセル以外のオブジェクトを選択中であってもエラーとならない様にするため、Selectionを使わずにActiveCellを基準にして処理を行う様にしています。 　又、選択中のセルよりも下には、そのセルとは異なる色で塗られたセルが存在していない場合には、セルの移動は行わず、その代わりに 「選択されているセルの下には、選択されているセルとは異なる色で塗りつぶされているセルは存在しません」 という表示が現れる様になっております。 Sub QNo9134099_マクロで色のついたセルへ移動() Dim c As Range, LastRow As Long, myBoolean As Boolean, myRange As Range With ActiveSheet.UsedRange LastRow = .row + .Rows.Count End With myBoolean = False If ActiveCell.row <= LastRow Then Set myRange = Range(ActiveCell, Cells(LastRow, ActiveCell.column)) For Each c In Range(ActiveCell, Cells(LastRow, ActiveCell.column)) myBoolean = False With c.Interior If Not myBoolean Then myBoolean = _ .Pattern <> c.Offset(1).Interior.Pattern _ And .Pattern <> ActiveCell.Interior.Pattern _ And .Pattern <> xlNone If Not myBoolean Then myBoolean = _ .PatternColorIndex <> c.Offset(1).Interior.PatternColorIndex _ And .PatternColorIndex <> ActiveCell.Interior.PatternColorIndex _ And .PatternColorIndex <> xlNone If Not myBoolean Then myBoolean = _ .Color <> c.Offset(1).Interior.Color _ And .Color <> ActiveCell.Interior.Color _ And .Color <> 16777215 If Not myBoolean Then myBoolean = _ .TintAndShade <> c.Offset(1).Interior.TintAndShade _ And .TintAndShade <> ActiveCell.Interior.TintAndShade _ And .TintAndShade <> 0 If Not myBoolean Then myBoolean = _ .PatternTintAndShade <> c.Offset(1).Interior.PatternTintAndShade _ And .PatternTintAndShade <> ActiveCell.Interior.PatternTintAndShade _ And .PatternTintAndShade <> 0 End With If myBoolean Then c.Select Exit For End If Next c End If If Not myBoolean Then MsgBox "選択されているセルの下には、" _ & "選択されているセルとは異なる色で塗りつぶされているセルは存在しません" _ , vbInformation, "無効な選択" End Sub
表示する個数は変更できます。 1.タスクバーを右クリックして「プロパティ」を選択。 2.[スタート]メニューのタブを選択し「スタートメニューのリンク・・・」と書かれているところの「カスタマイズ」」ボタンをクリック。 3.[スタート]メニューのカスタマイズダイヤログの一番下、「ジャンプリストに表示する最近使った項目の数」を好きな個数に設定し「OK」ボタンをクリック。 4.タスクバーのプロパティダイヤログの「OK」ボタンをクリック。 以上で変更されます。
貴エクセルには「Excelの玉手箱」アドインの「機能354：ボタン作成マクロ３」が組み込まれています。ブックを開くと、自動的にそのブックにツールボタンが作成されるようです。心当たりはありませんか？ エラーになるブックは、保護されていて、マクロの実行が拒否されるのでは？ 「Excelの玉手箱」アドインについてはこちら↓に情報があります。 http://www.freeformat.co.jp/AddInIndex.htm
A1からA31まで時間の整数でB1からB31まで10分単位の整数が入力されていると考えれば良いですね？ B列の合計を30分で丸めて1時間単位の値をA列の合計に加算するのですよね？ A32=SUM(A1:A31,INT(SUM(B1:B31)/60)) B32=MOD(FLOOR(SUM(B1:B31),30),60)
条件付書式でやるなら、Sheet2の条件付書式の数式に↓のような式を入れます。 =(COUNTIF(Sheet1!A:A,A1)>0)
こんな感じでいかがでしょう nFirst = Columns("B:B").Find(What:="い").Row nLast = Columns("B:B").Find(What:="い", SearchDirection:=xlPrevious).Row
並べ替えたい項目を選択して「データ」タブ➡️「Z➡️A」をクリックでどうですか？
こんにちは。 添付画像のシート名「W10」は 部署番号「X100」と喰い違いがありますが、 さておき、 こんな感じで如何でしょうか？ 　　　　n = 部門(ws1.Range("C" & i)) の部分は、関数を用いずとも、単に、 　　　　n = Left$(ws1.Range("C" & i).Text, 3) としても同じ結果になりますが、 より明示的に「（部署番号）の左3桁をキーに」していることが 解り易くなり、後々の書換えが楽になるかという意図で 敢えて関数にしてあります。 .Textプロパティを使うのは、 文字列値であっても数値であっても、 表示された文字列を読むことで "0"から始まる数値文字列（"0"から始まる表示形式）にも対応させる為です。 尚、ご提示のマクロへの修正という形でお応えするので、 仕様には変更を加えていません。 すでに出力が済んでいるデータについては 再度出力することになりますから、その点留意しておいて下さい。 何か不足があれば補足欄にでも書いてみて下さい。 ' ' /// Sub ReW9133479() Dim ws1 As Worksheet Dim n As String Dim c As Long, L As Long, i As Long 　　Set ws1 = Sheets("Sheet1") 　　L = ws1.Range("C65536").End(xlUp).Row 　　For i = 2 To L 　　　　n = 部門(ws1.Range("C" & i))　'　★部門名抽出（関数にて左３桁抽出） 　　　　On Error GoTo ErrorHandler　'　★ エラートラップは限定的に！！ 　　　　With Sheets(n)　'　★ With フレーズでシート参照を統一 　　　　　　On Error GoTo 0 '　★ エラートラップは限定的に！！ 　　　　　　c = .Range("C65536").End(xlUp).Row '部門のシートの最終行位置 　　　　　　ws1.Rows(i).Copy Destination:=.Rows(c + 1) 　　　　End With　'　★ 　　Next i 　　Exit Sub ErrorHandler:　　 '部門のシートが無い時の処理 　　With Worksheets.Add(after:=Worksheets(Worksheets.Count)) '★最後のシートの後へ追加 　　　　.Name = n '★部門の名前をシートの名前にする 　　　　ws1.Rows(1).Copy Destination:=.Rows(1) '★1行目の項目名をコピー 　　End With　'　★ With フレーズでシート参照を統一 　　Debug.Print n　'　★新規追加シート名をイミディエイトウィンドウに表示 　　Resume End Sub Private Function 部門(r As Range) As String　'　★ 　　部門 = Left$(r.Text, 3)　'　★ End Function　'　★ ' ' ///
　御質問文の表現方法がおかしいので状況が良く解りませんが、A2セルに 50 という値が入力されていて、その一方で、A1セルには 8 という値が入力されている場合において、関数を使って 「A1セルの値でA2セルの値を割った値に100を掛ける事で、割った答えの100倍の値が別のセルに表示される様になっている」 という状態で、そこからその50が表示されているセルの表示を5000%ではなく50%にしたいという事なのでしょうか？ 　それでしたら割った答えに100を賭けるのは止めて、単純に =IF(COUNT(A1,A4)=2,A2/A1,"") という関数とした上で、セルの書式設定の表示形式を[パーセンテージ]にすればOKです。 　間違っていたのは書式ではなく、質問者様が作った関数の方だったという事です。
ざっとこんな感じかな Sub Sheet_Copy() Dim x As Object Worksheets("sheet1").Cells.Copy For Each x In Worksheets 'Stop If UCase$(x.Name) = "SHEET1" Then Else Sheets(x.Name).Select Cells.Select ActiveSheet.Paste End If Next End Sub
CONCATENATE関数は「Lotus 1-2-3のユーザーをExcelに乗り換えし易くするため」つまり「互換性のため」に存在します。 Lotus 1-2-3では「&演算子」は「文字列同士」にしか使えません。 A1に数値で「1230」が、A2に文字列で「円」と入っている時、Lotus 1-2-3で「=A1 & A2」と書いても「エラーになってしまう」のです。 このエラーを防ぐには、Lotus 1-2-3では「=CONCATENATE(A1,A2)」と書かなければいけません。 ところが、Excelでは「=A1 & A2」と書いても「エラーにならず、1230円という結果が出てしまう」ので、CONCATENATE関数は不要になってしまったのです。 ですが「Lotus 1-2-3のユーザーをExcelに乗り換えし易くして、ユーザーを奪おう」という戦略があるため「CONCATENATE関数を使えるように残した」のです。
＞それぞれのコースのセルにどういう式を立てればよいか ナニを計算したいのか肝心なことがご相談に書かれてませんが，いまのご質問内容だけから言うと ＝（２２５０円 × 時間・日数 ＋９８００円）×生徒数 でしょ。
こんな感じかな？ Excel2013では未確認です。 Sub Sample01() 　　Dim oName As Name 　　On Error Resume Next 　　For Each oName In ActiveWorkbook.Names 　　　　If oName.Value Like "*[#]REF[!]*" Then 　　　　　　oName.Delete 　　　　End If 　　Next End Sub
>セルE35(平日の8時間内時給)が、1,000円です。 >契約時間は、セルJ38に8:00 と入力されています。 >セルE36に時給1,500円を入れています。 >セルD36の日に対応するものの合計 上記のセル位置に変更のときは2行目の数式は次のようになります。 F2=IF(COUNT(C2:D2)=2,D2-C2-E2,0) G2=IF(B2="日",0,MIN($J$38,F2)) H2=F2-G2 I２=G2*24*$E$35 J2=IF(B2="日",H2*24*$E$36,H2*24*$E$35*1.25) F2からJ2を選択して下へ32行目までコピーしてください。 日曜日の合計は次のようになります。 C36=SUMIF($B$2:$B$32,$D$36,$J$2:$J$32) 貼付画像は7行目から30行目までを非表示にしてあります。 尚、F2:J32は条件付き書式で値が0のとき文字の色を白にしました。
sheet1に既に単価が入力されてるなら空白を入力しないようにするだけでしょう。その修正も出来ませんか？ Sub データ検索() Dim I As Long Dim ws As Worksheet Application.ScreenUpdating = False Set ws = Sheets("sheet2") With Sheets("sheet1") I = 2 Do While .Range("A" & I).Value <> "" If Application.CountIf(ws.Range("A:A"), .Range("B" & I)) = 1 Then .Range("C" & I).Value = _ Application.VLookup(.Range("B" & I).Value, ws.Range("A:B"), 2, 0) End If I = I + 1 Loop End With Application.ScreenUpdating = True End Sub
H11式 =IF(COUNTA(F11:G11)<>2,"",VLOOKUP($F11,$O$11:$P$14,2,FALSE)*G11) 下方へオートフィル vlookupのfalseが無いのが起因していますが、他にもG11の数量を掛けるのはif関数内でかける必要があります。 空白を入力する場合は品名と数量どちらも入力している必要があるのでCOUNTA(F11:G11)<>2と変更しました。 vlookupは完全一致のfalseと近似値のtrueの記入漏れが多いので注意下さい。
> rankは配列数式で使えないのでしょうか 使えます。ただしルールを間違えなければですが。 =RANK(数値,参照,順序) 「参照」はセル範囲以外は受け付けません。計算結果は「配列」なので これを「参照」に入れても当然エラーになります。ヘルプにはよく読む と色んな情報が詰まっています。 とりあえず 今回の場合 RANKではなく =SUM((A1:A4+B1:B4>A1+B1)*1)+1 Ctrl + Shift + Enterで確定 これでいいと思います。
＞Sheet1全体をSheet2にコピーして 設定はセルじゃなくシートについているので，シートの全部のセルを選んでコピーしても駄目で，シートをコピーします。 シートを複製するには，コントロールキーを押しながらシート名タブをドラッグします。 参考： http://www.howto-ch.com/movie/7246_201202_excel2010_003/
Excelの罫線は、セルとセルの間にあるように見えますね。 実際、セルのどちら側からの指定でも、後から引いた罫線で上書きされるように見えます。 でも実は、セルの一つ一つに、上下左右、どういう罫線が引いてある、と言うデータの持ち方がされているのだそうです。 ＞EXCEL 罫線の謎 ＞http://ameblo.jp/marble-tencho/entry-10847207213.html ですので、一度 (1)表の1行だけを選択し、セルのプロパティから、上下の罫線をつけ直す。 (2)その行をコピーして、他の行に「書式設定をコピー」する。 という作業をしてみてはどうでしょうか。 コピーが終われば、その後行を増やしたり減らしたりしても書式コピーされるので、罫線のヌケは無くなると思います。
>ところでVLOOKUPで参照するA列の数値ですが、こちらは計算ではなく直接　0.035　のように入力されていますが、こちらは演算誤差は考えなくてもよいのでしょうか？それとも=ROUND(0.035,3)のようにしなければいけないのでしょうか？ キーボードで直接入力された値は端数が無いので前処理は不要のようです。 見方を変えてA列の値が次のようになっているときは質問の　=VLOOKUP(D1,A1:B5,2,FALSE)　で4が返り、=VLOOKUP(ROUND(D1,3),A1:B5,2,FALSE)　では#NAが返ります。 A1=(ROW()-1)/100+0.005 A1を下へA5までコピーする。 従って、検索範囲のデータは一貫した方法で作成し、検索値は検索範囲に合わせた値に処理する必要があります。
こんなことはすでにやっているのでしょうか？ http://excel-ubara.com/excel3/EXCEL019.html
ActiveWorkbook.Worksheets("hogehoge01") を ActiveWorkbook.Activesheet に書き換える。
こんにちは 画像のようにExcelシートの右はじの分割バーを1行分下げて、そのスクロールバー で1行ずつ見ていけば、その行だけチェック出来ます。
こんにちは 非常に分かりにくいですけど、 Sub test() 　　Dim r As Range 　　Dim i As Long 　　Rows("4:4").Copy Range("A2") 　　i = 1 　　For Each r In Rows("2:2").SpecialCells(xlCellTypeConstants) 　　　　r.Interior.Color = r.Offset(1).Interior.Color 　　　　If r.Value <> "" And r.Offset(1).Value <> "" Then 　　　　　　r.Value = r.Offset(1).Value 　　　　Else 　　　　　　r.Value = r.Offset(1).End(xlToLeft).Value 　　　　End If 　　　　If r.Value <> "" Then 　　　　　　r.Offset(-1).Value = "Q" & i 　　　　　　i = i + 1 　　　　End If 　　　　 　　Next 　　Rows("2:2").Copy Range("A3") 　　Rows("2:2").Clear End Sub こんな感じですか？ テストデータで試して下さい。
>今回、この条件に開始日と終了日を設定したいです。 >H2に終了日を指定したいのですが、自分で考えた画像の数式ではエラーになりました COUNTIF関数が誤りです。 検索条件の and(">="&$G$2,"<="&$H$2) は使えませんので他の方法を使います。 COUNTIF($A$2:$A$11,$G$2) の代替数式は次のような方法が良いでしょう。 １．COUNTIF($A$2:$A$11,">="&$G$2)-COUNTIF($A$2:$A$11,"<"&$H$2) ２．COUNTIFS($A$2:$A$11,">="&$G$2,$A$2:$A$11,"<="&$H$2) ３．SUM(($A$2:$A$11>=$G$2)*($A$2:$A$11<=$H$2)) また、SMALL関数の内がはにあるIF関数は2つの条件を満たす行番号に変更しなければなりません。 IF($A$2:$A11=$G$2,ROW($A$1:$A$10)) この数式ではG2と一致する日付の行のみ行番号を拾えますがG2セルとH2セルの期間の行番号を拾えません。 次のように変更する必要があります。 IF(($A$2:$A11>=$G$2)*($A$2:$A11<=$H$2),ROW($A$1:$A$10)) 全体の数式はあなたの応用力で対処してください。
再提示された模擬データでは下記の数式で目的の処理が出来ると思います。 L列は作業用です。 L2=LARGE(INDEX((LEFT(A$2:A$1001,1)="P")*ROW(A$2:A$1001)+(LEFT(A$2:A$1001,1)="C")*ROW(A$2:A$1001),0),SUMPRODUCT((LEFT(A$2:A$1001,1)="P")+(LEFT(A$2:A$1001,1)="C"))-ROW()+2) L2セルを下へ必要数コピーします。 B2=INDEX(OFFSET($A$1,$L2-1,0,10),COLUMN(B2)-1) B2セルをJ2セルまでコピーします。 K2=IF(OR(LEFT(INDEX(OFFSET($A$1,$L2-1,0,10),COLUMN(K2)-1),1)="P",LEFT(INDEX(OFFSET($A$1,$L2-1,0,10),COLUMN(K2)-1),1)="C"),"",INDEX(OFFSET($A$1,$L2-1,0,10),COLUMN(K2)-1))&"" B2からK2セルを選択して下へコピーしてください。 尚、データの中でシリアル値の列については表示書式を目的に合わせて修正してください。
E2: =IF(COUNTIF(B2:D2,"○"),WORKDAY(A2,3,HolidayList),"")
A1セルに20と入れてから、以下の式のように、19の部分をA1に変更してみてください。 =IFERROR(VLOOKUP(C$4,商品A!$B$6:$Z$23,A1,FALSE),0) =IFERROR(VLOOKUP(C$4,商品A!$B$6:$Z$23,19,FALSE),0)
〉 他のシートに連動されていたようなものはシートごと削除済みです。 ここら辺りに問題が隠れていそうな感じです テンプレートでは無く初めから自分で作ってみたらどうでしょう
はい、「サブプロシージャ」は、昔で言う「サブルーチン」と考えて頂いて結構だと思います。 私のような古い人間は、今でも、つい「サブルーチン」と言いそうになります。 Sub Macro() 　　｜ End Sub しかし、自分で関数を作る機能の Function FN() 　　｜ End Function もあり、こちらは「サブファンクション」とは言いませんでした。 回答No.1の方がおっしゃるとおり、諸般の事情で「プロシージャ」と呼ぶことになったのでしょう。 しかし、「VBA（Visual Basic for Applications ）」では、必ず「Sub」が存在しますが、同じ「Visual Basic」系でも、「Visual Basic」そのものや、「VBScript（Microsoft Visual Basic Scripting Edition）」などは、別に「Sub」は存在しなくても構いません。
If Application.CountA(Columns(2)) = 0 Then MsgBox "Ｂ列は空" End If
サイト側もそうですが、IE側にも理由があります。 IE10以降で使えるIInternetExplorerManagerの方を試されるとか。
sub macro1() 　on error resume next 　with range("R:R").specialcells(xlcelltypeformulas) 　　.value = .value 　end with end sub みたいに。 ＃数式が実はひとつも入ってなかったみたいな場合にも，エラーにならないように細工をします。 ＃参考 実際には，どこまで数式が入ってる「可能性があるか」だけで sub macro2() 　range("R2:R999").value = range("R2:R999").value end sub とか sub macro3()　’あまりお勧めはしません 　range("R:R").value = range("R:R").value end sub とかでもかまいません。
AAだったらF1を参照する、違えば空白とする。 =if(vlookup(a1,B1:C10,2,false)="AA",F1,"")
　今仮に、J6～J8のセル範囲に3名の受信者名を追加するものとします。(つまり、受信者名はJ4～J8のセル範囲に入力されている全5名に変わる) 　その場合のドロップダウンリストの追加方法は以下の様なものとなります。 Excelウィンドウの上の方にある[データ]タブをクリック 　　↓ 現れた「データツール」グループの中にある[データの入力規則]ボタンをクリック 　　↓ 現れた選択肢の中にある[データの入力規則]をクリック 　　↓ 現れた「データの入力規則」ダイアログボックスの中にある[設定]タブをクリック 　　↓ 現れた「入力値の種類」欄をクリック 　　↓ 現れた選択肢の中にある[リスト]をクリック 　　↓ 現れた現れた「元の値」欄に $J$4:$J$8 と入力(マウス等を使ったセル範囲の選択によっても設定する事が出来ます) 　　↓ 「データの入力規則」ダイアログボックスの中にある[OK]ボタンをクリック 　以上です。
　セルの書式設定の表示形式を[ユーザー定義]の [DBNum1]ggge"年"m"月"d"日" に設定されては如何でしょうか。
添付図は Excelヘルプの[アドインを追加または削除する](Add or remove add-ins)のページ中の[アドインについて](Learn about add-ins)の記述ですが、参考になりますか？ 【独白】よくもまぁ日本ＭＳは、こんなヘンテコな日本語機械翻訳をシャーシャーと載せているなぁ～と、私は呆れ返っています。品質管理部門のない会社だ！
こう言うことですか？ Sub MyMacro() Range("D7").End(xlDown).Select Selection.Offset(0, 1).Borders(xlEdgeTop).Weight = xlHairline Selection.Offset(0, 1).Borders(xlEdgeBottom).LineStyle = xlDouble Selection.Offset(0, 2).Borders(xlEdgeTop).Weight = xlHairline Selection.Offset(0, 2).Borders(xlEdgeBottom).LineStyle = xlDouble Selection.Offset(0, 3).Borders(xlEdgeTop).Weight = xlHairline Selection.Offset(0, 3).Borders(xlEdgeBottom).LineStyle = xlDouble End Sub
【１】お示しの文面を私なら次のように解釈します。 「このバージョンを保持するには」＝「改造にならないようにするには」＝「このシート(ブック)のリンク状態を保つためには」 version は「〔原型・原物に対する〕異形, 変形； 改作, 改造」ですね。 つまり、お示しの「バージョン」は Excel のバージョンのことではありません。 【２】仰るとおりだと思います。
>セルを選択するとリボンの下のボックスに内容が表示されるかと思いますが、その表示されるボックス 　もしかしますと「数式バー」の事なのでしょうか？ 　数式バーを再表示させるには、まず[表示]タブをクリックし、現れた「表示」グループの中にある[数式バー]と記されている箇所をクリックしてチェックを入れれば良いと思います。 【参考URL】 　近日出荷-キンジツシュッカ- > 2015年10月 > 2 > 実務で使えるExcel入門セミナー　関数の入力でエラーが出たときの対処方法　2015/10/5 　　http://www.yskzt.com/how-we-should-prepare-for-function-error-on-MS-Excel-20151005
>しかし、参照サイトでは、ぐらいまでしか反映されません。 >ぐらいまで伸ばして使いたいのです。 「１１列」と「100列」は用語の誤りです。 「11行」と「100行」に読み換えて回答します。 >関数をどこを改造したら反映列を増やせますか？ 「反映列」これも用語に誤りがあります。 元となるセル範囲（行）を広げることになります。 Excelでは表の上に表示されているA、B、C等を列記号と呼んでいます。 それに対して、左側に表示されている数字を行番号と呼んでいます。 行と列を誤って表現すると勘違いが起り数式を誤る原因になるので注意すべきです。 G5セルに設定されている数式で範囲で指定している引数をすべてチェックしてください。 COUNTIF($A$2:$A$11,$G$2)の$A$2:$A$11を$A$2:$A$100に修正するとA列の2行目から100行目までに$G$2と同じ日付のセル数を数えることになります。 IF($A$2:$A11=$G$2,ROW($A$1:$A$10))の$A$2:$A$11を$A$2:$A$100に修正し、ROW($A$1:$A$10)をROW($A$1:$A$99)に変更するとA列の2行目から100行目までに$G$2と同じ日付のセルについて行の順番を配列として返します。このとき、$G$2と一致しないセルについてはFALSEを返しますので数値で返った値を小さい順に取り出せば目的のデータを抽出する指標になります。 数式の他の部分についても同様に検索範囲や元データの行番号を変更すれば良いでしょう。 あなたの知識で応用ができない場合は模擬データ（提示のURLと伊那路もの）を作成し、9行目と10行目の間へ89行挿入するとG5セルの数式が自動的に100行目まで対応する数式に変化します。 修正後の数式 G5=IF(COUNTIF($A$2:$A$100,$G$2)<ROW(A1),"",INDEX(A$2:A$100,SMALL(IF($A$2:$A100=$G$2,ROW($A$1:$A$99)),ROW(A1)))) 貼付画像は10行目の上に89行挿入し、11行目から98行目を非表示にしたものです。
もしかしてA22セルには姓、B22には名が入力されていてC22には「=A22&B22」という式が式のままで表示されており、ここを姓名の表示にしたいということですか？ そしてセルC22の書式設定を文字列にしても変化なしだということですか？ その場合、一旦C22の式を削除してから書式設定を標準にしてその後「=A22&B22」を入力してみてください。 これで姓名が表示されるはずですので、その下以下のセルも修正するならC列全体を選択してから上記の作業を行ってみてください。
＞2 を２回、3 を３回、4 を４回、… それぞれ繰り返す その通りにやってみると 任意のセル，仮にB3に初期値を記入 右隣のセルに =B3+(COUNTIF($B3:B3,B3)=B3) 右にコピー。
セル A1 または B1 または範囲 A1:B1を選択して、Ｃtrl +Shift +] を押すとどうなりますか？ セル C1 を選択して、Ctrl+Shift+[ を押すとどうなりますか？
　対数目盛を使用されては如何でしょうか。 　縦軸を対数目盛に変更する方法は以下の通りです。 縦軸の数字の部分を右クリック 　　↓ 現れた選択肢の中にある[軸の書式設定]をクリック 　　↓ 現れた「軸の書式設定」ダイアログボックスの中の左上にある[軸のオプション]をクリック 　　↓ 現れた「対数目盛を表示する」と記されている箇所をクリックしてチェックを入れる 　　↓ 「軸の書式設定」ダイアログボックスの[閉じる]ボタンをクリック
　 全く自由ですよ 好きな数値を入力すればよい 　
>先頭の２つの会社名に選択できるようにするにはどうしたらいいのでしょうか？ 会社名を特定のセル（E1とE2等）に入力してデータの入力規則でリストの範囲をセルの番地（$E$1:$E$2）で指定すれば良いでしょう。
　回答No.3です。 >証明したいのは、「A」がある場合すべての「A」が「BAB」の文字列になっていないといけないということなので、2つ目の「A」が「BAB」となっていないので判定は"無"となっていただきたいのです。 >「A」が含まれない場合は「是」としたいと思っています。 という事でしたら、 =IF(A1="","",IF(SUBSTITUTE(A1,"A",)=SUBSTITUTE(A1,"BAB","BB"),"是","無")) でも大丈夫だと思います。
ご利用のエクセル2000では，画像を「自由に回転」することはできません。 2000で自由に回転できるのはオートシェイプ等の図形だけです。 画像を自由に回転するには，オフィスXP以降をご利用ください。
私なら、「次を検索」ではなく「すべて検索」にします。 すると、すべての検索結果が下に表示されますから、その一番下が「最新」になります。 その「一番下の検索結果」の文字をクリックすれば、そのセルが表示されますよ！
申し訳、ございません。 完全な回答にはなっていないのですが、 Option Explicit Sub Test() Dim w, e As Object Dim c As String Dim r As Integer Set w = CreateObject("WScript.Shell") c = "type D:\t.txt" Set e = w.Exec("%ComSpec% /c " & c) r = 0 Do While e.Status = 0 r = r + 1 Cells(r, 1).Value = e.StdOut.ReadLine Loop Set e = Nothing Set w = Nothing End Sub と、１行ずつ読み込んでエクセルに書き出すと、かなりの量（4096バイトははるかに超えている）が書き出せたのですが、あと、何行か、残ってしまいました（私が読み込んだテキストデータに何か変な文字コードでも入っていた？）。 質問者のプログラムでしたら、「Do Wile・・・」の前に「Result = ""」とし、「Do While・・・Loop」の間に「Result = Result & wExec.StdOut.ReadLine & vbCrLf」とし、最後に「MsgBox Result」としてみてください。
>・塗りつぶしの代わりに網掛けを使う⇒やはり面倒 との事ですが、 >条件付き書式で１行おきにセルの色を変える の方を「網掛け」で行い、 >特定のセルを目立たせるために別の色にしたいとき の方は通常の「塗りつぶし」を使われては如何でしょうか？ 　後、他には、目立たせたいセルの罫線を「太線」にしたり、罫線の色を変更するなどといった方法も考えられます。
#3です。 #3では回答を書いてなかったね。 普通の丸めならこうです。 =IF(ABS(MOD(A1,10^(CEILING(LOG10(A1),1)-3))*10^(3-CEILING(LOG10(A1),1))-0.5)<0.000001,ROUND(A1/2,3-CEILING(LOG10(A1),1))*2,ROUND(A1,3-CEILING(LOG10(A1),1)))
こんにちは ご自分のコードを再利用すれば、 Function Extraction1(住所文字列 As String) 　　Dim strPref As String 　　Dim N As Long 　　strPref = Left(Trim(住所文字列), 3) 　　Select Case strPref 　　　　Case Is = "東京都", "北海道", "大阪府", "京都府" 　　　　　　N = 3 　　　　Case Else 　　　　　　N = InStr(Left(住所文字列, 4), "県") 　　End Select 　　If N > 0 Then 　　　　Extraction1 = Mid(住所文字列, N + 1, Len(住所文字列)) 　　Else 　　　　Extraction1 = 住所文字列 　　End If End Function こんな感じでは？
シートの左上隅をクリックして「全セルを選択」して、「データ」→「入力規則」→「日本語入力」タブ→「IME」の「日本語入力」を「コントロールなし」に変更→「OK」ボタン、で、勝手に入力モードが変わるのを防げます。 なお、シートが保護されている場合は上記の変更ができないので、事前に「シート保護の解除」を行なっておいて下さい。
該当のセルで右クリックセルの書式設定で、表示形式から文字列を選択すると 3-10でも何でも「文字列」で入力できます。 セルの書式設定は、Ctrl＋1（テンキーじゃないほうの1）でも表示されます。 （ショートカットとして）
　回答No.1です。 >単に18:00と入力しただけでは出勤してから何日目の18:00なのかという事を区別する事が出来ません。 という事に関して、少々言葉足らずな感がありましたのでで説明させて頂きます。 　例えば18:00に出勤してその直後に再度タイムカードを押しますと出勤時刻と退社時刻はともに18:00になります。(勤務時間は0時間) 　又、18:00に出勤してその翌日の18:00に退社した場合にも出勤時刻と退社時刻はともに18:00になります。(勤務時間は24時間) 　更に極端な話を言えば、18:00に出勤してその翌々日の18:00に退社した場合にも出勤時刻と退社時刻はともに18:00になります。(勤務時間は48時間) 　これら3つの例では、どれもセルに入力されている値自体は全く同じなのですから、パソコンにその違いを区別せよというのは無理な話です。(それどころか例え人間であっても区別する事など出来ない事でしょう) 　ですから、翌日の18:00を入力する際には「18:00」と入力するのではなく、「翌18:00」とか「42:00」などの様に入力しなければならない訳です。 　因みに、退社時刻欄に 翌18:00 と入力する様にした場合にも正しい計算が行われる様にするためには、G3セルの関数を次の様なものにする必要があります。 =IF(AND(ISNUMBER($E3),$E3>=0,$E3<1,ISNUMBER(1/(SUBSTITUTE($F3,"翌",)+(LEFT($F3,1)="翌")>$E3))),SUBSTITUTE($F3,"翌",)+(LEFT($F3,1)="翌")-$E3,"")
>売上、原価、確度にそれぞれ日付が入っており、それが一週間刻みで更新されていきます>(W行とX行の間に3行ずつ追加されていくイメージです) >この時、例えば2602行ならば2015/11/5の欄に最終の数字が入っており、それぞれが右端の対応項目に入ります。 >一方、2604行は2015/10/29の欄が最後の入力なので、それらの数値が右端の対応項目に入っております。 >行ごとに一番最後に入力されている売上、原価、確度を転記したく、更に今後3行ずつ挿入をしても同じように反映されているとベターです。 　「売上　2015/11/5」がU1セルに入力されていて、3列で1組となっているという事は、最初の「売上」はC1セルに入力されているものと考えて宜しいのでしょうか？ 　それと念の為に確認しておきたいのですが、最後の「原価　○○○○/○○/○○」の列には必ず数値データが入力されていて、尚且つ最後の「確度　○○○○/○○/○○」の列には数値データが入力されている事は絶対に無いものと考えれば宜しいのでしょうか？ 　もし上記の条件通りであった場合には、Y2セルに入力する関数は次の様なものとなります。 =IF(COUNT($D2:INDEX(2:2,COLUMN()-3)),HLOOKUP(9E+307,$D2:INDEX(2:2,COLUMN()-3),1),"") 　同様に、X2セルに入力する関数は次の様なものとなります。 =IF(ISNUMBER($Y2),INDEX($C2:INDEX(2:2,COLUMN()-3),MATCH(9E+307,$D2:INDEX(2:2,COLUMN()-2))),"") 　同様に、Z2セルに入力する関数は次の様なものとなります。 =IF(ISNUMBER($Y2),INDEX($E2:INDEX(2:2,COLUMN()-3),MATCH(9E+307,$D2:INDEX(2:2,COLUMN()-4))),"")
他ファイルの関数の呼び出し時は、候補表示や自動選択は出来ないので、以下のように、セルに「ファイル名付き」で直接入力して下さい。 =macro.xlsm!MyFunc(A1,B1) 参照するファイルのファイル名に半角スペースや特殊文字を含む場合や、参照するファイルが異なるフォルダに存在してパス付きで指定する場合は、以下のように「'」でファイル名を括って下さい。 ='C:\Users\User Name\Documents\macro.xlsm'!MyFunc(A1,B1) 因みに、参照先のファイルを開いてないと、式の結果が「#NAME?」になるので、式の入力時は参照先のファイルをオープンしていないといけません。
セル C2 に式 =CELL("type",A2) を入力して、此れを下にオートフィルしてみてください。 セル C2、C3 の戻り値はそれぞれ b、l ですね。 ♪ドレミの歌♪のメロディーで歌ってぇ～ 　♪ｂは blank(空白)のビー♪ 　♪ｌは labek(文字列)のエル♪ 　♪なぜ評価が違うか理解できましたか～♪
No.2補足欄、拝見しました。 > この目的は、元々は、2つのシートの内容が、 > 完全に一致することを確認したかったのですが、 完全に【一致】するか[y/n] だけを調べるなら、 【相違】がひとつもないか[y/n] を調べる方が簡単ですよね？ 【相違】ではなく【一致】を採る理由が、 ご説明からは読み取れないです。 さておき、 > 条件付書式では、すぐに結果が出たので、 > この結果を利用して、一致しないセルが > あるかどうかとその場所を取得できれば、 > 2つのシートの内容が完全に一致することを > 確認できるのではないかと考えたわけです。 お気持ちは理解できます。 なるほど、条件付き書式であれば、 即時に、結果を表示された書式に反映させることは出来ますが、 そもそも条件付き書式は、 閲覧時の表示用、或いはプリント用に用意された修飾に特化した機能ですから、 条件に合致したセル範囲を返すような属性は 残念ながら用意されていませんので、 これを分析に用いるというのは本来の目的に適うものではありません。 No.2で紹介した、range.DisplayFormat プロパティは、 ユーザーの要望に応える形でxl2010で追加された新しい機能ですが、 条件付き書式の結果としての表示された書式［以下、"表示書式"］ を利用するということだと（方法は幾つかありますが） 例えばDisplayFormatより簡単なもの、は、ありません。 表示書式を見れば、せっかく結果が表示されているのだから、 これを使いたい、ということがお望みなのでしょうけれど、 フラグやマークアップとして使える情報は保持してませんので、 速さで言うならば、結論として、 表示書式とは無縁に、愚直にＶＢＡで値を比較した方が速いです。 手元で走り書きのマクロで試してみましたが、、 　データ（数値）：二千五百万セル、 　表示書式としての塗りつぶし：八百万セル、 　という条件で、 DisplayFormatを調べた場合は、１０分ほど（戻り値は単一セル範囲多数） 　データ（数値）：二千五百万セル、 　というシートを二つ 　一致するセル：三百万セル、 　という条件で、 二つのシートの値を比較した場合は、１分ほど（結果はセル座標多数） の所要時間でした。 セルの数に比してこの結果を膨大な時間と呼ぶかどうかは、 主観の問題ですが、私の感覚としてはこれ以上をExcelに求めるのは酷かな、と。 > セル数が膨大 もう少し具体的であれば、その概数によって、 どんな計算方法が速いのか、というお話なら出来るとは思います。 とは言え、【一致】を調べて本当は何をしたいのか、 全体を理解出来ないと提示できる情報は少ないです。 手法としては、 想定されるセル数が比較的少ない順に（概ね数万セルから数千万セル程度のスケール） ●Evaluate メソッドを介してExcel側に計算させる 　　（使用メモリが多く喰うけど、比較的高速）（結果は座標） ●第三のシートに比較する数式を展開する 　　（一致する範囲を選択するのが目的なら、最適） ●一旦HTMLテーブルとして読み込んで、正規表現やDOMで処理する 　　（一致したセルを編集するのに向いている）（結果はセルの書換え） ●配列変数に格納した値を比較する 　　（使えるメモリは有限だけど、比較的高速）（結果は座標） ●一旦、テキストファイルに書きだして（端からテキストにする）テキストを比較する 　　（ハードディスクを使うのでメモリ消費を抑えられる） ●ADODBで読み比べる。 など方法はいくつか考えられます。 > Excel2010のあるシートのあるセル範囲(例えばA1～XFD1048576)に 百億超のセルを扱うのは、Excelには（ブックとして扱うのは）まず無理ですから、 > セル数が膨大 ある程度想定される最大セル数を決めておいて、 それに合った手法を選んでいくことになると思います。 後は全体の処理や具体的な仕様にどう合わせていくかだと思いますし、 簡単さと処理速度のコストバランスをどう考えるかでしょうか。 要約すると、 条件付き書式は表示用、プリント用。 結果をフラグとして分析に使うことは難しい。 直接、値の方を比べる事になるでしょう。 題意への理解が未だ不十分なのかも知れませんが、 この程度で御容赦ください。 それではまたいつか。
各シートのB~AC列のデータをsheetAのA列~AB列にセルの結合を含めたコピーするコードを作成したいのでしたら下記のような方法は如何でしょう。 Sub コピー() Dim sh1 As Worksheet Dim FoundCell As Range, FirstCell As Range Dim MaxRow As Long Dim CR, PR As Range '「項 目」という文字列を検索 For i = 1 To Worksheets.Count - 2 '←最大シート数 Sheets(Sheets(i).Name).Select Set FoundCell = Cells.Find(What:="項*目") If FoundCell Is Nothing Then MsgBox "見つかりません" Exit Sub Else 'コピー元セル範囲を変数に格納 Set CR = FoundCell.Resize(2, 28) 'sheetA　最終行 MaxRow = Sheets("SheetA").Cells(Rows.Count, 1).End(xlUp).Row 'コピー先セル範囲を変数に格納 Set PR = Sheets("SheetA").Range("A" & MaxRow + 2).Resize(2, 28) '指定の範囲を貼り付け先にコピー CR.Copy Destination:=PR End If Next i End Sub 添付画像は赤い罫線は結合をしていないセルの罫線をしめしています。 Copy Destinationは一般的なcopyより高速だといわれています。 注意事項はコピー元とコピー先共に同一セル数でセル範囲を指定する事が必須です。 Range("A1:A5").Copy Range("C1")は可能ですが、Copy Destinationではセル範囲が異なるのでこのような指定は出来ません。
IE11限定でしょうか？ IEではないですがフリーでIEのブラウザ表示エンジンを使用した 「ScriptBrowserK」という多機能ブラウザがあります。 「公開・サポートは終了しました」となってますが、確認したところ まだダウンロードはできるようです。 http://www.scriptbrowserk.com/index.html 自動ログインや自動フォーム入力などできますし、スクリプトを 作成し実行することも可能です。 当該ホームページの「スクリプト作成入門」にある 　・テーブル内（表内）のテキストを取得する方法 　・Webページ内の情報（株価など）をファイルに保存するスクリプトの例 　・スクリプトからMicrosoft Excelを操作する（Webページから株価を取得） 辺りが参考になるかと思います。 それぞれサンプルスクリプトのソースが書かれているので それを真似て作れば、ご質問で書かれていることが出来るかも しれません。 ご参考まで。
とりあえずご質問の直接の回答としては if mystr like "*[[]*" then のようにします。ＶＢＡのヘルプでは「Ｌｉｋｅ演算子」に必要な事が書かれています。 一般に含む含まないなら if instr(mystr, "[") > 0 then のようにしてしまうことが多いかなと思います。
> 書き忘れたのが悪いのですがこれだと量があると大変ですね。 量が多いと書いてたらそもそも こんな方法で回答してません。 テキストエディタに持っていって Tab記号を「、」に置換した方が 早そうな気もしますが Excelでやるなら手段は２つです。 手段１：作業列に計算を分けて１つずつ繋げる。 手段２：ユーザー定義関数を作る。 前者は既に回答が付いてますので 後者で回答します。 Function UNION(セル範囲 As Range, 記号 As String) Dim c As Range For Each c In セル範囲 If c.Value <> vbNullString Then UNION = UNION & 記号 & c.Value End If Next c UNION = Mid$(UNION, 2) End Function
　回答No.1です。 >質問内容の >(1)０５０電話番号と >(2)のＩＰアドレスは、全くの別もの（別ファイル）の質問でございます。 >(1)と(2)を全く分けていただくことは可能でしょうか？ 　早とちりをしてしまい申し訳御座いません。 　しかしそうしますと、御質問文を良く読んだ限りでは、(1)に関しましても、単に >Ｃ列をセルの書式設定で「文字列」に設定してないからなのかな？と思いますが、強制的に先頭に５を表示させたいのです。 という点を実現出来さえすれば良いという意味に受け取れる様に思えます。 　それにも関わらず、何故、 >Ｂ列にドロップダウンリストで「050」を強制的に選ばせるようにしました。 >（選択肢は１つなので、わざわざと思われそうですが、０５の後にハイフンを入れる9ような方もいらっしゃいますので・・・・） >セルの書式設定で050の後にハイフンが表示するようにしています。 という話を述べておられるのかが良く解りません。 >Ｂ列にドロップダウンリストで「050」を強制的に選ばせるようにしました。 >セルの書式設定で050の後にハイフンが表示するようにしています。 という話が、本件にどう関係して来るのかという事を御説明願えませんでしょうか？ 　後それから、入力した7桁の数値をセルの書式設定で「5〇〇〇-〇〇〇〇」としたとしましても、それはあくまでモニターで見た時や印刷した時に「5〇〇〇-〇〇〇〇」に"見える"だけであり、セルに入っているデーターそのものは入力した時の7桁の数値のままで、「5〇〇〇-〇〇〇〇」になっている訳ではありませんので、例えば「050」とC列の値を組み合わせても「050-5〇〇〇-〇〇〇〇」にはなりませんが、その点は御承知の事なのでしょうか？ 　上記の様に不明な点が若干残ってはおりますが、取りあえずB列の値とは関係なしに >Ｃ列をセルの書式設定で「文字列」に設定してないからなのかな？と思いますが、強制的に先頭に５を表示させたい という御質問に対する直接的な回答としましては以下の様なものになります。 C列のセルの中で、書式と入力規則を設定したいセルを選択 　　↓ Excelウインドウの上の方にある[データ]タブをクリック 　　↓ 現れた「データツール」グループ内の[データの入力規則]ボタンをクリック 　　↓ 現れた選択肢の中にある[データの入力規則]をクリック 　　↓ 現れた「データの入力規則」ダイアログボックスの中にある[設定]タブをクリック 　　↓ 現れた「入力値の種類」欄をクリック 　　↓ 現れた選択肢の中にある[整数]をクリック 　　↓ 現れた「最小値」欄に 0 と入力 　　↓ 「最大値」欄に 9999999 と入力 　　↓ 「データの入力規則」ダイアログボックスの[入力時メッセージ]タブをクリック 　　↓ 現れた「セルの選択時にメッセージを表示する」と記されている箇所にチェックを入れる 　　↓ 「メッセージ」欄に 電話番号の末尾の7桁の数字のみを入力して下さい。 「-」(ハイフォン)等の数字以外の文字や記号は入力しないで下さい。 と入力 　　↓ 「データの入力規則」ダイアログボックスの[エラーメッセージ]タブをクリック 　　↓ 現れた「無効なデータが入力されたらエラーメッセージを表示する」と記されている箇所にチェックを入れる 　　↓ 「スタイル」欄をクリック 　　↓ 現れた選択肢の中にある[停止]を選択してクリック 　　↓ 「タイトル」欄に 無効な値が入力されました と入力 　　↓ 「エラーメッセージ」欄に 電話番号の末尾の7桁の数字のみを入力して下さい。 入力出来るのは 0 1 2 3 4 5 6 7 8 9 の10個の半角数字のみからなる7桁以下の数値のみです。 「-」(ハイフォン)等の数字以外の文字や記号は入力できません。 と入力 　　↓ 「データの入力規則」ダイアログボックスの[OK]ボタンをクリック 　　↓ 選択範囲を変更せずに、選択範囲を示す黒い太枠の内側を右クリックして、現れた選択肢の中にある[セルの書式設定]をクリック 或いは [Ctrl]キーを押しながら[1 ! ぬ]キーを押す 　　↓ 現れた「分類」欄の中にある[ユーザー定義]をクリック 　　↓ 現れた「種類」欄に "5"000-0000 と入力 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　上記の様に設定しますと、例えば 1234567 を入力しますと 5123-4567 と表示されます。(セルに入力されているデータは1234567のままです) 　又、例えば 1 を入力しますと 5000-0001 と表示されます。(セルに入力されているデータは1のままです) 　又、例えば 0000001 と入力しますと 5000-0001 と表示されますが、セルに入力されているデータは1になります。 　(1)に関しては以上です。 　一方、(2)に関してですが、入力するのがIPアドレスという事ですと、 >数字と.（ドット）以外入力出来ないように するだけでは、例えば .999.256......1234567890.99999999999999.9876543210. などの様なIPアドレスではない値が入力されてしまう事を防ぐ事が出来ません。 　IPアドレスは「.」(ドット)で区切られた4個の整数で構成されていて、その4個の数字は0～255の範囲の整数であり、負の数や255を超える数字が設定される事はありません。 【参考URL】 　IPアドレス - Wikipedia > 4.1 グローバルIPアドレス 　　https://ja.wikipedia.org/wiki/IP%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9#.E3.82.B0.E3.83.AD.E3.83.BC.E3.83.90.E3.83.ABIP.E3.82.A2.E3.83.89.E3.83.AC.E3.82.B9 　＠IT > 自分戦略研究所 > スキル創造研究室 > CCENT／CCNA 試験対策 2014年版（5）：究極の入門 プライベートIPアドレスとパブリックIPアドレス (1/2) 　　http://www.atmarkit.co.jp/ait/articles/1412/25/news029.html 　ですから、もしIPアドレス以外は入力出来ない様にするのでしたら、「3個の『.』(ドット)で区切られた4個の『0～255』の整数の組み合わせを表す文字列」以外は入力出来ない様にする入力規則が必要になります。 　入力規則に設定可能な数式の文字数には制限があり、その制限文字数はセルの制限文字数よりも少ない様で、セルを使って最初に作った判定用の数式が、入力規則の「数式」欄に入力する事が出来ず、数式をダイエットするのに時間が掛かりましたが、例えばB2セルに設定する場合の例は以下の様なものになります。 B2セルを選択 　　↓ Excelウインドウの上の方にある[データ]タブをクリック 　　↓ 現れた「データツール」グループ内の[データの入力規則]ボタンをクリック 　　↓ 現れた選択肢の中にある[データの入力規則]をクリック 　　↓ 現れた「データの入力規則」ダイアログボックスの中にある[設定]タブをクリック 　　↓ 現れた「入力値の種類」欄をクリック 　　↓ 現れた選択肢の中にある[ユーザー設定]をクリック 　　↓ 現れた「数式」欄に =COUNTIFS($B2,"*?.*?.*?.*?",$B2,"<>*-*",$B2,"<>*.*.*.*.*",$B2,"<>*????.*.*.*",$B2,"<>*.*????.*.*",$B2,"<>*.*.*????.*",$B2,"<>*.*.*.*????")*ISNUMBER(SUBSTITUTE($B2,".",)+0)*(SUMPRODUCT(ISNUMBER(FIND(ROW(INDIRECT("Z256:Z999")),$B2))*1)=0) という数式を入力 　　↓ 「データの入力規則」ダイアログボックスの[入力時メッセージ]タブをクリック 　　↓ 現れた「セルの選択時にメッセージを表示する」と記されている箇所にチェックを入れる 　　↓ 「メッセージ」欄に IPアドレスを入力して下さい。 と入力 　　↓ 「データの入力規則」ダイアログボックスの[エラーメッセージ]タブをクリック 　　↓ 現れた「無効なデータが入力されたらエラーメッセージを表示する」と記されている箇所にチェックを入れる 　　↓ 「スタイル」欄をクリック 　　↓ 現れた選択肢の中にある[停止]を選択してクリック 　　↓ 「タイトル」欄に 無効な値が入力されました と入力 　　↓ 「エラーメッセージ」欄に IPアドレスを入力して下さい。 IPアドレス以外の値は入力できません。 入力出来るのは 数字.数字.数字.数字 の型式で表される4個の整数の組み合わせからなる値で、各[数字]の部分に入れる事が出来るのは0～255の範囲の整数のみです。 「&」を始めとする「.」以外の記号やアルファベット等の文字の類は入力できません。 　又、全角文字は入力できませんので、入力は半角文字で行って下さい。 と入力 　　↓ 「データの入力規則」ダイアログボックスの[OK]ボタンをクリック 　以上です。
ＯＳのバージョンや、エクセルのバージョンに関係なく、必ずちゃんと、出ますよ！ 念のため、パソコンを再起動してみて、もう一度、やり直してみてください。 それでもダメでしたら、「ファイル」→「オプション」で表示される、フォント名とフォントサイズを調べてみてください。 と言っても、あまり意味はありませんが・・・ 書式設定などを全く行っていない、サラのシートのセルに文字を入力してもセル内に文字が表示されないのでしたら、原因は分かりません。 申し訳ございません。
添付図参照 E2: =COUNTIFS($A:$A,E$1,$B:$B,$D2)
D1が1/1からで良いのでしょう・ D1に2016/1/1を手動入力又はセル参照による関数等で実うるう年である今年を1/1として下さい。 D2式 =IFERROR(IF(MONTH(D1)=MONTH(D1+1),D1+1,"集計"),C1+1) 右方向にNE1までオートフィル 集計が12作成されてる事を確認 月合計数式 １月 AI2式 =SUM(OFFSET(AH2,,,,-DAY(AH$1))) 下方へオートフィル AI2~数式までをコピー 各月の集計の２行目にペーストする。 ２月、３月修正 閏年の月末及び、3/1数式修正 2/29日のBL1式を下記に修正（コピペ） =IFERROR(IF(MONTH(BK1)=MONTH(BK1+1),BK1+1,""),"") BM1に集計を入力 3/1のBN1式 =IF(BL1="",BK1+1,BL1+1) 2月集計数式BM2式 =SUM(OFFSET(BL2,,,,-29)) 下方へオートフィル D1の年を変更で２月の29日表示も自動で行います。 添付画像は１日と月末間は非表示で非表示セルは空白で、１日と月末だけ数値を入力し集計欄で月集計させています。数式は上記の通りです。
Office更新　Office365の配信　原因は不明のままだと思いますが ネット上のヘルプにアクセスすれば閲覧可能　Microsoftに改善意欲は無いように感じます ちゃんと日本語のメッセージが用意されている　表示不可能になると確認したうえのUpdateと感じます 現象はさまざまなようで　もう確認済かも知れませんが http://answers.microsoft.com/ja-jp/office/forum/office_2013_release-excel/%E3%83%98%E3%83%AB%E3%83%97%E3%81%8C%E6%A9%9F/369a8218-c371-4437-ae9b-62e1dcdbdbe0?page=1 同様の操作を試してダメだったら諦めるしか無いと思います
　以下の様な操作を行ってK1～AN3900のセル範囲に条件付き書式を設定されると良いと思います。 K1セルを選択 　　↓ Excelウィンドウの[ホーム]タブをクリック 　　↓ 現れた「スタイル」グループの中にある[条件付き書式]ボタンをクリック 　　↓ 現れた選択肢の中にある[ルールの管理]をクリック 　　↓ 現れた「条件付き書式ルールの管理」ダイアログボックスの中にある[新規ルール]ボタンをクリック 　　↓ 現れた「新しい書式ルール」ダイアログボックスの「ルールの種類を選択して下さい」欄の中にある[数式を使用して、書式設定するセルを決定]をクリック 　　↓ 現れた「次の数式を満たす場合に値を書式設定」欄の中に =AND(ISNUMBER(K1),K1>HLOOKUP(9E+307,$J1:J1,1)) と入力 　　↓ 「新しい書式ルール」ダイアログボックスの[書式]ボタンをクリック 　　↓ 現れた「セルの書式設定」ダイアログボックスの[塗りつぶし]タブをクリック 　　↓ 現れた背景色のサンプルの中にある赤色の四角形をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「新しい書式ルール」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[新規ルール]ボタンをクリック 　　↓ 現れた「新しい書式ルール」ダイアログボックスの「ルールの種類を選択して下さい」欄の中にある[数式を使用して、書式設定するセルを決定]をクリック 　　↓ 現れた「次の数式を満たす場合に値を書式設定」欄の中に =AND(ISNUMBER(K1),K1<HLOOKUP(9E+307,$J1:J1,1)) と入力 　　↓ 「新しい書式ルール」ダイアログボックスの[書式]ボタンをクリック 　　↓ 現れた「セルの書式設定」ダイアログボックスの[塗りつぶし]タブをクリック 　　↓ 現れた背景色のサンプルの中にある青色の四角形をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「新しい書式ルール」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの「適用先」欄を2箇所とも =$K$1:$AN$3900 に変更（カーソルとマウスの左ボタンによる範囲選択が使えます） 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[適用]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[OK]ボタンをクリック 　以上です。
compコマンドは ほかのファイルを比較しますか (Y/N)? と言うプロンプトを「標準エラー出力」に出力します。 ですので 　If wshExec.StdErr.AtEndOfStream = False Then が「真」になり 　　'エラー 　　result = wshExec.StdErr.ReadAll だけが実行されます。 そして、resultには ほかのファイルを比較しますか (Y/N)? と言う文字列が返って来ます。 なので MsgBox result とやっても ほかのファイルを比較しますか (Y/N)? しか表示されず、欲しい結果は得られません。 なので「標準エラー出力になにか出力されても、無視する」ようにして下さい。 つまり 　'判定しない 　’If wshExec.StdErr.AtEndOfStream = False Then 　　'エラー 　　'result = wshExec.StdErr.ReadAll 　'Else 　　'正常 　　result = wshExec.StdOut.ReadAll 　'End If のように、if文をコメントアウトして下さい。 なお「compコマンドは、プロンプトを出して、ｙかｎが入力されるまで、待ってしまう」ので 　command = "echo n | comp " & file1 & " " & file2 にしないといけません。じゃないと「手でｎを入力しないとcompコマンドが終了しない」です。
Ｂ列には =IF(ROW(B1)>COUNTIF(A:A,"<=10000"),"",SMALL(A:A,ROW(B1))) 以下コピー Ｃ列には =IF(ROW(C1)>COUNTIFS(A:A,">10000",A:A,"<=20000"),"",SMALL(A:A,ROW(C1)+COUNT(B:B))) 以下コピー Ｄ列には =IF(ROW(D1)>COUNTIF(A:A,">20000"),"",SMALL(A:A,ROW(D1)+COUNT(B:C))) 以下コピー。
>行がA2からA4000まであるのですが との事ですが、B2に入力されているのは >日産とかのようにメーカー名前 なのでしょうか、それとも「メーカー名」などと言ったその列の項目名なのでしょうか？ 　その事に関して御質問文には何も説明が御座いませんので、取り敢えずB2には「メーカー名」などと言ったその列の項目名が入力されている場合に関して回答させて頂きます。 　その場合、下記の様なマクロでは如何でしょうか。 Sub QNo9118473_宜しくお願いいたします_急いでるのですが列がA2か() Const ItemRow = 2 '表の中で項目名が入力されている行の行番号 Const ListColumns = "A:AJ" '表の罫線が引かれている列の範囲 Const SearchColumn = "B" '表の中でメーカー名が入力されている列の列番号 Dim c As Range, LastRow As Long LastRow = Range(SearchColumn & Rows.Count).End(xlUp).row If LastRow <= ItemRow Then MsgBox "処理すべきデータがありません。" & vbCrLf _ & "マクロを終了します。", vbExclamation, "データ無し" Exit Sub End If Application.ScreenUpdating = False For Each c In Range(SearchColumn & ItemRow + 1 _ & ":" & SearchColumn & LastRow) If c.Value <> c.Offset(1).Value Then _ Intersect(c.Resize(2, 1).EntireRow, Range(ListColumns)) _ .Borders(xlInsideHorizontal).Weight = xlThick Next c Application.ScreenUpdating = True End Sub
参考に Dim c As Range, v As Variant For Each c In Selection 　　v = Split(c.Text, "/") 　　If UBound(v) = 2 Then 　　　　c.NumberFormatLocal = "yyyy/m/d" 　　　　c.Value = DateValue("H" & c.Text) 　　ElseIf UBound(v) = 1 Then 　　　　c.Value = v(0) + 1988 & "/" & v(1) & "/00" 　　End If Next
下記のような数式で可能ですが、ifとNETWORKDAYSが一緒に使用出来ないと思われた理由がわかりませんが。 =IF(COUNT(A1:B1)=2,NETWORKDAYS(A1,B1,$A$3:$A$25),"") 又は =IF(or(A1="",B1=""),"",NETWORKDAYS(A1,B1,$A$3:$A$25)) $A$3:$A$25は祝日や貴社の指定休日記載セル範囲又は名前の定義の名称を指定
そんなに変な関数とか使わなくても 添付図： Ｄ２ =IF(COUNT(B2:C2)=2,(SUM(B$2:B2)-SUM(C$2:C2))/COUNT(A$2:A2),"") 以下コピー ぐらいでいいです。 既出回答でも指摘されていますが、「相当する日数で割った」の日数の意味が曖昧ですね。
　質問者様が御使いになられているExcelはどのバージョンのExcelなのでしょうか？ 　Excel2007以降(Excel2007も含む)のバージョンであれば以下の様にされると良いと思います。 　まず、使用していない適当なシート(ここでは仮にSheet2とします)に下記の添付画像の様なリストを作成して下さい。 　次に、C列～E列に各項目を入力し終えるごと(添付画像の例で言えばC2～E7までのデータを全て入力し終えるごと)に、C列～E列を選択してから、Excelウインドウの上の方にある[データ]タブをクリックし、現れた「データツール」グループ内の[並べ替え]ボタン(或いは[ホーム]タブの「編集」グループ内の[並べ替えとフィルター]ボタンをクリックすると現れる[ユーザー設定の並べ替え])をクリックして下さい。 　すると「並べ替え」ダイアログボックスが現れますので、その中の「先頭行をデータの見出しとして使用する」と記されている箇所にチェックを入れ、「列」欄の「最優先されるキー」をC列の「商品」に設定してから、「並べ替え」ダイアログボックスの[OK]ボタンをクリックする事で、同じ商品名の商品の行同士が一塊に纏まっている様にして下さい。 　次に、「商品をドロップダウンリストで選択するセル」が例えばA2セルである場合には、同じ行の「規格１をドロップダウンリストで選択するセル」を選択してから、[データ]タブをクリックし、現れた「データツール」グループ内の[データの入力規則]ボタンをクリックし、現れた選択肢の中にある[データの入力規則]をクリックして下さい。 　すると「データの入力規則」ダイアログボックスが現れますので、その中の[設定]タブをクリックして下さい。 　次に、現れた「入力値の種類」欄をクリックし、現れた選択肢の中から[リスト]を選択してクリックして下さい。 　次に、現れた「元の値」欄に次の様な数式を入力して下さい。 =OFFSET(INDEX(Sheet2!$D:$D,MATCH($A2,Sheet2!$C:$C,0)),0,0,COUNTIF(Sheet2!$C:$C,$A2)) 　次に、「データの入力規則」ダイアログボックスの[OK]ボタンをクリックして下さい。 　次に、同様の操作を「規格２をドロップダウンリストで選択するセル」に対しても行って、「元の値」欄に次の様な数式が設定されている入力規則を設定して下さい。 =OFFSET(INDEX(Sheet2!$E:$E,MATCH($A2,Sheet2!$C:$C,0)),0,0,COUNTIF(Sheet2!$C:$C,$A2)) 　以上です。
こんにちは No1～3です。 選択した範囲全てなら、 Sub test2() 　　Dim s As Range 　　For Each s In Selection 　　　　On Error Resume Next 　　　　s = "2015/" & Format(Split(s, "（")(0), "m/d") 　　　　s.NumberFormatLocal = "yyyy/m/d" 　　　　On Error GoTo 0 　　Next End Sub で。 色々なエラーを想定して適宜エラー処理を入れて下さい。
１．セル E1、F1 にそれぞれ数値 50、85 を入力し、セル G1 に文字列で ＿＿「85以上」を入力 ２．セル E1、F1 をそれぞれ次のように“ユーザー定義”で書式設定 ＿＿ E1: G/標準"未満" ＿＿ F1: "50以上"G/標準"未満" ３．セル D2、D3 にそれぞれ「2015/12/1」、「2016/1/1」を入力 ４．範囲 D2:D3 を次のように“ユーザー定義”で書式設定 ＿＿ yyyy/mm ５．セル E2、F2、G2 にそれぞれ下記の式を入力 ＿＿ E2: =SUMPRODUCT(($A$2:$A$100>=$D2)*($A$2:$A$100<=EOMONTH($D2,0))*($B$2:$B$100>0)*($B$2:$B$100<E$1)) ＿＿ F2: =SUMPRODUCT(($A$2:$A$100>=$D2)*($A$2:$A$100<=EOMONTH($D2,0))*($B$2:$B$100>=E$1)*($B$2:$B$100<F$1)) ＿＿ G2: =SUMPRODUCT(($A$2:$A$100>=$D2)*($A$2:$A$100<=EOMONTH($D2,0))*($B$2:$B$100>=F$1)) ６．範囲 E2:G2 を下方にオートフィル
D1セルに以下の式を入れてみてください。 =VALUE("H"&A1&"/"&B1&"/"&C1)
任意のセルに下記数式をコピーして下方へオートフィル =COUNTIF(OFFSET($A$1,(ROW(A1)-1)*51,,51),">0")
　使用した事がある最後のセルの位置情報が残っています。 　例えば、H1セルを称した事が1度も無い場合であっても、例えばH3セルとA99セルに値を入力したり、何らかの書式を設定した事があれば、H99セルが最後のセルとして扱われます。 　試しに[並べ替えとフィルター]ボタンの右隣にある[検索と選択]ボタンをクリックし、現れた選択肢の中にある[条件を選択してジャンプ]をクリックすると現れる「選択オプション」ダイアログボックスにおいて、[最後のセル]の所にチェックを入れてから[OK]ボタンをクリックしてみて下さい。 　或いはCtrl キーを押しながら End キーを押してみて下さい。 　使用した最後の行と最後の列が交わる所にあるセルが選択される筈です。 　[最後のセル]の位置情報をリセットするには、「現在実際に使用している最後の列の右隣の列」～「『最後のセル』ジャンプと選択されるセルがある列」の列範囲を纏めて選択してから、[並べ替えとフィルター]ボタンの左隣にある[クリア]ボタンをクリックし、現れた選択肢の中にある[すべてクリア]をクリックする事で、選択した列範囲内の全てのセルの値や書式、コメント等を消去した上で、そのExcelbookを保存してから一旦閉じなければなりません。 【参考URL】 　ワークシートの最後のセルを特定してリセットする - Excel 　　https://support.office.com/ja-jp/article/%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%B7%E3%83%BC%E3%83%88%E3%81%AE%E6%9C%80%E5%BE%8C%E3%81%AE%E3%82%BB%E3%83%AB%E3%82%92%E7%89%B9%E5%AE%9A%E3%81%97%E3%81%A6%E3%83%AA%E3%82%BB%E3%83%83%E3%83%88%E3%81%99%E3%82%8B-c9e468a8-0fc3-4f69-8038-b3c1d86e99e9
>３．それで印刷しようとしたのですが　PDFドキュメントの 保存というのがでてきてしまいます。 という現象が発生する原因は、おそらく質問者様が御使いのパソコンの設定で、「主に使うプリンター」の設定の所で、「プリンター」ではなく「印刷内容を(紙にプリントするのではなく) pdf形式のファイに変換して保存する」という働きをするアプリケーションソフトを、プリンターの代わりに指定しているからではないかと思われます。 　ですから、Excelウィンドウの左上の辺りにある[ファイル]タブをクリックし、現れた画面の左側に並んでい選択肢の中から[印刷]を選択してクリックし、現れた「プリンター」と記されている箇所のすぐ下にあるプリンターの機種名が記されているボタンをクリックし、現れた選択肢の中から、使用したいプリンターを選択し直してから、印刷をやり直せば良いと思います。
縮小専用 http://www.forest.impress.co.jp/library/software/shukusen/ このソフト使って一括で画像を指定サイズに変換して貼り付けるのはどうでしょうか。サイズも指定サイズ以下に変更できます。 ただし大本の画像を小さくするので、エクセルに貼り付けてから縮小するのと違って画像の質が落ちてしまいます。 貼り付けてから縮小したいなら、画像をまとめてエクセル内に貼り付けてから「サイズとプロパティ」をクリックして、大きさを打ち込みで指定すれば選択した画像のサイズをまとめて変更できます。 保存先を指定するのについて、画像をダウンロードする時の話なら、名前をつけて保存を選んで、特定の場所に保存すれば、次に保存するときもそこに保存できると思います。 質問を勘違いしてたらごめんなさい。
NO4です。 B列内の重複をしたいのでしたら、B列全体選択後、条件付き書式の数式を下記で設定で =COUNTIF(B:B,B1)>1 ３つ以上の重複と２つだけの重複を区別したいのなら、条件付き書式をB列で２回行います。 ２回重複 =COUNTIF(B:B,B1)=2 ３回以上の重複 =COUNTIF(B:B,B1)=3 条件付き書式の数式を使用する方法を下記に再度添付しますので、お読みになって下さい。 http://love-guava.com/excel-conditional-format/ 添付画像は２回重複をマゼンダ、３回以上を水色でB列の条件付書式をしています。
=SUMPRODUCT((A1:A99<>B1:B99)*1) とかでいいです。 ご利用のエクセルのバージョンがご相談に書かれていませんが、新しいエクセルを使っているなら =SUMPROEUCT((A:A<>B:B)*1) と計算する事も可能です。ただし劇重なので、教わっても使ってはいけません。
この回答は、結果は出ると思うのですが（完全な形では確かめていないので）、ご要望の趣旨と異なるので、無視して頂いて結構です。 一応説明します。 以下のプログラムをテキストエディタにコピー＆ペーストし貼り付けます（メモ帳でも構いません）。 「～.vbs」という名前で保存するのですが、保存する場所は、「集計」と「個別」フォルダの上のフォルダです。 例えば「集計」フォルダと「個別」フォルダが「Ｄ」ドライブの「エクセル」フォルダの下にあるのでしたら、「エクセル」フォルダに保存します。 保存した「～.vbs」ファイルをダブルクリックする（シングルクリックしてEnterの方がより確実）と、集計を始めます。 今は、安全のため、「集計１.xlsx」という名前で保存し、元の「集計.xlsx」は、そのまま残っています。 処理が終了すると、「Finished!」と表示しますが、それまでの間、絶対にパソコンをいらってはいけません。 特に今回の処理に関係の無いファイルであっても、エクセルのファイルを開けたり、エクセルを起動しただけで、間違いなくエラー終了してしまいます。 もう一つ、注意事項としては、「個別」フォルダにある、エクセルファイルは、ファイル名に関係なく、すべて処理してしまいますので、関係の無いエクセルファイルは「個別」フォルダには入れないでください。 Option Explicit Dim a, b, c, d, f, i, j, k, r, t, u, v, w, x, y, z Set t = CreateObject("Scripting.FileSystemObject") Set u = t.GetFolder(".") Set f = t.GetFolder(u & "\個別") Set v = CreateObject("Excel.Application") v.Application.DisplayAlerts = False Set w = v.Workbooks.Open(u & "\集計\集計.xlsx") Set x = w.Worksheets(1) r = x.Range("A1").End(-4121).Row For Each a In f.Files b = LCase(t.GetExtensionName(a.Name)) If b = "xls" or b = "xlsx" Then Set y = v.Workbooks.Open(u & "\個別\" & a.Name) For i = 1 to y.Worksheets.Count Set z = y.Worksheets(i) For j = 1 to z.Range("A1").End(-4121).Row c = z.Cells(j, 1).Value d = z.Cells(j, 2).Value For k = 1 to r If x.Cells(k, 1).Value = c and x.Cells(k, 2).Value = d Then x.Cells(k, 3).Value = x.Cells(k, 3).Value + z.Cells(j, 4).Value x.Cells(k, 4).Value = x.Cells(k, 4).Value + z.Cells(j, 5).Value x.Cells(k, 5).Value = x.Cells(k, 5).Value + z.Cells(j, 6).Value x.Cells(k, 6).Value = x.Cells(k, 6).Value + z.Cells(j, 7).Value End If Next Next Set z = Nothing Next y.Close Set y = Nothing End If Next w.SaveAs(u & "\集計\集計1.xlsx") w.Close v.Quit Set x = Nothing Set w = Nothing Set v = Nothing Set u = Nothing Set t = Nothing MsgBox("Finished!")
PHONETIC関数は、ほかの皆さまが回答してくださったように、ドラッグでコピーするとできます。 名前がコピーしたものですと、この関数を使っても漢字のまま表示されます。 フリガナが表示されても違う場合もあります。 次の方法で修正したり、表示させたりしてください。 カナを振らせたいセルごとで　[ALT]+[Shift]+[↑]　押すと、編集状態になります。 [ALT]+[Shift]+[↑]を押すごとに、候補が現れますので、正しいフリガナになったときに [Enter] を2回押して確定してください。 PHONETIC関数が入ったセルに、フリガナが表示されます。 PHONETIC関数はコピーでいいですが、修正自体はひとつづつになります。修正したりフリガナを入力することを思えば、機械的に行えばいいので、100件ぐらいでしたら、頑張ってください。
かってにユーロに変わったってことですが、 元はどのような文字列が入っていたのでしょうか。 例えば「10(e)」という文字列がある場合、オートコレクト 機能によって「10€」に変換されます。変換されると書式も 恐らく変わるとおもいます。 念のため、オプション→文章校正→オートコレクトの オプションがどのような設定になっているか確認した方が よいかもしれません。
＃5です。 63で返ってきたということですが、それは「?」の コードですね。 CSVに変換する前の元データのExcelファイルでご確認されたん ですよね？ で、CSVへの変換はどうやってやってるのでしょうか。 変換ツール？それとも名前を付けて保存でCSV選択？
こんにちは。 > そして3枚目のシートに1枚目データと2枚目マスターとが一致したものだけを > 全て抽出したいと考えております。 フィルターを使います。 > 2枚目のシートに自分の抽出したいマスター機種一覧があります。 「2枚目のシート」の「どこに」「どのように」 ということが要件になりますが、 こちらで仮の設定として、 　　　　A 1　　品目 2　　りんご 3　　バナナ のように、 １行めが項目タイトル、 抽出したい「品目」はＡ２から下方向に連続して配置されている場合 を例にお応えしますので、あとはそちらで応用なさってください。 > 1枚目のシートに2000列くらいのデータがあり、 > 2列あれば2列とも抽出したいのですが、 2000行、2行という意味ですよね？ ともあれ、基データには、空の行が含まれないことが条件になりますので、 ご注意を。 因みに、ご提示のサンプルで言えば、 　　ぶどう　　1/15　　8　　　　トラック　　　　100　　　　1/30　　　　1/20 のように横並びになったデータ（レコード）をExcelでは行と呼び、 　　品目 　　りんご 　　りんご 　　ぶどう 　　パイン 　　バナナ 　　バナナ のように縦並びになった項目（フィールド）をExcelでは列と呼びます。 > ...マスターにりんごとバナナの品目と注文数と注文納期だけを別シートに抽出するにはどうすればよいでしょうか？ 　　「2枚目のシート」の「マスター機種一覧」に 　　「品目」として "りんご" "バナナ" が指定してあるようなケースで 　　"りんご" "バナナ" に該当するすべてのデータを抽出した上で、 　　「品目」「注文数」「注文納期」の３項目を 　　「3枚目のシート」に転記したい。 ということで宜しいでしょうか？ 「3枚目のシート」の「どこに」「どのように」転記したいのか 書かれていませんので、 １行めが項目タイトル、 A列「品目」、B列「注文数」、C列「注文納期」 という風に、これも仮の設定をこちらでしていますので、 、あとはそちらで応用なさってください。 > 変数とif　で一致したら、、というところまでできたのですが、りんごの列が２つあると > 下の列のりんごしか抽出できないのです。2列あれば2列とも抽出したいのですが、 > できません。 ご自分で書いた記述を提示されたなら、その記述への修正を加える事は可能です。 ただ、抽出などを扱う場合の多くで、Excelの一般機能を活用する方が、 簡易に短時間で処理できることが多いです。 今回の例でも、Excelの一般機能のフィルターを使うのがお奨めです。 尚、 「1枚目のシート」という表現に合わせて、 Sheets(2)のようにシートの並び順による指定方法でお応えしていますが、 シートの並びは容易に変更されてしまうものですから、 ＶＢＡではあまり使われない指定方法です。 なるべく、Sheets("Sheet1")　Sheets("Sheet2")　Sheets("Sheet3") 等のように、シートに設定されている実際の名前で指定するようにしてください。 不足・不明・応用の相談、などあれば"具体的に"補足してみてください。 ' ' /// Sub ReW9114698() Dim aryCrit　'　「品目」を配列として格納しておく変数 　　' ' 「2枚目のシート」 　　With Sheets(2) 　　　　' ' マスター機種一覧から「品目」を配列として取得。 　　　　' ' 「品目」が、A2から下方向に連続して配置されている場合の例 　　　　aryCrit = .Range("A2:A" & .Cells(Rows.Count, "A").End(xlUp).Row).Value 　　End With 　　' ' 取得済の「品目」配列を一次元配列に置換。 　　aryCrit = Application.Transpose(aryCrit) 　　' ' 「1枚目のシート」 　　With Sheets(1) 　　　　If .FilterMode Then .ShowAllData　'　フィルター抽出状態を解除（全表示） 　　　　' ' 「品目」配列をキーにフィルターで抽出。 　　　　.Cells.CurrentRegion.AutoFilter Field:=1, Criteria1:=aryCrit, Operator:=xlFilterValues 　　　　Application.ScreenUpdating = False　'　Excelの描画一時停止 　　　　' ' 抽出されたデータの内、「品目」「注文数」「注文納期」にあたる「A列,E列,G列」をコピー 　　　　.Range("A:A,E:E,G:G").Copy 　　　　' ' 「3枚目のシート」→ Sheets(3)　の　「セルA1」→.Range("A1")　を先頭に貼付け 　　　　Sheets(3).Range("A1").PasteSpecial 　　　　If .FilterMode Then .ShowAllData　'　フィルター抽出状態を解除（全表示） 　　End With 　　Application.CutCopyMode = 0　'　コピーモード解除 　　Application.ScreenUpdating = True　'　Excelの描画再開 End Sub ' ' ///
　いいえ、VLOOKUP関数とCOUNTIF関数のどちらも曖昧検索を行う事が出来ます。 　VLOOKUP関数とCOUNTIF関数は全く異なる機能を持った関数です。 　VLOOKUP関数は =VLOOKUP(検索値,範囲,列位置,検索の型) という形式で記述する関数で、「範囲」の所で指定されているセル範囲の中で、最も左端にある1列の中から、「検索値」の所で指定されている値を検索し、その検索値と同じ値が存在している行と同じ行で、「範囲」の所で指定されているセル範囲の中で左から数えて「『列位置』の所で指定した数」番目の列の所にあるセルに入っている値を返す関数です。 　尚、[,検索の型]の所をその直前の所にある「,」も含めて省略して =VLOOKUP(検索値,範囲,列位置) という形式で記述するか、或いは「検索値」の所に TRUE か或いは数値の 1 を記入しておきますと、下から順番に検索して行った際に「『検索値以下の値』が最初に現れた行(上から順番に見て行った場合には、「検索値以下の値」が入っているセルがある最後の行)と同じ行」で、「範囲」の所で指定されているセル範囲の中で左から数えて「『列位置』の所で指定した数」番目の列の所にあるセルに入っている値が返されます。 　因みに、「範囲」の所で指定されているセル範囲の中で最も左端にある1列の中に、(空欄以外の)「検索値以下の値」を持つセルが存在していなかった場合には#N/Aエラーとなります。 　一方、「検索の型」の所に FALSE か或いは数値の 0 を記入しておきますと、「検索値」の所で指定されている値と完全に同じ値のセルが存在する行で、「範囲」の所で指定されているセル範囲の中で左から数えて「『列位置』の所で指定した数」番目の列の所にあるセルに入っている値が返されます。 (但し、この場合の「完全に同じ」とは、「以上」や「以下」といった関係にある値は検索しないという意味であって、ワイルドカードを使用した曖昧検索は可能です) 　因みに、「範囲」の所で指定されているセル範囲の中で最も左端にある1列の中に、「検索値」の所で指定されている値と完全に同じ値のセルが存在していなかった場合には#N/Aエラーとなります。 【参考URL】 　よねさんのWordとExcelの小部屋 > エクセル関数一覧表 > VLOOKUP 　　http://www.eurus.dti.ne.jp/~yoneyama/Excel/kansu/vlookup2.htm 　それに対しCOUNTIF関数は =COUNTIF(範囲,検索条件) という形式で記述する関数で、「範囲」の所で指定されているセル範囲の中に、「検索条件」の所で指定されている値と同じ値を持つセルが幾つあるのかをカウントした結果を返す関数です。 【参考URL】 　よねさんのWordとExcelの小部屋 > エクセル関数一覧表 > COUNTIF 　　http://www.eurus.dti.ne.jp/~yoneyama/Excel/kansu/countif.htm#countif
＞アドレスを分類別に分けたもの これは「カテゴリ」でのグループ分けのことですね？ であれば、作成画面の「宛先」から、そのカテゴリーを追加すると「＋カテゴリー名」と入ると思います。 で、＋をクリックすると、個々の表示名表示（区切りは;）になると思いますが、ここではWindowsの仕様である表示名の文字コードの順（数字、アルファベット、・・・の順）になるようですね。 順番を気にされるとなると、ここで、移動したい方の表示名の右にある;の直後に、カーソルが置けるので、左にドラッグして選択→右クリック→切り取り、入れたい位置にカーソルを出して、右クリック→貼り付け（又はCtrl＋V）の方法で、揃えるしかないと思います。 受信した方のメールソフトなどによっては、受信メールで順が逆になることもあるので、どうかな？とは思います。
こんにちは 範囲指定（合計は除く）して、挿入、グラフ、縦棒（積み上げ縦棒） 出来たグラフを観後クリックして、データソースの選択で、 行/列の切り替えをクリック で。
　以下の様に操作して、A列のセルとB列のセルに入力規則を設定して下さい。 A1セルを右クリック 　　↓ 現れた選択肢の中にある[セルの書式設定]をクリック 　　↓ 現れた「セルの書式設定」ダイアログボックスの[表示形式]タブをクリック 　　↓ 現れた「分類」欄の中にある[ユーザー定義]をクリック 　　↓ 現れた「種類」欄に 0000 と入力 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ Excelウィンドウの上の方にある[データ]タブをクリック 　　↓ 現れた「データツール」グループの中にある[データの入力規則]ボタンをクリック 　　↓ 現れた選択肢の中にある[データの入力規則]をクリック 　　↓ 現れた「データの入力規則」ダイアログボックスの[設定]タブをクリック 　　↓ 現れた「入力値の種類」欄をクリック 　　↓ 現れた選択肢の中にある[リスト]をクリック 　　↓ 現れた「元の値」欄に 0120,0570,0800 と入力 　　↓ 「データの入力規則」ダイアログボックスの[OK]ボタンをクリック 　　↓ B1セルを右クリック 　　↓ 現れた選択肢の中にある[セルの書式設定]をクリック 　　↓ 現れた「セルの書式設定」ダイアログボックスの[表示形式]タブをクリック 　　↓ 現れた「分類」欄の中にある[文字列]をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「データツール」グループの中にある[データの入力規則]ボタンをクリック 　　↓ 現れた選択肢の中にある[データの入力規則]をクリック 　　↓ 現れた「データの入力規則」ダイアログボックスの[設定]タブをクリック 　　↓ 現れた「入力値の種類」欄をクリック 　　↓ 現れた選択肢の中にある[ユーザー設定]をクリック 　　↓ 現れた「数式」欄に =AND($A1<>"",ISNUMBER(B1+0),LEN(B1)=6+($A1=800)) と入力 　　↓ [空白を無視する]と記されている箇所をクリックしてチェックを外す 　　↓ 「データの入力規則」ダイアログボックスの[OK]ボタンをクリック 　以上です。
>初めに私もそう思い、マクロの記録でやってみたのですが、うまくいきませんでした。 試してみましたが、マクロの記録でテーブルを取り込むことが できました。 生成されたコードをそちらの環境に合せて修正しました。 Sub Macro1() ' ' Macro1 Macro ' ' With ActiveSheet.ListObjects.Add(SourceType:=0, Source:=Array( _ "OLEDB;Provider=Microsoft.ACE.OLEDB.12.0;Password="""";User ID=Admin;Data Source=\\192.168.11.200\abc\共有ファイル\A1.accdb;Mode=Share Deny Wr" _ , _ "ite;Extended Properties="""";Jet OLEDB:System database="""";Jet OLEDB:Registry Path="""";Jet OLEDB:Database Password="""";Jet OLEDB:Engi" _ , _ "ne Type=6;Jet OLEDB:Database Locking Mode=0;Jet OLEDB:Global Partial Bulk Ops=2;Jet OLEDB:Global Bulk Transactions=1;Jet OLEDB:N" _ , _ "ew Database Password="""";Jet OLEDB:Create System Database=False;Jet OLEDB:Encrypt Database=False;Jet OLEDB:Don't Copy Locale on C" _ , _ "ompact=False;Jet OLEDB:Compact Without Replica Repair=False;Jet OLEDB:SFP=False;Jet OLEDB:Support Complex Data=False;Jet OLEDB:B" _ , "ypass UserInfo Validation=False"), Destination:=Range("$A$1")).QueryTable .CommandType = xlCmdTable .CommandText = Array("テーブル1") .RowNumbers = False .FillAdjacentFormulas = False .PreserveFormatting = True .RefreshOnFileOpen = False .BackgroundQuery = True .RefreshStyle = xlInsertDeleteCells .SavePassword = False .SaveData = True .AdjustColumnWidth = True .RefreshPeriod = 0 .PreserveColumnInfo = True .SourceDataFile = "\\192.168.11.200\abc\共有ファイル\A1.accdb" .ListObject.DisplayName = "テーブル_A1.accdb" .Refresh BackgroundQuery:=False End With End Sub
こんにちは No1です。 「なし」にした後に、ピボットテーブルの更新を忘れずに。
こちらをどうぞ（複数条件） 　↓↓↓ http://www.becoolusers.com/excel/countifs.html
No.2 です。 早とちりです。すみません。 ただしくはこちら =EXP(LN(300/55.67)/0.4896)
17MBもあるので、逆にしてみたら？ 17MB側をコピーして別名で作成し、そこへ貼り付け先のシートを 複写したら如何でしょうか？
私は好きですね。 表計算ソフトは、ＤＯＳ版の『マルチプラン』で覚えましたので、Ａ１形式よりも馴染みがあります。 好む理由は、セルの指定が簡単であること。 現在のセル位置よりも｛＋｝方向なのか、｛－｝方向なのかを指定すればいいので計算が楽です。（相対指定） セル番号を明言すれば、絶対指定となります。 例えば、 現在位置よりも２列前のセル　ＲＣ［－２］ 現在位置よりも２行次のセル　Ｒ［＋２］Ｃ このセル限定　Ｒ４Ｃ３ 計算は、Ａ１形式と変わりません。
こんにちは コードお借りすると、 Sub file_open() 　　Dim f_fmt As String, i As Integer '設定============== 　　Const dpath As String = "C:\Users\Documents\" 　　Const adr As String = "A1" 　　Const adr1 As String = "A2" 　　Const st As String = "シートA" 　　f_fmt = "#<NO>\シート選択#<NO1>.xlsm" '================== 　　If Len(Range(adr).Value) = 0 Then MsgBox "セルＡ1入力されていません": Exit Sub 　　If Len(Range(adr1).Value) = 0 Then MsgBox "セルＡ2入力されていません": Exit Sub 　　f_fmt = dpath & Replace(f_fmt, "<NO>", Range(adr).Value) 　　f_fmt = dpath & Replace(f_fmt, "<NO1>", Range(adr1).Value) 　　If Dir(f_fmt) = "" Then MsgBox "ヒットするNo.がありません": Exit Sub 　　Workbooks.Open Filename:=f_fmt 　　For i = 1 To Worksheets.Count 　　　　If Worksheets(i).Name = st Then 　　　　　　Worksheets(i).Activate 　　　　　　Exit Sub 　　　　End If 　　Next i 　　MsgBox "ワークブック """ & Dir(f_fmt) & """ に、ワークシート """ & st & """ が見つかりません" End Sub こんな感じでしょうか？
　COUNTIF関数は「複数のシートを跨いでいる範囲」をカウント対象の範囲とする事は出来ませんから、一例としては次の様な関数にして下さい。 =SUMPRODUCT(COUNTIF(INDIRECT({"Sheet1","Sheet2","Sheet3","Sheet4","Sheet5","Sheet6","Sheet7","Sheet8"}&"!F16"),">0")*1)
　回答No.5です。 >これだけの長い式を全行に記載するのは数千行に及ぶと計算時間がかかるのではないかと心配です。 　現代のパソコンは高速ですので、Windows 7 Home Premium　SP1　 64ビットオペレーティングシステムが使える様な32bitパソコンであれば、配列数式の様な繰り返し計算を行う様な箇所が何箇所もあるというのであれば兎も角、その様な繰り返しを必要としない処理で、数千行行程度のデータを扱う際に処理が重くなる事を心配する必要は殆ど無いと思います。(多分ですが、数千行程度なら、例え配列数式でも大して重くはならないと思います) 　それに、特に処理が重くなるのは配列数式やSUMPRODUCT関数などの繰り返し処理を(広いセル範囲を繰り返し処理の対象にして)行う場合ですし、その次に重くなりがちなのはMAX関数、MIN関数、RANK関数、LARGE関数、SMALL関数等の「基準となる値を範囲内の全ての値と比較する」という様な類の処理を行う関数ですが、今回の御質問内容の場合、その様な重くなりがちな処理を行う必要が御座いませんので、回答No.5には特に処理が重くなる様な関数を使用している箇所は御座いません。(確認はしておりませんが、おそらく他の方々が回答されている関数も、重くならないという点では同様な筈です) 　ですから、計算時間に関してはその様な心配は無用かと存じます。 　只、どうしても気になる様でしたら、作業列を用いる事で若干高速化を図る事は可能です。 　回答No.5では1個のセル内に入力した関数だけで処理の全てを済ませるために、「現在の日付以前の直近の誕生日が何日になるのか」という事を求める計算を、1つの関数内で2、3回計算し直すという無駄がどうしても生じてしまっていますので、どこか使用していない列を作業列として使用して、関数を使ってその列のセルに「現在の日付以前の直近の誕生日」を一旦、表示させる様にしておいた上で、そのセルの値を用いて「現在時刻における満年齢」を求める様にすれば、「『現在の日付以前の直近の誕生日』という1つの値を使用する必要が生じる度に計算をやり直す」などという無駄が無くなる分だけ、若干計算速度が上がる筈です。 　例えば、今仮に >R1C10 に「生年月日シリアル値」「12345」 >RC1 に「今日の年月日」例えば「2016/1/1」 >RC2 に「現在の時分」例えば　「10:30」 といった元データが入力されているのがSheet1のR2行目以下の行であり、Sheet2のC2列のセルとSheet2のR2C1セルを作業用のセルとして使用するものとします。 　その場合、まずSheet2のR2C1セルに次の関数を入力して下さい。 =IF(AND(Sheet1!R1C10>=1,Sheet1!R1C10<"9999/12/31"+0),Sheet1!R1C10,"") 　次に、Sheet2のR2C2セルに次の2つの関数の内のいずれか一方を入力して下さい。 =IF(COUNT(R2C1,Sheet1!RC1,Sheet1!RC2)=3,IF(AND(Sheet1!RC1>1,Sheet1!RC1<"9999/12/31"+0,MOD(Sheet1!RC1,1)=0,Sheet1!RC2>=0,Sheet1!RC2<1,SUM(Sheet1!RC1,Sheet1!RC2)>=R2C1),DATE(YEAR(Sheet1!RC1)-(Sheet1!RC1<DATE(YEAR(Sheet1!RC1),MONTH(R2C1),DAY(R2C1))),MONTH(R2C1),DAY(R2C1)),""),"") 或いは =IF(COUNT(R2C1,Sheet1!RC1,Sheet1!RC2)=3,IF(AND(Sheet1!RC1>1,Sheet1!RC1<"9999/12/31"+0,MOD(Sheet1!RC1,1)=0,Sheet1!RC2>=0,Sheet1!RC2<1,SUM(Sheet1!RC1,Sheet1!RC2)>=R2C1),DATE(YEAR(Sheet1!RC1)-(TEXT(Sheet1!RC1,"""2000/""m/d")-TEXT(R2C1,"""2000/""m/d")<0),MONTH(R2C1),DAY(R2C1)),""),"") 　次に、Sheet2のR2C2セルをコピーしてSheet2のC2列の3行目以下に貼り付けて下さい。 　次に、Sheet1のR2C3セルに次の関数を入力して下さい。 =IF(COUNT(Sheet2!R2C1,Sheet2!RC2)=2,YEAR(Sheet2!RC2)-YEAR(Sheet2!R2C1)+(RC1+RC2-Sheet2!RC2)/(365+ISNUMBER((YEAR(Sheet2!RC2)&"/2/29")+0)),"") 　次に、Sheet1のR2C3セルをコピーしてSheet1のC3列の3行目以下に貼り付けて下さい。 　以上です。
Excel2013では、作成したピボットテーブルレポートの中のセルを選んだ状態で ピボットテーブルツールの分析タブの中にある「データソースの変更▼」から テーブルまたは範囲を選択で範囲を付け替えます。
　 １月１日は０ １月末日は、任意の値（３５０など） ２月１日は０ ２月末日は、任意の値（７６０など） その通りの値でグラフを書けばよいです
　回答No.3です。 　申し訳御座いません。 　回答No.3のB2セルに入力する関数において、参照先のセルの1つを間違えておりました。 　ですから、B2セルに入力する関数を以下の様に変更して下さい。 × =IF(ISNUMBER(INDEX($A:$A,ROW())),IF(AND(INDEX($A:$A,ROW())=INDEX($A:$A,ROW()-1),MOD(ROW()-1,$F$3)),INDEX(B:B,ROW()-1)+1,1),"") 　　　↓ 〇 =IF(ISNUMBER(INDEX($A:$A,ROW())),IF(AND(INDEX($A:$A,ROW())=INDEX($A:$A,ROW()-1),MOD(ROW()-1,$F$2)),INDEX(B:B,ROW()-1)+1,1),"")
引数の指定が間違えてます。COUNTIF(範囲,条件)なので =COUNTIF($D$3:$D$303,B4) ですね。
#2さんの回答をみて、大昔に回答した事を思い出しました。 http://okwave.jp/qa/q3558298.html さすがに中のリンクは切れていますが、Vectorを覗いてみると、今でも何種類かは存在していました。例えば「グラフ読み取り」で検索してみて下さい。 前提として、画像データに変換する（簡便には画面コピー）とか、更にエクセルのワークシートに貼り付けるといった処置が必要です。 ワークシートに貼り付けたグラフ（画像）上にターゲットマークを置いて座標を読み取るマクロの場合、フローチャート用の丸の中に×印がある図形が適当と思います。（塗り潰し無しにして線を細くして用いる）この場合、座標変換は自分で作り込む必要があります。 ご参考まで。
F1: =(COLUMN(A1)<=($C1-$B1)/"0:15")
こんにちは Sub RedHat() 　　Dim objIE As InternetExplorer 　　Dim urlName As String 　　 　　Set objIE = CreateObject("InternetExplorer.Application") 　　 　　objIE.Visible = True 　　 　　Call ieView(objIE, "https://idp.redhat.com/idp") 　　 　　If objIE.LocationURL <> "https://idp.redhat.com/idp/" Then 　　　　Call ieNavi(objIE, "https://www.redhat.com/wapps/ugc/protected/account.html") 　　　　Call tagClick(objIE, "li", "utility-account") 　　　　Call tagClick(objIE, "p", "ログアウト") 　　　　Call ieNavi(objIE, "https://idp.redhat.com/idp") 　　End If 　　 　　Call formText(objIE, "j_username", "丸秘") 　　Call formText(objIE, "j_password", "丸秘") 　　Call tagClick(objIE, "button", "ログイン") 　　 　　Set objIE = Nothing End Sub こうすると、どうなりますか？
こんにちは Sub Sample10() 　　Dim p As Variant 　　With Application.FileDialog(msoFileDialogFolderPicker) 　　　　If .Show = True Then 　　　　　　p = .SelectedItems(1) 　　　　End If 　　End With 　　If IsEmpty(p) Then Exit Sub 　　Call FileSearch(p) End Sub 別件ですが、 FileSearch というプロシージャ名は変更した方がいいかも。
エクセルのオプションの数式欄で「ピボットテーブル参照にGetPivotData関数を使用する」のチェックを外します。
どこが上手く行かないか書かないとまともに回答してもらえませんよ。 セルから情報を取り出すのにつまづいているのか、AddShapeの引数が分からないのか、shapeにテキストを設定できないのか、ループにつまづいているのか、いったい何なのでしょうか？ Dim r As Range Dim shp As Shape For Each r In ActiveSheet.UsedRange.Rows If r.Cells(1, 1) = "" Then Exit For Set shp = ActiveSheet.Shapes.AddShape(msoShapeRectangle, r.Cells(1, 1) * 100, 100, r.Cells(1, 3), r.Cells(1, 4)) shp.TextFrame.Characters.Text = r.Cells(1, 2) shp.TextFrame.HorizontalAlignment = xlCenter shp.TextFrame.VerticalAlignment = xlCenter Next
こんにちは 「ページ1で四半期毎に表示させ、ページ2で上期下期毎に表示させる」 と書いておきました。 「フィールド1では四半期 1～4、フィールド2では前期、後期と名前を付ければ、 1/4単位、1/2単位で集計ができる」 で、合っています。 「ただ、絶対に必要なものでもないと思いました」 だと、思います。 「複数のワークシートをピボットテーブルで統合する」事が今まで無かったのですが、 集計したい表を事前に想定して、元データを一元管理するようにしていれば、不要 だと思います。 そのデータを元に普通にピボットテーブルで集計した方が便利だと思います。
こんにちは 　　Set k = s1.Range("A1:C1") '項目セル範囲 　　Set n = s1.Range("D1:F1") '年度セル範囲 を 　　On Error Resume Next 　　Set k = Application.InputBox("項目セル範囲を選択して下さい。", , , , , , , 8) 　　Set n = Application.InputBox("年度セル範囲を選択して下さい。", , , , , , , 8) 　　If k Is Nothing Or n Is Nothing Then Exit Sub 　　On Error GoTo 0 に変更して下さい。
A20に=A10&"円"と入力してみてはどうですか？
こんにちは 別の画面とは、別のユーザーフォームの事ですか？ UserForm1のCommandButton1から、 Private Sub CommandButton1_Click() 　　UserForm2.Show End Sub とかで、表示出来ませんか？ 別件ですけど、希望する処理に別のユーザーフォームが良いのか タブ等で対処するのがいいのか等、良く検討した方がいいですよ。 ただ、ユーザーフォームが作りたいからユーザーフォームを使うのか、 ユーザーフォームでなくてもシート上のフォーム、コントロールで 対処したほうが良いのかとかも。
こんにちは。 ソースの概要（条件と具体的な処理内容）と最終的な出力方法 が判らないと何とも言えない面もありますが、 差し当たり需要がありそうな処理例で４例挙げてみます。 私の第一感では、/// j あたりのことをお求めなのかな？と思いましたが、 他の例も理解した上で目的に照らして使い分けて頂ければ、と。 例えば、/// a と /// j では、 数値なのか数字（文字列）なのか、どちらにも容易に切り替え可能です。 Split()関数に拘らずにArray()関数を使うなら、/// b と /// b でも 同様に扱えます。 ただ、区切り文字を挟んで連結された文字列がソースになる処理って 需要が多いですから、Split()関数じゃないと困る？こともあろうかと。 最終的には 　matrix(1 To 5, 1 To 2) というサイズの二次元配列を扱うように書いていますが、 X方向のサイズ「2」が固定でない場合は、工夫が必要です。 具体的な条件を説明できるようでしたら、補足してみて下さい。 ' ' /// a ' ' 予め定義した二次元配列に直接格納する場合 Sub ReW9109291a() Dim matrix() As Variant Dim nYSize As Long Dim i As Long Dim j As Long 　nYSize = 5 　ReDim matrix(1 To nYSize, 1 To 2) 　' ' 二次元配列に直接格納する 　For i = 1 To nYSize '　　matrix(i, 1) = i　'　option 1/2 数値として扱う場合 　　matrix(i, 1) = CStr(i)　'　option 2/2 数字文字列値として扱う場合 　　matrix(i, 2) = Chr$(64 + i) 　Next i 　' ' 二次元配列の全要素をイミディエイトウィンドウに出力 　For i = LBound(matrix) To UBound(matrix) 　　Debug.? "-"; i; "-", 　　For j = LBound(matrix, 2) To UBound(matrix, 2) 　　　Debug.? matrix(i, j), 　　Next j 　　Debug.? 　Next i 　' ' デバッグ・トレース 　Stop　'　ローカルウィンドウで変数の中身を（構造と要素について）確認 　' ' 確認が済んだら［中断（デバッグ）モード］を［F5キー］で抜けて、以下を実行 　' ' 出力例　セル範囲に出力 　With Cells(1).Resize(UBound(matrix), UBound(matrix, 2)) 　　.NumberFormat = "@"　'　option 数字（文字列）として扱う場合 　　.Value = matrix() 　End With End Sub ' ' /// b ' '　Split()を使う例：二段配列（ジャグ配列） （数字（文字列）として扱う場合） Sub ReW9109291b() Dim matrix As Variant Dim nYSize As Long Dim i As Long Dim j As Long 　nYSize = 5 　ReDim matrix(1 To nYSize) 　' ' 連結文字列を取得（作成）して、一次元配列に格納 　For i = 1 To nYSize '　　matrix(i) = i & "," & chr$(64 + i) 　　matrix(i) = CStr(i) & "," & Chr$(64 + i)　'　省略せずに書く場合 　Next i 　' ' 一次元配列に格納された連結文字列をSplit()関数で一次元配列にして、 　' ' 一次元配列の要素が一次元配列である二段配列（ジャグ配列）として配列を書き換える 　For i = 1 To nYSize 　　matrix(i) = Split(matrix(i), ",") 　Next i 　' ' 二段配列の全要素をイミディエイトウィンドウに出力 　For i = LBound(matrix) To UBound(matrix) 　　Debug.? "-"; i; "-", 　　For j = LBound(matrix(i)) To UBound(matrix(i)) 　　　Debug.? matrix(i)(j), 　　Next j 　　Debug.? 　Next i 　Stop 　' ' 出力例 　' ' 一次元配列の要素が一次元配列である二段配列（ジャグ配列）を二次元配列に変換 　matrix = Application.Transpose(Application.Transpose(matrix)) 　With Cells(1).Resize(UBound(matrix), UBound(matrix, 2)) 　　.NumberFormat = "@"　'　option 数字文字列値 　　.Value = matrix 　End With End Sub ' ' /// c ' ' Split()を使う例：各行ごとに連結文字列を一旦一次元配列に格納しておいて、二次元配列に変換 (数字文字列値として扱う場合) Sub ReW9109291c() Dim ary() As String Dim matrix() As Variant Dim tmp As Variant Dim nYSize As Long Dim i As Long Dim j As Long 　nYSize = 5 　ReDim ary(1 To nYSize) 　' ' 一次元配列に連結文字列を格納する 　For i = 1 To nYSize 　　ary(i) = CStr(i) & "," & Chr$(64 + i) 　Next i 　ReDim matrix(1 To nYSize, 1 To 2) 　' ' 一次元配列の要素である連結文字列をSplit()関数で配列として分けてから二次元配列に格納する 　For i = 1 To nYSize 　　tmp = Split(ary(i), ",") 　　For j = 1 To 2 　　　matrix(i, j) = tmp(j - 1) 　　Next j 　Next i 　' ' 二次元配列の全要素をイミディエイトウィンドウに出力 　For i = LBound(matrix) To UBound(matrix) 　　Debug.? "-"; i; "-", 　　For j = LBound(matrix, 2) To UBound(matrix, 2) 　　　Debug.? matrix(i, j), 　　Next j 　　Debug.? 　Next i 　Stop 　' ' 出力例 　With Cells(1).Resize(UBound(matrix), UBound(matrix, 2)) 　　.NumberFormat = "@"　'　option 数字（文字列） 　　.Value = matrix() 　End With End Sub ' ' /// j ' ' 格納する文字列を連結しながら文字列変数に格納してEvalateメソッドでダイレクトに二次元配列にする例 Sub ReW9109291j() Dim matrix As Variant Dim buf As String Dim nYSize As Long Dim i As Long Dim j As Long 　nYSize = 5 　' ' 文字列を連結して文字列型変数に格納 　For i = 1 To nYSize '　　buf = buf & ";" & i & "," & """" & chr$(64 + i) & """"　'　option 1/2 数値 　　buf = buf & ";" & """" & i & """" & "," & """" & Chr$(64 + i) & """"　'　option 2/2 数字文字列値 　Next i 　' ' 連結文字列をExcel数式の配列表記として整形 　buf = "{" & Mid$(buf, 2) & "}" 　Debug.? "Excel数式：　"; buf 　' ' Evaluateメソッドで、二次元配列を取得 　matrix = Application.Evaluate(buf) 　' ' 二次元配列の全要素をイミディエイトウィンドウに出力 　For i = LBound(matrix) To UBound(matrix) 　　Debug.? "-"; i; "-", 　　For j = LBound(matrix, 2) To UBound(matrix, 2) 　　　Debug.? matrix(i, j), 　　Next j 　　Debug.? 　Next i 　Stop 　' ' 出力例 　With Cells(1).Resize(UBound(matrix), UBound(matrix, 2)) 　　.NumberFormat = "@"　'　option 数字文字列値 　　.Value = matrix 　End With End Sub ' ' ///
>(1)セルA1に年を設定し、A2に月を設定する 手入力ですね？ >(2)=DATE（$A$1,$A&2,1～31）で、日付を出す 1日のセル位置と日付の数式を設定するセル範囲が明確ではありません。 推測ですがA3=1日、A4=2日、・・・・、A33=31日と言うことですか？ >(4)　(2)の日付の横のセルに=TEXT(WEEKDAY((2)のセル,1),"aaa")で曜日を表示 曜日はB3～B33でよろしいでしょうか？ >これを、その月の月末の日付までしか表示しないようにしたいです。 A3=IF(DATE($A$1,$A$2,ROWS(A$3:A3))>EOMONTH(DATE($A$1,$A$2,1),0),"",DATE($A$1,$A$2,ROWS(A$3:A3))) B3=A3 としてA3とB3を下へ33行目までコピーしてください。 A3～A33セルの書式はユーザー定義「d」で良いですがB3～B33はユーザー定義「"aaa"」にします。 B3～B33は日付のシリアル値ですが表示形式で曜日を指定すればTEXT関数で文字列に変換する必要はありません。
ご質問の直接の回答としては、 =B2 & IF(C2="",""," ")&C2 & IF(D2="",""," "&D2) のように組み立てることができます。式中で使っている、Ｃ２とＤ２の２つのパターンのどちらでもＯＫな事を確認してみて下さい。 一般論としてはIF関数じゃなく、既出回答で寄せられているようにTRIM関数を使った方が簡単です。 =TRIM(B2&" "&C2&" "&D2) =TRIM(CONCATENATE(B2," ",C2," ",D2)) （Ｃ２や）Ｄ２が空白だったときに、結果の値が 「Ｂ２やＣ２の値と□」（□はスペース） のように、後ろに余計なスペースが１個付いて残ってしまっているみたいな結果にならないよう、注意もしてください。
「かなり初心者」の貴方には失礼ながら、“超”初心者向けの説明でご勘弁願いたく。 １．セル A3 を選択 ２．[ホーム]タブ→[スタイル]リボン→[条件付き書式]コマンド→[新しいルール] ３．上段窓内で“数式を…”を選択 ３．下段窓内に次式を入力 　　　=AND(A1>="8:0"*1,A1<="17:0"*1,A2>="17:0"*1,A2<="24:0"*1) ４．下端右の[書式]をチョーン ５．[塗りつぶし]タブをチョーン→赤パレットをツン→[OK]]をツン、ツン
当該のフォルダの名前をちょこっと変更してからエクセルを起動します。 オプションの詳細設定で設定を消去してください。
集計期間内に該当が無いときは空欄にすることを考慮すれば次の数式で良いと思います。 =IF(COUNTIFS(Sheet1!$D:$D,"<="&$E$3,Sheet1!$B:$B,$D$3,Sheet1!$A:$A,A2),SUMIFS(Sheet3!$B:$B,Sheet1!$A:$A,$A2,Sheet1!$B:$B,">="&$D$3,Sheet1!$D:$D,"<="&$E$3),"") 複雑すぎる数式を理解せずに応用することは混乱の元です。 データの信頼性を再確認し、余分なチェック項目を排除して数式を簡素化するも検討された方が良いでしょう。
#1,2です。 >（DPI）を１３５％にしてwindowsの文字の大きさを変更していたのが原因のようです。文字の大きさを変更しても正常に表示できるようにすることは可能でしょうか？ そこまでお分かりならご自分で対応されてはどうかと思いますが、DPI、PPIを決め打ちでは無くて環境から取得する様にしてみました。例によって右クリックの事例です。 なお、DPIは縦横別々に取得出来ますが、簡便にX方向の値を採用しています。 Private Type POINTAPI X As Long Y As Long End Type Private Declare Function GetCursorPos Lib "User32" (lpPoint As POINTAPI) As Long Private Declare Function GetDC Lib "User32.dll" (ByVal hWnd As Long) As Long Private Declare Function ReleaseDC Lib "User32.dll" (ByVal hWnd As Long, _ ByVal hdc As Long) As Long Private Declare Function GetDeviceCaps Lib "gdi32.dll" (ByVal hdc As Long, _ ByVal nIndex As Long) As Long Dim PPI As Long, DPI As Long Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean) Dim myMousePt As POINTAPI Cancel = True PPI = GetPPI DPI = GetDPI GetCursorPos myMousePt MsgBox screenToCellAddress(myMousePt) End Sub Private Function GetPPI() As Long GetPPI = Application.InchesToPoints(1) End Function Private Function GetDPI() As Long Dim hdc As Long 'X方向のDPIを採用 Const LOGPIXELSX = 88 hdc = GetDC(Application.hWnd) GetDPI = GetDeviceCaps(hdc, LOGPIXELSX) Call ReleaseDC(&H0, hdc) End Function 'ワークシート上のクリックより得られたスクリーン座標をセル座標に変換する Private Function screenToCellAddress(scrnPOINT As POINTAPI) As String Dim pointDifX As Single, pointDifY As Single Dim startX As Single, startY As Single Dim targetRange As Range Dim pointX As Single, pointY As Single Dim zoomX As Single, zoomY As Single Dim i As Long '左上隅セルの左上角との距離をポイントに変換 Call realZoomRate(zoomX, zoomY) pointDifX = (scrnPOINT.X - ActiveWindow.PointsToScreenPixelsX(0)) * PPI / DPI / zoomX pointDifY = (scrnPOINT.Y - ActiveWindow.PointsToScreenPixelsY(0)) * PPI / DPI / zoomY startX = ActiveWindow.VisibleRange(1).Left startY = ActiveWindow.VisibleRange(1).Top Set targetRange = ActiveWindow.VisibleRange(1) For i = 1 To ActiveWindow.VisibleRange(1).Column pointX = pointX + targetRange.Width Next i For i = 1 To ActiveWindow.VisibleRange(1).Row pointY = pointY + targetRange.Height Next i Do Until pointX > pointDifX Set targetRange = targetRange.Offset(0, 1) pointX = pointX + targetRange.Width Loop Do Until pointY > pointDifY Set targetRange = targetRange.Offset(1, 0) pointY = pointY + targetRange.Height Loop screenToCellAddress = targetRange.Address End Function '真のズーム倍率を求める 'by kanabunさん Private Sub realZoomRate(ByRef zoomX As Single, ByRef zoomY As Single) Dim c As Range Dim dotX As Long Dim dotY As Long Dim dotX1 As Long Dim dotY1 As Long Set c = Range("a1") With ActiveWindow ' ---------- 実際のZoom比の計算 --------------- dotY = c.Height * DPI / PPI dotY1 = dotY * .Zoom / 100 zoomY = dotY1 / dotY '実際に適用されているZoom率 dotX = c.Width * DPI / PPI dotX1 = dotX * .Zoom / 100 zoomX = dotX1 / dotX End With End Sub
以下のようにして下さい。 Sub 全角() Dim i As Long, buf As String Dim ac As Range For Each ac In Selection buf = "" For i = 1 To Len(ac.Value) If Mid(ac.Value, i, 1) Like "[ア-ン]" Then buf = buf & StrConv(Mid(ac.Value, i, 1), vbWide) Else buf = buf & Mid(ac.Value, i, 1) End If Next i ac.Value = buf Next ac End Sub プログラム内の「ア」と「ン」は半角カナに直して下さい。このサイトは半角カナを書くと勝手に全角カナに書き換えてしまいます（貴方の質問文も、勝手に全角カナに直されてしまっています）
「形式を選んで貼り付け」を使わずにコピーする方法はありますが、計算式を入れないという条件ですと右クリックを使わずに貼り付ける方法は無いかと思われます。 「Ctrl + Alt + V」で形式を選択して貼り付けをショートカットで呼び出し、「V」で値を選択し、Enterキーで決定する方法が早いとは思いますが、もっと早い方法があり、対象セルG4の境目にマウスカーソルを合わせると上下左右の矢印アイコンが出ると思いますのでその状態で右クリックでドラッグし、コピー先セルG9でドロップすると自動的にメニューが表示されますので、メニューが表示されたらキーボードの「V」キーを押すと値のみをコピーする事が出来ます。 それ以外の方法ですと、式を使う方法でG９セルに「=G4」と入れるかG4の式を「$C$4 + $E$4」で固定し、コピー貼り付けを行っても式の参照セルがずれないようにするしかないかと思います。 以上宜しくお願い致します。
右クリックして「コピー」で画像保存されるので、画像ソフトを開いて「貼り付け」ればOK
vlookupは検索元データの左側に作業列が無いといけませんが、index　matchでは右側に検索データがあっても構いません。 sheet1 C列を作業列 C1式 =IF(A1="○",ROW(),"") sheet2　A1式 =IFERROR(INDEX(Sheet1!A:A,MATCH(SMALL(Sheet1!$C:$C,ROW(A1)),Sheet1!$C:$C,0)),"") A１をB1にコピー A1~B1を下方へオートフィル。 データが無い場合は空白を返すので、想定より多いセル範囲に数式をコピーしておけば、sheet1のデータが修正されても追随します。
>今日の曜日の「文字列」が含まれているセル の範囲が、例えばA2:A9のセル範囲であるものとした場合には以下の様な設定方法となります。 A2セルを選択 　　↓ Excelウィンドウの[ホーム]タブをクリック 　　↓ 現れた「スタイル」グループの中にある[条件付き書式]ボタンをクリック 　　↓ 現れた選択肢の中にある[ルールの管理]をクリック 　　↓ 現れた「条件付き書式ルールの管理」ダイアログボックスの中にある[新規ルール]ボタンをクリック 　　↓ 現れた「新しい書式ルール」ダイアログボックスの「ルールの種類を選択して下さい」欄の中にある[数式を使用して、書式設定するセルを決定]をクリック 　　↓ 現れた「次の数式を満たす場合に値を書式設定」欄の中に =FIND(TEXT(TODAY(),"aaa"),A2) と入力 　　↓ 「新しい書式ルール」ダイアログボックスの[書式]ボタンをクリック 　　↓ 現れた「セルの書式設定」ダイアログボックスの[塗りつぶし]タブをクリック 　　↓ 現れた背景色のサンプルの中から、セルを塗りつぶしたい色の四角形をクリック 　　↓ 「セルの書式設定」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「新しい書式ルール」ダイアログボックスの[OK]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの「適用先」欄を2箇所とも $A$2:$A$9 に変更（カーソルとマウスの左ボタンによる範囲選択が使えます） 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[適用]ボタンをクリック 　　↓ 「条件付き書式ルールの管理」ダイアログボックスの[OK]ボタンをクリック
B1式 =LEFT(A1,FIND("/",A1)-1)/MID(A1,FIND("/",A1)+1,LEN(A1)-FIND("/",A1)-4)*25.4 A列が半角英数字である事が前提です。 端数処理をしていませんので、round関数等で有効桁数の調整をして下さい。 FIND("/",A1)-1で/の位置を取得します。-1はスラッシュの前までが必要なので引いています。 LEN(A1)-FIND("/",A1)-4は LEN(A1)でA1の文字数取得 FIND("/",A1でスラッシュまでの文字数 -4はinchの文字数 文字数からスラッシュまでの文字数と4文字引いた数値が分母の桁数となり、MID関数の取得文字数の指定値としています。
>開いているbookを含むファイルは1ファイルのみです。 という条件なのでしたら、 Sub QNo9106515_マクロ_別のブックを指定() Dim wb As Workbook For Each wb In Workbooks If wb.Name Like "Book*" Then wb.Activate Exit For End If Next wb Range("A10").Select End Sub 或いは、 Sub QNo9106515_マクロ_別のブックを指定2() Dim wb As Workbook, myBookName As String For Each wb In Workbooks myBookName = wb.Name If myBookName Like "Book*" Then Exit For Next wb Windows(myBookName).Activate Range("A10").Select End Sub
＞作業枠の色の選択が、白、灰色、濃い灰色 これは、オプションの「officeのテーマ」の選択肢ですよね。 それは３つしかないですし、「ページレイアウト」タブの「テーマ」グループの配色などは挿入した図形などの初期色を変更するだけのようです。 ＞EXCELの背景色(目の疲れにも重要) この背景色は、入力スペースの全体の背景色（Wordであれば、「ページの色」に当たる？）ということであれば、「ページレイアウト」タブの「ページ設定」グループの「背景」メニューから入手できる画像※を挿入することで、例えば、薄い灰色など目に優しい背景色にすることはできます。 ※ペイントでも作成できますが、適当な大きさの単色画像ファイルを作成しておいて、それを読み込むと背景全体に反映されて、「背景」メニューは「背景の削除」に変わります。 以上、趣旨違いでしょうか・・。
>それとも2ページ目に何らかのデーターがあるのでしょうか？ 　その様な可能性もありますが、それ以外の事が原因である可能性もあります。 　例えば、印刷範囲の設定によって、印刷すべきセル範囲が指定されていた場合において、もし印刷範囲の中で最も右端にある列の「その列の右端の枠線」や、印刷範囲の中で最も下にある行の「その行の下端の枠線」が2ページ目にはみ出していた場合、例えその部分に何も入力されていなかったとしても2ページ目が印刷されてしまう事になります。 　ですから印刷範囲の設定で指定されているセル範囲を、1ページのみに収まるように設定をやり直してみられる事をお奨め致します。 【参考URL】 　よねさんのWordとExcelの小部屋 > エクセル2007基本講座 > 印刷範囲を設定する 　　http://www.eurus.dti.ne.jp/~yoneyama/Excel2007/excel2007-print2.html 　初心者のためのOffice講座 > Excel2003の目次 > 印刷範囲の設定 　　http://hamachan.info/excel/insatu-e.html
＞それら請求書の内容をシート２に記録保存していきたい そういうのはそもそも関数じゃありませんので、エクセルのオマケで付いてきた「データ追跡機能付きテンプレートウィザード」を使ってデータを蓄積していくことが出来ます。 下記にだいたいご相談と同じ内容で解説されているので、参考にしてください。 参考： http://kokodane.com/tec3_25.htm
エクセルのバージョンによりますが、以下の方法で分かるかな、と。 まずは該当のエクセルファイルを開いてください。 1.2007以前の場合 ファイル→名前を付けて保存 現在そのファイルを保存している保存先のフォルダ名が保存先として出てくるので、そのフォルダへ別のウィンドウを開いて遷移してください。 正しい保存先がでないときは、一旦上書き保存してから行ってみてください。 2.2007の場合 Officeボタン→配布準備→プロパティ→ ドキュメント情報パネル(ドキュメントのプロパティ)が開く→「情報」にあるパスを右クリック→ctrl+A→コピー→新規に開いたウィンドウへペースト→パスの内、最後に書かれている「￥エクセルファイル名．拡張子」を削除し、移動→あとはショートカットを作るだけです。 3.2010以降 ファイルタブ→情報→「○○(ファイル名)の情報」にあるパスを右クリックしてコピー→あとは2007の手順と同じ操作を、新規ウィンドウを開いて行います。 これでできなければサーバーにどんな風に保存されてるのか、等々詳細が要りますね。 でもその辺りってここで書くのはコンプライアンス違反になりませんか？ 出来ないときは、諦めて同僚や先輩に教えてもらってください。 分からないことをいつまでも留まって調べたり時間を浪費しまうよりは、聞いて効率よく時短するのも仕事のテクニックの内です♪
ＡＬＴ＋Ｆ１１でＶＢＥ画面を開き、挿入メニューから標準モジュールを挿入、下記をコピー貼り付ける sub macro1() selection.phonetics.visible = not selection.phonetics.visible end sub その後シートを保護、振り仮名の表示／非表示をしたいセル範囲を選び、マクロを実行する／マクロをクイックアクセスツールバーあるいはボタン、リボン等に登録して利用する。 ＞それでも、「ふりがなの表示／非表示」がグレーアウトしています。 背景の削除が操作出来なくなるのと同じで、シートを保護するとふりがなの表示／非表示も操作できません。
G2: =SUMPRODUCT((A$2:A$1000>=D$2)*(A$2:A$1000<=E$2)*(B$2:B$1000=F2))
ん？　 ＞平均値を求めたい なら回答した通りにSUMIFS関数の代わりにAVERAGEIFS関数をそのまま使ってください。
Ｊ６に =COUNTIFS(E:E,">="&H$4,E:E,"<"&EDATE(H$4,1),F:F,H6,D:D,I6) でいいです。
１．セル結合した範囲 D1:E1 内に 2016/1/1 を入力して、“ユーザー定義”で 　　yyyy"年"m"月"　　に書式設定 ２．セル E3 に次式を入力して、此れを下方にオートフィル 　　 =SUMPRODUCT((A$2:A$8>=D$1)*(A$2:A$8<=EOMONTH(D$1,0))*(B$2:B$8=D3)*1)
＼ 　Ｘ　　　Ｙ　　　Ｚ Ａ「Ｂ３」「Ｃ４」「Ｄ５」 Ｂ「Ｂ４」「Ｃ４」「Ｄ５」 Ｃ「Ｂ５」「Ｃ４」「Ｄ５」 「＝Ｂ３＊５００～」は、「Ｂ６」セルに入っていて、「下の表」というのが「Ａ７」に１番多い商品名、「Ａ８」に２番目の商品名、「Ａ９」に３番目。 「Ｂ７」にその１位の金額、「Ｂ８」に２位の、「Ｂ９」は３位、という前提条件で、 「Ｂ７」：「=Large(B6:D6, 1)」 「Ｂ８」：「=Large(B6:D6, 2)」 「Ｂ９」：「=Large(B6:D6, 3)」 「Ａ７」：「=Lookup(B7, B6:D6, B1:D1)」 「Ａ８」：「=Lookup(B8, B6:D6, B1:D1)」 「Ａ９」：「=Lookup(B9, B6:D6, B1:D1)」 と、それぞれ、入力してください。 「Large()」は範囲内から順位を導き出す関数です。
＞日曜日の日付を赤にしたいのです。（曜日の欄は赤になっています） ＞日付の「１月３日」という文字も赤色にしたいのです。 下記などを参考に自力で頑張ってみて下さい。 http://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=014384 元のご相談は「条件付き書式の出し方」についてです。 ＞ここから先が解らなくなりました。 新しいご質問は、このご相談投稿をしっかり解決で閉じてから、改めて「こんどはこういう状況でこういう事がしたい」とキチンと詳しい状況補足を添えて新しいご相談として投稿し直して下さい。 ちょこっと聞いてみたの手抜き追加ご質問ででよく見かける状況ですが、具体的にどこのセルに何を記入していて何がシタイのか、目に見える状況説明が何一つありません。
>Sheet3のA2では、IF関数の中で、COUNTIF関数が使われていますが、なんのためなのかわかりません。 　COUNTIF関数を使って、Sheet1のA2セルに入力されている値(科目)と同じ値を持つセルがSheet1のA1～A2の範囲に幾つ存在するかをカウントした場合、そのカウント結果が1となっていれば「その科目が最初に現れた行」である事が判りますので、IF関数と組み合わせる事により、カウント結果が1の場合にはその行の行番号を表示し、それ以外の場合には何も表示しない様にしておけば、各科目が最初に現れる行の行番号のみが表示されますので、後でSheet2のA列の関数を使って、現れている科目を、現れた順番通りに書き出す際に、関連のある行の行番号を拾い出す事が出来ます。 >Sheet3のB2セルには関数の中に">1904"と数値の1904より大きい値を指定する関数が組み込まれたいますが、なんのためか理解できていません。 　Excelでは日付をシリアル値を使用して取り扱っています。 【参考URL】 　エクセルの使い方を覚えよう > エクセルの使い方講座 > 1.シリアル値 　　http://exinfo.biz/lec/lec_serial.shtml 　シリアル値は、Excelの詳細設定を切り替える事で、数値の1を1901年1月1日とするモードと、数値の0を1904年1月1日とするモードに設定を切り替える事が出来るのですが、例えば数値の1を1901年1月1日とするモードでシリアル値が0.00002だった場合、日時の値は1900/1/0の0:00:01となってしまい、日付のデータとして正しく扱う事が出来ません。 　それを避けるためにISERROR関数とYEAR関数を組み合わせる事で、日付として扱う事が出来るかどうかを確認している訳ですが、単に、 ISERROR(YEAR(INDEX(Sheet1!$B:$B,ROW()))) としてしまっただけでは、前述の様にシリアル値が0.00002だった場合、日時の値は1900/1/0の0:00:01となりますので、YEAR関数の結果も1900年となってしまい、エラーとはなりませんから、単なる時刻データのみが入力されていた場合も、日付のデータが入力されているものと誤った判定結果が出てしまう恐れがあります。 　そのため、YEAR関数の結果が1905以上の場合に対してのみ計算を行う様に制限をかける事で、確実に日付データと言える場合にのみ計算を行う様にしている訳です。 　尚、">1901"としたのでは、数値の0を1904年1月1日とするモードだった場合で、尚且つ日付データではなく、時刻データが入力されていた場合には、YEAR関数の結果が1904年となってしまいますから、日付が入力されていると誤って判定してしまう場合が出て来てしまいますので良くありません。 　それならば、シリアル値が数値の1以上であるかどうかで判定させれば良いと思われるかも知れませんが、Excelでは9999年12月31日の23:59:59(シリアル値2957003.99998843)までしか日時のデータとして扱う事が出来ないため、2957004以上の値が入力されている場合に日付データではない事を判定出来る様にする必要がありますから、シリアル値が数値の1以上であるかどうかだけで判定する訳にもいかないのです。 >Sheet2のA2では、「Sheet2のA１：A２がSheet3のA列より大きい」という条件に適合しなかった場合、最小値を求める計算をしていますが、何のために行っているのかわかりません。 　その様な判定は行っておりません。 　行っているのは、「『Sheet2のA$1:A2のセル範囲に含まれている行数』が『Sheet3のA列の中で数値が入っているセルの個数』よりも大きい」という条件を満たさなかった場合、即ち、「『Sheet2のA$1:A2のセル範囲に含まれている行数』が『Sheet3のA列の中で数値が入っているセルの個数』以下」という条件を満たしている場合にのみ、「Sheet3のA列の中に入っている数値」を値の小さなものから順番に取り出して、その数値と同じ行番号の行のSheet1のA列の値を返すという処理です。 　SMALL関数を使用する際に、指定した範囲内に存在する数値データの個数よりも大きな数を、順位の値として指定してしまいますとエラーとなってしまうため、エラーを出さない様にするために「『Sheet2のA$1:A2のセル範囲に含まれている行数』が『Sheet3のA列の中で数値が入っているセルの個数』よりも大きい」という条件を満たさなかった場合にのみ処理を行う様にしている訳です。 >Sheet2のB2では、A2に適合しなかった場合、Sheet１のA列から何かを何かの条件に一致したものを合計して時間表示していますが、よくわかりません。 　Sheet2のA列に入力されている科目と同じ科目が、Sheet1のA列に入力されている行と同じ行番号の、Sheet3のB列の値のみを合計しています。 　Sheet3のB列には、「Sheet1のB列に入力されている日付とSheet1のC列に入力されている時刻の合計」(終了日時)から「Sheet1のD列に入力されている日付とSheet1のE列に入力されている時刻の合計」(開始日時)を差し引いた値が表示されています。
=IF(COUNTIF(A$2:A2,A2)>1,COUNTIF(A$2:A2,A2),"") または、 =IF(COUNTIF(A$2:A2,A2)<2,"",COUNTIF(A$2:A2,A2))
　回答No.4の続きです。 Private Sub QNo9104083_ファイル選択マクロで教えて下さい_コア部分(ByVal ParentPath _ As String, ByVal OriginPath As String, ByRef NoSheetFile As String, ByRef n As Integer) Const CopyFileName = "RawData" 'データのコピー元とするファイルのファイル名 Const CopyCells = "B1:B180" 'データのコピー元とするセル範囲 Const PasteCell = "F2" 'データの貼付先のセル範囲の内、左上の隅のセルのアドレス Const InitialWord = "pbs" '貼付先のシート名の先頭に付く文字列 Const FormatSheetName = "雛型" '貼付先のシートを新規作成する際の雛型となるシートのシート名 Dim f As Variant, i As Long, j As Long, buf As Variant, buf2 As Variant, _ myObject As Object, PasteSheetName As String, FirstCopyColumn As Long, _ CopyColumns As Long, FirstCopyRow As Long, LastCopyRow As Long, _ myCalculation As Integer, myBoolean As Boolean With Range(CopyCells) FirstCopyColumn = .Column CopyColumns = .Columns.Count FirstCopyRow = .Row LastCopyRow = FirstCopyRow + .Rows.Count - 1 End With Set myObject = CreateObject("Scripting.FileSystemObject") For Each f In myObject.GetFolder(ParentPath).SubFolders Call QNo9104083_ファイル選択マクロで教えて下さい_コア部分( _ f.Path, OriginPath, NoSheetFile, n) If Dir(f.Path & "\" & CopyFileName) <> "" Then PasteSheetName = f.Path i = 0 For i = 1 To 9 PasteSheetName = Replace(PasteSheetName, i, 0) Next i If InStr(InStrRev(f.Path, "\"), PasteSheetName, 0) > 0 Then PasteSheetName = Mid(f.Path, InStr(InStrRev(f.Path, "\"), PasteSheetName, 0)) If Replace(PasteSheetName, 0, "") <> "" Then Do While Left(PasteSheetName & "1", 1) = "0" PasteSheetName = Mid(PasteSheetName, 2) Loop End If PasteSheetName = InitialWord & PasteSheetName Else PasteSheetName = Mid(f.Path, InStrRev(f.Path, "\") + 1) End If PasteSheetName = Replace(Mid(Left(f.Path, InStrRev(f.Path, "\")) _ , Len(OriginPath) + 2) & PasteSheetName, "\", "-") myBoolean = Not IsError(Evaluate("ROW('" & PasteSheetName & "'!A1)")) If Not myBoolean Then If IsError(Evaluate("ROW('" & FormatSheetName & "'!A1)")) Then NoSheetFile = NoSheetFile & vbCrLf & Mid(f.Path, Len(OriginPath) + 1) Else Sheets(FormatSheetName).Copy After:=Sheets(Sheets.Count) Sheets(Sheets.Count).Name = PasteSheetName myBoolean = True End If End If If myBoolean Then Open f.Path & "\" & CopyFileName For Input As #1 Sheets(PasteSheetName).Range(PasteCell).Resize( _ LastCopyRow - FirstCopyRow + 1, CopyColumns).ClearContents If Not EOF(1) Then For i = 1 To LastCopyRow Line Input #1, buf If i >= FirstCopyRow And buf <> "" Then buf = Replace(Replace(",," & buf & String(CopyColumns, ","), ",", "", _ , FirstCopyColumn), ",", vbVerticalTab, , CopyColumns + 1) buf = Mid(Left(buf, InStrRev(buf, vbVerticalTab) - 1), _ InStr(buf, vbVerticalTab) + 1) Sheets(PasteSheetName).Range(PasteCell).Resize(1, CopyColumns) _ .Offset(i - FirstCopyRow).Value = Split(buf, vbVerticalTab) End If If EOF(1) Then Exit For Next i End If Close #1 n = n + 1 End If End If Next f If NoSheetFile <> "" Then buf = "指定されたフォルダー内の下記のサブフォルダーにもデータの" _ & "コピー元のファイルとして指定されている" _ & vbCrLf & vbCrLf & CopyFileName & vbCrLf & vbCrLf _ & "というファイル名のファイルが存在していますが、" _ & "コピーしたデータの貼付先となるシートが見つからなかった事と、" _ & "貼付先のシートを新規に作成する際の雛型となる" _ & vbCrLf & vbCrLf & FormatSheetName & vbCrLf & vbCrLf _ & "というシート名のシートも見つからなかったため、" _ & "データを転記する事が出来ませんでした。" & vbCrLf & vbCrLf & vbCrLf NoSheetFile = buf & Replace(NoSheetFile, buf, "") End If End Sub 　以上です。
カテゴリーが無い場合はその列は空白を返すので良いのですか？ C11：データ D11:ページ名 E11：カテゴリ F11：ページ名 D11式 =LEFT(C11,FIND("/",C11,1)) E11式 =IF(LEN(C11)-LEN(SUBSTITUTE(C11,"/",""))>1,LEFT(SUBSTITUTE(C11,D11,""),FIND("/",SUBSTITUTE(C11,D11,""),1)),"") F11式 =SUBSTITUTE(SUBSTITUTE(C11,D11,""),E11,"") D11~F11を下方へオートフィル E11式は、質問の数式では最初のスラッシュが４文字目以降に無いと数式が成り立たちません。言語の文字を空白置換した後にfind関数でスラッシュを検索すれば、言語の文字数に依存されない方法として修正しました。
貴方を除くすべての人がそうなら、その会社はヤバイと思いますが、たまにそういう人が居てもヤバくはないと思います。 電卓でも、エクセルでも、しょせん、人が数値を打ち込みます。エクセルに慣れていなければエクセルのほうが誤りが多いと感じる人はいるでしょう。計算の誤りだけを取り上げたら「どっちも同じ」となると思います。 ひとつの単純な計算をするだけででれば、（その結果を再利用することがない）わざわざエクセルを起動して実行する必要はありません。手元に電卓があればそれを使えばいいと思います。 しかし、エクセルは計算をするだけのツールではありません。成果物をファイルとして保存し、再利用することができます。一次データが変わったら、変わった値だけ修正するだけで再計算してくれます。エクセルはまた、電卓では手に負えない、高度の計算をする機能（関数）を備えています。 計算は電卓でするとなれば、ひとつの一次データが変わっただけで関係する計算をやり直し、表を作り直す必要があります。そのような面倒で、生産性が低い作業をのんびりとやっていることができる会社は余裕があるとしか言いようがありません。
その状況でＢＳキーを何回か押してみて。 動くようなら、ＴＡＢが数回押されています。 ＴＡＢは、画面上に表示しないからね。
私の勝手な提案ですが、提示式の末尾の「&"年度"」を取っ払って、 セル G3 の書式を G/標準"年度" に変更しました。 そうすると、[条件付き書式]の数式は簡単に次でＯＫです。 =G3=J1
>何が間違っているのでしょうか？ あなたが提示された数式は本来なら数式の記述エラーにならなければいけないものです。 #VALUE!エラーになる原因はExcelを作成した人でなければ分かりませんがプログラム上のバグと推測できます。 IF関数は入れ子構造で複雑な条件分岐を可能にしていますが、提示された数式はIF関数の入れ子になっていません。 つまり、2つのIF関数をカンマで繋いだ形です。 何を求めたいのかを再確認してフローチャートに書き出してみると原因が見つかるでしょう。
D列にデータが入力されているとして、別の列（仮にE列とします。）の1行目に、 =LEFT(D1,3)&"."&MID(D1,4,2)&"."&RIGHT(D1,2) と入力し、下方へオートフィルします。 これで、E列には「Hxx.xx.xx」とデータが表示されます。 このままでは、D列のデータが削除されると修正したE列の値がおかしくなります。(D列を参照しているので、参照先がなくなり、） そこで、E列のデータの範囲を選択し、コピーし、「形式を選択して貼り付ける」で、「値」として同じ場所に貼り付けます。すると、E列のデータは、D列のデータの参照ではなくなり、D列のデータを削除してもかまいません。 形式を選択して貼り付けるとき、D列に貼り付けても良いのですが、失敗するとオリジナルデータが失われます。（そのときは、編集を中断してエクセルを上書きなしで閉じる。） D列のデータを削除し、E列のデータをE列に移動します。 以上です。
何かの変換ソフトが必要です。 無料であれば Renee　PDF　Aideがお勧め 何度も使う可能性があり 複合機がCanonであれば、 読取革命の正式版を購入してください 割引価格で購入可能です。 http://www.panasonic.com/jp/company/pstc/products/yomikaku/shopping.html
「まさか、そんなこたー、アンメエ～」と試してみたら、「あれ？ホンマや～」でビックリポンしました。 理由は分からねど、試した結果は[オプション]の “大文字と小文字を区別する” “半角と全角を区別する” の両方にチェックを入れておくと 》 「々」を対象としたときには、「ー」は除外させたい を満足するようです。
参考に Sub Test() 　　Dim v As Variant 　　Dim i As Long 　　Dim strName As String 　　v = Range("A2", Cells(Rows.Count, "A").End(xlUp)).Resize(, 3) 　　For i = 1 To UBound(v) 　　　　If strName <> v(i, 1) Then 　　　　　　strName = v(i, 1) 　　　　Else 　　　　　　v(i, 3) = "" 　　　　End If 　　Next 　　Range("A2").Resize(UBound(v), 3).Value = v End Sub
モニターの設置と番号がズレているのであれば　添付された画面のモニターをドラッグドロップで移動できます https://121ware.com/qasearch/1007/app/servlet/qadoc?QID=012052 正しい位置であれば　どちらのモニターを１にするか選択可能です https://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=012050 １の画面がタスクバーのスタートメニューが表示される画面 表示位置を記憶していれば　ウインドウを移動した状態で終了すれば　次回起動時に終了した場所に表示されると思います
536870910 Microsoft Office https://msdn.microsoft.com/ja-jp/library/dd313951.aspx 先頭の－は不要です。 Microsoft　コミニュティ　E0000002 http://answers.microsoft.com/ja-jp/office/forum/office_2013_release-office_install/office2013/b11a6984-b0f6-401f-867e-75f3832662b8?auth=1 以上を参考に。
こんにちは。 ワークシート関数のMATCH()を使う例です。 エラートラップや外部オブジェクトを扱わずに済む分だけ、 取っ付き易いかと思います。 不足・不明がある場合は補足欄にでも書いてみて下さい。 ' ' /// Sub ReW9101218() Dim arrSep(), vTemp, vRtn, vKey Dim c As Range 　　arrSep() = Array("A", "B", "C")　'　要指定：「A、B、Cが現れたら」なら "A", "B", "C" 　　With Application 　　　　.ScreenUpdating = False 　　　　.EnableEvents = False 　　　　.Calculation = xlCalculationManual 　　End With 　　For Each c In Range("B1:B" & Cells(Rows.Count, "B").End(xlUp).Row)　'　要指定：B列なら "B" 　　　　vTemp = c.Value 　　　　If vTemp <> "" Then 　　　　　　vRtn = VBA.Array(Application.Match(vTemp, arrSep(), 0)) 　　　　　　If Not IsError(vRtn(0)) Then 　　　　　　　　vKey = vTemp 　　　　　　　　c.ClearContents 　　　　　　ElseIf vKey <> "" Then 　　　　　　　　c.Offset(, -1).Value = vKey　'　要指定：基準列のひとつ左のセルなら -1 　　　　　　End If 　　　　End If 　　Next 　　With Application 　　　　.Calculation = xlCalculationAutomatic 　　　　.EnableEvents = True 　　　　.ScreenUpdating = True 　　End With End Sub ' ' ///
こんにちは =IF(ISERROR(FIND(A1,B1,1)),1,0) で、どうでしょうか？
添付図参照 左図において、 １．セル E1 に次の配列数式(←注意！)を入力 ＿＿ =SUM(IF(A1:C1="",0,COLUMN(A1:C1)*10+ROW())) ２．此れを下方にズズーッとオートフィル ３．列範囲 A:E を選択 ４．列Ｅをキーにして昇順に並べ替え その結果を右図に示した。 【備考】データ範囲の行数が10行、100行を超える場合は上式中の「10」をそれぞれに応じて「100」、「1000」に変更すればＯＫです。
こんにちは 所要時間　合計時間　時刻　の列の書式を「h:mm」としておいて 　B　　　C　　　　D　　　　　E　　　　　F 日程　　内容　　所要時間　　合計時間　　9:30 　　　　挨拶　　0:05　　　　　　0:05　　9:35 　　　　ア　　　0:03　　　　　　0:08　　9:43 　　　　イ　　　1:10　　　　　　1:18　　11:01 のようにしてはどうですか？ セルE2に =D2 セルE3には =E2+D3 で以下にフィルコピー セルF2に =F1+E2 で以下にフィルコピー 位で出来そうですけど。
データA~D列 E~G列作業列 I~L列データ抽出 作業列１：E2式 =IF(C2="","",ROW()) A~D列データがあるまで下方へオートフィル 作業列２：F2式 =IFERROR(INDEX($A$2:$A$1000,MATCH(SMALL($E$2:$E$1000,ROW(A1)),$E$2:$E$1000,0)),"") 作業列３：G2式 =IF(F2="","",COUNTIFS($A$2:$A$1000,F2,$B$2:$B$1000,"<>")*COUNTIFS($A$2:$A$1000,F2,$D$2:$D$1000,"<>")) F2~G2下方へオートフィル I2式 =IF(F2="","",F2) I3式 =IF(ROWS($2:3)>SUM($G$2:$G$100),"",IF(COUNTIF(I$2:I2,I2)<INDEX($G$2:$G$100,MATCH(I2,$F$2:$F$100,0)),I2,INDEX($F$2:$F$100,MATCH(I2,$F$2:$F$100,0)+1))) J2式 =IFERROR(OFFSET(INDEX($B$2:$B$1000,MATCH(I2,$A$2:$A$1000,0)),INT((COUNTIF($I$2:I2,I2)-1)/COUNTIFS($A$2:$A$1000,I2,$D$2:$D$1000,"<>")),),"") K2式 =IFERROR(VLOOKUP(I2,$A$2:$C$1000,3,FALSE),"") L2式 =IFERROR(OFFSET(INDEX($D$2:$D$1000,MATCH(I2,$A$2:$A$1000,0)),IF(MOD(COUNTIF($I$2:I2,I2),COUNTIFS($A$2:$A$1000,I2,$D$2:$D$1000,"<>"))=0,COUNTIFS($A$2:$A$1000,I2,$D$2:$D$1000,"<>"),MOD(COUNTIF($I$2:I2,I2),COUNTIFS($A$2:$A$1000,I2,$D$2:$D$1000,"<>")))-1,),"") J2~L2をJ3~L3までコピー I3~L2を下方へオートフィル
こんにちは。 > 右からループするにはどうすればいいですか？ 基本的には、 For Each...Next ステートメントで逆順のループをさせることは出来ませんので、 既出の回答のようにFor...Next ステートメントで インデックスを逆順でループすることになります。 なぜ「右からループ」させたいのか、という説明があれば、 そう少し他の話が出来るのかも知れませんが、 私個人の経験から 何度も繰り返し頻繁に「右からループ」する必要があるという理由で、 ブックを開いた時に、逆順のコレクションを用意するようにして、 総当たりで「右からループ」を簡単に出来るようにした実践コード がありましたので、参考としてあげてみます。 「右からループ」の理由、実務からの要求ではなくて、 基本技術の学習が目的、ということでしたらば、 インデックスを逆順でループするのが普通のやり方です。 何か不足があるようでしたら、補足をお願いします。 ' ' /// 〓　以下、ひとつの標準モジュールに併記する場合　〓 w9100377 Option Explicit Private colWsk As New Collection ' ' 全ワークシートを逆順でCollectionオブジェクトに格納 Private Sub Auto_IOpen() Dim i As Long 　　With Worksheets 　　　　For i = .Count To 1 Step -1 　　　　　　colWsk.Add .Item(i), CStr(i) 　　　　Next i 　　End With End Sub ' ' 逆順の全ワークシートが格納されているCollectionオブジェクトを総当たりループ Sub main()　'　「右からループ」 Dim wks As Worksheet 　　If colWsk.Count = 0 Then Call Auto_IOpen 　　For Each wks In colWsk 　　　　Debug.Print wks.Name 　　Next End Sub ' ' ///
No.2 です。お礼欄、補足欄、拝見しました。 > しかしなぜかApplication.Run arrProc(i)でエラーが発生して動作させることができませんでした。。 どのようなエラーでしょうか。 ｜　実行時エラー '1004' ｜ ｜　マクロ 'test0' を実行できません。このブックでマクロが使用できないか、またはすべての ｜　マクロが無効になっている可能性があります。 添付画像で示した実行時エラーでしたら、 複数のモジュールにまたがってプロシージャ名が重複している場合に 簡単に再現されるものです。 対策としては、同一VBProject内に同名のプロシージャ名がないように命名し直すか、 簡単に済ませるなら、 >　　　　　　Application.Run arrProc(i) に対して、モジュール名を明示するように書き直す方法があります。 仮に、 私が提示したプロシージャすべてが、 [Module3]という標準モジュールに書かれている場合でしたら、 　　　　　　Application.Run "Module3." & arrProc(i) のように、モジュール名の末尾に"."を付加したものを文字列として書き加えれば、 プロシージャの呼び出しが適切に行われるようになります。 エラーに関しては、エラーメッセージの内容によって対応が異なります。 > Sheet1とは一体何なのかを知りたかったのです。 VBProject クラスのメンバーとして、 シートオブジェクトが生成される時に（新規ブック作成時やシート追加時） [Excel Objects]（vbext_ct_Document）タイプのVBComponentが追加され 仮の名前を自動的に振られたものが、[Sheet1] になります。 VBComponentの名前については[ThisWorkbook][Module1][UserForm1]などと同等のもので、 自動的に付番されますが、変更可能な名前です。 一般的な記法で 　　UserForm1.Show 等と同様、CodeModuleに関連付けられたオブジェクトを参照する際にも この名前を「オブジェクト名」として用いることができます。 　　Sheet1.Select などのように、、、。 VBProject で定義された オブジェクト ≒ クラス としての 　　Sheet1 です。 VBComponent の名前が、そのままオブジェクト名になります。 > Sheet1もオブジェクト変数なのではないか 習熟の段階に合わせて「円周率は３」のように、 正しくはないけれど、一旦はそういうことにしておいて次の段階に進むことを 優先させるような教え方としては、「Sheet1もオブジェクト変数」という 覚え方でも支障はないような気はします。 実行時に格納される値（オブジェクト）を変更可能なのが変数です。 VBProject で定義された オブジェクト ですので、実行時のアクセスもVBから見れば直接的で単経路になります。 実際的には、プロシージャやモジュールで定義・設定されている変数の方が より単経路になる筈ですから微かにアクセスは速いようですし、 変数に格納した方が、名前の衝突や各種オーバーヘッドを事前に回避する意味があります。 > CodeNameの意味 Worksheet クラス（Chart クラス）の CodeName プロパティです。 VBProject で定義された オブジェクト名＝VBComponent名を返します。 以下、引用 ｜Excel 開発者用リファレンス ｜Worksheet.CodeName プロパティ ｜オブジェクトのコード名を返します。値の取得のみ可能です。文字列型 (String) の値を使用します。 ｜構文 ｜式.CodeName ｜ ｜式 Worksheet オブジェクトを返すオブジェクト式を指定します。 ｜ ｜備考 ｜コード名は、選択したオブジェクトの [プロパティ] ウィンドウの Name プロパティで確認できます。デザイン時に、このプロパティの値を変更してコード名を変更することができます。実行時に、このプロパティの値をコードで変更することはできません。 ｜オブジェクトのコード名はオブジェクトを表すオブジェクト式の代わりに使用できます。たとえば、ワークシートのコード名が "Sheet1" である場合、次の式は同じです。 ｜Worksheets(1).Range("a1") ｜Sheet1.Range("a1") ｜シート名とコード名は異なる場合もあります。シートの作成時は、シート名とコード名は同じです。しかし、シート名を変更してもコード名は変更されません。また、Visual Basic Editor の [プロパティ] ウィンドウでコード名を変更してもシート名は変更されません。 ｜使用例 ｜次の使用例は、ワークシート 1 のコード名を表示します。 ｜MsgBox Worksheets(1).CodeName 以上引用。 ヘルプでのここら辺の扱いについては、[コード名]のような用語が統一されていないようなので、 こちらでは積極的に紹介しなかったのですが、 今回のお尋ねについて一通り解説した内容ではあります。 私の説明もうまくないように感じていますが、伝わるものがあるといいです。
こんにちは 標準モジュールとかフォームモジュールとか、シートモジュール内の コードは全て無い状態で「マクロなしのファイルに名前を付けて保存」 しようとしていますか？
Wordで動作させるVBAでしょうか？ もしそうだとすればExcelのダイアログを使う 意味がわかりません WordのVBAで保存ダイアログを表示し保存できる VBAサンプルを貼っておきます Excelの機能を使う必要のないものです Sub test() Dim fname As String Dim SF As String SF = "\\osaka\PCBackup\" '現在開いているファイル名を取得 fname = ActiveDocument.Name With Application.FileDialog(msoFileDialogSaveAs) '保存先を開いてファイル名は現在開いているものにする .InitialFileName = SF & fname If .Show = False Then Exit Sub 'キャンセル Else .Execute '保存 End If End With End Sub いろいろ案がでているようなので Excelで動作させるVBAであって 求めているものと違うのであればごめんなさい ちなみに With Application.FileDialog(msoFileDialogSaveAs) を With Application.FileDialog(msoFileDialogFilePicker) に変更するとファイル参照用のダイアログがでます ただし動作内容のVBAは変更する必要がありますけど 今作っている部分を汎用はできるかと思います
ご利用のエクセルのバージョンが不明のご相談ですが、最近のエクセルを使っているなら ＞たとえば(1)で「常にある」or「時々ある」を選んだ人で、(2)で「常にある」or「時々ある」 =COUNTIFS(S2:S51,"*ある",T2:T51,"*ある") のように計算することも出来ます。 たとえば次の数式をＴ６１セルに =COUNTIFS($S2:$S51,"*ある",T2:T51,"*ある") 置いてこれを右向けにコピーすると、（１）と（２）、（１）と（３）、（１）と（４）…のように計算結果を並べることも出来ますね。 ＃具体的な関数式をまるっと教えて欲しいときは、「具体的にあなたは何を計算したいのか」をしっかり丁寧に質問するようにしてみて下さい。
>B〇〇〇の所に変動できる数値を関数でC1に行数指定 との事ですが、そのC1とは、どのシートのC1セルの事なのでしょうか？ 　入院費用一覧シートのC1セルの事なのでしょうか？　それともAシートのC1セルの事なのでしょうか？　それともBシートのC1セルの事なのでしょうか？ 　取り敢えず、AシートのC1セルに「B〇〇〇の所に変動できる数値」の値が存在している場合に対応するVBAを御伝えしておきますので、もしシートが違っている場合には指定するシートを適時変更して下さい。 Dim myRange As Range, buf As Variant buf = Worksheets("A").Range("C1").Value If Not(buf > 1 and buf <= Rows.Count) Then buf= 0.5 If buf > Int(buf) Then Msgbox "C1セルlに行数が指定するための値が入力されておりません>" _ & vbCrLf & "マクロを終了いたします。" & vbExclamation, "行数未設定" Exit Sub End If Set myRange = Worksheets("入院費用一覧").Range("A1:B" & buf) Worksheets("B").Range("A1") _ .Resize(myRange.Rows.Count_,myRange.Columns.Count).Value _ = myRange.Value Worksheets("B").Activate
一応、マクロを組みました。 あえて、いろいろなチェック作業はしていません。 チェック作業というのは、ちゃんと７桁入力されているか、とか、すべて半角の数字で入力されているか、など一切のチェックを行っていませんので、郵便番号の数字を入力する際は注意してください。 エクセルを立ち上げ、郵便番号のファイルを開きます。 「Ｃ」列と「Ｄ」列は削除しておいてください。 「Alt（「オルト」と読みます）」キーを押しながら、「F11」キーを押します。 「Visual Basic」の画面が現れますので、メニューから「挿入」→「標準モジュール」を選択します。 すると、右側の画面が白くなりますから、その新たに白くなった部分にカーソルを移動して、下のマクロをコピー＆ペーストします。 「F5」を押して、マクロを走らせます。 入力を求めてくる画面になりますから、「-」のない、７桁の郵便番号を入力します。 すると、「Ｃ」列に該当の住所が表示されます（今回は文字列ですので、「F2」による訂正ができます）。 何も入力せず、「Enter」だけを押すと、入力が終了しますが、それまでは、７桁の数字を入力し続けられ、１行ずつ下げて住所を入れていきます。 通常のエクセルの画面に戻って、「F12」（名前を付けて保存）を押して、「～.xlsm」を選んで（「～」の部分は何でも構いません）保存します。 注意事項としては、次、このファイルを開くと、前回の文字（住所）がそのまま残っています。 しかも、マクロを走らせると、また、１行目からスタートしますので、気をつけてください（ファイルを閉じるときか、立ち上げるたびに「Ｃ」列を削除する、とか）。 Option Explicit Sub zip() Dim c As Integer Dim i, r As Long Dim z As String r = Range("A1").End(xlDown).Row c = 0 z = "0" Do Until z = "" z = InputBox("郵便番号を入力してください" & vbCrLf & "（ -は入力しないでください）。" & vbCrLf & "何も入力しなければ終わります") For i = 1 To r If z = Cells(i, 1).Value Then c = c + 1 Cells(c, 3).Value = Cells(i, 2).Value End If Next i Loop End Sub 以下は、読む必要はありません。 私の回答を見た、他の人に対して書いているようなものですから。 通常は「Find」などを使って検索するのが普通だとは分かっていますが、それでは、エラーが出てしまうので、あえて、泥臭い「For」ループを使って、入力された郵便番号を探しています。 大昔のパソコンと違って、たかが１２万件ほどのループぐらい、全く時間はかかりませんから。 しかもこれなら、見つからなかった場合、何もしないので、そのまま再入力が可能だからです。
ブラウザは何ですか？ 他のブラウザでも同じ現象でしたら、当該Outlook.comアカウントのOneDrive上で扱うアプリの不具合かなと思います。 もし、他のブラウザでOKでしたら、ユーザーが対処するとしたら、当該使用ブラウザのキャッシュなどの履歴をクリアしてみる、リセットしてみる、新規のOutlook.comアカウントを取得するくらいしかないと思います。 なお、質問内容とは関係ないですが、既にご存知かも知れないですが、現所有のアカウントの無料分のOneDrive（現在15GB）のストレージは、5GBに減らす方針のようですが、それを回避する対応はされましたか？ （参考） http://www.itmedia.co.jp/pcuser/articles/1512/17/news122.html
画像は６６行目の内容にリンクします。「ドロップダウンリストにリンク」しているワケではありません。 ６６行目の内容が、ドロップダウンの選択だろうが、直接手入力だろうが、「計算式の結果」だろうがナンでも構わないということです。 つまり ＞65行と66行が連動していないので、一回一回手動で66行を操作しないといけません。 ６６行目に手入力(ドロップダウンリストからの選択)するのを止めて、６５行目の結果に基づいて適切な結果(＝手で入れたかった／ドロップダウンリストで選択したかった)を計算する数式を６６行目に放り込んでおけば、それで十分です。 具体的に「どのように連動」させたいのかはナイショのご相談なので、そこはご自分で考えて下さい。
振り仮名を使わずの例示が手元の計算と異なりますが、まぁ置いておいて。 順位は要するに「自分より『小さい(大きい)』データ」の個数＋１です。 使わない方が計算は簡単で Ｄ２： =SUMPRODUCT((B$2:B$8<B2)*1)+1 以下コピー とかで十分です。 使う方はPHONETIC関数の特性を逃げるため、例えば Ｃ２： =SUMPRODUCT((PHONETIC(INDIRECT("B"&ROW(B$2:B$8)))<PHONETIC(B2))*1)+1 以下コピー みたいに、仕込みが要ります。
これでどうでしょうか？ また、何かありましたら、聞いてください。 Option Explicit Sub Test() Dim i, j As Integer Dim s, t, z As String For i = 2 To 32 s = "" t = "" For j = 2 To 21 z = Cells(j, i).Value If z = "☆" Or z = "★" Or z = "◎" Then s = s & "," & Cells(j, 1).Value End If If z = "※" Then t = t & "," & Cells(j, 1).Value End If Next j If s <> "" Then Cells(i, 34).Value = i - 1 & "日" & s End If If t <> "" Then Cells(i, 35).Value = i - 1 & "日" & t End If Next i End Sub
＞セルの書式設定の「ユーザー定義」で変換できないでしょうか。 できません。 元の数値がA1セルに入って居るのであれば、どこか別の空きセルに =DATE(A1/10000,MOD(A1/100,100),MOD(A1,100)) と入力して、日付に変換して下さい。 変換したら、日付になったセルをコピーして、元のセルに「形式を指定して貼り付け」→「値」で貼り付けて、表示形式を日付に指定して下さい。
　COUNTIFS関数は COUNTIFS(条件範囲 1, 検索条件 1, [条件範囲 2, 検索条件2]…) という形式で記述しなければなりませんが、質問者様の =COUNTIFS(A1:B1,"○","×") では、 =COUNTIFS(条件範囲 1, 検索条件 1, 検索条件2) という形式になってしまっており、条件範囲 2が指定されておりません。 　そのため >この関数に対して、少なすぎる引数が入力されています。 という警告文が現れてしまうのです。 　それと、例え =COUNTIFS(A1:B1,"○",A1:B1,"×") としたとしましても、これでは「『セル範囲A1:B1』に含まれているセルの中に『セルの値が"○"であると共に"×"でもある』という条件を満たしているセルが幾つあるのか」をカウントする関数になってしまいます。 　1個のセルに入力する事が出来る値は1つだけしかありませんから、「セルの値が"○"であると共に"×"でもある」などという条件を満たしているセルは存在する筈もありませんので、返される値は必ず0になってしまいます。 　要するにCOUNTIFS関数では、異なった値を持つセルの合計数を数える事は出来ないのです。 　異なった値を持つセルの合計数をカウントする場合には、それぞれの値に対して、その値を持っているセルの個数を(COUNTIFS関数ではなく)COUNTIF関数を使用して求めて、それらのCOUNTIF関数の結果を合計する、というやり方をするしかありません。 　ですから御質問の件の場合は =COUNTIF(A1:B1,"○")+COUNTIF(A1:B1,"×") になります。 　回答No.2様の方法に似ていますが、こちらは回答No.2様の方法とは違い、「COUNTIF」と「(A1:B1」との間に「'\」を入れていません。
>本屋とかでExcelの本を読んだりしましたが、このような技術は本に書いてありません。 >どのようなところで調べたり学んだらこういう技術が得られるのでしょうか？ 　私の場合は自己流ですので万人に対しても適した方法なのかは存じませんが、まず目的を果たすために必要となる機能を、各処理の要素ごとに分けた上で、その要素ごとに対して、Excelのヘルプで目的の処理を行う事が出来そうな機能が無いかどうかを探します。 　Excelのヘルプを開くと、「関数リファレンス」や「条件付き書式の設定」などといった項目が並んでいますので、例えば「こういった目的に使う事が"出来そうな"関数は無いか」という場合には、「関数リファレンス」を開き、並んでいる「検索/行列関数」、「日付と時刻の関数」、等々の項目の中から関連のありそうな項目を選んで開き、表示された関数とその機能の一覧を眺めて、目的としている処理を行う際に役立ちそうな関数のページを開いてその関数の機能を確認します。 　Excelのヘルプの内容で解らない事があったり、目的の機能が見つからなかったりした場合には、インターネットで検索して、個々の処理の要素ごとに目的を果たすために役立つ情報(機能に関する解説や、使用例などに関する情報)を探します。 　そうして集めた情報を組み合わせて一つに纏めた関数などを試しに作ってみて、想定通りの機能を果たす事が出来ているのかどうかを、「想定している全ての条件(例えばA1セルの値が10以上、20未満という条件であれば、その関数をB列の各行のセルに入力しておき、A列のセルに9、10、11、19、20、21を入力しておく)に対して確認を行う」という事を繰り返します。 　そうした事を繰り返して行きますと、目的を果たすためには役立たない機能に関する情報の中にも、「こんな事も出来るのか」と思える情報に触れる事も出来ますので、そういった情報も頭の隅に残る事になり、後に全く別の目的を果たす際に「確かこの場合に使う事が出来る『こんな機能』があった筈」という事を思い出し、調べ直す際に役立てる事が出来ます。 　そういった事を、様々な例題等で繰り返して行きますとその手の技術が自然と身に付く様になります。 　特に、この様なQ&Aサイトに投稿されて来るExcelに関する質問を例題として捉えて、回答を投稿するか否かは別として、解決方法を自分で考え出したり、他の回答者の回答内容を参照したりする事は、良い練習になりました。 　尤も、このサイトの場合、「教えてgoo」がパートナーサイトで無くなってからは、投稿数が極端に減った上に、関数に関する質問も少なくなりましたので、昔ほど良い例題にはならないかもしません。 　後、ネット上にはExcelに関して開設されているサイトも少なくありませんので、そういったサイトで目的を果たすために必要な機能を探すのも一つの手だと思います。 　下記はその一例ですが、下記のもの以外にも同様のサイトは多数あります。 【参考URL】 　よねさんのWordとExcelの小部屋 　　http://www.eurus.dti.ne.jp/~yoneyama/ 　エクセルの路地 　　http://www.geocities.jp/oyakamassan_m/index.html 　Office TANAKA > 機能と数式 　　http://officetanaka.net/excel/index.htm 　Excelでお仕事！ 　　http://www.asahi-net.or.jp/~ef2o-inue/top01.html
最後の方の If IsEmpty(strBuffer) Then MsgBox strX & "が見つかりませんでした。" WScript.Quit End If Set objTS = objFSO.OpenTextFile(strNewFile, ForWriting, True) objTS.WriteLine strBuffer objTS.Close ですが、これ全体を「If」にしないといけないのではないでしょうか？ すなわち、 If IsEmpty(strBuffer) Then MsgBox strX & "が見つかりませんでした。" WScript.Quit Else Set objTS = objFSO.OpenTextFile(strNewFile, ForWriting, True) objTS.WriteLine strBuffer objTS.Close End If というように、見つかったときの処理として、テキストファイルを作成するのです。 あと、ご質問の意味が理解できなかったのですが、「InputBoxを再び使用せずに」というのは、最初の「InputBox」で「抽出文字」と「変換文字」を指定したい、ということでしょうか？ １つの「InputBox」は、１つの文字列しか入力できませんが、工夫はできます。 x = InputBox(""抽出したい文字列と" & vbCrLf & _ "変換したい文字列を" & vbCrLf & "半角スペースで区切って" & vbCrLF & _ "入力してください") p = InStr(x, " ") If p > 0 Then y = Left(x, p - 1) z = Mid(x, p + 1, Len(x) - p) Else y = x z = "" End If 最初に入力するときに、上記の場合でしたら、半角スペースで文字を区切ります。 すると、半角スペースの前の部分を「y」に、後ろの部分を「z」に入れますので、その「z」を使えばいいわけです。 区切り文字を入力しなかった場合は、「z = ""」に設定し、「y = x」とすればいいでしょう。 最後に、「InputBox("抽出したい文字列を入力してください。", "変換処理")」とされていますが、後ろの「"変換処理"」は、「InputBox」のタイトルになります。 「タイトル」というのは、このプログラムを実行したとき、「InputBox」で文字の入力を求めてきますが、その「InputBox」の一番上に表示されている窓の名前です。 「InputBox」が実行されたとき、「InputBox」の窓の上の方を見てみてください。
　例えばC2セルに =TODAY() C3セルに ="" と入力しておいた上で、入力規則の元の値欄には =$C$2:$C$3 などの様に入力されると良いと思います。
Excelでは複数のデータを1つのセルに表示するのは合理的な操作法ではありません。 添付画像のようにAIセルから右に該当する名前を列挙するならA1セルに以下の式を入力して右方向および下方向にオートフィルします。 1日、名前1、名前2、…のようなテキストが欲しいなら（Wordに貼り付けたいなら）以下のような手順で処理することができます。 AH2から表示データ範囲を選択し右クリック「コピー」、そのままワードの新規ファイルに「貼り付け」して、貼り付け後に右下に表示される貼り付けオプションをクリックして「テキストのみ」を選択します。 最後に、Ctrl+Hで置換ダイアログを出し、「オプション」ボタンを押し、「ワイルドカードを使用する」にチェックを入れ、検索する文字列に「^t」置換後の文字列に「、」を入力いして「すべて置換」し、そのまま検索する文字列に「、^13」置換後の文字列に「^13」で「すべて置換」し、さらに検索する文字列を「、、」置換後の文字列に何も記入せず「すべて置換」してください。
＞VALUEしたセルのところは数値に変換されたが、オートフィルしたところは数値に変換されず初めのVALUEしたところの数値が表示された。 このパターンはシートの再計算が「手動」になっているような気がします。 F9キーを押して正しい値が表示されるなら、Alt+T,Oのショートカットで「数式」から計算方法を「自動」にチェックを入れてください。 ＞オートフィルしたセルのVALUEの式をみると、オートフィルしたセルの番号が表示されている。 意味がよくわからないのですが、セルの番号とは参照しているセル番地が正しく表示されｇているということでしょうか？ VALUE関数で数値化できる文字列なら、その列を選択してデータタブの「区切り位置」で「完了」するのが文字列数字を数値に一括変換できる簡便な操作です。
こんにちは。 =AND($A1<>"",$B1="") でどうでしょう。
こんにちは それは本当に必要な処理なのでしょうか？ 気になりますが、「test」で正しいファイルパスがイミディエイトウィンドウに 表示されるか確認しておいて下さい。 A列のデータの最後に円マークが無いならそれを追加するコードが必要です。 Sub test() 　　Dim r As Range 　　With ThisWorkbook.Worksheets("ファイル") 　　　　For Each r In .Range("A1", .Range("A" & Rows.Count).End(xlUp)) 　　　　　　Debug.Print r & r.Offset(, 1) '　　　　　　Debug.Print r & "\" & r.Offset(, 1) 　　　　Next 　　End With End Sub 正しいパスが表示されるなら、「test1」をフォームのボタンのマクロに登録して下さい。 Sub test1() 　　Dim r As Range 　　Dim b As Workbook 　　Application.ScreenUpdating = False 　　With ThisWorkbook.Worksheets("ファイル") 　　　　For Each r In .Range("A1", .Range("A" & Rows.Count).End(xlUp)) 　　　　　　Set b = Workbooks.Open(r & r.Offset(, 1)) '　　　　　　b.Save '保存しない場合はコメントアウト 　　　　　　b.Saved = True 　　　　　　b.Close 　　　　Next 　　End With 　　Application.ScreenUpdating = True End Sub
下記数式をB8にコピー =IF(OR(B2="",B6=""),"",IF(B2="A銀行",IF(B4="B支店",0,IF(B6>=30000,300,100)),IF(B6>=30000,400,200)))
セルＣ1以外のセルは同じで，セルＣ1に =IF(B1="東京都",LEFT(E1,FIND("区",E1)),IF(IFERROR(MATCH(LEFT(E1,1),{"堺"},FALSE), IFERROR(MATCH(LEFT(E1,2),{"札幌","仙台","千葉","横浜","川崎","新潟","静岡","浜松","京都","大阪","神戸","岡山","広島","福岡","熊本"},FALSE), IFERROR(MATCH(LEFT(E1,3),{"相模原","名古屋","北九州"},FALSE), IFERROR(MATCH(LEFT(E1,4),{"さいたま"},FALSE),-1))))>0,LEFT(E1,FIND("区",E1)), IF(IFERROR(MATCH(LEFT(E1,2),{"郡山","市原","郡上","蒲郡","小郡","市川"},FALSE),-1)>0,LEFT(E1,3), IF(IFERROR(MATCH(LEFT(E1,3),{"四日市","廿日市"},FALSE),-1)>0,LEFT(E1,4), IF(IFERROR(MATCH(LEFT(E1,4),{"大和郡山市"},FALSE),-1)>0,LEFT(E1,5), LEFT(E1,IFERROR(FIND("郡",E1),FIND("市",E1)))))))) ということですか？
#3です。 >[並べて比較]は Excel 2013 にもありますが、２つのシートの左右の >[整列］との動作の違いが分からず、また、「2つ同時にズームすること」 >の確認ができないでおります。 わたしもそれほど詳しくはないのですが、違いとしては昨日 回答した通り、「並べて比較」は二つのブックなり、シートを 比較するものです。 表示している二つのブック（シート）は連動しており、 ([同時にスクロール]を押すと)同時にスクロールさせたり できますし、二つ同時に拡大/縮小もできます。 で、[整列]は単純に複数のブック(シート)を表示するのみ ですが、[並べて比較]と違って二つ以上のブック(シート)を 同時に表示することが可能です。但し、連動してないので 個別にスクロールさせたり、拡大/縮小させる必要があります。 > 「2つ同時にズームする」コツを教えてください。 [並べて比較]の状態であれば2つ同時にズームできると思います。 特にコツはありません。 >また、試してみましたが、複数のシートを作業グループにしても >同時ズームはできない、と理解しています。 作業グループの状態になっているとき、ブック名のところに [作業グループ]と表示されますが、試されたときに表示されて ましたでしょうか。 上記はあくまでも2010で試しているので2013でも同じかどうか 分かりませんが、恐らく並べて比較も作業グループも基本的には 同じ動きになると思います。
同一列に5000行なら、その列を選択する。又は変更したい列をドラッグ マウス右クリック→セルの書式設定→ユーザー定義→種類(T)に下記コピー "≪"@"≫" OKボタン 下記ユーザー定義書式　様をつける方法と考え方は同じです。 http://www.bindman.jp/tosweb/2010/05/microsoft-excel-2.html
percentile関数については以下のページを参考にしてください。 http://blog.goo.ne.jp/nobutoshi3/e/bf2d93386305ee0810eec40c2e61c4b0 一般に、例示の5段階評価のように評価の分類基準がある場合はpercintile関数で自動的に判定するのが合理的です。 今回は、10段階評価ですので、この割合の基準を設定すればよいことになります。 ポイントは6の人の中央値が50％になるように設定する必要があります。 現在の5段階評価がなければ簡単に基準を作成できますが、これとリンクさせた割合を決定するのが制約となります。 少なくとも6の人の評価が真ん中になるようにするには、5の人と7の人の基準が50％の前後同じパーセントのところになるように設定する必要があります。 おそらく5段階評価と完全に対応した区切りを設けると、バランスが悪い区切りができるかもしれませんが、3,5,7,9など奇数の基準部分については、ご自分で区切る位置を設定してください。
ご希望の操作をするには、オプションボタンではなくチェックボックスを配置します。 フォームコントロールのチェックボックスを３つ配置し、右クリックからコントロールの書式設定で「リンクするセル」をそれぞれD2、D2、D4としておきチェックした商品の金額を出す欄には「=SUMPRODUCT(B2:B4*D2:D4)」を入力しておきます。 最後にD2：D4のセルの書式設定でフォントを白にする、あるいはD列を非表示にしてください。
こんにちは。 > ウインドウのサイズを最大化 Private Sub Workbook_Open() Application.WindowState = xlMaximized End Sub なのでは？ > ActiveWindow.WindowState = xlMaximized では、Excel配下のワークブック配下のウィンドウのサイズを変更します。 対して、 Application.WindowState = xlMaximized では、Excel全体のウィンドウのサイズを変更します。
こんにちは。 ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 ' ' 参照設定 ■ Microsoft Internet Controls ■ SHDocVw Sub ReW9095183() Const navOpenInNewTab = 2048 Dim myObj As Object Dim objIE As InternetExplorer Dim objIE2 As InternetExplorer Dim objShell As Object　'　As Shell32.Shell　'　■ Microsoft Shell Controls And Automation ■ Shell32 Dim cnWnd As Long ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー 　　Const GOOGLE = "https://mail.google.com/mail/u/0/?pli=1#inbox" 　　Const DOCOMO = "https://mail.smt.docomo.ne.jp/mail/#fid=10000000&page=1" ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー ' ' objShell.Windows で 逐一 エクスプローラ を捉える為のShell オブジェクト 　　Set objShell = CreateObject("Shell.Application")　'　　Set objShell = New Shell32.Shell ' ' objShell.Windows.Count ＝ エクスプローラ（Windows+Internet）の数、現在値 　　cnWnd = objShell.Windows.Count ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー 　　Set objIE = CreateObject("InternetExplorer.Application") 　　With objIE 　　　　.Visible = True 　　　　.Navigate GOOGLE　 '　グーグル 　　　　.Navigate2 DOCOMO, navOpenInNewTab　'　navOpenInNewTab = 2048　'　ドコモ 　　End With ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー ' ' objShell.Windows.Count で 追加タブの エクスプローラ が読み込まれるまで待機 　　Do While objShell.Windows.Count < cnWnd + 2 　　　　DoEvents 　　Loop ' ' objShell.Windows の 最後にあるのが 追加タブの エクスプローラ 　　Set objIE2 = objShell.Windows(cnWnd + 1)　'　ドコモ ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー 　　With objIE　 '　グーグル 　　　　Do While .Busy Or .ReadyState <> READYSTATE_COMPLETE　'　 READYSTATE_COMPLETE = 4 　　　　　　DoEvents 　　　　Loop 　　' ' グーグル 処理　？ 　　End With ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー 　　With objIE2　'　ドコモ 　　　　Do While .Busy Or .ReadyState <> READYSTATE_COMPLETE 　　　　　　DoEvents 　　　　Loop 　　' ' ドコモ 処理 '　　　　.Document.getElementById("Di_Uid").Value = "ID"　'　? 必要ならイキ　アカウントID要指定 　　　　.Document.getElementById("Di_Pass").Value = "PassWord"　'　? パスワード要指定 '　　　　.Visible = False '　　　　.Document.getElementsByClassName("button_submit nextaction")(0).Click　'　? ログインするならイキ '　　　　.Visible = true 　　End With ' '　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー '　　objIE2.Quit:　　objIE.Quit　'　? 必要ならイキ 　　Set objIE = Nothing:　　Set objIE2 = Nothing End Sub ' ' 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓
む～ 残念ですがOSが対応していないようですね vistaですとoffice2010です
こんにちは。 > myObj.class ではなくて、 myObj.className なのでは？ プロパティのあるなしで躓くようでしたら、MSHTMLに参照設定なさった方が宜しいかと。 ローカルウィンドウ、オブジェクトブラウザ、なども活用できると 困ることが減らせると思いますよ。 ' ' /// ' ' ■ SHDocVw　参照設定：　Microsoft Internet Controls ' ' ■ MSHTML　参照設定：　Microsoft HTML Object Library Sub Re9094432() Dim strURL As String Dim objIE As InternetExplorer Dim myObj As Object　'　As HTMLAnchorElement 　　strURL = "http://tabelog.com/tokyo/rstLst/washoku/" 　　Set objIE = CreateObject("InternetExplorer.Application") 　　objIE.Visible = True 　　objIE.Navigate strURL 　　Do While objIE.Busy = True Or objIE.ReadyState < 3 　　　　DoEvents 　　Loop 　　For Each myObj In objIE.Document.all.tags("a") 　　　　If myObj.className = "list-rst__rst-name-target js-click-rdlog" Then 　　　　Debug.Print myObj.href 　　　　End If 　　Next 　　objIE.Quit 　　Set objIE = Nothing End Sub ' ' /// 因みに、 　　For Each myObj In objIE.Document.getElementsByClassName("list-rst__rst-name-target js-click-rdlog") 　　　　Debug.Print myObj.href 　　Next みたいに、クラス名で篩に掛けておくようにしてみてもいいかも知れませんね。
もし、「Ｂ」列以外の列には「zz2300」が全く存在しない、そのシートに「zz2300」は１個だけ、なら、 Sub Test_01() MsgBox (Cells.Find(”zz2300”).Row) End Sub だけで、何行目にあるか表示できます。 しかし、他の列に「zz2300」が存在する可能性があるのでしたら、 Sub Test_01() MsgBox (Range("B:B").Cells.Find("zz2300").Row) End Sub Range("B:B")で、「Ｂ」列を範囲指定します。 なお、「test＝Range("b65535").End(xlUp).Row」というのは、エクセルが持っている一番下の行（エクセルに入力可能な最終行）からデータが存在する一番下の行を調べて、その行を「test」に代入しています 例えば、Ａ列縦に「１、２、３」と入っていて、４行目は空白、５行目からまた「５、６」と入っているとします。 このとき、「Range("A1").End(xlDown).Row」とすると、１行目から調べて、空白行が見つかる前の行「３」を返します。 これでは、実際の「６」が返ってこないので、エクセルの一番下の行から上へ調べるのが、 Range("b65535").End(xlUp).Row ですが、エクセルによって、持っている最終行は異なりますので（「65535」はエクセル2003）、数値で指定せず、 Cells(Rows.Count, 2).End(xlUp).Row というように、「Rows.Count」を用います。 これで、エクセルのバージョンに関係なく、また、数値を覚えなくても、すべてのエクセルの最終行が指定されます。 「Rows.Count」の横の「２」は「Ｂ」列のことです。 これで、そのバージョンのエクセルで利用できる最終行から上（xlUp）に向かってRow「行」を調べられます。
こんにちは。お邪魔します。 > もっと平易というか、保守性が高く、無駄のない、可読性に優れたコードが無いものかと ... 人様への返信を引用するのは恐縮なのですが、 そうありたいとは恒に思いつつも中々その通りには出来ない、 という、、、高い理想、である訳で、気後れしそうですが、 私なりに努めて答えを書いてみます。 ただ、「保守性」ということになると「メンテのし易さ」まで慮って、 「無駄のなさ」「可読性」という点でギャップを大きく感じる方も 居られるでしょうから、多分に管理者の個性に頼る面もあり、 相対的になるのはある程度避けられないだろうとは思います。 私なりに書くと、少し保守寄り（？そんなキャラではありませんが自分の職場の基準寄り） になってしまうのかな？と。 なので、解（ほぐ）したいところは適当に手直しを入れて貰えればな、と思いつつ書きました。 > "CRT","CRN"についてはB列の値0の範囲内で、"MRT","MRN"についてはB列の値1の範囲内で このての対応関係を表す、定義（テーブル/辞書）、については、 Excelでは本来、シート上に表現しておく方が保守的ですし設計が簡易になります。 （余談。一昔前ならCustomDocumentProperties、今ならCustomXMLPartsを使う方法もあるようですが、 　それこそ、マクロを読むだけでは気が付かないものになってしまいます） 　　"CRT"　0 　　"CRN"　0 　　"MRT"　1 　　"MRN"　1 という対応関係を解り易くする、というのは、「可読性」に直結するのではないでしょうか。 今回は、Array()関数をネストして上記の表のような要素配列で、 二次元配列を明示的に表現するようにしました。 Excel関数に強い人なら、Evaluateメソッド（またはショートカット）で、 二次元配列を表現する方が簡素な印象はあるでしょうけれど、 誰にでも解るかどうかという点で「可読性」にArray()関数を使っています。 より複雑な処理をする場合なんかは、 CollectionオブジェクトやDictionaryオブジェクトを用いたりすることもあるでしょう。 Classモジュールについては、定義（リスト/辞書）が固定で、コード上で変更するだけなら、 必要はないですね。Typeで宣言したい、という方も居るのかも知れませんが、 却って「可読性」というか、理解され難いものになるのだと思います。 > Cat0,1ともに15個ですので下段の通り現在はMOD関数でカウンター変数の余りを求めて処理していますが、 > あまりいい処理とは思えません。 > つまり、"CRN"が16行目にあるときに実行したら、"CRN"を2行目に持ってくる（"CRT"も同様）、 > MRNが31行目にあるときに実行したら"MRN"を17行目に持ってくる、という感じです。 ここら辺を読む限りでは、 　（Visual Basic とは別の系譜に離れて５年） 　Visual Basic for Applications ユーザーとして、 　そしてExcelカテゴリへの質問であることも合わせて考えると、 お奨めするのは、.Find メソッドを軸に設計することです。 Excel の一般機能[検索]を再現する.Find メソッドでは、 「この次に見つかる」という指示だけで、最下行の次に最上行を追ってくれますから、 ループで（意図を汲み難い）工夫をする必要がない、という一点だけで、 大きく簡素化できます。 また、万が一検索結果がNothingになっていても、 エラートラップよりも簡単なやり方（Nothing判定）で、 エラー回避できる点でも、保守的に読み易く書くことに繋がります。 ご質問について、 もしも、二次元配列変数の演習という意図が含まれているのでしたら、 あらためて補足してみて下さい。 ただ、 セルの値と配列変数のやりとりにループを挟むような方法を 今回の課題については、私なら、選びません（適した場面なら寧ろ積極的な私ですが、、、）。 因みに、ですが、 修飾子mtx-は（段階配列ではない）一次元配列の場合にはあまり使われないかも、です。 Variant型、または、Variant型配列、で宣言する変数の修飾子に、 mtx-を使うのは、私を含めて小数派です。 元々は、アメリカやドイツのサイトで見かけたもので、 一次元なら、ary-やarr-、二次元または段階配列なら、mtx-、 という区別をはっきりさせる意図で使われていたものだと思います。 配列変数を多用する私が拘って、一次元か二次元かを修飾子に表しているだけで、 どちらもary-で表現するのが多数派のようですので、 （もっと言えば、配列であることすら表現しない書き手も普通に多いですし） 一応念の為。 ついでに、Option Base 1 についてですが、 複数セル範囲の値（.Value等）をVariant型に格納する場合は、 放っておいても最小の添え字は 1 になります。 また、Array()関数の場合は、Option Baseに依存、 VBA.Array()関数は、常に 0 オリジンです。 個人的には、Option Base 1 が原因で、 転用されたり、改編された時に、設計意図を汲んで貰えない、という経験が何度か あったので、Option Base を使わず、Option Base に左右されないように書く、 というのが、最近の私の「保守」に対する考え方になりました。 やや蛇足かも、でしたね。 以下、動作確認はしましたが、ニーズに即わない場合はご指摘ください。 シートがどのような状況であっても、 とにかく次を探す、または、見つからなければ（Else以下に追記すれば別ですが）何もしません。 ' ' /// Sub ReW9093999c() Dim Wb As Workbook, Ws As Worksheet Dim rngMarkPos As Range, rngNewPos As Range Dim mtxMkCat As Variant Dim nColDiff As Long, EndRow As Long, iNA As Long ' ' 動作条件変更時の指定修正項目 Const CAT_COL = "B", MARK_COL = "I" 　　Set Wb = ThisWorkbook 　　Set Ws = Wb.Sheets("Sheet1")　'　シートの並び順（Index）での指定は避けたい（保守） 　　nColDiff = Ws.Columns(MARK_COL).Column - Ws.Columns(CAT_COL).Column 　　mtxMkCat = VBA.Array( _ 　　　　　　　　　　VBA.Array("CRT", 0), _ 　　　　　　　　　　VBA.Array("CRN", 0), _ 　　　　　　　　　　VBA.Array("MRT", 1), _ 　　　　　　　　　　VBA.Array("MRN", 1) _ 　　　　　　　　　　) ' ' 以下、修正不可。 　　EndRow = Ws.Cells(Rows.Count, 1).End(xlUp).Row 　　With Ws.Columns(MARK_COL) 　　　　For iNA = LBound(mtxMkCat) To UBound(mtxMkCat) 　　　　　　Set rngMarkPos = .Find( _ 　　　　　　　　What:=mtxMkCat(iNA)(0), After:=.Cells(1), LookIn:=xlValues, LookAt:=xlWhole, _ 　　　　　　　　SearchOrder:=xlByRows, SearchDirection:=xlNext) 　　　　　　If Not rngMarkPos Is Nothing Then 　　　　　　　　Set rngNewPos = .Offset(0, -nColDiff).Find( _ 　　　　　　　　　　What:=mtxMkCat(iNA)(1), After:=rngMarkPos.Offset(0, -nColDiff)) 　　　　　　' Else　'　見つからないなら、、、msg ? 　　　　　　End If 　　　　　　If Not rngNewPos Is Nothing Then 　　　　　　　　rngMarkPos.ClearContents　'　元々のマークした値を消すのはココ！ 　　　　　　　　rngNewPos.Offset(0, nColDiff) = mtxMkCat(iNA)(0)　'　新たにマーク値を設定する 　　　　　　　　Set rngMarkPos = Nothing:　　Set rngNewPos = Nothing 　　　　　　' Else　'　見つからないなら、、、msg ? 　　　　　　End If 　　　　Next iNA 　　End With End Sub ' ' ///
B1: =LEFT(A1,MIN(FIND({"市","区","郡"},A1&"市区郡"))) C1: =SUBSTITUTE(A1,B1,"")
>タイトルが長くて1行で書くこと出来ません。 タイトルの枠組みは横幅が足りないとき折り返して複数行にできます。 強制的に改行（Enterキー）すれば行を増やせます。 >フォントサイズを小さくするとか、2行に書き改める以外に、タイトルの長さを少し長くしたいのです。 グラフのプロット幅を超えるタイトル枠は作成できませんのでテキストボックスをグラフに重ねる方法で対処してください。
>折れ線グラフを作成しています。 >横（項目）軸に、製品の各々のロット番号を付したいのですが、代表数字しか記載されていません。 状況から判断してX軸（横軸）が数値としてプロットされているようです。 グラフの種類が散布図になっていると思われますので折れ線グラフに変更すると良いでしょう。 X軸の書式でテキストにすれば数値ではなく文字列として扱われますのでロット番号が等間隔で表示されるようになります。
>「年齢層または性別が無記入」をどう処理すればよいのでしょうか。 COUNTIS関数の中でOR関数を使うことができませんのでCOUNTIFS関数+COUNTIFS関数のような方法で条件に合うカウント数を加算してください。 尚、年齢層と性別が双方共空欄のカウントはどうしますか？ 貼付画像はExcel 2013で検証した結果です。 次の数式は年齢層と性別の双方がブランクもカウントできるようにしました。 G24=COUNTIFS(G$2:G$14,1,$B$2:$B$14,"",$C$2:$C$14,"<>")+COUNTIFS(G$2:G$14,1,$C$2:$C$14,"",$B$2:$B$14,"<>")+COUNTIFS(G$2:G$14,1,$B$2:$B$14,"",$C$2:$C$14,"") G24セルを右へ必要数コピーしてください。 但し、行番号は質問で提示の行数となっていますので必要に応じて変更してください。
こんにちは 1列余分になっちゃいますけど、Ｅ列を作業列としてます。 セルＢ1に =IF(MID(A1,4,1)="県",LEFT(A1,4),LEFT(A1,3)) セルＥ1に =MID(A1,LEN(B1)+1,150) セルＣ1に =IF(ISERROR(FIND("大和郡山市",E1))=FALSE,"大和郡山市",IF(ISERROR(FIND("四日市市",E1))=FALSE,"四日市市",IF(ISERROR(FIND("廿日市市",E1))=FALSE,"廿日市市",IF(ISERROR(FIND("郡山市",E1))=FALSE,"郡山市",IF(ISERROR(FIND("市原市",E1))=FALSE,"市原市",IF(ISERROR(FIND("郡上市",E1))=FALSE,"郡上市",IF(ISERROR(FIND("蒲郡市",E1))=FALSE,"蒲郡市",IF(ISERROR(FIND("小郡市",E1))=FALSE,"小郡市",IF(ISERROR(FIND("市川市",E1))=FALSE,"市川市",IF(ISERROR(FIND("郡",E1))=FALSE,LEFT(E1,FIND("郡",E1)),IF(ISERROR(FIND("市",E1))=FALSE,LEFT(E1,FIND("市",E1)),IF(ISERROR(FIND("区",E1))=FALSE,LEFT(E1,FIND("区",E1)),IF(ISERROR(FIND("町",E1))=FALSE,LEFT(E1,FIND("町",E1)),IF(ISERROR(FIND("村",E1))=FALSE,LEFT(E1,FIND("村",E1)),"")))))))))))))) セルＤ1に =SUBSTITUTE(SUBSTITUTE(A1,B1,"",1),C1,"",1) 合併とか市町村名変更とかあるとメンテが大変かと思います。
　1つに纏めた後の表におけるデータが並んでいる順番が、行番号が小さい順になる方法です。(念のためにコピーしたシートで試す様にして下さい) エクセルシートの列の中で、表が存在している全ての列を纏めて選択 　　↓ Excelウインドウの左上の辺りにある[ホーム]タブをクリック 　　↓ 現れた「編集」グループの中にある[並べ替えとフィルター]ボタンをクリック 　　↓ 現れた選択肢の中にある[フィルター]をクリック 　　↓ 現れた複数の「▼」印のボタンの内、「日付」欄の上にあるボタンをクリック 　　↓ 現れた選択肢の中にある[日付フィルター]にカーソルを合わせる 　　↓ 現れた選択肢の中にある[ユーザー設定フィルター]をクリック 　　↓ 現れた「オートフィルターオプション」ダイアログボックスの中にある[OR]と記されている箇所をクリックしてチェックを入れる 　　↓ 「オートフィルターオプション」ダイアログボックスの右端にある欄を上下2ヶ所とも「と等しい」に設定する 　　↓ 「オートフィルターオプション」ダイアログボックスの左側に上下2ヶ所並んでいる欄の内、片方に *? と入力し、もう片方は何も入力されていない状態とする 　　↓ 「オートフィルターオプション」ダイアログボックスの中にある[OK]ボタンをクリック 　　↓ フィルターがかかっている状態でも表示されている行の内、「『1番上の項目欄の行』のすぐ下の行」から「『表の枠線が引かれているセルを含んでいる行』の内、最も下の行」にかけての全ての行を纏めて選択 　　↓ 選択されている行をまとめて削除 　　↓ 「編集」グループの中にある[並べ替えとフィルター]ボタンをクリック 　　↓ 現れた選択肢の中にある[フィルター]をクリックし、オートフィルタ―を解除
ご相談の直接の回答として、例えば次の資料のように操作してセルにリンクしたメモをグラフのデータラベルに表示させます。 http://ciao.aoten.jp/ciao/2012/02/post-fd1c.html ご利用のエクセルの２００７では、一つ一つのデータラベルに対してリンクするセルを設定していくような段取りとなります。 ちなみにエクセル２０１３では、エクセルの操作によって一括で操作ができるようになりました。 参考： http://hamachan.info/win8/excel/label.html あとはまぁ余談になりますが、ちなみに添付図は折れ線グラフを複合グラフにしてイベントの「縦棒」を表現しています。 判りやすいように第二軸の縦横軸ラベルを表示していますが、実際にはこれらは表示をしない設定にしておきます。 この複合グラフの作成方法が判らないときは、その旨別途のご相談を投稿してください。 マクロを使って主横軸の表示範囲を調整しているという事で、そのマクロに追加して第二横軸の表示範囲も同時に調整してください。
　今仮に、基準となる日付が入力されているセルがB4セルであり、何年後かを指定する値を入力するセルがF4セルであるものとします。 　まず、G4セルに「年間」と入力しておく事で、F4セルに入力する値は「1年間」、「2年間」、「3年間」ではなく、1、2、3の整数値となる様にして下さい。 　次に、【１年・２年・３年】後の日付を表示させるセルの書式設定の表示形式を、[日付]の 平成13年3月14日 か、或いは[ユーザー定義]の ggge"年"m"月"d"日" に設定して下さい。 　その上で、【１年・２年・３年】後の日付を表示させるセルに次の関数を入力して下さい。 =IF(AND(COUNT($B4,$F4)=2,$B4>1,$F4>=0,INT(SUM($F4))=$F4),EDATE($B4,$F4*12),"")
新たに、最大化の状態でシートにパスワードをかけてファイルを作り試してみてください。
B1 =DATE(A1,8,15)-CHOOSE(WEEKDAY(DATE(A1,8,15)),4,0,1,2,1,2,3) B2 =B1+1 B3 =B2+1 式の解説 B1では「８月１５日」を基準に「土日以外の３日間が何日前から始まるか？」を計算しています。 つまり「８月１５日が何曜日か？」を見て、８月１５日が日、月、火、水、木、金、土のどれかによって「日曜なら４日前から」「月曜なら０日前から」「火曜なら１日前から」「水曜なら２日前から」「木曜なら１日前から」「金曜なら２日前から」「土曜なら３日前から」を計算しています。 B2は「B1の次の日」なので、単純に「B1+1」で良いです。 同様にB3は「B2の次の日」なので、単純に「B2+1」で良いです。
> 画像を小さく張り付けているので、 > 解像度も同時に小さくなっています。 > 解像度をそのままで貼り付けはできそうですか？ > こちらも試しましたが、 > やはり、画像解像度かなり小さくなってしまいました。 > なにとぞよろしくお願いします。 画質を重視しているのなら、そうと分かるように タイトルや質問本文を書いておいた方が良かったですね。 技術的には似て非なるもので、私にとっては守備範囲外のジャンルですから、 その課題に応えるに相応しい識者に委ねたいところですが、 一応、私なりの答えは用意しました。 もし解決に至らなかったとしたら、 質問を建て直して、専門的な情報を持った方の眼に触れ興味を引き易いように。 工夫した方が解決の可能性は高まるかと思います。 > 画像を小さく張り付けているので、 > 解像度も同時に小さくなっています。 小さく貼り付けたせいで画像が圧縮され、解像度が低くなる、 という意味で仰っているのなら、 Excelデフォルトの設定では、そういう仕様です。 つまり再び原寸に戻しても元の画質からの劣化が著しいという意味ですよね？ 　[詳細設定] 　　[イメージのサイズと画質]　　（←ブック限定の設定） 　　　[ファイル内のイメージを圧縮しない]　にチェック 　　[印刷]　　（←Excelの設定） 　　　[グラフィック用の印刷モード]　にチェック まずはオプション設定を確認、または変更してください。 ソースが.jpg ですから、 編集（トリミングやリサイズ、縦横比変更）、保存する 都度都度、ファイルは圧縮されていくことはExcelだけの問題でもなくて 程度の差はあれど圧縮は起きる、という風に私は理解していますけれど。 また、Excelが自動で画像を極端なレベルで圧縮するのは、 ファイルサイズの肥大化を敬遠する方が多いという背景があってのことだと思います。 画質とファイルサイズの最適化は、ある意味でバーターですね。 不得手なジャンルですので、時間を限ったの中で見つけただけの暫定回答ですけれど、 上述のオプション設定を事前に済ませた上で、 ImageコントロールにLoadPictueして、 CopyPictueして、[図 (拡張メタファイル)]として貼付けてみました。 紙に印刷まではしていませんが、PDFに出力した際の目視の判断では、 こちらでの環境である程度の改善がみられるように思われます。 どの程度のことを期待されているのかにもよると思うのですが、 うまく行かなかったとしても、すみません、今の私にはここまで、です。 解決に近づけることを祈っています。 ' ' /// Sub Re9090551img2meta() Dim oImage As OLEObject Dim fName, x, y Dim i As Long 　　fName = Application.GetOpenFilename("JPG, *.jpg", MultiSelect:=True) 　　If IsArray(fName) Then 　　　　Application.ScreenUpdating = False 　　　　With Cells(3, "B") 　　　　　　.Select 　　　　　　x = .Width * 2:　　y = .Height * 6 　　　　End With 　　　　With ActiveCell 　　　　　　Set oImage = ActiveSheet.OLEObjects.Add( _ 　　　　　　　　ClassType:="Forms.Image.1", Link:=False, DisplayAsIcon:=False, _ 　　　　　　　　Left:=.Left, Top:=.Top, Width:=x, Height:=y) 　　　　End With 　　　　With oImage.Object 　　　　　　.AutoSize = True 　　　　　　.BackStyle = 0　'　fmBackStyleTransparent 　　　　　　.BorderStyle = 0　'　fmBorderStyleNone 　　　　End With 　　　　For i = 1 To UBound(fName) 　　　　　　oImage.Object.Picture = LoadPicture(fName(i)) 　　　　　　DoEvents: DoEvents 　　　　　　oImage.CopyPicture 　　　　　　ActiveSheet.PasteSpecial _ 　　　　　　　　Format:="図 (拡張メタファイル)", _ 　　　　　　　　Link:=False, _ 　　　　　　　　DisplayAsIcon:=False 　　　　　　With ActiveSheet.Shapes 　　　　　　　　With .Item(.Count) 　　　　　　　　　　.Width = x:　　.Height = y 　　　　　　　　End With 　　　　　　End With 　　　　　　Cells(i * 7 + 3, "B").Select 　　　　Next i 　　　　oImage.Delete 　　　　Application.ScreenUpdating = True 　　End If End Sub ' ' ///
＞て、事は ＞Average = Evaluate("AVERAGE(" & CStr(リスト) & ")") ＞ですかね？ Variant型の動的配列には、CStr()は使えません。上記のようにしても「型が一致しません」が出ます。 わざわざforループで回して、いちいち面倒臭く文字列変数に文字列を作っているのは「一気にCStrで変換出来ないから」です。 また、CStrは「単一の変数を文字列として関数に渡す場合」に使用し、普段は使いません。 ・単一の変数を文字列として関数に渡す場合 Dim val As Variant Dim ans As Variant val = cells(1,1) '中身はどんな型か判らない 'そのまま「MyFunction(val)」では「文字列になってくれない」のでCStrが必要。 ans = MyFunction(CStr(val)) 'MyFunctionは引数に文字列型を要求する ・CStrが不要な場合 Dim val As Variant Dim ans As Variant val = cells(1,1) '中身はどんな型か判らない '文字列定数に連結し段階で「式が文字列になる」ので、CStrは不要 ans = MyFunction("(" & val & ")") 'MyFunctionは引数に文字列型を要求する 「&演算子」で連結する場合、CStrが無くても正しく文字列に変換されるし、CStrは「呼び出すと処理が重い」ので、式に&演算子を含む場合は、CStrは呼ばなくても良いです。
　以下の様なマクロは如何でしょうか。 Sub QNo9090316_エクセルのマクロで全シート複数条件検索() Const ConditionSheetName As String = "Sheet3", FirstConditionRow As Long = 2, _ ConditionColumn As String = "B", SearchColumn As Long = 2, FirstOutputRow As Long = 1 Dim ConditionSheet As Worksheet, OutputSheet As Worksheet, _ LastConditionRow As Long, NotApplicable As Boolean, _ FindCell As Range, c As Range, i As Long, j As Long, k As Long If IsError(Evaluate("ROW('" & ConditionSheetName & "'!A1)")) Then MsgBox "検索条件が入力されているシートとして設定されている" _ & vbCrLf & vbCrLf & ConditionSheetName & vbCrLf & vbCrLf & _ "というシート名のシートが見つかりません。" & vbCrLf _ & "マクロを終了します。", vbExclamation, "存在しないシート" Exit Sub End If Set ConditionSheet = Sheets(ConditionSheetName) LastConditionRow = ConditionSheet.Range(ConditionColumn & Rows.Count).End(xlUp).Row If LastConditionRow <= FirstConditionRow Then MsgBox ConditionSheetName & "の" & ConditionColumn _ & "列に検索条件が入力されておりません。" & vbCrLf _ & "マクロを終了します。", vbExclamation, "条件未指定" Exit Sub End If With Application .ScreenUpdating = False .Calculation = xlManual End With Sheets.Add After:=Sheets(Sheets.Count) Set OutputSheet = Sheets(Sheets.Count) i = FirstOutputRow For Each c In ConditionSheet.Range(ConditionColumn & FirstConditionRow _ & ":" & ConditionColumn & LastConditionRow) If c.Value <> "" Then For j = 1 To Sheets.Count - 1 If j <> ConditionSheet.Index Then k = 0 With Sheets(j).Cells(Rows.Count, SearchColumn).End(xlUp) Set FindCell = .EntireColumn.Resize(.Row). _ Find(c.Value, , xlValues, xlWhole, xlByColumns, xlNext, False, False, False) End With NotApplicable = FindCell Is Nothing Do Until NotApplicable L = L + 1 k = FindCell.Row If FindCell.Column = SearchColumn Then FindCell.EntireRow.Copy OutputSheet.Cells(i, 1).PasteSpecial _ xlPasteValuesAndNumberFormats, xlNone, False, False i = i + 1 Set FindCell = Sheets(j).Cells.FindNext(After:=FindCell) End If NotApplicable = FindCell.Row <= k Loop End If Next j End If Next c If i = FirstOutputRow Then Application.DisplayAlerts = False OutputSheet.Delete Application.DisplayAlerts = True MsgBox "検索条件を満たしているデータは見つかりませんでした。" _ & vbCrLf & "マクロを終了します。", vbExclamation, "該当データ無し" End If Set c = Cells.Find("", ActiveCell, xlFormulas, _ xlPart, xlByRows, xlNext, False, False, False) With Application .Calculation = xlCalculationAutomatic .ScreenUpdating = True End With End Sub
判らないことがいろいろあります。 >エクセルでマクロを作成し 作成したExcelのバージョンは幾つですか？ >そのファイルをOneDriveに保存し利用していますが OneDrive上でブラウザを通して編集しているのですか？都度ダウンロードしてローカルなPCにインストールされたExcelで編集しているのですか？ >いずれかのタイミングでボタンが消えてしまいます 「いずれか」とはどことどこを指すのでしょう？ また、OneDrive上ではなく、ローカルに保存した場合でもボタンが消えますか？ >これはなぜでしょう。 上記の作業の環境・状況が判らないので何とも言えませんが、Office Onlineではマクロが作成できないという制限付きだから ということは考えられませんか？ 例えば、2003まで等の古い書式で作成したシートをOneDrive上に保存すると、そのファイルをブラウザでクリックした時点で新しい書式に変換されてしまいます。そこでOnlineのExcelで開いてしまうと…と言うことではないでしょうか？ 参考） https://technet.microsoft.com/ja-jp/library/excel-online-service-description.aspx >Excel Online では VBA を使用してマクロを作成することはできませんが、 >ファイルに含まれる VBA を削除 (または破損) しなくても、VBA が有効な >スプレッドシートを開いて編集することは可能です。 これは私の周辺での話ですが… Office OnlineなどのCloud絡みのサービスが開始されてから、操作や互換性の面で混乱している方が私の周辺にも多いです。なのでCloudの基本的な仕組みを理解していない方・理解しようとしない方には私はあまりOneDriveをお勧めしていません。そのような方にとっては、OneDriveはoffice関連のファイルを保存するプラットフォームとしては解りにくいのです。違いや仕組みを理解して使用できる方には非常に便利なのですが…。
こんにちは。 > ColumnDifferencesメソッドの引数ComparisonはVariant型のようですが、文字列を指定することはできないのでしょうか？ 少なくとも、文字列値を基準に列範囲を切り分けることは出来ません。 ComparisonはRange型専用 （改めて訊かれると詳しく調べた訳ではないので自信が揺らぎますが） と考えておいていいと思います。 Range型として受け取ることの出来るオブジェクト、 というような意図でそうした仕様になっているのでしょうが、 古めのＶＢＡのメソッドには、特に理由も見当たらないのに オブジェクト型引数をVariant型にしていることが多々ありますね。 元々はExcelの一般機能をＶＢＡから呼び出せるようにしたものですから、 列範囲を選択して、ショートカット Ctrl+Shift+| キーを押したタイミングの、 アクティブセルにあたるのが、引数Comparisonですので、値を指定する余地は無いような。 例外を挙げるなら、 selection.ColumnDifferences(null).select を実行すると、アクティブセルを無視して、 選択範囲の先頭セルがComparisonになりますから、 もしかしたらNull値を受け取る為のVariant型だったのかなぁ？とか。 それならObject型やRange型ではない、という理由の説明としては十分のような。 該当するオブジェクトが無い場合にエラーを返すメソッド の扱い方として基本通りのやり方として、２通り、 用途に合わせて使い分けてみて下さい。 勿論、単に 　　On Error Resume Next だけでも用途によっては十分というケースもあると思います。 ' /// Dim rng As Range 　　Set rng = Range("A1:A100") 　　On Error Resume Next 　　Set rng = rng.ColumnDifferences(rng(2)) 　　If Err.Number <> 0 Then 　　　　MsgBox "ないよ！" 　　Else 　　　　rng.EntireRow.Delete 　　End If 　　On Error GoTo 0 ' /// ' /// Dim rng As Range Dim rng2 As Range 　　Set rng = Range("A1:A100") 　　On Error Resume Next 　　Set rng2 = rng.ColumnDifferences(rng(2)) 　　On Error GoTo 0 　　If Not rng2 Is Nothing Then 　　　　rng2.EntireRow.Delete 　　Else 　　　　MsgBox "ないよ！" 　　End If ' /// （MsgBoxは仮設） range.ColumnDifferences メソッドは私も良く使いますが、 設計時によく迷う他の方法として、 　AutoFilterで抽出後に表示・非表示の差分に対して処理（削除）する方法 　セル範囲にフラグを出力しておいて、.SpecialCells()で切り分けて処理（削除）する方法 　　フラグを２種類のデータ型　　[数値or文字列、 数値orエラー値、論理値or数値、、、] 　　の組合わせで建てておけば、range.SpecialCells(Type, Value)の引数Valueに [xlErrors,xlLogical,xlNumbers,xlTextValues]を指定して判別出来るので、.EntireRow.Delete などがあります。 　前者は、抽出の前後で表示行数に変動があるかどうか、 　後者は、該当するオブジェクトが無い場合にエラーを返すので、 　　.ColumnDifferences同様エラートラップで、判別します。 　　フラグの方でよく使うのは、 　　　=(条件式)/1 みたいなExcel数式をセルに計算させておいて、 　　　数値orエラー値で切り分けるとかですね。 　　　場合によっては、二次元配列に格納したものを出力するとか、 　　　Evaluateメソッドで丸ごと計算させる場合もあります。 いずれの方法でも、XL2010でしたら、ご承知のように、 ソートしてから削除するのが処理速度的にベターです。 ２種の値だけを切り分ける目的でしたら、ソートした上で、 下方に位置する値の先頭行をrange.Findメソッドで取得して、 以降の行を削除する手もあります。 range.Findメソッドの場合は、 該当するオブジェクトが無い場合にもエラーにはなりませんから、 　　If Not Is Nothing Then　みたいな判別だけで、 エラートラップ無しでも行けます。 エラートラップというと腰が引けちゃう人結構いるみたいですが、 エラーを放置して実行時エラーで処理が中断するこは問題になりますが、 エラートラップについては、オブジェクトを扱う以上は扱いに熟れた方がいいです。 野菜も食べましょうね！的なニュアンスで、これは閲覧者さん向けのメッセージです。 実例を見れば、もう少し絞り込んだ提案も出来ると思いますが、一般論として、 とりあえず、以上です。 何か不足、不明があれば、遠慮なくお尋ねください。
=IF(COUNT(B1:B10)=10,AVERAGE(B1:B10),"数値未入力")
　今仮に、 >フリーソフトからエクセルに吐き出されたシート とはSheet1であるものとし、Sheet3のA列とB列を作業列として使用して、Sheet2に科目ごとの勉強時間の合計を集計するものとします。 　まず、Sheet3のA2セルに次の関数を入力して下さい。 =IF(INDEX(Sheet1!$A:$A,ROW())="","",IF(COUNTIF(Sheet1!$A$1:INDEX(Sheet1!$A:$A,ROW()),INDEX(Sheet1!$A:$A,ROW()))=1,ROW(),"")) 　次に、Sheet3のB2セルに次の関数を入力して下さい。 =IF(COUNT(INDEX(Sheet1!$B:$E,ROW(),))=4,IF(ISERROR(1/(INDEX(Sheet1!$B:$B,ROW())=TEXT(INDEX(Sheet1!$B:$B,ROW()),"yyyy/m/d")/(INDEX(Sheet1!$B:$B,ROW())>=1))/(INDEX(Sheet1!$C:$C,ROW())=TEXT(INDEX(Sheet1!$C:$C,ROW()),"h:m:s")+0)/(INDEX(Sheet1!$D:$D,ROW())=TEXT(INDEX(Sheet1!$D:$D,ROW()),"yyyy/m/d")/(INDEX(Sheet1!$D:$D,ROW())>=1))/(INDEX(Sheet1!$E:$E,ROW())=TEXT(INDEX(Sheet1!$E:$E,ROW()),"h:m:s")+0)),"",IFERROR(TEXT(SUM(INDEX(Sheet1!$D:$E,ROW(),))-SUM(INDEX(Sheet1!$B:$C,ROW(),)),"[h]:m:s")+0,"")),"") 　次に、Sheet3のA2～B2セルをコピーして、Sheet3のA列～B列の3行目以下に貼り付けて下さい。 　次に、Sheet2のA2セルに次の関数を入力して下さい。 =IF(ROWS(A$1:A2)>COUNT(Sheet3!$A:$A),"",INDEX(Sheet1!$A:$A,SMALL(Sheet3!$A:$A,ROWS(A$1:A2))))。 　次に、Sheet2のB2セルに次の関数を入力して下さい。 =IF($A2="","",TEXT(SUMIF(Sheet1!$A:$A,$A2,Sheet3!$B:$B),"[h]:m:s")+0) 　次に、Sheet2のA2～B2セルをコピーして、Sheet2のA列～B列の3行目以下に貼り付けて下さい。
追記。 Excel2013以降のバージョンの場合は、以下の記事を参照して下さい。 https://support.office.com/ja-jp/article/%E5%A4%96%E9%83%A8%E5%8F%82%E7%85%A7-%E3%83%AA%E3%83%B3%E3%82%AF-%E3%81%AE%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B-21e995b5-bab1-4328-8ab3-dd357fe0e653 （書いてあることはほぼ一緒です）
こんにちは Sub test() Dim a As Variant Dim d As Variant a = Array(1, 2, 3, 4, 5) d = test_func(a) Debug.Print d End Sub Function test_func(v As Variant) As Variant Dim i As Long For i = LBound(v) To UBound(v) test_func = test_func + v(i) Next End Function とか、ParamArray 使うとかかと思いますけど、配列数式を与えるという 配列数式とはどのようなものですか？
回答No.3の関数にタイプミスがありました。 =SUMPODUCT(MID(A1:A10,3,1)="1")*1) 　　　　　↓ =SUMPRODUCT(MID(A1:A10,3,1)="1")*1)
C列のセルに、 =IF(DATEDIF(A1,TODAY(),"M")>=5,"○","×")
「自動入力」とうのが「単に計算結果を表示する」でいいなら =EDATE(A1,24) 表示形式を日付に。
＞》 調べる範囲に数値しか含まれないなら、min/minA、 ＞》 max/maxA、どちらを使うのも好み、… ＞それって正しくないのでは？ ＞調べる範囲に数値だけでなく、文字列セルが混在していても、どちらも使えるでしょ？ 補足すると、 →調べる範囲に数値しか含まれないなら、(結果は同一だから) min/minA、max/maxA、どちらを使うのも好み と書いたわけです。 文字列セルを含む可能性があるなら、 →(結果が違ってくるから) min/minA、max/maxAを、自分の都合のいいように使い分けなければならない。 ということになります。 「文字列セルをゼロ扱いする」というのは、一般的な使用においては不都合なことが多いでしょうから、普通はmin() max()だけ使っておけばいいんじゃないかと、正直、思います。 でも、minA() maxA() を活用できる例として何かないかと頭をひねったのが 回答No.2の中段、ということになったんですけども…。
D2セルに下記の計算式を入力してください。 =IF(SUMPRODUCT(($A$2:$A$30=A2)*($B$2:$B$30=B2)*($C$2:$C$30<>0))<>0,B2,"") D3以降はD2セルをドラッグしてコピーしてください。 なお、行番号３０までの対応となっていますので、それ以上ある場合は計算式中の「30」を変更して下さい。
