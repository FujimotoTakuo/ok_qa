初心者向けとあり、またマクロをまず学んで、その後にVBAに入っていくような構成みたいですので、質問者さんが今は区別が付かなくても大丈夫かと思います。 本のタイトルに10日間でとありますが、10日間で終わらないといけないという考えは持たずに、じっくりと理解できるようにすればよいかと思います。 また一冊だけでは全ての理解はできないと思いますので、この本を読み終わった後に別の本を購入してみるといいかと思います。 わからない所があればこちらで質問されるのも良いかと思います。 頑張ってください。
og:imageなどメタタグ<meta> はOpen Graph Protocolといわれるものです。 メタタグ自体は拡張して使えるはずなので、なんら問題はないです。 SEOのためのhtml構文チェッカーが対応してないために構文チェックに引っかかっているのだと思います。 実際、SEOでも最高の強さを持ってるYahoo!でも使われてます。
「"shikaku"の部分の文字列」が何を指しているか質問文からははっきりしませんが(「部分」てどこ？)、おそらくその属性値を持つ要素の値の「応用」や「基本」などですよね？ であれば、問題点はMessageBox.Show()の引数部分にあたる所かと思います。 ループ内の変数「shikaku」はvalue要素自体を表すオブジェクトなので、「(string)shikaku.Element("shikaku")」としてしまうとvalueのさらに子の「shikaku」要素値を取得しようとしてしまいます。 # 「<value type="shikaku"><shikaku>XXXXX</shikaku></value>」のようなXML構造から取得する場合の記述になっている。 value要素自体の値を取得したいのだと思うので、単に「(string)shikaku」が正しいかと思います。 質問文末尾の「すべての文字列を取得する方法」というのはちょっと意味がわかりませんのでスキップします。 # 「<?xml ....</staff_list>」までの全ファイル内容をstringに読み込みたいならば、 File.ReadAllText() が利用出来ますが。 ついでに余計なことかもしれませんが、「クエリ式」方式でLINQを利用されているようですが、当方の個人的な意見としては「メソッドチェーン」方式でLINQを使う方が書きやすく、読みやすく、保守しやすいように思います。 たとえば、(あまり実用上意味はないかもしれませんが)全staffのshikakuを重複するものをまとめて一覧化する、という場合は以下のような。 var xmlDoc = XDocument.Load(@"path/to/file.xml"); var allShikakus = xmlDoc.Root .Elements("staff") .Elements("value") .Where(elem => (string)elem.Attribute("type") == "shikaku") .Select(elem => (string)elem) .Distinct(); もうひとつ細かい点ですが、Attributeを参照する際には、.Valueプロパティを使うともしも属性が無い要素があるとNullReferenceExceptionになってしまうので、上記のようにキャストして属性値取得するほうが便利かと思います。
//item[text()='Name']/../value でしょうか。VBでXMLパースをしたことが無いので、これ以上はわかりません。
MSXMLを使用することになると思います。 参考ページ http://wiki.mesolabo.com/?%E3%83%A1%E3%82%BD%E3%81%A7%E3%82%82%E3%81%A7%E3%81%8D%E3%82%8B%2FWSH%E8%AC%9B%E5%BA%A7%2F%E7%AC%AC7%E7%AB%A0
<?xml version="1.0" encoding="UTF-8"?> <data> ××××<a hide="hide">○○○○○<c>*****</c>○○○</a>・<a>◎◎◎◎◎<b hide="hide">●●●</b>▲▲▲▲</a>△△△△ </data> ================================== <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"> <test> <xsl:apply-templates /> </test> </xsl:template> <xsl:template match="*"> <xsl:choose> <xsl:when test="count(@hide) > 0"> </xsl:when> <xsl:otherwise> <xsl:apply-templates /> </xsl:otherwise> </xsl:choose> </xsl:template> </xsl:stylesheet> ============結果===================== <?xml version="1.0" encoding="UTF-8"?> <test>××××・◎◎◎◎◎▲▲▲▲△△△△</test> ===================================== * 特に指示がなかったので、c要素のように「その要素自身にはhide属性はないが、その親にhide属性がある」ような要素は内容を表示しないことにした。特に指示がなかったので、その要素の名前空間(接頭辞がない奴)以外の「接頭辞のある属性」についてはhide属性としては扱わないものとしている。(今後指示がついてもやらないけど) * 今考えると、xsl:apply-templatesのselect属性に指定するXPathで、hide属性のない要素だけが対象となるようにしてもよかったかも、とも思うがまぁいいや。
はい。従来のIEは標準でなかったので 　⇒XSLT の互換性の変更点 (Windows)( http://msdn.microsoft.com/ja-jp/library/ie/hh180178(v=vs.85).aspx )
多分、単純に画像へのpathが通って無いだけだと思うけど…。 今の引越し後の新サイトに実在する画像のURLと、その表示されてない空白になってる画像部分のimgタグを見比べてみて、その差異を修正すれば良いです。 過去記事が少ない（30未満）なら手打ちでOKでしょうが。100超える様なら、何かツールを使った方が良いですね。その何とかってインポートツールは良く知りませんが、ツールのみだとなかなか完璧に全てのデータを修正し切れないので。後で人の手で細かい修正が必須になります。
以下の資料が参考になると思います。 http://www.ibm.com/developerworks/jp/xml/library/x-tipsub/index.html http://d.hatena.ne.jp/tacohachi/20090129/p1 私自身は、質問のような用途であれば属性のほうが好 みです。ファイルの中身を確認するときに、圧倒的に 読みやすいので。 (開発中はファイルに書き込まれたデータを直接確認する こともたびたび発生しますが、要素で書かれているとデー タが縦に長くなるので、とても読みにくいんですよね…) 属性の名前は、後で判らなくならないレベルで付ければ 良いかと。x でも posX も結局『独自の属性名』ですから あまり気にすることはありません。
よくわからんけど、こういうこと？ import lxml.html root = lxml.html.fromstring(r'''<html> <body> <h2>hello world</h2> <h2>foo <em>bar</em> baz</h2> </body> </html>''') res = root.xpath('//h2') print res[1].text # foo print res[1].text_content() # foo bar baz print res[1][0].text # bar print res[1][0].tail # baz 名前空間うんぬんの件はよく意味がわからない。 HTMLを処理しようとしてるんじゃないの？
XMLDocument.LoadXMLに先立って、正規表現でも使ってスキーマの行を削除してしまえばいいのでは？ それ以前に、スキーマのとおりにXML文書が作られていないところに問題があると思いますが。
XMLはマークアップ言語ですから、お好きなタグを・・ <doc> 　<situmon> 　　<danraku> 　　　これは何のタグですか？ 　　</danraku> 　　<danraku> 　　　何かユーザー定義のものでしょうか。リファレンス等で調べても出てきませんでした。 　　</danraku> 　</situmon> ・・・とか・・御随意に・・ たのしいXML: XML/XHTML入門ページです( http://www6.airnet.ne.jp/manyo/xml/index.html ) 　このあたりとか読むと良いでしょう。
スタイルシートは何をお使いでしょうか？ XSLTでしたら、 <xsl:template match="LineBreak"> <br /> </xsl:template> CSSでしたら、内容がない要素なので内容の追加は出来ませんので Linebreak+*:before{content:"\A";disp;ay:block;white-space:pre;} になるでしょう。
多くのスクリプト言語にsimple_xmlというモジュールがあります。 基本的にはXMLの構造をそのまま読み込んでくれますので、ほとんど何も考えずに必要なデータを取り出せます。 PHP使いではないので詳しくはわかりませんが、このあたりを参考に http://php.net/manual/ja/simplexml.examples-basic.php
何故出力されないのかはわからないですが、xsl:chooseを使うのはどうでしょうか？ <xsl:choose> <xsl:when test="式"> テンプレート </xsl:when> …… xsl:when 要素の繰り返し …… <xsl:otherwise> テンプレート </xsl:otherwise> </xsl:choose> で、whenにtrueを、そうでないその他をotherwiseで処理出来ます。
sgrep（構造化grep）というソフトが使えるかもしれません。質問の例をcorpus.txtという名前でテキストファイルに保存して、コマンドラインから次のように検索すれば sgrep '"<neg>" .. "</neg>" in ( "<speaker=\"John\">" .. "</speaker>" in ("<dialogue>" .. "</dialogue>"))' corpus.txt 結果が標準出力に次のように出力されます。 <neg>NOT</neg> 件数を知るにはこれをリダイレクトして、行数を他のソフトでカウントすれば良いかと。
XmlDocument doc = new XmlDocument(); doc.Load(new StringReader(文字列)); あるいは直接URLから読むのが手っ取り早い doc.Load("http://～");
http://search.yahoo.co.jp/search?b=1&n=10&ei=UTF-8&fr=ie8sc&p=%22XML%22+%22%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%83%8E%E3%83%BC%E3%83%89%22 http://search.yahoo.co.jp/search?p=%22XML%22+%22%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E7%A8%AE%E9%A1%9E%22&aq=-1&oq=&ei=UTF-8&fr=ie8sc&n=10&x=wrt ですよね。どのようなノードがあるか、階層があるのか、あなたが探る必要がありますね。 ＞値を保持してる・ http://www.atmarkit.co.jp/fxml/rensai2/xmlmaster12/master12.html Xpath を理解すれば、ノードに対する考え方も、言い方も代わってくるでしょう。確かにフォーマットからすると、ちょっと違う言い方があるかもしれないが、「保持」とは変更が在ることが期待されての言葉だと思う。
新しいときは、　#006400　DarkGreen 古くなってくると、#008080　Teal くらいかな～と思います。
Windows7 Home 32bit版で動いてるなら、 その動いているXalan環境フォルダごと、 たとえばUSBメモリなどにいったんコピーして、 それを、今度はWindows7 Home 64bit版の 同じフォルダ位置にコピーして、 Pathをつなげば、たぶん動くのでは？ （おそらくWindows7 Home 32bit版上で 　圧縮ファイルを解凍したものであれば、 　エラーなく動くはず・・・）
わからないときは、仕様で確認するといいかも。 「select 属性が無いときは、カレントノードの全ての子ノード」ってかいてあったよ？ 5.4 Applying Template Rules - XSL Transformations (XSLT) → http://www.w3.org/TR/xslt/#section-Applying-Template-Rules 「In the absence of a select attribute, the xsl:apply-templates instruction processes all of the children of the current node, including text nodes.」 だから、 select="node()" の省略とみなして、いい気がする。
output method="xml" だと <element></element> は <element/> と等価だから xslt からは制御はできないよ？ そういう出力を強制するオプションを持つ処理系を使うとか。 無理やりやるとしたら xsl:comment かな？ 処理系によるけど。。。 ■ 検証用ファイル [q7574909.xml] <?xml version="1.0" encoding="UTF-8"?> <root>   <textnode>text</textnode>   <commentnode><!--comment--></commentnode>   <emptynode /> </root> [q7574909.xsl] <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet version="1.0"     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" encoding="UTF-8"/> <xsl:template match="/">   <xsl:apply-templates select="node()"/> </xsl:template> <xsl:template match="@*"><xsl:copy/></xsl:template> <xsl:template match="node()">   <xsl:copy>     <xsl:choose>       <xsl:when test="0!=count(node())">         <xsl:apply-templates select="@*|node()"/>       </xsl:when>       <xsl:otherwise><xsl:comment></xsl:comment></xsl:otherwise>     </xsl:choose>   </xsl:copy> </xsl:template> </xsl:stylesheet> ■ 結果(Xalan) C:\xalan-j_2_7_1>java -cp xalan.jar;serializer.jar;xml-apis.jar;xercesImpl.jar org.apache.xalan.xslt.Process -IN q7574909.xml -XSL q7574909.xsl <?xml version="1.0" encoding="UTF-8"?><root>   <textnode>text</textnode>   <commentnode><!--comment--></commentnode>   <emptynode><!----></emptynode> </root> C:\xalan-j_2_7_1> ■ 結果(xsltproc) $ xsltproc q7574909.xsl q7574909.xml <?xml version="1.0" encoding="UTF-8"?> <root>   <textnode>text</textnode>   <commentnode><!--comment--></commentnode>   <emptynode></emptynode> </root> $
http://www.w3.org/TR/xpath/#location-paths
「XMLでは親が異なる場合にはその子孫には同じ名前の要素を配置してはいけないのでしょうか。」 配置してもいいし、どちらかというと、配置できるから XML がデータ形式として使いやすいので、どんどん活用するといいとおもう。 「これが正しければこの回答で納得するのですが、どのパーサーも整形式XML文書であると判定しているようなのでXMLでは許されているように思われます。」 Yes。 「解説の中で各宣言はどの順番に記述してもよいと説明されていたのをみて、これでは同じ名前の異なる要素の親と子の対応関係がどうように分かるのか疑問に思っていましたが未だによく分からないままです。」 DTD の基本方針は、 『すべて許可』の状態から、少しずつ『制限を追加』していく と考えると、わかりやすいかも。 例えば、いくつかの仕入先から入荷できる果物の定義は、…… <!ELEMENT from (warehouser_A|warehouser_B)> <!ELEMENT warehouser_A (apple|orange)> 卸問屋A からは、(りんご、または、オレンジ)だけ。 <!ELEMENT warehouser_B (apple|orange|peach)> 卸問屋B からは、(りんご、オレンジ、または桃)だけ。 『要素名にする』か、それとも『要素名を同じにして、ユニークな属性にする』か というところで、質問者さんはモヤモヤしているような気がするけど、 上の例のようなデータの制限をしたいなら、DTD は『要素名にする』を強制してる。 でも、こんな制限は、はっきりいって苦痛。 ↓ (なので) ↓ XML Schema などなど。。。 「このことは親と子の対応関係だけでなく要素と属性の対応関係にも言えます。このような基本的な構造がDTDで表記できないというのもDTDの仕様として変な気がします。」 DTD の表現上の制限だから。。。ずばり、それが仕様！ 問答無用の絶対的存在。 「DTDでは記述できないというようなことが仕様のどこかに明記されているのでしょうか。できればその理由も分かると今後のDTDの理解にも役立ちます。」 『○○はできない。』なんて書かれてなくても、 できることが『全て』書かれているのだから、 できないことは論理的に導けるでしょ？
xmllint は試した？
入手先探し回らないといけませんが次のurlで紹介されてるMSVとか http://www.atmarkit.co.jp/fxml/rensai2/xmltool05/01.html JavaやC#などが扱えるなら自分で作っちゃう手もあります。
external の entity は ハンドラ実装しろって、ドキュメントにかいてあったよ？ メモしてないから場所はしめせないけど。。。
ご希望に添っているかわかりませんが、僕はPerlでXMLのテキストを取得したいときは「XML::XPath」モジュールを使用しています。XPathの書き方さえわかってしまえば、簡単にループ処理なども書けて便利です。 基本的な使い方はこちらのサイトで紹介されています。 http://www.ksknet.net/perl/xmlxpath.html XPathの書き方は、こちらが必要十分な内容がまとめられています。 http://yakinikunotare.boo.jp/orebase/index.php?XML%2FXPath%2FXPath%A4%CE%BD%F1%A4%AD%CA%FD Perl本は「Perl CPANモジュールガイド」がおすすめですが、XMLのことについて特別詳しく扱っているわけではありません。 「XML::Simple」と「XML::LibXML」における基本的なパースの仕方を紹介しています。 http://www.amazon.co.jp//dp/486267108X/
改行が<xsl:value-of select...> の前にある（複数行で編集・保存している）からでしょう。 改行の影響を無くすには、見にくいでしょうが影響のあるであろう改行を除いて一行にXSL ファイルを直す必要があります。この場合、<xsl:template> タグ内は改行がそのまま影響する事になります。 ＃表示中は改行・段落表示され、保存すると無改行になる編集ソフトがあると便利ですけどね（フリーであるかな？）
まず、前提。 XML　ファイルは、なにかルート要素が何かあるはずだよ？ <なにかルート要素があるはず> <Content Title="タイトル1" DestPage="000" リンク先_DestPage="010" Level="1"></Content> <Content Title="タイトル2" DestPage="001" リンク先_DestPage="012" Level="1"></Content> <Content Title="タイトル3" DestPage="002" リンク先_DestPage="013" Level="1"></Content> : : : </なにかルート要素があるはず> 以下は手順。 Firefox(試したのはversion 11)で XML ファイルを開いて、 [Ctrl]+[Shift]+[K] で [Web コンソール] を開いて、 下のコードを [Web コンソール] の 「>」 のところに貼り付けて、 (function (nodes) {   for (var i=0; i<nodes.length; i++) {     var el = nodes.item(i);          (function (arr, add) {       for (var j=0; j<arr.length; j++) {         var get = el.getAttribute(arr[j]);         var int = add + parseInt(get, 10);         var set = int.toString();         while (set.length<get.length)           set = "0"+set;         el.setAttribute(arr[j], set);       }     })(["DestPage", "リンク先_DestPage"], 50);   } })(document.getElementsByTagName("Content")); [Enter] キーをおして、 [Web コンソール] の下のページ表示部分をクリックして、 [Ctrl]+[A] で全て選択して 右クリックして、 [選択した部分のソースを表示(E)] を選択。 おしまい。
[No.3] のお礼の質問に対する回答ね。 「MSVでは、OKになりますが、PHPではエラーに なります。 もし、この事情が分かるなら、教えて下さい。」 エラーを出す PHP が正しいよ。 xsd:all は、使用制限が二つあって、 1) xsd:complexType のはじめの子要素で、唯一の子要素にしかなれない。 2) xsd:all のなかで、sequence や group のようなグループ要素はつかえない。 なので、『できないけど。』ということ。
>http://luxnate.com/memo/2011/02/-flash30.html のページの下の方の download 欄にある fla_as2_slide_show.zip(*) を ダウンロードして、展開した ./slideshow.as をチラッと見ただけだけど、 photo.xml の XML ファイルを修正すれば 画像一枚一枚に違うリンク先をつけられるようにはなっていくて slideshow.as も修正しないと、できるようにはならないとおもうよ。 Flash と ActionScript は知らないから slideshow.as の修正できないけど、 [技術者向] コンピューター > プログラミング > XML じゃなくて [技術者向] コンピューター > プログラミング > Flash なら、 できる人がたくさんいるかも。 (*fla_as2_slide_show.zip) http://luxnate.com/memo/2011/02/17/archive/fla_as2_slide_show.zip
それだと表示されるはずです。
PHPというスクリプト言語でHTMLの中に命令を書き込めばできます。 （お使いのサーバーでPHPが実行できる環境になっていれば） simplexml_load_file(”XMLのファイル名"） などの命令を使います。 詳しくはこれらのキーワードで検索して調べてみてください。
前回の回答で、ソースコードと、どのような環境で編集（OS、ツール等）したのかなぜ問題か、少しだけ説明しておきます。今後、投稿する時のために、ある程度めぼしがつくと思いますよ。 No unserialized data available. Use XML_Unserializer::unserialize() first. をこのサイトで直訳 http://www.microsofttranslator.com/Default.aspx?ref=IE8Activity 「シリアライズ データがありません。最初に XML_Unserializer::unserialize() を使用します」 と言うことです。「XML_Unserializer」これが何者か調査してください。 http://search.yahoo.co.jp/search?b=1&n=10&ei=UTF-8&fr=ie8sc&p=%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%80%80XML_Unserializer http://phpspot.net/php/man/pear/package.xml.xml-serializer.html http://www.okayamaweb.net/blog/archives/76 http://webtech-walker.com/archive/2007/04/06023523.html ですね。unserialize()　メソッドが最初に実行されるようですね。 http://phpspot.net/php/man/pear/package.xml.xml-serializer.xml-unserializer.unserialize.html で、シリアライズとはなにか？ http://search.yahoo.co.jp/search?p=%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA%E3%81%A8%E3%81%AF&aq=-1&oq=&ei=UTF-8&fr=ie8sc&n=10&x=wrt 意味はたくさんあるが、ようはエンコード、デコードする事です。ここまで解説して、なんなんですが、実は、そんな事どうでもいいんです。このエラー内容は、 「シリアライズするデーターが何も無い」 と言っているわけです。何も無いからエラーで止まったわけです。何か有る事を期待して、作成されているもので、無かった場合、何が問題なのか、本来、メッセージとして、表示すれば（解析して）いいのに、プログラムの落ち度をユーザーのせいにしているだけです。そこまで、作りこむサービスでもないのか？　と言うレベルの事です。なので、サポート側も、自分たちの落ち度をつっこまれたくないのです。 取得データーの正当性チェックに、パーサーのみで済まそうと言う、安易なつくりが、あなたを惑わせています。 ただ、カスタマイズ可能なアプリ（Webアプリを含む）の提供の場合、必ず、カスタマイズ側に条件をだしています。そう、「プログラム開発経験者」です。これは業務として（プロとして）作成経験者と言う事です。 しかし、一般公開しているサービスに、それは無いはずです（通常業務用アプリのみ）。 で思い出して欲しいのが、 http://www.okayamaweb.net/blog/archives/76 の使用体験ブログです。文字コードにえらくひっかかって、苦労しているようです。 いかかでしたか、ソースコード見ないと、なんともいえないことが、なんとなくお分かりいただけましたでしょうか。
DOMドキュメント($dom)の生成時や、コード12行までに至るまでの処理途中に問題があり、DOMドキュメントの中身が空になっているということはないでしょうか？ あと、参考URLの内容もチェックされてみてください。 ※それでも解決しない場合は、よろしければ、コードも差し支えない範囲で補足に記載されると、他の方のご回答の参考になるかもしれませんよ。 ご参考まで。
わかってしまえば、なんてことないんだけど、 ポイントは、値が必要な field 要素の一つ上の要素(Book)から、相対パスで field 要素を指定するところで、このとき select の条件に name 属性の条件も含めればいいだけ。 <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:output method="text" encoding="UTF-8"/> <xsl:template match="/">   <!-- 省略 -->   <xsl:apply-templates select="//Book" /> </xsl:template> <!-- csv のレコードを出力する処理 --> <xsl:template match="Book"> <xsl:value-of select="field[@name='keywords']"/>,<xsl:value-of select="field[@name='listName']"/>,<xsl:value-of select="field[@name='publisher']"/>,...(省略)..,<xsl:value-of select="field[@name='isbn13']"/><xsl:text> </xsl:text> </xsl:template> </xsl:stylesheet>
現象を簡単に説明しますと、UTF-8であることを判別するための文字が、ソース中になかなか現れないということでしょう。UTF-8固有のバイト配列をソースの先頭のほうに記述することが対策になります。 そのひとつがBOMをつけることです。それが嫌ならUTF-8特有の文字を先頭近くに記述することです。 …で自分でも試してみたのですが「<span style="display:none;">怠怠</span>」が有効でした。本当はコメントでも大丈夫なはずなのですが、少なくとも私の環境(WinXP IE8 ローカルで実行)ではコメントは駄目でした。また一文字でも駄目で「怠怠」としたときにのみ正しく判別しました。 とりあえず「<span style="display:none;">怠怠</span>」で試してみてください。 で、もしよろしければ参考のために結果と環境(OS、ブラウザバージョン)を教えてください。 よろしくお願いします。 Unicode 版美乳テーブルを探せ http://www1.ocn.ne.jp/~tabby/language/binyu.html#ap03
＞simplexml_load_file() で読み込めない～ と言う事はつまり、読み込み元のXMLが正しい構文になっていないと言う事です。 ◆XMLデータ:: <?xml version="1.0" encoding="utf-8"?> <rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xml:lang="ja"> <feed> <title>たいとる</title> <description>PHPでXMLデータを取得。</description> <link>http://example.com/</link> <language>ja</language> <lastBuildDate>Wed, 02 Nov 2011 00:11:22 +0900</lastBuildDate> <webMaster>hoge@example.com</webMaster> <item> <title>たいとる-001</title> <link>http://www.hoge.com/hage/001.html</link> </item> <item> <title>たいとる-002</title> <link>http://www.hoge.com/hage/002.html</link> </item> <item> <title>たいとる-003</title> <link>http://www.hoge.com/hage/003.html</link> </item> </feed> </rss> ◆PHP:: $file = './test.xml'; $xml_data = simplexml_load_file( $file ); $i = 0; while ( $value = $xml_data->feed->item[$i] ) { $my_data = $value->link; echo "<p>". $my_data ."</p>\n"; $i++; } ～こんな感じOKなはず？ P.S. 一応、XML内では大文字小文字、日本語も要素名として使って良い事になってますが。後々、PHPなどでパース処理する事を考えたら、半角英数“小文字”オンリーで統一して置いた方が誤動作を防げます。 上記例文がRSS-2.0に基づいた最小構成のXML構文になるので、これ以上は端折らない方が良いと思います。また要素も、あまり複雑な多重階層にしてしまうと、やはり後からPHPなどでパースする時に面倒かつ誤動作の主たる原因となりますので。基本は <item> 直下に全ての要素を並列化して記述する様に習慣化して置いた方が良いと思います。 最初の例文の様に、 ・Items -> Item-> ItemLinks-> ItemLink-> URL ～などと無駄に階層が深くなると、ヒューマンエラーが続出しますので…。
TextReader を読み込む方の ReadXml() を使って、 StringReader sr = new StringReader(strXML); ds.ReadXml(sr); で直接データセットを生成できると思います。
//value = "aiueo" とか？
in C# var doc = XDocument.Load(uri); // uri : XMLを指すURI MSDN: XDocument.Load メソッド (String) (System.Xml.Linq) http://msdn.microsoft.com/ja-jp/library/bb343181.aspx
検索しなさいよ。 http://search.yahoo.co.jp/search?p=TubeFireTools&search.x=1&fr=top_ga1_sa&tid=top_ga1_sa&ei=UTF-8&aq=&oq=
下記参照。 http://oshiete.goo.ne.jp/qa/6884487.html http://oshiete.goo.ne.jp/qa/6906521.html というか、同じ質問を何度も繰り返すというのは何を考えていらっしゃるのでしょうか。
表示はそのXML文書に対していかなるスタイルシートを使うか，という問題なので，XML文書側ではどうしようもないです。 ただし，改行を含む空白文字をそのまま取り扱うことを要求したいのであれば，xml:space属性を使うべきです。 これだけXMLカテゴリで質問しているのですから，仕様書の http://www.w3.org/TR/xml/#sec-white-space を見逃しただけだとは思いますが。
サーバにデータだけではなく、ソフトもおいてあるものです。 今までですとサーバにデータのみを置いておきましたが、クラウドコンピューティングはソフトもおいてあり、使用できるものです。 と簡単に回答ｗ
確認ですが， Flash で JavaScript を動作させるとか その他の場所で JavaScript を スクリプト として利用するとか そういうレベル(そういう段階)の話ではなくて 単に XML としての文字列データを作る話ですよね？ それだと単に 「キッチリと書く！」 ということが大切です。 そもそも最初の HTML入り ノードの方もできていませんよ。 うまくできてないものの通りをしても うまくできないのは当然です。 <pageText>～</pageTextt> 明らかに↑開始タグと ↑終了タグが違ってるでしょう？ 「キッチリ」しましょう。 ！[CDATA ↑「!(半角)」ではなく「！(全角)」になってますよ。 「キッチリ」しましょう。 XMLとして受け入れられる例(単なる一例)です↓。 ---------------------------------- <?xml version="1.0" encoding="Shift-JIS"?> <page> <pageText> <![CDATA[ <b> <a hret="aaa．html" target="_blank"><u>コチラ </u></a> </b> ]]> </pageText> <pageText> <![CDATA[ <b> <a hret="aaa．html" oncliick="window．open（'aaa．html', '_blank', 'width=200.height=200'）; retun false;"><u>コチラ </u></a> </b> ]]> </pageText> </page> ---------------------------------- ↑保存したXMLファイルを IE や Firefox で開いてみて 　 XMLとして認識(表示)されるかどうかを確かめるのが 　 手っとり早い検証方法です。 ↑★注意★ 　XMLとしては認識(表示)されると思いますが 　ドットが 「．(全角)」 のままになっているとか 　JavaScript が スクリプト として動作するかなど 　そんなことは知りませんよ。 　XML の問題 と JavaScript の問題とを 　一緒くたにしてはいけません。 　「問題の切り分け」が大切です。 　問題を作り出す根源(キッチリしてないところ)は 　同じように思えますけどね。。。 ※P.S 　 XML以前の話です。 　 「日本語の質問文」も改行を入れていらっしゃらないので 　 ものすごく読みにくいです。 　 改行省略の限度を完璧に超してますよね？ 　 自身で読んでも「ワケワカラン！」状態でしょ？↑ 　 そのようなものでは 　 最初から他人に自分の意思を伝える気はなくて 　 ただダラダラと書いたどうでも良い質問 　 と見られる可能性が高いですよ。
質問自体がナンセンスです。 XMLはマークアップ言語のためのメタ言語なので，スキーマが決まらないとそこに入る要素や属性は決まりません。 XMLにJavaScriptを埋め込みたいのであれば，スキーマに沿って埋め込んでくださいとしか言えません。 HTMLとXMLを対比させるような記述がありますが，HTMLを基準として対比するならばXHTML， XMLを基準として対比するならばSGMLでないと，異なる目的のものを対比していることになります。
オフラインで授業の中でホームページを作成するだけならキャラクターを使用しても授業目的の利用として無断でも著作権侵害にはなりませんが、インターネットに公開することはその目的から逸脱してしまいます。目的外使用となり複製権が再び及びます。また著作権法３５条１項は複製権のみの制限で公衆送信権までは許されません。
RSS自体，XML形式です。 ただし，ブラウザがRSSの表示方法として独自のスタイルシートを当てるため， 単純なXMLと異なる様に見えるだけです。 なお，RSS1.0とRSS2.0は別物 (新旧関係にあるわけではない/RSSの元の語も異なる) なので，それぞれ異なる方法で記述されています。 RSS 1.0だと， /{http://www.w3.org/1999/02/22-rdf-syntax-ns#}:RDF/{http://purl.org/rss/1.0/}:item/{http://purl.org/rss/1.0/}:link が各記事のURL， RSS 2.0だと， /rss/channel/item/link が各記事のURLになります。 # 名前空間プレフィックスの代わりに名前空間を直接{}内に書いています。 Site: RDF Site Summary (RDF) 1.0 http://web.resource.org/rss/1.0/spec Site: RSS Best Practices Profile http://www.rssboard.org/rss-profile
今のパソコンはPC本体の中にプログラムやデータを保存しています。インターネットを使用する場合もプログラムというソフトウェアが必要になります。 ワードやエクセルというソフトをご存知ですか？ワードは日本語ワードプロセッサでエクセルは表計算ソフトです。パソコン上にインストール（ハードディスクという記録媒体にする）してパソコンで使用できるようになります。またワードで作った文章や、エクセルのデータもハードディスク上に保管されます。今のパソコンはハードディスクが壊れたらバックアップデータがない限り元のデータを復旧させることはできません。 クラウドコンピューティングは、データやプログラムをネットワーク上で管理しようとするものです。一番近いものといえば、GooメールなどのWebメールが近いかもしれません。どこのパソコンでも他人のパソコンでもIDとパスワードさえ入れれば見ることが出来ますよね。 企業で取り扱うデータは膨大なものになります。そこでインターネット上にデータを保管しておいて、その情報を許可された人たちだけで使用するのがクラウドコンピューティングとなります。もちろんデータを取り出すプログラムや何らかの処理が必要な場合はクラウドコンピューティング上に用意しておけば、使用するパソコンはどんなものでも構わないということになります。 今回の災害でもデータセンターが壊れて被害受けた企業あるそうですが、クラウドコンピューティングではデータを分散してインターネット上に保管できますのでより安全だと言われています。もっともセキュリティの問題はかなり残るようなきもしますが。 今度、アップル社がituneに変わって、クラウドコンピューティングみたいなサービスを始めるそうです。ipodで購入した音楽情報を別なパソコンやipadでも利用できるようにしたものらしいです。
同じ質問を何度も見てるような気がしますが… クラウドコンピューティングは、以前はネットワークコンピューティングと呼ばれていた技術です。 企業など多くのパソコンを管理する時、すべてのパソコンのアプリケーションのバージョンアップに一台一台アップデートする必要がありました。 それを一元管理する為にサーバーにアプリケーションを置いておき、パソコンはネットワークごしに使うのが最初でした。 その当時はアプリケーションはサーバーのアプリケーションを、作成したファイルの保存はパソコンのハードディスクでしたが、ネットワーク上にファイルを保存できるようになって今のようなクライドコンピューティング技術になりました。
昔は一つの大きなシステムに全処理を任せてて、徐々に分散システムになって、そのシステム達がインターネットという網目で見えにくくなり、やがて雲に包まれてサーバーの存在がわかりにくくなった。ユーザーはサーバーを意識しなくなり、大きな雲の中から情報を引っ張ってくるクラウドコンピューティングが成立した。 という感じでどうでしょう？
私見ですが、基本はWEB全体を一つのデータベースととらえて、 同じ性質のものに統一の名前や定義をつけていくというくらいものだと思います。 また、ユニークな名前にしておくことで、 後々似たようなデータと合わせて使うことになっても、 取り出すデータを区別できます。 つまり、同じxmlnsをつけたものは機械的には共通の意味合いの値が入っていると仮定して処理します。 ただし、様々な人が作りますから100％規格を守るという保証は全くありませんが。 titleタグなどは多くのXMLで使いますし、 どこどこの住所にいるtitleさんという形で呼び出さないと特定できないですし、 WEB上の全てのデータから機械的にデータを収集するときには具体的な名前があるのは便利です。 話が大きくなればなるほど名前空間が大きな意味を持ってくると思います。 ただ、個人レベルで使う分には混在する可能性は低いどころか、 むしろ呼び出すコードが面倒になるだけなので、 何のためにあんな長い名前をつけてるのか疑問になりますよね。 それでも下記の2個目のURLのようなことがよく起こるとのことです。 ▼参考URL XML名前空間の簡単な説明 http://www.kanzaki.com/docs/sw/names.html XMLの常識 名前空間の基本 http://www.infoteria.com/jp/xmlnote/column/doc/xml_column_xml_010313.html XML用語事典 [XML名前空間] http://www.atmarkit.co.jp/aig/01xml/namespace.html XML 名前空間 http://gogodiet.net/z/xml/6.htm 質問とずれていたらすみません。
CALSは初めての人にはやっかいな物ですね。 ですが、少し落ちつて質問しましょう。 支離滅裂で何を質問しているのか分かりませんよ。そのくらいは考えて投稿する余裕を持ちましょう。 で、データは何を使って作成しているのですか。 エラーメッセージ（と思われる）文章からすると、基準（案）に沿った作りになっていないと思います。 　・どの基準に合わせてデータを作成するのか。また作ったのか。 　・データを作成しているソフトは何を使用しているのか。 面倒でも最低でもこの二つを補足してください。 作成しているソフト次第で操作や設定が変わってきますから、これらの情報が無いとどうにもできません。 （工事完成図書の電子納品要領(案)に準拠する必要があればそれを、 　メモ帳で作成しているのでしたら、メモ帳と補足してください。） ちなみに、どの基準に準拠すればいいのか不明な場合は納品先の担当者に基準について確認しましょう。 （工事写真や CADデータなどに不備が発生するかもしれませんが、その時も担当者へ連絡して相談しましょう。） なお、自分が補足に対して回答をできるのは12時間以上後になりますが、 補足を見た他のかたからアドバイスや回答をいただける可能性があります。
「パソコン」のは無いです。 それぞれのソフトで違います。
機械翻訳？ 質問文修正。 | インターネットに公開されている RSS を参考にして、 | 自分で RSS 文書をつくってウェブサイトに公開してみのですが、 | googleリーダーを使って見てみると、日本語部分が文字化けしてしまいます。 | | encodingは、できるだけシフトJISにしたいのですが、 | どうやったらできますか。教えてください。 一行目の | <?xml version="1.0" encoding="utf-8"?> の部分を | <?xml version="1.0" encoding="Shift_JIS"?> に変更してみて！
>if文やfornextはないのですか詳しく教えてください ある意味、欲しいことがあるかもしれませんが・・・マークアップ言語の発想からは必要性が薄いということで実装されているのは少ないと思います。 TeXも代表的なマークアップ言語でTeXにはif文ありますが少数派ですね。 TeX入門/マクロの作成 http://oku.edu.mie-u.ac.jp/~okumura/texwiki/?TeX%E5%85%A5%E9%96%80%2F%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%AE%E4%BD%9C%E6%88%90
質問文にて提示されたリンク先には， > isbn (必須) : 書籍のISBNを指定します。カンマ区切りで複数指定できます。 と説明されていますが，質問文に挙げられた２冊の例はこれに従っていません。 私はアプリケーションキーを取得していませんので， 　　isbn=4480863303,4834000435 で問い合わせるとどのような結果になるのか，提示していただけますか。
utf-8 ファイルのデータの先頭に EF BB BF がはいちゃってるからかな？ 処理系によってもちがうけど、xslt をふくめて xml ファイルは、xml 宣言の前にどんなコードがはいることも許さないから、それに引っ掛かったのかも。 http://www.w3.org/TR/2008/REC-xml-20081126/#NT-prolog Windows のメモ帳だと必ず先頭文字列が入っちゃうから、他のテキストエディタで、保存方法を指定して先頭文字列が入らないように保存ね！
質問の中の XML が整形式 XML 文書(※1)になってないから、適当に、修正しておいたよ(↓xmldoc.xml)。 (※1 整形式 XML 文書) http://ja.wikipedia.org/wiki/Extensible_Markup_Language#XML.E3.81.AE.E6.A7.8B.E6.96.87.E3.81.A8.E6.95.B4.E5.BD.A2.E5.BC.8FXML.E6.96.87.E6.9B.B8 [xmldoc.xml] <?xml version="1.0" encoding="utf-8"?> <?xml-stylesheet type="text/xsl" href="xslt.xsl"?> <RootNode>   <Menulist>     <Menu No="1" Item="3" Time="100"/>     <Menu No="2" Item="1" Time="60"/>     <Menu No="3" Item="1" Time="120"/>     <Menu No="4" Item="2" Time="10"/>   </Menulist>   <Setlist>     <Set No="1"><Name>Push Up</Name></Set>     <Set No="2"><Name>Run</Name></Set>     <Set No="3"><Name>Swim</Name></Set>     <Set No="4"><Name>Squat</Name></Set>   </Setlist> </RootNode> たぶん html 文書を出力したいんだとおもうけど、html タグかくとごちゃごちゃして、ポイントがわかりづらくなるからテキスト出力にするね。HTML 出力したいときは、必要なところに html タグ追加して完成させてね。 [xslt.xsl] <?xml version="1.0" encoding="utf-8"?> <xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform">   <!-- 出力が html のときは↓も↑に含める   xmlns="http://www.w3.org/1999/xhtml" --> <xsl:output   method="text"   encoding="utf-8"   media-type="text/plane"/> <!-- 出力が html のときは↓を使う。   doctype-public="-//W3C//DTD XHTML 1.1//EN"   doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"   media-type="application/xhtml+xml" --> <xsl:template match="/">   <xsl:apply-templates select="RootNode/Menulist/Menu" /> </xsl:template> <xsl:template match="Menu">   <xsl:variable name="no"><xsl:value-of select="@No" /></xsl:variable>   <xsl:value-of select="$no" />   <!-- ↓出力が html のとき xsl:text 要素はらない -->   <xsl:text> </xsl:text>   <xsl:value-of select="/RootNode/Setlist/Set[@No=$no]/Name" />   <!-- ↓出力が html のとき xsl:text 要素はらない -->     <xsl:text> </xsl:text> </xsl:template> </xsl:stylesheet> xslt だけど、とりあえず下のタグだけ覚えておけば、簡単なのはかけるようになるから、気が向いたらしらべてみて！ - stylesheet - output - template - apply-templates - value-of - variable - element - attribute - copy ちょっと複雑なことする場合は、これが必要になるかも。 - for-each - sort - call-template - with-param - param - copy-of - if - choose - when - otherwise 正典 http://www.w3.org/TR/xslt 関数型の美しさに魅了されると手続型のちまちまがだるだるでいやいやだから覚悟しておいて！
ざっくり説明してみるよ。 「HTML 文書」は「ウェブブラウザ」に読み込ませて「その内容を表示させるため」の言語。 「」で囲まれたところを、(A)、(B)、(C) と書いてみるよ。 (A) は (B) に読み込ませて (C) させるための言語。 (A)、(B)、(C) をあてはめて、XML を説明すると、 『「XML 文書」 は (B) に読み込ませて (C) させるための言語。』 となるね。 でも、「XML 文書」 は、(B) も (C) 「これ！」 と決まっていないんだ。 ここが、XML 文書と HTML 文書の大きな違いだね。 ソフトウェアは「ウェブブラウザ」以外にも、たくさんあって、これからもどんどん作られていくと思うけど、、、 そのようなソフトウェアに読み込ませる文書(A) は、それぞれのソフトウェア(B) で読み込ませるように、そのソフトウェア独自の文書形式に従って書かれる必要があったし、 ソフトウェア(B)は、その文書(A) を読み込むためにそれぞれ独自にその文書(A)を読み込む為の機能を作る必要があったよ。 でも、XML という文書の基本的なルールができたおかげで、それぞれのソフトウェア(B) で使う文書を XML というルールに従って作れば、その文書を読み込むための機能を作る必要がなくなったんだ。 つまり、HTML は ウェブブラウザの為の言語で、 XML は用途が決まっていないから、使いたければどんな機能(C) をもつソフトウェア(B) でも使える言語といえるね。
まだ詰まってる？ @url に何か入っているときだけ、表示するところを xsl:if ではさんだだけだけど、   <xsl:if test="@url!=''">     <tr>       <td>URL</td>       <td><a>         <xsl:attribute name="href">           <xsl:value-of select="@url" />         </xsl:attribute>         <xsl:attribute name="target">_blank</xsl:attribute>         <xsl:value-of select="@url" />       </a></td>     </tr>   </xsl:if> 全部書くとこんなかんじ。 <?xml version="1.0" encoding="utf-8"?> <xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"   xmlns="http://www.w3.org/1999/xhtml"> <xsl:output   method="html"   encoding="utf-8"   doctype-public="-//W3C//DTD XHTML 1.1//EN"   doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"   media-type="application/xhtml+xml" /> <xsl:template match="/">   <xsl:apply-templates select="page/message"/> </xsl:template> <xsl:template match="page/message">   <table>   <tr>     <td>名前</td>     <td><xsl:value-of select="name"/></td>   </tr>   <xsl:if test="@url!=''">     <tr>       <td>URL</td>       <td><a>         <xsl:attribute name="href">           <xsl:value-of select="@url" />         </xsl:attribute>         <xsl:attribute name="target">_blank</xsl:attribute>         <xsl:value-of select="@url" />       </a></td>     </tr>   </xsl:if>   </table> </xsl:template> </xsl:stylesheet>
「XML ドキュメント内では最上位の要素に限り、使用できます。」 だから Internet Explorer のエラーメッセージだね。 XML 文書を編集するなら、XML 文書の基本的なルールを知っておかないと難しいよ。 XML 文書は、ルート要素(一番外側の要素、この場合 <status>) が一つでなければならないのに、単純に wget で取得した status ファイルを一つのファイルに追加すると、ルート要素が 2つ以上になるから、XML 文書として正しくなくなる。 これを避けるために、追加するなら、 ※ xform.xsl が status ファイル追記のファイルと同じディレクトリに置かれている場合 <?xml version="1.0" encoding="utf-8"?> <?xml-stylesheet type="text/xsl" href="xform.xsl" ?> <statuses> と </statuses> の間に、各 status ファイルの <status> から </status> までを挿入する必要があって、下のような構造になる。 <?xml version="1.0" encoding="utf-8"?> <?xml-stylesheet type="text/xsl" href="xform.xsl" ?> <statuses> <status> : </stauts> <status> : </status> <status> : </status> : : : </statuses> これなら Internet Explorer で表示できるよ。
とりあえず意図している状態では表示されると思う。 ※SDK Ver.2.2以上 <?xml version="1.0" encoding="utf-8"?> <TableLayout android:id="@+id/tableLayout1" android:layout_height="match_parent" android:layout_width="match_parent" xmlns:android="http://schemas.android.com/apk/res/android" android:stretchColumns="0,1"> <TableRow android:id="@+id/tableRow1" android:layout_width="match_parent" android:layout_height="wrap_content"> <TextView android:text="TextView" android:id="@+id/textView1" android:layout_width="match_parent" android:layout_height="wrap_content"></TextView> <TextView android:text="TextView" android:gravity="right" android:id="@+id/textView2" android:layout_width="match_parent" android:layout_height="wrap_content"></TextView> </TableRow> <TableRow android:id="@+id/tableRow2" android:layout_width="match_parent" android:layout_height="wrap_content"> <TextView android:text="TextView" android:id="@+id/textView3" android:layout_width="match_parent" android:layout_height="wrap_content"></TextView> <TextView android:text="TextView" android:gravity="right" android:id="@+id/textView4" android:layout_width="match_parent" android:layout_height="wrap_content"></TextView> </TableRow> </TableLayout>
添付画像が見えないので想像ですが下じゃダメですか？ ※SDK2.2以上 <?xml version="1.0" encoding="utf-8"?> <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="fill_parent" > <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="wrap_content" android:layout_height="wrap_content" > <ImageView android:layout_height="wrap_content" android:id="@+id/imageView1" android:src="@drawable/icon" android:layout_width="wrap_content"></ImageView> </LinearLayout> <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="wrap_content" android:layout_height="wrap_content" > <TextView android:text="ながいもじながいもじながいもじながいもじながいもじ１行目" android:id="@+id/textView1" android:layout_width="wrap_content" android:layout_height="wrap_content"></TextView> <TextView android:text="ながいもじながいもじながいもじながいもじながいもじ２行目" android:id="@+id/textView2" android:layout_width="wrap_content" android:layout_height="wrap_content"></TextView> </LinearLayout> </LinearLayout>
　プログラムを作るとか、パッケージソフトを探すにしても、こおいった事をやる場合、まずは、Macは止めて、Mac環境のlynuxとか、いっそのことWindows環境に切り替えた方が幸せになります。
TreeViewで試してないので自信なし。 例外出るの。 https://ideone.com/fQ04I こうすると出ないの。 https://ideone.com/e3HEI
>読んでくれるでしょうか。 おそらく読み込んではくれないでしょう。 スキーマを読むとsitemapindex要素はsitemapindex要素を子に持たないようなので。 http://www.sitemaps.org/schemas/sitemap/0.9/siteindex.xsd #もちろん俺のせいじゃないがな。
おそらく無理。 メモ: ●一応XML Schemaにはそれっぽい仕組みがあるようだ。XML SchemaもRELAX NGも勉強してないので自信はない。 試しに、https://cid-b89cb784f5346675.office.live.com/browse.aspx/TestCase/Q6480799 XML Schemaにschema.xsd,XML Instanceにvalid.xmlを指定して、結果を見るとValidと言われ、XML Instanceにinvalid.xmlを指定すると、「Duplicate unique value [1] declared for identity constraint of element "Top".」と言われるからチェックされているように思う。 http://tools.decisionsoft.com/schemaValidate/ ●無理な理由は簡単。IEはDTDの妥当性検証を行うことはあっても、XML Schemaの妥当性検証は行わないorz
適当な情報を提示しまして申し訳ありません。 単純にloadXMLしただけでは、パーサーを通るときにエラーになってしまうようです。 また、DTDのファイルも探しに行ってしまうようです。 さらに、DOCTYPEのみのXMLではだめで、何らかの本文も必要なようです。（<abc>1</abc>の部分） 簡単に検証しましたが以下のコードではなんとなくうまくいっているようです。 doctypeプロパティなどでDOCTYPEが取れるので良いように思うのですが。。。 ちょっと無理やりのようにも思いますので要件に合うかわかりませんが、参考になればと思います。 研究してみて下さい。 ---- Dim Str As String Str = "<!DOCTYPE BookList SYSTEM ""Title.dtd""><abc>1</abc>" xmlDoc.async = false xmlDoc.resolveExternals = false xmlDoc.validateOnParse = false If xmlDoc.loadXML(Str) <> true Then WScript.Echo "エラー" xmlDoc.Save "C:\_Books\Title.xml" ----
差し支えなければ、ここに生成したKMLファイルの中身を載せられませんか。
よくわからない質問ですが、ルート要素が複数あるって事ですか？ それはだめですよ。 <xml version="1.0" encoding="UTF-8" ?> <!DOCTYPE ルート要素名[....]> <ルート要素名> <content> －－－－－－－－－ </content> <content> －－－－－－－－－ </content> </ルート要素名>
SQLiteを使うようなので、もう少し・・・ 名前はLiteですが、Firefoxも内部では利用しているｄｂで意外とメジャーなｄｂです。 プログラム的には「文字列だけで他の型がない」、「ｄｂエンジンを持たないため、ユーザという概念がない。」などLiteな仕様ですが、開発段階では自由にフィールド設計してｄｂ・プログラムを段階的に作成するには最適だと思います。 他のｄｂでは、ユーザ設計、ファイル・レイアウトなどなどｄｂの本体設計以外の部分を決定しないとｄｂを構築できないです。 また、MySQLなど主要なｄｂへの移行も意外とスムーズにできると思いますが、最低限のCREATE TABLEなど「ｄｂとは？」など基礎レベルの知識は必要です。 Wiki http://ja.wikipedia.org/wiki/SQLite
Googleが公式に公開している取得方法じゃないので、 オリジナルなGoogle News検索を作りたいなら↓を使って、 http://code.google.com/intl/ja/apis/newssearch/ News検索サイトを作っちゃいましょう。
「動的に」ってどのような意味（局面）ですか？ 使用されるツールとかプログラミング言語は決まってるんですか？ 変更した後、当然、保存もするんですよね？
フィード（RSS）のパース処理ですね。 javascriptベースで、APIサービス使うなら、 「Google　AJAX　Feed　API」で出来ます。 http://code.google.com/intl/ja/apis/feed/v1/ それとも、サーバーサイドのプログラムを作りたいという質問かな？
何度かやったことがありますが、サイトマップの形式は、googleと同じ型式で大丈夫みたいですよ。操作方法は、画面に説明がでていますから説明はいたしませんが。。
＞この紫のバーは、とても凝っている構造でしょうか？ 凝っているか凝ってないか？感じ方は人それぞれだと思うのですが、それなりに凝っている方ではないでしょうか？ 色や形は単純に CSS で制御しており、動作は javascript で制御していますね。 それでも作成するには物凄く高等な知識が必要か？と言われればそんな事は全然ありません。 スタイルシートに関してはテンプレート配布サイトなどがありますので気に入ったデザインがあれば丸写しできますし、javascript に関してもフリーで公開されているライブラリがそれこそ星の数ほどありますので、ゼロから作り上げる知識がなくとも作成する事は充分可能です。 やる気さえあれば。 ＞サムネイルを作って、その画像をクリックしたら、画像を見れる様にしたいのですが・・ ＞この方の言っている通りに行えば成功するでしょうか？ 成功します。だからまずは実際に自分で作業してみましょう。 こういう質問サイトには『まず自分でやってみて、それで上手くいかない。原因を調べてみたが自力では突き止められない』という場合に質問してみるものです。 初心者である、という事はなんの免罪符にもなりゃしません。 あとこれはどうでも良い事かもしれませんが、ここは XML に関する質問を書き込むスレですので、あなたの質問は全くカテゴリが違いです。
Sub NARABEKAE() Dim A As MSXML2.DOMDocument60 Dim B As MSXML2.IXMLDOMNodeList Dim C As MSXML2.IXMLDOMElement Dim D As MSXML2.IXMLDOMNode Dim E As MSXML2.IXMLDOMElement Dim N&, I&, J&, K&, X&, Y&, Z& ReDim L(1, 0) Set A = New MSXML2.DOMDocument60 If Not A.Load("C:\～.xml") Then 　　　　MsgBox "ファイルが読み込めません" 　　　　Exit Sub End If Set B = A.getElementsByTagName("ITEMS") If B.Length <> 1 Then 　　　　MsgBox "ITEMSノードがありません" 　　　　Exit Sub End If Set C = B.Item(0) Set B = C.selectNodes("ITEM") X = B.Length - 1 For I = 0 To X 　　　　Set D = B.Item(I) 　　　　Set E = D.selectNodes("NUMBER").Item(0) 　　　　If E Is Nothing Then 　　　　　　　　MsgBox "NUMBERノードがありません" 　　　　　　　　Exit Sub 　　　　End If 　　　　N = Val(E.nodeTypedValue) 　　　　ReDim Preserve L(1, I) 　　　　Y = I - 1 　　　　For J = 0 To Y 　　　　　　　　If L(0, J) > N Then 　　　　　　　　　　　　Z = J + 1 　　　　　　　　　　　　For K = I To Z Step -1 　　　　　　　　　　　　　　　　L(0, K) = L(0, K - 1) 　　　　　　　　　　　　　　　　Set L(1, K) = L(1, K - 1) 　　　　　　　　　　　　Next 　　　　　　　　　　　　Exit For 　　　　　　　　End If 　　　　Next 　　　　L(0, J) = N 　　　　Set L(1, J) = D 　　　　C.removeChild D Next For I = 0 To X 　　　　C.appendChild L(1, I) Next A.Save "C:\～.xml" End Sub こんな感じでどうでしょう。
http://cid-b89cb784f5346675.office.live.com/browse.aspx/TestCase/Q6069966?uc=1 字数が足らんのでファイルをひとまとめにしておいた
http://w4ard.eplusx.net/translation/W3C/REC-xml-20081126/#safe-behavior Firefoxは非検証XMLプロセッサとして、IEは検証XMLプロセッサとして動くのでしょう。 ><!ELEMENT members (member)*> >と書くのと、 ><!ELEMENT members (member*)> BNF的には違うものでしょうが、意味するところは同じだと思います。 http://w4ard.eplusx.net/translation/W3C/REC-xml-20081126/#elemdecls
●エラーの内容としては見ての通り。 ●Yahoo!がデータを作成するときに正しいコードを作らない のが最大の原因(元のブログで提供されるデータは正しいのに…)。だからYahoo!に文句言うのが正しいが、問い合わせフォームが見つからない。Yahoo!を恨みながら諦めるべし。 ○ブラウザ等のユーザーエージェントが勝手に補正しやがる。 ○「補正しないべき」って考える自分にとって「補正してなんとか読みたいのですが、どうしたらいいですか？」とか聞かれたりしたらイライラする。聞くなよ？
IEは6ですが特に問題なく表示できました。 確認ですが、保存したファイルの文字コードはutf-8になっていますか？ 文字コードをutf-8以外に変更したら質問にあるようなメッセージが表示されました。
意味処理。意味を処理する。意味とはデータという事でしょうかね～。 とりあえずXML は、HTML とは違ってデータを格納する事をだけを目的としています。ツリー状のDOM 構文を形成しています。 具体的には、アドレス帳とかデータベースに代えて使われてます。 XML はXSL で処理する事でHTML にできます。もしかしたらそれが意味処理になるんですかねー。もしかして「意味処理」って、先生の直訳（誤訳）だったりしてｗ
preceding-sibling::*[1][aaa] <a> <b xml:id="x0100"> <aaa id="x0101"></aaa> </b> <b xml:id="x0200"> <aaa id="x0201"></aaa> </b> <c xml:id="x0300"/> </a> 現在c要素を指しているとすると 要素名関係(*)なくpreceding-siblingを取って来る。その時の順番はreverse orderであるから preceding-sibling::*[1]/@id は x0200 preceding-sibling::*[2]/@id は x0100 です。 その1番目の要素、つまりx0200の要素(ここまで今回はたまたま1個しかない条件)の中で 「aaa要素を子要素として持つ」という条件を満たすものです。= x0200の要素は条件をみたすのでこれが選ばれる。 preceding-sibling::*[1][self:aaa] 名前空間接頭辞selfに関連付けられた名前空間のaaa要素を子に持つ、という条件をみたすかどうか、という条件に変わっただけです。 ちなみに、 preceding-sibling::*[1][self::aaa] はx0500の要素から見て、0x400の要素です。 preceding-sibling::*[1]自身の要素名が名前空間なしのaaaですから。 <a> <b xml:id="x0300" /> <aaa xml:id="x0400" /> <c xml:id="x0500"/> </a> preceding-sibling::*[1][name()='aaa')] は構文エラー preceding-sibling::*[1][name()='aaa'] は最後の条件が「コンテキストノードのQNameが'aaa'」ということでpreceding-sibling::*[1][self::aaa]と同じ結果になるでしょう。 #厳密には[]でくくられたPredicateはnodeからbooleanへの変換がかかっていると思うけどね。 http://www.w3.org/TR/xpath/#predicates #QNameって何？とかコンテキストノードって何？って聞かないでね。
宿題の質問に丸投げ回答はちょっと．．．． フルスクラッチで自分で作れないなら、インターネットでAJAXとかの入門 サイトを幾つか回って、使えそうなやつをまるまるコピーして、理解する努力 だけはしましょう。何もしないよりは、ましです。
PHPのDOMDocumentの処理は、UTF-8でないとうまくいかない場合が多々あります。 mb_internal_encoding("UTF-8"); mb_http_output("UTF-8"); mb_language("ja"); も明示的にセットしましょう。
#1です。 Seesaaブログにはありますが、FC2ブログにはsitemap.xmlを吐き出す機能がなかったと思います。 なのでご自分でsitemap.xmlを作り、画像をアップロードするようにxmlファイルをアップロードするしかないのかな？と思います。 そしてアップロードしたsitemap.xmlのURLを、ウエブマスターツールにてサイトマップ送信すればいけるかな？と思いますよ。
http://msdn.microsoft.com/ja-jp/netframework/ff621556.aspx を参考にすると TextBox 単位でしか 前景色・背景色の指定ができないみたいですね。 そうすると、こういう方法↓で逃げるとか。 <TextBox Margin="0,0,0,0" VerticalAlignment="Top" Height="25" Text="始めまして、　　　　　　　　　　　です。宜しくお願いします。" TextWrapping="Wrap" Foreground="black" Background="Transparent" /> <TextBox Margin="60,0,0,0" VerticalAlignment="Top" Height="25" Text="【Goo太郎】" TextWrapping="Wrap" Foreground="red" Background="Transparent" />
XMLのタグの意味はXML毎に決められているので、一般的にどうこうというのはありません。 ＞<u>（アンダーライン）,<i>（イタリック）,<b>（ボールド）とかはわかるのですが、 とお書きのようすからすると、もしかして、XMLじゃなくて、HTMLの話ですか？ その場合でも<o>は定義されていません。HTMLでは未定義のタグは無視されます。 つまり、<o> は無かったものとされます。
プログラムはSAXですか？DOMですか？ あるいはXSLTとか？ どんなプログラムなのか書かれていないのでわかりませんが 処理するのはプログラムなのでXMLに罪はありません。 XMLは単なるテキストですからそれ自身がどうこうということはありません。 そんなわけで >こういう”いくつかわからないけどデータがある”ような場合、XMLではどのように記述すれば良いかご教授願えますでしょうか。 別に質問内容通りのXMLの書き方で特に問題は無いです。 （まぁ私なら 　<place name="渋谷"> 　　<time>0</time> 　　・ 　　・ 　とか 　<place> 　　<name>渋谷</name> 　　<event> 　　　<time>0</time> 　　・ 　　・ 　とかにしますけど。まぁこんなのは好みの問題です。） ひとつしか取らないのなら、プログラムのロジックがひとつしか取らないようになっているんだと思います。 例えばDOMを使っているのならgetElementsByTagName("time")とかで リスト形式で取れるはずです。 もちろん書き方は開発言語とかにもよって違ってきますけど。 おそらく渋谷は渋谷でtimeを取得したいでしょうし、 sundayはsundayで取得したいとかあると思います。 そんなわけでXQueryとか取れるメソッドを使って取ってくることも多いです。
PC用のサイトマップと同一の階層に質問者の方が書かれたように別ファイル名で保管します。 モバイル用のサイトマップ形式とPC用のサイトマップ形式は異なりますので、モバイル用として認識してくれます。 ただ、SEOの観点から、http：//www.homepage.com/mobile/　のような同一サイト内に混在するのは、 モバイルのトラフィック量が大きくならないかぎり、PC用として認識されることが多くありますので、グーグルから アナウンスされているとおり、m.homepage.com などの別サイトとして運営されることを強くお勧めします。
自信なし ($xml->posts->post->photo) - (url[0]); っていう引き算だと解釈されているのかも
ギブアップ。諦めた方が良い DOMはおそらく設計的にテキストファイルとして扱うことを前提としてない。(#わざわざ行番号を使って何をしたいんだろう？とは思うのだけれど) で、SAXを眺めてたらISAXLocatorに、linenumberがあるから出来るかな、とか期待したんだけど、 http://msdn.microsoft.com/en-us/library/ms753775%28VS.85%29.aspx Javaのマニュアルにあるように http://java.sun.com/j2se/1.5.0/docs/api/org/xml/sax/Locator.html ソースコードの厳密な行番号を与えるものではなく、あくまでデバッグ目的用に曖昧な番号を示すものであり、少なくともMSXMLは以下のように、属性区切り子に改行を用いたXMLの、要素の開始行番号を期待通りに返さなかった。 <data> <item id="hoge" kekeke="gag">○○○○</item> <item id="fuge"> <item id="fuga"> ×××× </item> </item> <item id="gura">△△△△</item> </data> =================試みたこと(役に立たないけど関心があれば)============ 実行するまでは上記の挙動であることに気付かず、実装してやろうと悩んだ。 IVBSAXContentHandlerの各イベントで渡されるのはノードではなく、要素名とか属性とか、そのテキストの内容。これだけでは、他のノードを拾ってしまいかねないので わざわざ数えてそれをIVBSAXContentHandlerを実装した独自クラスのメンバ変数に保存しておいて、イベントでカウントして、同じ数になったときに適用、というような方法を取っていた。ちゃんと一致するノードを取れているようではあったのだが、 上記の問題により断念せざるを得なかった Set dom = New DOMDocument60 dom.async = False dom.preserveWhiteSpace = True Dim succeed As Boolean succeed = dom.Load("C:\Environment\Users\WWW\OKWave\Q5696567\aaa.xml") dom.setProperty "SelectionLanguage", "XPath" Set element = dom.selectSingleNode("//*[@id='fuga']") Set nodes1 = element.selectNodes("preceding::node() | ancestor::node()") Dim x As Class1 Set x = New Class1 x.XXX = nodes1.Length Dim y As SAXXMLReader60 Set y = New SAXXMLReader60 Set y.contentHandler = x y.Parse (dom.XML)
文字コードがおかしいとかですかね。
　お望みのhtmlファイル生成は、「北海道」という単語を <a href="hokkaido.php">北海道</a> という文字列に 置き換える操作をすれば、実現できるでしょう。 　XML のノード内の文字列の一部を加工する操作のための便利なメソッドはよく分かりませんが、文字列の置き換えはプログラム言語の文字列操作命令や正規表現オブジェクト操作などを活用すれば実現できます。特に正規表現を使えば、<body> </body>内の素の文字列のみを置き換えるようなことができます。 　そして、できあがった文字列をいったんhtmlファイルとして保存し、ブラウザで開く操作をする（プログラムの中での自動機能も可能）か、WebBrowser コンポーネントのようなhtml表示用のオブジェクトのソース文字列として流し込むことでリンク付きページを扱えるでしょう。
「URI」の「I」は「identifier」、つまり「識別子」です。 これはIDのように一意に識別を行うことを目的として使用されます。 > 1. 実際に衝突が起きなければURIは任意に決めていいのでしょうか? はい、自由に決めることができます。 発想が逆でして、衝突を起きないようにするため（一意に識別するため）にURIを使用します。 > 2. 1と若干かぶりますが、ネットに上げなければ何でもよいのでしょうか? 外部に公開さえしなければ、例えあなたが http://www.google.co.jp/を名前空間として使用していようと 誰も知ったこっちゃないので全く問題ありません。 というよりシステムの観点から言えば ネット上で誰かとかぶっているとか、そういうことは全く意味がなくて 作成したxmlの想定される利用範囲でかぶらなければそれで良いです。 しかし、システム的には問題無くとも 例えば誰かのドメインと同じだったりすると倫理的にはあまりよく無いので （例えば全く関係の無いサイトのURLと同じだったりするとややこしいので） 誰かと絶対かぶらないような名前にするのが普通です。 3. ネット上で使用するにあたって、それを定義する際どのようなURIを使うと良いでしょうか? 普通は自分の持っているドメインを利用します。 それなら誰かとかぶることは（意図的にされない限り）まずありませんし 自分の公開しているサイトと関連性があることが一目でわかります。
本当に日本語が原因かしら？ 最初からやり直してみて日本語を1つだけ追加しても 同じエラーになる？ 単に修正したときに 余計なところを削除しちゃったとか 半角スペースを全角にしちゃったとか 意外とそんなところが原因かもしれないわよ。 あと、 そもそもそのXMLファイルを読み込んでいるアプリ？が 日本語を解釈できないだけ っていう可能性もあるわね。
会員要素が1000件もある<XML>ともなると、 DOM型アクセス(ツリーベース)じゃ重そうなのでSAX型(イベントベース)アクセスが有利では、 となると、JAVAとかPHPとかでSOAP利用かな（知ったかぶり） あるいは、Xpathとか使えばDOM型アクセスでもOKかも、 メモリー馬鹿食いしそう。
一応XSVってのがあったりするし、 http://www.stylusstudio.com/xml_schema/xsv.html #こっちはSchema自体を使ってValidateだと思うけど http://tools.decisionsoft.com/schemaValidate/ #なんてので自分のXML Schemaをチェックしたりすることがある。 ##当時 ##http://www.horobi.com/xml/XMLSchemaDosAndDONTs.ja.html ##>第一に、バリデータにとってこのチェックを厳密に実施することは大変なことなんだ。 仕様書のこの制約を定義している箇所をちょっと見て欲しい。何が許され何が許されないかを指定するのに 3.9.6 章が丸ごと割かれている。[バリデータを実装する]開発者がこの制約チェックを実施しないで済ませたい、という強い誘惑に駆られたとしても不思議じゃないのがわかるだろう。たいていの人はこのチェックが実施されなくても気付きはしないだろうから。このあたりは XML Schema ワーキンググループのメンバーが開発した XSV でさえ、部分的にしかサポートしていないんだ。 ##とかいわれていたけれど、今はどうなんだろう…
>#1 はずれ。 http://www.w3.org/TR/xml/#elemdecls 'empty'は認められない。正しくは'EMPTY' >質問文 <!ELEMENT 名前 (#CDATA)*> 同様に、#CDATAではなく#PCDATAが正しく、、 #PCDATA単独の時は*を付けないのが正しい。 http://www.w3.org/TR/xml/#attdecls >The Name in the AttlistDecl rule is the type of an element. >The Name in the AttDef rule is the name of the attribute. ということで、一つの属性リスト宣言中に出てくる要素名の回数は1回。 それに続いて属性名と属性値の型、デフォルト値と続きます。 したがって <!ATTLIST SKU 倉庫 NMTOKENS #REQUIRED 単価 CDATA #REQUIRED > あるいは <!ATTLIST SKU 倉庫 NMTOKENS #REQUIRED> <!ATTLIST SKU 単価 CDATA #REQUIRED> が正しいです。 ここまでを総合すると、 ===============外部DTD(Q5484519-1.dtd)=============== <?xml version="1.0" encoding="UTF-8"?> <!ELEMENT 製品管理 (製品)*> <!ATTLIST 製品 製品番号 ID #REQUIRED> <!ELEMENT 製品 (名前|SKU)*> <!ELEMENT 名前 (#PCDATA)> <!ELEMENT SKU EMPTY> <!ATTLIST SKU 倉庫 NMTOKENS #REQUIRED 単価 CDATA #REQUIRED > ===================XMLそのもの(Q5484519-2.xml)================= <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE 製品管理 SYSTEM "Q5484519-1.dtd"> <製品管理> <製品 製品番号="001"> <名前>シューズ</名前> <SKU 倉庫="ABC" 単価="10000" /> </製品> </製品管理> となります。なお、文字符号化方式とファイル名はこちらの都合で弄っています。 ================ 説明については やさしく読むXML 1.0勧告 http://www.atmarkit.co.jp/fxml/indexes/index_col.html#xe13 や、その序盤で出てくる EBNFの記事で学んでください。 http://www.atmarkit.co.jp/fxml/ddd/ddd004/ddd004-bnf.html ================= ただ…個人的には スキーマを作るメモのつもりでインスタンスを書くならともかく、 スキーマの無いXMLのインスタンスからスキーマを書け、というのは嫌いだ。 ひょっとしたら <!ELEMENT 製品管理 (製品)> かもしれないのを、根拠も無く、複数の製品要素が登場する、と決め付けているから。
ノード同士を比較するだけで同じかどうかわかるようです。 http://www.oborodukiyo.info/Forms/F-XMLSameParent.aspx
ざっと見ただけですが……。 問題点は， ・タイトルの親は製品ではない ・カテゴリは1回と2回が出てきているのに1回となっている ・補足は0回と1回が出てきているのに1回となっている あたりでしょうか。 要素型定義の内容部分には，「どの要素がどの順番で何回出てくるのか」を記述します。 > <!ELEMENT 製品 (タイトル,名前,単価,カテゴリ,補足)> は， ・「製品」という要素の中に ・「タイトル」「名前」「単価」「カテゴリ」「補足」という要素が 　・この順序で 　・それぞれ1回のみ 　出てくる ということを意味しています。 慣れないうちは，各要素の親子関係を樹形図に書いてみることをお勧めします。
　XMLとXBRLの研究を少々やっております。 　ご希望のXBRLは財務情報用のXBRL FRでしょうが、私が取り組んでいるのは、取引記帳用のXBRL GLです。以下の参考URLでXMLとXBRLの操作の感覚は体験できるのではないかと思います。 　基本的なXMLはスタイルシート指定とDOMオブジェクトのプログラム操作の技術を活用すれば、操作できます。 　XMLに関しては、 「XML逆引きクイックリファレンス」 坂田健二著 毎日コミュニケーションズ刊 が詳しかったです。 　XBRLに関しては、 「XML技術とXBRLデータ標準を用いたインターネット財務情報システム」　湯浦克彦著　ソフトリサーチセンター刊 が参考になりました。 　そのうちにEDINETの情報をインポートし財務分析するシステムを開発してみたいと考えていますが、現状では参考意見程度を挙げておきます。
>あるいはDTDでの記述は無理なのでしょうか。 うん、無理。XMLSchemaでも出来そうな気がしないような。 http://www.w3.org/TR/REC-xml/#NT-elementdecl http://www.w3.org/TR/REC-xml/#NT-Mixed http://www.w3.org/TR/REC-xml/#NT-children
以前は、Googleで検索結果をXMLで返す無償のAPIサービスがあったけれど、 いつのまにかAPIサービス提供を止めたはずです。 現状、公式には、Google AJAX Search APIのコントロールを使う方法しかありません。 Googleで検索結果ページをXMLに変える仕組みを、自サーバーで作りこむしかないですね。 どこかで、非公式にやっているサイトがきっとあるはずでは？
Windowsでサンプルプログラムをビルド出来たのなら。 そのプログラムのxxx.exeファイルが出来てるはずですよね。 どうやって実行して、何が出力されるのかはそのサンプルプログラムの 中身がわからないと答えようがないですが。 普通は、 c:\>hoge.exe < fuga.xml みたいに、コマンドプロンプトで実行するものでしょ。
http://d.hatena.ne.jp/pyopyopyo/20060503/p1 等を参考にしてもいいですが、 極端なことを言えば、 所詮はテキストファイルなので解析をどうするか次第でしょう。
確かに、$xmlは配列じゃないですね。 $xmlはobjectです。とりあえずはif文を if (is_object($xml)) { にすれば、表示されますが、失敗した時の else{ の処理を直す必要があります。
サイトのソースを拝見させて頂きました。 原因はHTMLの ----- <object type="application/x-shockwave-flash" data="4balls.swf" width="825" height="276" id="husui.swf" > <param name="movie" value="husui.swf" /> <param name="quality" value="high" /> <param name="bgcolor" value="#FFFFFF" /> <p>This content requires the <a href="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&amp;promoid=BIOW">Adobe Flash Player</a></p> </object> ----- の部分の記述だと思うのですが、4balls.swfというファイルはきちんと配置されていますか？
噛み砕いて説明すると…、 HTMLはデータ(文書と言った方が適切かも知れませんが…)としてよりも、むしろ記述されたデータをブラウザで表示する目的で策定されたマークアップ言語であるのに対して、XMLはデータそのものを記述する目的で策定されたマークアップ言語です。 XMLは人間が読める形で記述できる上、構造化されたデータを記述することができるのでアプリケーション間やインターネット上でやり取りするデータとして作成されることが多いです。 XMLは要素(タグ)や属性の名前を自由に決めることができるので、適当にタグ名を決めて例えば下のようにXMLを書いても、もちろんXMLと呼ぶことができます。 ----- 適当なXMLの例 ----- <?xml version="1.0" encoding="UTF-8"?> <a> <b id="foo">bar</b> <c>hoge</c> </a> ただし、XMLはアプリケーション間やインターネット上でのデータのやり取りを主な目的にしていますから、上のようなXMLは意味をなしません。 (XMLを書いた本人は意味が分かっても、相手には分からないので) そのため、目的に応じて「スキーマ」と呼ばれるXMLの構造定義を公開して、XMLを書く人(アプリ等)はその定義に従ってXMLを書き、そのXMLを利用する人(アプリ等)はその定義に従ってXMLを読み込みます。 利用目的に応じて各スキーマがあるのですが、インターネット上で最も良く使われているのは、ブログ等の更新情報に利用されているRSSではないでしょうか。 その他、数式を記述するためのMathML、図形や画像を記述するためのSVG、あとはあまり知られていませんが、デジタル放送のデータ放送もBMLと呼ばれるXMLデータが使われています。
選ばれた要素の空白を除いた長さが4であるかをチェックしてみてはいかがでしょう <xsl:for-each select = "descendant::artist[contains(text(),'cobu')]"> 　　<xsl:if test="string-length( normalize-space( text() ) ) = 4" > 　　　　<xsl:value-of select ="text()" />: 　　　　<xsl:value-of select ="title" /><br/> 　　</xsl:if> </xsl:for-each> といった具合で ...
sitemap.xmlファイルはYahoo!やGoogle等のロボット型検索エンジンがサイトをクロール(巡回)しにきたときに、そのサイトの各ページの構成を知らせるために作成します。 ファイルには各ページのURLや最終更新日、更新頻度などを記述しておきます。 検索エンジンは基本的にサイト内でリンクされているページを順にクロールしていきますが、sitemap.xmlファイルがある場合はそこに書かれているURLについてもクロールしていくので、検索エンジンにインデックス(登録)されやすくなります。
画像に欠陥がある場合もたまにありますね。 画像がたくさんある場合はdownsizeallなどのフリーソフトを使用して 一括保存で短時間で処理できるかもしれません。 ともあれ、 前進できてよかったです★
VC6持ってないので厳密に検証はしてないけど, insertBeforeメソッドって使えない？ http://msdn.microsoft.com/en-us/library/ms754519%28VS.85%29.aspx http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-184E7107 http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-952280727
<xsl:attribute>は、XSL変換をするまで分からない出力属性を作成するときに使うもので、既にcontentという属性名を知っている場合は、使う必要はないです。いまの場合は、contentという属性名を知っているわけだから、DTDでcontent属性をCDATA指定してやれば、XMLタグ内の要素でもなんでも入れることができます。 ”<xsl:attribute> 要素は、ドキュメントを変換するまでわからない出力属性を動的に作成するのに非常に便利ですが、既に属性を知っている場合は、この要素を使用する必要はありません。たとえば、前の例で、IMG 要素に src 属性が含まれている必要があることが既にわかっているかもしれません。その場合は、ドキュメントを変換する前に、その要件がわかっているため、<xsl:attribute> 要素を使用する必要はありません。” http://msdn.microsoft.com/ja-jp/library/ms256165(VS.80).aspx
　あるページから、他のファイルの位置を参照する(ブラウザとサーバーの)機能をしっかり理解しておきましょう。なにしろ、ウェブの基本中の基本ですからね。 　ブラウザがあるファイルをサーバーにHTTPプロトコルで要求するときは、ネットワークに対して [HTTP要求ヘッダの例] GET /ディレクトリ(/ファイル名) HTTP/1.1 Host: サーバー名 User-Agent: Mozilla/5.0 (Windows; ***Firefox/3.0.10 Accept: text/html****application/xml;q=0.9,*/*;q=0.8 Accept-Language: ja,en-us;q=0.7,en;q=0.3 Accept-Encoding: gzip,deflate Accept-Charset: Shift_JIS,utf-8;q=0.7,*;q=0.7 Keep-Alive: 300 Connection: keep-alive という要求が行われます。 　ウェブ上のルーターが、サーバー名からIPアドレスを調べて、そのサーバーにファイルを要求します。 　GET(あるいはPOST)の要求を受け取ったサーバーは、指定されたファイルを提供しますが、【そのファイルは実在するとは限りません。】【重要】・・パスやファイル名を含めて動的に作成され提供される場合も多い。 [HTTP応答ヘッダの例] HTTP/1.x 301 Moved Permanently Date: Thu, 18 Jun 2009 09:51:40 GMT Server: Apache Location: http://サーバー名/ファイル名とパス Content-Length: 242 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/html; charset=iso-8859-1 　そのため、ブラウザは、そのページで指定されているファイル(画像・スタイルシート・スクリプトなど)の位置は知る由もありません。 　そこでブラウザは、そのファイルの【サーバー上のルートからの見かけのパスとファイル名】から、それらのファイルの場所を算出して、再びサーバーに要求します。そのとき、ページでの必要な指定方法は、 [ウェブ上の要求プロトコルと絶対パスとファイル名] 　http://[サーバー名][パス][ファイル名] [同じサーバーでの絶対パス] 　/[パス]と[ファイル名] 　　ブラウザからは、現在のファイルのプロトコル・サーバー名が付与される。 　http://サーバー名/[パス]と[ファイル名]とみなされる。 [同じサーバーでの相対パス] 　../[パス]と[ファイル名] 　./[パス]と[ファイル名] 　[パス]と[ファイル名] 　http://サーバー名/[算出されたパス]と[ファイル名]とみなされる。 以下同様・・・ 　よって、指定方法は 　../format.xsl ないし、 　http://[サーバー名][パス][ファイル名] のいずれか・・ 　
訂正、XMLからのテーブル書き換えはこちら↓ http://allabout.co.jp/internet/javascript/closeup/CU20051030A/index.htm でした。
×<xsl:sort select="@Num|No" /> <!-- これは NAMAE要素の子のNo要素、つまり <NAMAE>加藤<No>3</No></NAMAE> これなら多分ヒットする。 --> というわけで変えてみた。 ○<xsl:sort select="@Num|following-sibling::No" data-type="number" /> こっちの都合でdata-type属性まで付けてみた。他の属性をどうするかはお好みで。 #多分@Numもfollowing-sibling::Noもどちらもある要素の場合は@Numの方がノードリスト中で先に出てくるので，@Numの方が優先されると思う。多分。自信ないけど。 http://www.w3.org/TR/xslt#element-sort
●これからサイトを作るならxhtml。 普及は加速しているし、開発はxhtmlに引き継がれています。名前空間も使えますし。 ●UTF-8 サポートするブラウザが増えたから。これから制作で主流になるのは間違いないです。shift_JISで機種依存文字を使う人がいるんですよねぇ。携帯向けのサイトは作りませんよね? 携帯だとまだshift_JISでないとだめみたい。
Microsoft XML v3.0 以上だと、selectNodesメソッドでxpathが使えるようです。 Dim ObjXml As MSXML2.DOMDocument Set ObjXml = CreateObject("MSXML2.DOMDocument") ObjXml.Load("​hoge.xml")​ Set nlist = xmldom.selectNodes("//情報/大問/@形式=""1""") Dim node As MSXML2.IXMLDOMNode For Each node In nlist Debug.Print node.nodeName Debug.Print node.childNodes(0).nodeValue Next できるかなああ...
検索したらけっこうみつかりましたよ。 単に、 <script src="http://www.feedbeater.com/widgets/add.min.js"></script> を組み込むだけみたいですけど... カストマイズは http://www.diffbot.com/apps/feedbeater/ のサービスでできるようだ
私も，同じ疑問を抱えていて，つい最近解決しました。 ので知識不足ですが，参考になれば。。。 concat，substringを利用して以下のようにしてみました。 下記の場合，文字長＝７として動作させています。 質問では，空白によるパディングですが，仮に０詰めであれば， 簡略に， <xsl:value-of select="format-number(text(), '0000000')" /> とすればよいかと。 ＝＝＝　XML　＝＝＝ <?xml version="1.0" encoding="Shift_JIS"?> <?xml-stylesheet type="text/xsl" href="numbers.xsl"?> <numbers> <number>1</number> <number>12</number> <number>123</number> <number>1234</number> <number>12345</number> </numbers> ＝＝＝　XSLT　＝＝＝ <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:output method="text" encoding="Shift_JIS"/> <xsl:template match="number"> <xsl:value-of select="concat(substring(' ',1,7-string-length(text())),text())" /> </xsl:template> </xsl:stylesheet>
手元にあるのはこれです。 10日でおぼえるXML入門教室 http://www.amazon.co.jp/dp/4798104876 久しぶりにXMLを本格的に使うので、リハビリのためにと買ったのですが、なかなか良くまとまってます。
まず，XMLではシステム識別子を省略できません。 http://www.w3.org/TR/REC-xml/#NT-doctypedecl おそらく公開識別子のみでできる、というのはSGMLの話です。 僕はSGMLについて詳しくありませんが， どうやら http://www.kanzaki.com/docs/html/doctype.html#fpi にあるような 「SGML Open catalog」という定義用のファイルを書くことができるようです。 #俺の予想だけど，当時は常時接続って稀で文書インスタンスのシステム識別子としてファイルパスを与えるのが一般的だったのかもしれない。マシンを移動する度に毎回システム識別子を書き換えるのは面倒だから外部にあるのも解らんでもない気がする。相対URIで書いて二つのファイルを持ち歩けばよかったんじゃないかと思うと，何か違うような気もするが。いずれにしても俺の予想だから当てにしてはいかんぞ。
一つのリテラルで表記するのは無理だと思います。…と思ったんだけどなあ まず，XPath 1.0規格で一つのリテラルで表現する事はできないようです。 http://www.w3.org/TR/xpath#NT-Literal >そのプログラムではクオート文字をダブルコーテーションに限定しているので、 これがなく，一つのリテラルでなくて良い(計算結果でも良い)なら 回避策として concat("AB'C",'DE"F') とかどうにでもなるとは思うんですが。 念のためにXPath 2.0の構文を調べてみたら http://www.w3.org/TR/xpath20/#id-literals EscapeQuotやEscapeAposなんてものがあるので 多分"abc""def"というような表記が可能なようです。 #XPath 1.0同様にあとはXQuery 1.0 and XPath 2.0 Functionsの http://www.w3.org/TR/xpath-functions/#func-codepoints-to-string で計算してごまかすぐらい？ #実際にアドオンをインストールしていないのでFirefox AddonsがXPath 2.0に対応しているかは判りません。 #本題とは関係ないけど，プログラムのユーザーが 文字列を入力してそれが含まれるような要素を探すようなプログラムなら，XPath Injectionとか怖いから 文字列をXPath Expressionに直接つながないで，要素加えてからやるかな。
XMLと言うか、XHTMLへの変換ですが、以下のようなソフトがあります。 [参考]SourceForge.net: HtmlCleaner http://sourceforge.net/projects/htmlcleaner 「HTML」「XML」「変換」の3つをキーワードにぐぐれば、他にも色々見付かります。（変換精度は知りませんが。）
sitemap.xmlのことですよね？ サイトマップファイルはファイルが置いてある場所と同じ階層およびその配下しかURLを記述できないので、残念ながらサブドメインのサイトマップファイルを新たに作成する必要があります。 [参考サイト] http://www.sitemaps.org/ja/protocol.php#location
仕様自体がそうなのか自信ありませんが， とりあえず手元のXMLEDITOR.NETでは (//text())[1]とか(//text())[2]で aaaやbbbが取得できています。 #//text()[1]と書くと //(text()[1])という計算をするみたいです。
>「XMLの仕様では、要素は記述された順番に読み込まれるとは限らないよ」 本当です。 質問者様の参考サイトにも記述されていますが XMLにはパーサーの読み込み順序の規定は何もありません。 従いまして、パーサーによって読み込まれたXML要素の順序性は保証されず、 使用するパーサーに完全に依存することになります。 ただ、読み込み時にわざわざ要素を入れ替えるというパーサーを今までに私は見たことがありません。 （そもそも読み込む順序をわざわざ入れ替える理由も無いですから） ちなみにJavaならorg.w3c.domパッケージのElementクラスの getElementsByTagNameメソッドなどは「文書順に返す」といった記述が見られますね。 （ただ、Nodeインターフェースのメソッドはそういった記述が見当たらないですけど）
結論から言うとページ内のリンクが統一してあればどちらでも良いです。 ちなみに自分はindex.htmlを付けません。 将来的にトップページがindex.phpやindex.cgiになった場合に変更しなくて済むからです。
「文」で apply して投げているけれど 「文」の match による受け皿が無い って事じゃない？ その下位の「u」ではmatchするけどuだからね。その上位(同位)階層は含まれないでしょ？
ＸＭＬもＨＴＭＬも「マークアップ言語」と言われていて、その前進となったのがＳＧＭＬです。 で、マークアップ言語というのは、文章の構造をパソコンにもわかりやすくしてやるための言語です。 ・・・というと難しく聞こえますが、一冊の本に例えるとわかりやすいと思います。 例えば、小説なんかだと、「表題・章・節・段落」なんかに分けられますよね。 また、「状況を説明した文」とか「登場人物の会話」とかにも分解することが出来ます。 しかし、パソコンは言語を理解出来ませんから、パソコンにも分かるように「マーク」を付けてあげる必要があります。 この「マーク」が所謂「タグ」で、「Ｐタグは段落を表す」とか「Ｈ１は一番目の表題」などなどです。 パソコン（ブラウザ）は、この「タグ」を参考にして、「Ｐタグが合ったから段を変えて表示しよう」とか、「Ｈ１は一番目の見出しなんだから少し目立つようにしてみよう（※）」とか判断するわけです。 （※Hタグは、本来は「見出し」という意味であって文字の見栄えを変更するタグではありません。ただ、各ブラウザメーカの善意（？）で見栄えを変えているだけです） ＳＧＭＬというのは、パソコン黎明期に作られた規格です。 主に、出版関係者なんかで使われていました。 で、ＨＴＭＬというのは、それをネット通信でも使えるように再整理された規格です。 ＨＴＭＬは「マークアップ言語」ですから、文章の構造を考えて作られていきました。 しかし、ブラウザ競争の激化やJavaやFlashなどの新しい技術がどんどん取り入れられたり、その一方で携帯端末などのような機能が制限される環境で使われたりするようになっていきました。 技術開発にあわせて改訂を繰り返してきたHTMLでしたが、その度に「あっちを立てればこっちが立たず」な状況が生まれたりしてました。 また、各ブラウザメーカーが色々と「専用タグ」とか作って拡張されたりしていました。 特に、「文章の構造」を示す「タグ」と「文章の見栄え」を示す「タグ」とがごちゃ混ぜになっていきました。 そこで、「文章構造」と「見た目の構造」を厳密に分けようという考えが生まれてきます。 そうして出来たのが「CSS（カスケードスタイルシート）」です。 さらに進んで、「もう少しシンプルで拡張性のある仕様にしよう」という機運も高まってきます。 そうして生まれたのが、「XML」と「HTML」を融合させた「XHTML」です。 では、「XMLとは何か？」と言われると、SGMLをシンプルで拡張性のある仕様に整理されたモノです。 SGMLというのは、元々WEB環境のみを意識して作られたワケではなく、様々なシーンで文章を構造的に表現出来るように作られた規格です。 それと同じように、XMLもWeb環境以外の事も想定して作られています。 例えば、データベースを構築したり、検索しやすいテキストファイルを作ったりなどです。 下記に、それぞれの比較した違いを纏めてみます。 ○HTML ・規格策定団体であるW3Cによって「タグ」が決められている ・文章の階層構造を必ずしも表現していない ・終了タグを記述しなくてもよい ・大文字と小文字の区別をつけない ○XML ・「タグ」を自由に定義出来る（日本語のタグも使えます） ・文章の階層構造を表現できる ・終了タグを必ず記述しなければならない ・大文字と小文字の区別を付ける ○XHTML ・HTMLなので、「タグ」はW3Cによって決められている ・HTMLなので、従来のWebブラウザでも問題なく見られる ・XNLでもあるので、大文字小文字は区別する ・XMLでもあるので、終了タグは必ず記述する ・XMLでもあるので、MathMLやSVGなどのXML関連規格の言語も埋め込める といった感じかと思います。 まぁ、XMLもHTMLもSGMLという規格の子供であり、XHTMLはXMLとHTMLを掛け合わせて作った孫ってところでしょうか。
ここが参考になります。 ■特殊文字リファレンス http://www.htmq.com/text/index.shtml 特殊文字は「&キーワード;」(アンド、キーワード、セミコロン)、 「&#番号;」(アンド、シャープ、番号、セミコロン)といった 入力があります。 よく使うのは半角スペースを表示する &nbsp; ですね。 HTMLでは半角スペースは無視されてしまいますが、全角ではなく 半角のスペースを開けたい時などに使用できますね。 タグではないけど <html> といった表示をしたいときは ‹html› といった具合に置き換えます。 秀丸などの一括置換機能を利用したり、よく使う特殊文字コードを メモか何かに控えておくと良いかと思われます。
　レイアウト分けには、大きく分けて、二つの方法があります。 　一つは、<TABLE>を使用する方法。 　ボーダーなどの飾りをなにも表示しないテーブルを作成して、そのフィールドに、各ブロックを作っていきます。 　もう一つは、<div>を利用する方法。これは、ＣＳＳの、floatとwidthを利用して、各、divブロックの配置を指定していく方法です。 　div#container { width:100% } 　div#contents { width:70%; float:right; } 　div#sidebar { width:30%; float:right; } 　のようにやってあげて、後は、各divブロックの中に適切なコンテンツを入れていきます。widthとfloatの使いようで、相当自由なマルチカラムレイアウトの作成が可能です。（入れ子を駆使すれば、<table>より自由なレイアウトができます。） 　さて、テンプレートの件ですが・・・これは、htmlやcssの世界とは別の世界の話になります。ブログなどのページは、ユーザーが記事を随時追加していくわけですから、固定したhtmlファイルをサーバーに持っておくことはできません。というわけで、通常、aspやjsp等のアプリケーションサーバーを利用するのが普通です。（cgiのスクリプトという手もありますが・・・） 　この類の手を利用すると、テンプレートをいくつか用意しておいて、それをユーザーの指定により自由に組み合わせるという構成をとるることが可能になります。 　テンプレートファイルの中に、include文やタグで別のファイルを埋め込むような機構も用意されていますし、条件によってどのテンプレートを利用するかを選択する、果ては、条件によってテンプレートの一部を違う物とすり替える・その場で条件に合わせてテンプレートを自動で生成するなど、高度なことも可能です。が・・・これ、れっきとしたプログラミングの世界です。ホームページのデザインとは別の学習が必要となります。 　どんな世界かのぞいてみたければ、Ｊ２ＥＥとかＡＳＰとかアプリーションサーバーの様な単語で検索してみてください。
基本的な確認ですが、XMLファイルを書き換えた後、ちゃんとUTF-8で保存してますでしょうか？ Shift-JIS形式などで保存したら、ファイルの実コード自体がUTF-8じゃなくなってしまうので、文字化けしてしまうと思いますよ。 もしUTF-8で保存しているようでしたら、単純にFlash内でフォントが当てられてしまっているだけだと思います。 Flashにはフォントを埋め込むことができますから。 欧文フォントが割り当てられているため、日本語が文字化けしてしまうんでしょう。 その場合は、Flashの中身自体を編集できない限りは、直すことは不可能ですね。
<xsl:for-each select=".//1000"> -(1) これでは，変数にする以前の問題として，まともに動かないのでは？ 要素名の一文字目は数字にはできません。xpathも大丈夫でしょうか？ まず，変数にする前にきちんと動くようにしたとして，次に変数にするには，環境によって難易度が異なります。 xalanのようにdyn:evaluate()が使えるものは，要素名を変数に文字列として入れて，これをevaluate関数でノードセットに戻します。 概念的には， 　<xsl:variable name="hensu" select="'s1000'"/> として，要素名を''で囲んで，文字列としてhensuに格納します。 これを使うときは， 　<xsl:for-each select="dyn:evaluate($hensu)"> などとしますが，evaluateの引数は，パーサによって異なります。 なお，msxmlは，そのまんまではevaluateを使えません。 次に，<xsl:template match="1000"> -(2)ですが，これを変数化するのは不可能だと思います。 match内のxpath表現をランタイムで変更できる仕様はないと思います（多分）。 variableもparamも，xsltの変数は，通常のプログラム言語の変数と異なり，とても制限が多く，使いづらいものなのです。
XSLは、～～～ と、解説しようと思いましたが、下記の記事が参考になると思います。 http://www.atmarkit.co.jp/aig/01xml/xsl.html XML+XSLT->HTML
とりあえず，次のようにすると表示されると思います。 意図したような表示かどうかは別として。 </tr><tr> <td><xsl:value-of select="gai" /></tr> 　　～～～～～～～～～～～～～～～ </table> 　↓ </tr><tr> <td><xsl:apply-templates select="gai/link" /></td></tr> 　　～～～～～～～～～～～～～～～～～～～～～～～ </table> もうひとつ（各リンクを改行するために） <xsl:value-of select="text()" /> </a> </xsl:template> 　↓ <xsl:value-of select="text()" /> </a><br/> 　　～～～ </xsl:template>
いえ、関連づいていません。 #DTDで言うと、DOCTYPE宣言自体がない状態。 #妥当性検証は行われないがそれでもXMLとしては有効だ。 xsi:schemaLocation属性とかxsi:noNamespaceScemaLocation属性を調べてごらん http://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation
「SVG側の問題点」ではなく,俺があまり好きではない「ブラウザ側の実装状況」とかそういう観点からになるけど。 こういう書き方(直接svg要素が登場するケース)は問題ないけど Firefox系にとって,SVGはまだ、imageではなくobjectです。 https://bugzilla.mozilla.org/show_bug.cgi?id=231179 なのでimg要素に指定したり,CSSのbackground-imageで指定したりしても反映されません。(SafariやOperaは可能です。可能ならグラデーション背景をもっと自然に書けそうなのになあ…。) SVGのテキスト等は選択できません https://bugzilla.mozilla.org/show_bug.cgi?id=292498 #なお,確かXHTMLのimg要素のalt属性などによって表示されたテキスト, :before疑似要素や:after疑似要素等にcontentプロパティなどで指定して生成した文字列も選択できません。 https://bugzilla.mozilla.org/show_bug.cgi?id=12460 #svg:foreignObject要素に指定されたXHTMLの文字列は選択できたような気がする。 #svg:g要素等のtranform属性にrotateを指定してXHTMLの要素を含んだsvg:foreginObject要素を回転させようとしたとき,Flash等、プラグインを利用してレンダリングするタイプのものは回転しなかったような気がする。 ##関係ない話題も回答に含めてて,ポイント狙いとしては微妙な気がするけど関心ある話題ではあるので経験上わかっていることを書かせてもらった。
>携帯サイトで他サイトのRSSを自動で取得し表示させることはできますか？ できます >無知で申し訳ないのですが、他のブログのRSSから更新情報を取得して自分の携帯サイトに更新タイトルのみを表示させたいのですが、可能でしょうか? もちろん出来ます >ブログの内容を携帯用に変換することは考えておりません。 そういう難しいことは、私にはわかりません。 >可能であれば参考になるサイトなどご教授ください。 PHP一行で書けるRSSリーダー http://blog.myrss.jp/archives/2006/11/phprss.html ただし、WEBサーバで、PHP5　が使えることが条件です。 PHP5が使えるWEBサーバは、例えば、xreaとかロリポップ等があります。 ロリポップは、たぶん1週間か2週間お試しで、使わせてくれます。 試してみてはいかがでしょうか？
既に解決していると思うが、 すまん， 第一引数の名前空間コピペミスったorz XHTMLの名前空間じゃなくてMathMLの名前空間じゃなきゃいけませんねorz
ルートノードが一つに限られるのは，整形式のXMLでは絶対の基本です。 なので，ルートノードを付け加えないと，xsltでの変換はできません。 ただ，質問のようなXMLはfragment（フラグメント，断片）と言い，XMLを解析して操作するソフトをXMLパーサと言いますが，DOMを扱えるパーサであれば，フラグメントを読み込んで，ルートノードを付け加えるなどの処理をして，xsltで変換するなどが可能かもしれません。 なおxalanは，小生は使ったことがありませんので，このような処理が可能かどうかは分かりません。 あるいは，XMLは，単なるテキストファイルなので，プログラム的にルートノードを付加することも難しくはないので，フラグメントの読み込みなどよりも，テキストとして読み込んで処理するほうが簡単かもしれません。
<?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:output indent="yes"/> <xsl:template match="/*"> <xsl:element name="{local-name(.)}" namespace="{namespace-uri(.)}"> <xsl:apply-templates /> </xsl:element> </xsl:template> <xsl:template match="*"> <xsl:choose> <xsl:when test="count(*) = 0"> <xsl:copy-of select="." /> </xsl:when> <xsl:otherwise> <xsl:apply-templates select="*" /> </xsl:otherwise> </xsl:choose> </xsl:template> </xsl:stylesheet> このほうが圧倒的に簡単だね。(ただし,空要素はとってくる方針に変更)
MSXMLがXMLを読み込んで解析する際に，DTD部分がinvalidと判断されてエラーになっているのだと思います。 次のように，validateOnParseプロパティをfalseにしてみたらどうでしょうか。 var objDoc=new ActiveXObject("Msxml2.DOMDocument"); objDoc.validateOnParse = false; //←追加 objDoc.async=false;
好みの都合で余計なものいっぱいくっついているけど =================Q4511114-1.xml(入力)=============== <?xml version="1.0" encoding="UTF-8"?> <book> <ジャンプ>200円</ジャンプ> <マガジン>210円</マガジン> <サンデー>200円</サンデー> </book> =================Q4511114-1.xsl(変換)============= <?xml version="1.0" encoding="UTF-8"?> <!-- 教えてgooのシステムはURIっぽい文字列の前後にNO WIDTH SPACEをつけるため,回答をそのままコピーしても動きません --> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1999/xhtml" version="1.0"> <xsl:output method="xml" version="1.0" encoding="UTF-8" omit-xml-declaration="no" standalone="no" doctype-public="-//W3C//DTD XHTML 1.1//EN" doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" indent="yes" media-type="text/xml"/> <xsl:template match="/"> <html> <head> <title>Q4511114 TestCase 1</title> </head> <body> <xsl:apply-templates /> </body> </html> </xsl:template> <xsl:template match="book"> <table> <xsl:for-each select="*"> <tr> <td><xsl:value-of select="local-name(.)" /></td> <td><xsl:value-of select="text()" /></td> </tr> </xsl:for-each> </table> </xsl:template> </xsl:stylesheet> ==================Q4511114-2.xml(結果)============ <?xml version="1.0" encoding="utf-8" standalone="no"?> <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <title>Q4511114 TestCase 1</title> </head> <body> <table> <tr> <td>ジャンプ</td> <td>200円</td> </tr> <tr> <td>マガジン</td> <td>210円</td> </tr> <tr> <td>サンデー</td> <td>200円</td> </tr> </table> </body> </html>
XMLでは，ルート要素が必要です。 たとえば，次のように，<アルバム>というルート要素を定義し，すべての要素を，このルート要素の中に入れるようにします。 下の例では，個々の画像について，ファイル名を要素とし，時間や画像幅を属性としています。要素にするか属性にするかは自由に設定できますが，画像などは，実体としてのファイルがあって，そのファイルの属性として撮影日時などがあるので，これに合わせて要素や属性を決めると理解しやすいかもしれません。 --------sample.xml--------------- <?xml version="1.0" encoding="UTF-8"?> <アルバム> <画像 ampm = "pm" time = "7" min="30" width="300"> 0101.jpg </画像> <画像 ampm = "am" time = "9" min="40" width="300"> 0102.jpg </画像> </アルバム> このXMLから，画像と時間を表示するXSLは次のような感じです。 --------sample.xsl------------------------------ <?xml version="1.0" encoding="UTF-8" ?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="html" encoding="UTF-8"/> <xsl:template match="/"> <xsl:apply-templates/> </xsl:template> <xsl:template match="アルバム/画像"> <img src="{.}" width="{@width}"/> <br/> <xsl:value-of select="@ampm"/> <xsl:value-of select="@time"/>: <xsl:value-of select="@min"/> <br/> <hr/> </xsl:template> </xsl:stylesheet> これを表示するhtmlは次のとおり（IEのみに対応） --------------------------------------------- <html lang="ja"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <title>hello xml</title> <xml id="myxml" src="sample.xml"></xml> <xml id="myxsl" src="sample.xsl"></xml> <script language="JavaScript"> <!-- function start() { here.innerHTML = myxml.documentElement.transformNode(myxsl); } --> </script> </head> <body onload="start()"> <div id="here">ここに表示</div> </body> </html>
「ebank銀行の自分の口座の入出金明細情報をダウンロード」 ページってhttps(SSL)ではないですか？Microsoft.XMLHTTPは知りませんが XMLHttpRequestの場合、http:// => https:// の通信は出来ません。 https:// => https://　のみです。 「Ajaxで基本認証+SSL」というページを見つけました。
と要素はひとつしかもてませんから<doc></doc>とします。 XML <?xml version="1.0" encoding="UTF-8"?> <?xml-stylesheet type="text/xsl" href="./html.xsl" ?> <doc> <content> <text>データ１</text> <text>データ2</text> </content> <content> <text>データ3</text> <text>データ4</text> </content> </doc> XSL <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"> <html xml:lang="ja"> <xsl:apply-templates select="doc"/> <xsl:apply-templates select="doc/content/text"/> </html> </xsl:template> <xsl:template match="doc"> <body> </body> </xsl:template> <xsl:template match="doc/content/text"> <p> <xsl:value-of select="."/> </p> </xsl:template> </xsl:stylesheet>
こういう探し方じゃだめ？ http://www.google.com/search?lr=lang_ja&q=vbs%20xmlhttp
Countプロパティではないですか？ System.Diagnostioc.Debug.writeln( namelist.count.ToString() );
PHP5なら、前に回答したPEARのXML_Serializerの利用と同等の事が 簡単にできます。​ <?php $string = file_get_contents( XXXXX.XML); $xml = simplexml_load_string($string); /* Result Print*/ print "<pre>"; print_r ($xml); print "</pre>"; ?>
ShiftJISにおいて、半角の円マークをバックスラッシュの意味と円マークの意味の両方で使っているためです。 円マークは、Unicodeでは U+005CではなくU+00A5にマッピングされているので それがUTF-8表現で 0xC2 xA5 のようになっているのですが、 もはやこれはパスの区切り文字とは何の関係もないものなので (バックスラッシュは U+005Cなので 0x5Cとなる)、 その文字を含む文字列をパスを表すものとして解釈するプログラムが文句を言っているわけです。 libxml2 で受け付けるのかわかりませんが、encoding に Windows31-J とかはつかえませんか? あとはどうにかして円マークを使わないような表現にするとか(可能ならば)。
ルートノードがない地点でXML文書として認められない。 何かの書き間違いであると信じて要望を予測してみる。少なくとも何かのヒントにはなるはず ==============Q4374721-1.xml================ <?xml version="1.0" encoding="UTF-8"?> <customers> <customer0> <name>aaaa</name> <tel>1234</tel> </customer0> <customer1> <name>bbbb</name> <tel>2345</tel> </customer1> </customers> ==============Q4374721-1.xsl================ <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output indent="yes" /> <!-- お好みで --> <!-- templateは後から書いたものが優先されるので， ルート要素のcustomers要素は下のテンプレートに引っかかる 数字をチェックしているわけではなく単にcustomerで始まる要素をマッチさせているだけなので customersABCのような要素でもヒットする。 まぁその辺はXPathのsubstring関数とか，number関数に通してNaNかチェックしたり andで条件つなげればどうにでもなるでしょ？ --> <xsl:template match="//*[starts-with(local-name(),'customer') and namespace-uri()='']"> <item> <xsl:value-of select="name" /> </item> </xsl:template> <xsl:template match="/*"> <list> <xsl:apply-templates /> </list> </xsl:template> </xsl:stylesheet> ==============Q4374721-2.xml(結果)================ <?xml version="1.0" encoding="UTF-16"?> <list> <item>aaaa</item> <item>bbbb</item> </list>
================Q4352267A.xml=============== <?xml version="1.0" encoding="UTF-8"?> <books> <book> <title>絶対儲かる ルピーの稼ぎ方</title> <price>200</price> </book> <book> <title>フックショットの使い方 入門編</title> <price>50</price> </book> <book> <title>ハイラル城 鳥瞰図</title> <price>500</price> </book> <book> <title>早く走れる靴ランキング </title> <price>100</price> </book> <book> <title>世界の泉探索 -秋は夕暮れ-</title> <price>220</price> </book> <book> <title>ハートを求めて</title> <price>2000</price> </book> <book> <title>妖精の生態</title> <price>500</price> </book> <book> <title>世界の物語 53 闇の世界へようこそ！</title> <price>1500</price> </book> <book> <title>オカリナさんは俺の嫁！</title> <price>800</price> </book> <book> <title>ペンダントに使う宝石</title> <price>450</price> </book> </books> ================Q4352267B.xsl=============== <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/books"> <books> <xsl:for-each select="book"> <xsl:sort select="price" data-type="number" /> <xsl:if test="position() &lt;= 5 "> <book> <xsl:value-of select="position()" />:<xsl:value-of select="title" />:<xsl:value-of select="price" /> </book> </xsl:if> </xsl:for-each> </books> </xsl:template> </xsl:stylesheet> ===============Q4352267C.xml(結果。10件中5件を抽出。本の題名に突っ込んではならない. )============ <?xml version="1.0" encoding="utf-8"?> <books> <book>1:フックショットの使い方 入門編:50</book> <book>2:早く走れる靴ランキング :100</book> <book>3:絶対儲かる ルピーの稼ぎ方:200</book> <book>4:世界の泉探索 -秋は夕暮れ-:220</book> <book>5:ペンダントに使う宝石:450</book> </books> ============================== おまけ:猛烈な勘違いをしたようで，ソートルーチンを自作していた。 <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/books"> <hoge> <xsl:call-template name="minimum"> <xsl:with-param name="rank" select="1" /> <xsl:with-param name="all" select="book" /> <xsl:with-param name="min" select="book[1]" /> <xsl:with-param name="nodes" select="book[position() > 1]" /> </xsl:call-template> </hoge> </xsl:template> <xsl:template name="minimum"> <xsl:param name="rank" /> <xsl:param name="all"/> <xsl:param name="min" /> <xsl:param name="nodes" /> <xsl:if test="$rank &lt; 6"> <xsl:choose> <xsl:when test="count($nodes) = 0"> <p><xsl:value-of select="$min/price" /></p> <xsl:call-template name="minimum"> <xsl:with-param name="rank" select="$rank + 1" /> <xsl:with-param name="all" select="$all[ . != $min]" /> <xsl:with-param name="min" select="$all[ . != $min][position() = 1]" /> <xsl:with-param name="nodes" select="$all[ . != $min][position() &gt; 1]" /> </xsl:call-template> </xsl:when> <xsl:otherwise> <xsl:choose> <xsl:when test="$nodes[1]/price &lt; $min/price "> <xsl:call-template name="minimum"> <xsl:with-param name="rank" select="$rank" /> <xsl:with-param name="all" select="$all" /> <xsl:with-param name="min" select="$nodes[1]" /> <xsl:with-param name="nodes" select="$nodes[position() &gt; 1]" /> </xsl:call-template> </xsl:when> <xsl:otherwise> <xsl:call-template name="minimum"> <xsl:with-param name="rank" select="$rank" /> <xsl:with-param name="all" select="$all" /> <xsl:with-param name="min" select="$min" /> <xsl:with-param name="nodes" select="$nodes[position() &gt; 1]" /> </xsl:call-template> </xsl:otherwise> </xsl:choose> </xsl:otherwise> </xsl:choose> </xsl:if> </xsl:template> </xsl:stylesheet>
>Javaでも使えるでしょうか？ XMLとして適合する書式を持っていればjavaとか無関係だよ。 ちゃんとしたxmlになっているかどうか確認したかったらvalidatorを使うかfirefoxとかみたいなwebブラウザにドロップしてごらん。(IEはどう表示されるか判らないけど) パっと見、xmlになってない。 http://validator.w3.org/
http://www.google.com/search?q=xml%20dtd%20%E5%A6%A5%E5%BD%93%E6%80%A7%E3%82%92%E6%A4%9C%E8%A8%BC%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95&hl=ja&lr= なんかjavaでの検証の話が一杯だねぇ… で、探してたら一応こんなのを発見 http://www.xmleditor.jp/
実践してみたことはないんで自信はないけど xsl:importとかxsl:includeとか 使ってどうにかできないだろうか？
ちょっとメモ。 1. 何やりたいかはわかった。再帰全く関係ねー。 多分XMLとXSLTだけでは完結せず。他の言語によるプログラムで XSLTプロセッサに引数を渡すさないと無理っぽい(諦めろってこと) で,他の言語でやることになるなら xsl:templateの変数ではなく xsl:stylesheetの最初の子要素として <xsl:param name="TopData" select="1" /> を配置する(実際に試してみてはいない) 2.【オマケ】 文法ミス多すぎ。 CDATAに書いたものは単なるテキストノードになるだけ。XSLTの要素にはならないよ、当然。 #XSLTの変数はJavaとかで言うfinalって言えばわかる？ そもそも元のxmlファイルが整形式ではない ×<?xml:stylesheet type="text/xsl" href="hoge.xsl"?> ○<?xml-stylesheet type="text/xsl" href="hoge.xsl"?> 比較演算子が実体参照に直されてないためにXSLTスタイルシートそのものが整形式エラーを出してた。 xsl:attribute直下に何で要素が配置されてるんだよ xsl:sort のselect属性のpnoは@pnoの誤り #俺も知らなかった concat関数の引数はattribute value templateではないようで, {}で括るとエラーにされた・・・ので string($TopData+$PageData) とすることで切り抜けた。 s要素にマッチするテンプレートで出力される img要素やdiv要素は「XHTMLの名前空間の要素」ではなく「名前空間なしの要素」なので注意 個人的には【xsl:stylesheet要素】に「デフォルト名前空間はXHTMLの名前空間である」っていう名前空間宣言をつけとくのがいいと思う。 XHTMLの名前空間のimg要素はalt属性必須です。 XHTMLの名前空間のa要素の内容も指定しよう
実際にXMLマスターのプロフェッショナルを取得している者です。（当時はアプリケーションとデータベースの区別はありませんでした。） もう１年と半年以上も前の話なので今でも同じなのかは分かりませんが、参考になれば幸いです。 > C#では、同じものがあることもあるのですが、ないものもあるようです。 XMLはW3Cという機関が策定しており、例えばDOMの仕様に関して言えば、 レベル、エディション、モジュールという３つの概念で構成されます。 エディションはバージョンを示すだけですが、残り２つのレベルとモジュールによって DOMパーサーは選択的に機能を備えることができます。 つまり、使用しているDOMパーサーによって提供されるクラスやメソッドが変わるということです。 また、W3Cは仕様を制定しているだけで強制力は全くありません。 JAVAにしろVBにしろ、それぞれ独自のライブラリが存在し、 その中には、XMLデータを操作するためにそれぞれ特有のクラスやメソッドを提供しているものもあります。 私はC#を使ったことはありませんが、C#も同様に固有のクラスやメソッドを持っていることは十分に考えられることです。 しかしいずれの言語にしろ、XMLデータを扱う際の考え方にはさほど差はありません。 > 本番の試験ではプログラムが書かれている場合はJAVAなのでしょうか？ DOMとSAXの範囲はJAVAの文法で書かれていたように記憶しています。 しかし、問われるのは「W3Cで規定されているメソッド」の扱い方であり、 オブジェクト指向言語の基本的な考え方が備わっていれば、大して問題にはならないと思います。 > メソッド名とかも本で紹介されているもので覚えこまないと試験では通用しないのでしょうか？ 前述した通り、W3Cの規定した範囲が試験範囲となっているので、 本で紹介されているものだけを覚えてください。 余談ですが、DOMやSAXなどXMLを扱うためのインターフェース（言語仕様）をW3Cで規定しているのは どの言語でも同じようにXMLを扱えるようにするためという背景があります。 例えば、質問者様がC#で書かれたソースコードをJavaでも転用したくなった場合 そのときC#で使用していたDOMパーサーと同じレベル、エディション、モジュールを持つJavaのDOMパーサーを利用すれば ソースコードのロジックはほとんどいじる必要がなく移植することができます。（言語的な差異は出るでしょうが） 具体的に言えば、現在C#で動いているシステムがあったとします。 このシステムに利用しているXMLデータを、新たにJavaで作成するシステムでも利用するとなった場合を考えてみてください。 このとき、C#で作成されたシステムが行うXMLデータの解析処理がW3Cに則っていれば 新しく作成するJavaのシステムでも解析処理を転用しやすくなるということです。 XMLは「共通的にデータを扱うことに特化する」という特徴を忘れないでください。 それでは試験に無事合格されることをお祈り申し上げております。
XMLをブラウザで整形して表示するには、 xsltファイルとCSSが必要です。 学習されるなら、このあたりがXML入門者に易しいサイトだと思います。 http://www6.airnet.ne.jp/manyo/xml/ http://www6.airnet.ne.jp/manyo/xml/xslt/home.html
単にfor-each でデータ表示すればいいことなんじゃないの？ <xsl:for-each select="//test" > <xsl:value-of select="position()" />: </xsl:for-each>
http://www.google.co.jp/search?q=pdf%20%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA&hl=ja&lr=lang_ja PDFlibとかいうのが有るみたいだけど・・・・・希望の物かは良くわからない。
Javaや.NETでXMLって使えると思うけど、それじゃ駄目かな？ org.w3c.domとかSystem.Xml.XmlDocumentとか #IDE立ち上げるのが面倒なので,俺は何か確認する時にはブラウザ使っちゃうけど DOM Level 3系の実装とかが十分じゃないような。 #どっちかというとJava側の実装の方が好き。
============hoge.xml============== <testNode>aaa</testNode> =====================fuga.xsl============== <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match ="/"> <p> s<xsl:value-of select="name(.)" />s <!-- name(.)は何もありません。match="/testNodeとかなら値は出てくるだろうけど。"--> <xsl:apply-templates /> </p> </xsl:template> <xsl:template match="testNode"> <xsl:variable name="el"><xsl:value-of select="name(.)"/></xsl:variable> <!-- 7.6.2 Attribute Value Templates In an attribute value that is interpreted as an attribute value template, such as an attribute of a literal result element, an expression can be used 【by surrounding the expression with curly braces ({}). 】 {}で括らないでテストしたら$は要素名に使えないって怒られた。 --> <xsl:element name="{$el}">aiueo</xsl:element> </xsl:template> </xsl:stylesheet> ============= 出力結果 <?xml version="1.0" encoding="utf-8"?> <p> ss <testNode>aiueo</testNode> </p>
空要素とかの話は無視する。 文字符号化方式を変更すること自体は http://www.w3.org/TR/xslt#output xsl:outputのencodingを変更することで可能な模様。 ただし,実装によって以下の挙動がどうなるかは確認していない http://ja.wikipedia.org/wiki/Unicode#.E6.97.A5.E6.9C.AC.E8.AA.9E.E7.92.B0.E5.A2.83.E3.81.A7.E3.81.AEUnicode.E3.81.AE.E8.AB.B8.E5.95.8F.E9.A1.8C
＞「会議室」を書き出して、次の処理は下の処理に移動するが次には何もないので、「会議室」しか書き出されないのが答えなのかな 違います。 会議室から次の場所へ処理を飛ばすには、 <xsl:apply-templates /> のように、次の場所に飛ぶ命令をしなくてはいけません。 <xsl:template match="/"> 　　<xsl:value-of select="Conference/Room" /> </xsl:template> これでは、Conference/Roomの“会議室”という値を書き出したところで処理が止まってしまいます。 ちなみに、<xsl:value-of select="Conference/Room" />よりも <xsl:value-of select="." /> のほうが適当ですが、 下記の通りなので、詳しい説明は控えます。 根本的に、基礎的に質問者さんの認識はずれているので、質問と回答という形では、認識の矯正は難しいように感じます。 “XPath”と併せて入門書や入門サイトをご覧になられたほうが早いかもしれません。
まさに http://shikaku.impress.co.jp/errata/2142_xml_basic_mondai.html のことですか？
規則として#PCDATAは+に出来ないのよ。実は。 だからDTDの文法としてアウトなの。 http://www.isc.meiji.ac.jp/~miuraj/xml/xml_guide/xmldtd2.html
http://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation
(1)つまり、<color>要素の兄弟でループしているという考え方でよいのでしょうか？ OK (2) ><xsl:apply-templates select="." />で呼ばれるのは、<xsl:template match="color">であると思うのですが、 OK ><xsl:value-of select="jp" />で<jp>要素はよばれるが、 NG 呼ばれるけどjp要素に対して【templateを】適用しろ、とは言って無いし，value-of select自体はテンプレートでもなんでもないよね？ ><en>はビルトインテンプレートが呼ばれるのではないのでしょうか？？ NG これがもし， <xsl:when test="position() mod 2=0"> 　　<xsl:apply-templates /> </xsl:when> だったら， http://www.w3.org/TR/xslt#section-Applying-Template-Rules >In the absence of a select attribute, the xsl:apply-templates instruction processes all of the children of the current node, including text nodes. select属性がないので全ての子要素に対して該当するテンプレートを探して適用しますがね。 ============= 細かいことだけど，俺前回間違ったことを教えているところがあった。 http://www.w3.org/TR/xslt#strip
XMLの何をどう勉強されるのかによると思いますが、プログラムやXSLTで処理する用のデータを作りたいというのであれば、ネット上に転がっているXML文書（例えば、XML解説サイトのサンプルデータ）を拾ってきてそのまま使うかあるいは置換とか使ってタグ名などを書き直すかですかね。 もっと初期のXMLの文法とかの勉強だとしたら、実際に手を動かさないと憶えが悪いので、ANo.1さんのように雛形を作ってあとはコピーがいいんじゃないでしょうか。 もう少し勉強が進んでいて、文法は大体わかったから雛形すら打つのが面倒だとかいうことであれば、開発ツールについてくるXMLエディタとかを利用すれば、勝手に閉じタグを付けてくれたり、インデントしてくれたり、打ち間違えをチェックしてくれたりとかやってくれますので、それをコピーすればどうでしょうか。
WinXPで実験してみた ・・・・が，エレガントじゃ全然ない。 ファイル名が気に入らなかったというか考えながら打つのが面倒くさいので list.xml → hoge.xml elem.xml → fuga.xml となっている。 Editだとどうしても厳密に指定しなきゃいけなさそうな気がするので 諦めて新たにXSLTモドキを書いて別ファイル作ってしまえ！という策に出ることにした。こんなコマンド書くなら素直にXSLTファイルを別に用意してXSLTプロセッサに流したほうが楽だろうなあとは思う。 C:\xmlstarlet-1.0.1>xml sel -t -m "/x" -e "x" -m "@*" -c "." -b -m "e" -c "." -b -c "document('./fuga.xml')/x/e" -b ./hoge.xml 出力結果は以下の通り。 <x><e a="1">value1</e><e a="2">value2</e><e a="3">value3</e></x> ●ルート要素が共に各ファイルは/x/eという構造をしているものとしてのみ想定し，/x/aとか/x/text()があることは考慮されてない。 なお，一応XSLTの規格によれば http://www.w3.org/TR/xslt#section-Creating-Elements-with-xsl:element xsl:elementのname属性はattribute value templateらしいので 「ルート要素の要素名」という指定も可能だ。解説はしないので自分で読んどくれ。 ●hoge.xmlのルートのx要素に属性が存在していた場合には一応コピーするようにしたが，fuga.xmlのルートのx要素と属性が異なっていた場合は保証しない。 最後にこのコードをXSLTに直しておく。 面倒くさいのでxsl:output要素のencoding属性等コマンドラインでも 以下のシートでも指定してないのでUTF-16になる可能性大ですが。その辺はヘルプ見て。 <?xml version="1.0"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/x"> <xsl:call-template name="t1"/> </xsl:template> <xsl:template name="t1"> <xsl:element name="x"> <xsl:for-each select="@*"> <xsl:copy-of select="." /> </xsl:for-each> <xsl:for-each select="e"> <xsl:copy-of select="." /> </xsl:for-each> <xsl:copy-of select="document('./fuga.xml')/x/e" /> </xsl:element> </xsl:template> </xsl:stylesheet>
こんばんは(^^ ええと、本来VCDに該当しないファイルを置くとVCDとして認識されないんです。 どうしてもWhitebook規格外になってしまいますから。 </pvd>と<segment-items>の間に、VCDに相当しないファイルをおきます。 filesystem部分に記述します。 LinuxMpegTVが実行ファイルだけで動くなら（この辺りは未確認なのでDLLが必要ならそれも一緒に） <filesystem> <file src="パス\LinuxMpegTVのファイル" format="form1"> <name>LinuxMpegTVファイル実行ファイル名</name> </filesystem> これでbin+cueで出力してください。 bin+cueですから最初に仮想CDかなんかでマウントしWhitebook規格で通るのか確認してくださいね。Whitebook規格はうるさいから(^^;; ビットレートとかサイズとかです。 なので再生機にもよりますがね実は結構通りません。。 ただ、Linuxでは生mpegでも再生できるのであまり気にしないでいいかなと思います。 ではでは。
うん。誤解しまくっているね。 まずは「ビルトインテンプレート」について学ぼう。 http://okwave.jp/qa3362718.html #2リンク先 apply-templatesでselectしているのは 複数のbook要素ノードからなるノードセットだね。 <xsl:apply-templates select="books/book"/> 最初のbook要素はprice要素じゃないから 以下のテンプレートにマッチしない <xsl:template match="book/title/price"> よってビルトインテンプレートを適用する。 book要素の最初の子は(空白文字類からなる)テキストノード。これはそのまま。 次にtitle要素。だけどこれもprice要素じゃないからやっぱりテンプレートにマッチしない よってtitle要素にもビルトインテンプレートを適用する title要素の最初の子はテキストノードだからそのまま出力。 ●XMLとは title要素の次の要素はprice要素。ここでやっと，テンプレートにマッチするから適用していく。 テキストノード ● newTag要素開始タグ ●<newTag> テキストノード ● と続いて・・・ xsl:value-of要素のselectはマッチしているprice要素を基準に考えられるからprice要素そのもの。 xsl:value-of要素が出力する内容は http://www.w3.org/TR/xslt#value-of に従いstring関数にオブジェクトを指定した(string-value)のと同じ内容の文字列。 http://www.w3.org/TR/xpath#function-string http://www.w3.org/TR/xpath#element-nodes Element Nodeのstring-valueはその要素の子のstring-valueを全てつなげたもの。 price要素の子はテキストノードだけで，それはそのテキストノードの文字列そのものである。 http://www.w3.org/TR/xpath#section-Text-Nodes ●2000 テキストノード ● newTag終了タグ ●</newTag> テキストノード ● テンプレートおしまい。 次の要素はprice要素の次のノードだからテキストノード。 ● でtitle要素への適用終わり。 title要素の次はやっぱりテキストノード ● book要素への適用終わり。 テンプレートをbooks要素の子の次(二番目の)のbook要素に適用する。 この前のテキストノードはselectしてないから当然選ばれない。 ・・・・(以下略) だから出力結果は正しいです。 ====================== これがもし， <xsl:apply-templates select="books/book"/> ではなく <xsl:apply-templates select="books/book/title/price"/> だったら、出力結果は <?xml version="1.0" encoding="utf-8"?> <answer> <newTag>2000</newTag> <newTag>1800</newTag> <newTag>4000</newTag> </answer> となります。 ======================== ところで，多分サンプルの都合だと思うけど 普通はこういう構造にするよね・・・・ <?xml version="1.0" encoding="Shift_JIS"?> <books> <book> <title>XMLとは</title> <price>2000</price> </book> </books> #よく調べてないけど改行とかは無視されるのかも。 xml:spaceとか使うのかなあ？
俺自身はコード書くのが面倒くさいので eXtyle http://www.vector.co.jp/soft/win95/net/se236115.html (MSXML) とか XMLEDITOR.NET http://www.xmleditor.jp/cgi/yybbs/yybbs.cgi とか使って変換して確認している。 (ただ、掲示板で俺が述べているように，XGrepの仕様に疑問有り。次期バージョンでの修正に期待。XSLTの変換自体に問題はなさそう。実装自体は.NET Framework) 別に コマンドライン系のXSLTプロセッサを拾ってきたり .NETやらJavaやらで自分でコード書いてもらってもかまわないけどね。
XML、XSLTファイルはテキストエディタ（メモ帳など）で作成できます。 XMLファイルはXXX.xml、XSLTファイルはXXX.xsltのような拡張子で保存します。 動作確認は、作成されたXML文書のアイコンをWebブラウザにドラッグアンドドロップすれば確認できます。 XML文書をXSLTを利用してHTMLとして表示させるためには上記の2つがあれば良いので下記サイトなどを参考にして作成してみてください。 たのしいXML：http://www6.airnet.ne.jp/manyo/xml/
各ブログサービスはそもそもシステムが違います。 忍者ブログのテンプレートのインポート機能は、多分HTMLの中にある独自タグを忍者ブログのものに置き換えるんだとは思いますが http://www.ninja.co.jp/help/blog/admin/admin023.html ここに「現在は一部大手ブログのテンプレートのみの対応になっています」とあります。 ＞このXMLを使うにはどの様にしたら 自分で勉強してHTMLに置き換え、忍者ブログの独自タグを埋め込んでいくしかないでしょう。（そもそもBlogger・WordPress以外のブログで使うことは許されているんでしょうか） というわけで、このテンプレートは忍者ブログのテンプレートのインポート機能は使えません。
ヒント: exclude-result-prefixes
http://bakera.jp/ref/html/dataformat/rcdata >属性値の中で文字参照が解釈されることには注意が必要です。特に href属性の値に & を含む URL をそのまま書くことはできませんので注意してください。たとえば、http://example.jp/foo?bar&baz という URL があったとき、ブラウザのアドレスバーには http://example.jp/foo?bar&baz と打ち込むことになりますが、href属性の値としては href="http://example.jp/foo?bar&amp;baz" あるいは href="http://example.jp/foo?bar&baz" と指定する必要があります。 まあ要するに &voteid;という実体参照だとXML Parserが思っちゃっている(この解釈が正しい)から ;が足りない文法エラーだと言っているんだね。
えーっと。■は少なくともXML 1.0の要素名に使えない文字みたいです。(XML 1.1は知らん) まず http://homepage3.nifty.com/jgrammar/ja/tools/codeval0.htm の文字→符号値の欄に■を入力 UTF-16にチェックが入っていることを確認してください 符号値参照して調べると ■は16進数で25A0です ここで、 XML 1.0(Forth Edition)をみると http://www.w3.org/TR/REC-xml/#NT-STag 要素名がNameで それは http://www.w3.org/TR/REC-xml/#NT-Name Letter, _ , :のうちどれかで始まり、その後、0以上の任意の個数のNamecharが続くことになります Letterは BaseCharかIdeographic のどちらかですが、 示されたそれぞれのリストの範囲の中に#x2540は含まれません！ ちなみに Digit,CombiningChar,Extender, . , - にも含まれないので 要素名の2番目以降にも存在できません。規格上。 実際Minefield(Firefoxの開発版) XMLEDITOR.NET(フリーウェア),Safari,Opera 9.5等の実装も試してみましたが、当然のように駄目でした。
JDK 7でやろうとしたらエラーが出たし、エラーの原因を把握して動作するようにするのも面倒なのでメモだけ <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1999/xhtml" version="1.0"> <xsl:output method="html" encoding="UTF-8"/> <xsl:template match="/all"> <html> <head> <title>Q3861990 TestCase 1</title> </head> <body> <dl> <xsl:apply-templates select="index"/> </dl> </body> </html> </xsl:template> <xsl:template match="index"> <xsl:apply-templates select="product" /> </xsl:template> <xsl:template match="product"> <xsl:variable name="pos" select="floor((position() - 1) div 3)" /> <xsl:call-template name="compare"> <xsl:with-param name="pos" select="$pos" /> <xsl:with-param name="current" select="." /> <xsl:with-param name="nodes" select="../product[floor((position() - 1) div 3) = $pos]" /> </xsl:call-template> </xsl:template> <xsl:template name="compare"> <xsl:param name="pos"/> <xsl:param name="current" /> <xsl:param name="nodes" /> <xsl:if test="count($nodes[1]|$current) = count($current)"> <!-- 実際はここら辺にredirect:open要素やredirect:write要素の開始タグ・・ --> <dt><xsl:value-of select="concat($current/../@file_id,string($pos))" /></dt> <xsl:apply-templates select="$nodes/yoso" /> <!-- 実際はここら辺にredirect:open要素やredirect:write要素の終了タグ・・ --> </xsl:if> </xsl:template> <xsl:template match="yoso"> <dd><xsl:value-of select="../@file_id" />:<xsl:value-of select="text()" /></dd> </xsl:template> </xsl:stylesheet> 出力結果 <html xmlns="http://www.w3.org/1999/xhtml"> <head> <title>Q3861990</title> </head> <body> <dl> <dt>a0</dt> <dd>a-01:ああああああああああああああああ</dd> <dd>a-02:いいいいいいいいいいいいいいいい</dd> <dd>a-03:うううううううううううううううう</dd> <dt>a1</dt> <dd>a-04:ああああああああああああああああ</dd> <dd>a-05:いいいいいいいいいいいいいいいい</dd> <dd>a-06:うううううううううううううううう</dd> <dt>b0</dt> <dd>b-01:ああああああああああああああああ</dd> <dd>b-02:いいいいいいいいいいいいいいいい</dd> <dd>b-03:うううううううううううううううう</dd> <dt>b1</dt> <dd>b-04:うううううううううううううううう</dd> <dt>c0</dt> <dd>c-01:ああああああああああああああああ</dd> <dd>c-02:いいいいいいいいいいいいいいいい</dd> <dd>c-03:うううううううううううううううう</dd> </dl> </body> </html> ============================================ 教えてgooの仕様で,URIっぽい文字列の前後にXMLに存在できない空白文字を埋め込まれることが多い。動作しないことがよくあるのでテキストエディタで適宜編集してから使用すること。
サーバサイドプログラムが必要です。 自力でやるのであれば キーワード：お好きなサーバサイド言語 RSS 表示 他力本願なら キーワード：ブログパーツ RSS 表示
お役所ソフトで作成した オリジナルXMLとVBで作成したXMLファイルを 比較してみればいいのではないですか Windowsなら FC.EXEっていうファイル比較コマンドがあります コマンドプロンプトで (ファイル名は適宜修正してください) FC.EXE 役所.XML VB.XML[ENTER] または FC.EXE /B 役所.XML VB.XML[ENTER] といった使い方をします
MSXMLはMicrosoftが提供するXML関連ライブラリです。 ＞ブラウザに表示させるためにXMLをHTMLに変換するものと考えてよろしいんでしょうか？ ちょっと違います。 質問者さんの言っている変換機能(XSLT)はMSXMLの提供する機能の一部です。
まず、携帯ではJavascriptは動きません。これは携帯サイトを造るなら憶えておくといいです。 スクロールさせる要素としてはマーキーがあります。 http://www.htmq.com/html/marquee.shtml ただし、カーソルを載せるとスクロールを始めるというのは自動改行を禁止したテキストを表示するための携帯ブラウザ特有の機能だったりします。（機種によっては自動改行禁止が無効だったりもするようです） 例） <DIV MODE="NOWRAP">改行禁止のブロックで長い文章を書くとPCなら横スクロールバーが出ますが携帯ではその部分だけスクロールします。</DIV>
No7の方法は表記的には合っているけれど正しくないよ。 理由は item が複数有った場合正しい node を参照できていない可能性が有るから。 >で、どうやって解決したらよいのでしょうか？？ 見えないと判ったんだから見える所から持ってくるか、見える所から投げるか、って形に書き換えるしかないよ。 つまり A. match="item" の段階を作ってそこで生成する形に変更するか B. 現状の形で keyword で投げる時に title も渡すか C. rootで全部処理しちゃうか のどれか。 Bで要りそうなもの http://www.infoteria.com/jp/contents/xml-data/REC-xslt-19991116-jpn.htm#section-Passing-Parameters-to-Templates http://www.google.co.jp/search?q=xslt%20with-param&hl=ja&lr=lang_ja Cで要りそうなもの http://www.infoteria.com/jp/contents/xml-data/REC-xslt-19991116-jpn.htm#for-each 因みに「つまりどういうソース？」と聞かれてもそれは丸投げになっちゃうから答えてあげられない。
YAHOOのウェブマスターツールから実際にサイトマップを登録してみて、きちんと登録できれば認識出来ているかどうか分かると思いますよ。参照ＵＲＬにYAHOOウェブマスターツールからサイトマップの登録する方法が書いてある記事を入れておきました。 　認識されないファイルを入れるとエラーになるので一度試してみてください。
返事が遅くなりました。 すみません。 MSXML2.DOMDocumentでの文字コード指定による保存ですが、OKWave内でJScript.NETを用いた回答が過去にありましたので、参考URLをご覧になってみてください。 FileStreamを使用することで実現できそうです。 >また、初歩的なことかもしれませんが、XMLファイルの宣言文にある文字コード（encoding=）はどのように読めば良いのでしょうか。 読み込んで何をしたいのでしょうか？ System.Xml.XmlDocumentのLoadXMLメソッドを使用すれば、あまり気にしなくても良いと思うのですが...
　このSAXParserのparseだが、Fileインスタンスの他にInputStreamインスタンスを引数に取るオーバーロードが存在する。 　SAXParser#parse(InputStream, DefaultParser) これはInputStreamからreadしてパースするものだ。つまり、Stringを何らかの方法でInputStreamにしてやれば良い。方法は簡単。StringをgetBytesでbyte配列に取ってから、ByteArrayInputStremに食わせてやればよい。 // ※このように String str = "<xml? ......"; // SAXパーサーファクトリを生成 SAXParserFactory spfactory = SAXParserFactory.newInstance(); // SAXパーサーを生成 SAXParser parser = spfactory.newSAXParser(); // XMLファイルを指定されたデフォルトハンドラーで処理します parser.parse(new ByteArrayInputStream(str.getBytes()), new InsXMLParser()); 　動くと思うが頭ん中だけで書いているのでぜひ実験して欲しい。
><xsl:for-each select="pref"> ><p><xsl:value-of select="city" /></p> ></xsl:for-each> よーーーーーく　見てごらん for-eachの　繰り返す回数の基準は"pref" そしてその中で出力してる部分は1回のvalue-of(first-child) でも希望するのは全てのcityの出力。
＃１です。 >>Ａタイプのものを抽出する、ということをする場合において、どのようにプログラムを組むのか すみません、完全に見落としていました。 あくまで一例ですが、 データ構造１の場合でtype=Aを取り出したい場合は（xmlファイルはXMLobjにロードされているとします） var persons = XMLobj.getElementsByTagName("person"); var typeAs = new Array; var i; for(i=0;i<persons.length;i++){ if(persons[i].getAttribute("type")=="A"){ typeAs.push(persons[i]) } } これでtypeAsにtype=Aのものが配列として代入されます。 ただjavascriptはブラウザにかなり依存しますので 上記では動かない場合もあることをご留意ください。 たとえば、ブラウザによっては５行目を if(persons[i].type=="A"){ としても動くかもしれません。（※未確認です）
当方で検証不能。 関係してそうなところ。 http://www.w3.org/TR/xslt#output If no encoding attribute is specified, then the XSLT processor should use either UTF-8 or UTF-16. http://www.w3.org/TR/xslt#section-HTML-Output-Method >The encoding attribute specifies the preferred encoding to be used. If there is a HEAD element, then the html output method should add a META element immediately after the start-tag of the HEAD element specifying the character encoding actually used. 以上より 一応俺はXSLTファイルの方を弄って見る。 残念ながら >日本語がきちんと表示されるときとされない の境界条件が何かわからない。 本来なら常に化けないのが正しいと思うけどな #Shift-JISじゃなくてShift_JIS 間違えるとUTF-8だかUTF-16だかとして読み込まれるとかエラーになるとか そういう感じになると思うので注意。 http://www.iana.org/assignments/character-sets もし境界条件わかったら 補足なりお礼なりで教えてくれるとうれしい。
Adobe Dreamweaver CS3やSpryについては知りませんので、一般的なXMLの改行表示の方法について。 XMLを改行して表示させたい場合には、私の場合、保存する際にすべての要素ごとに改行を加えたりインデントを加えたりするXSLTを通すという手段を使っています。 Adobe Dreamweaver CS3というものにXSLTを通す機能があれば解決なのですが。。(そこについては我関せず) 以上役に立つかどうかわからない回答でした。
シェアウェアですが http://www.w-frontier.com/software/crosstalk/
Java開発者じゃないし，正しく意味が取れているか自信がないが，(というかJAXPがなんだか知らない(ぉ) 「schemaLocationやnoNamespaceSchemaLocation等をXML文書に記述しないで検証を行う」方法を調べることにした。 で，見つけたのが以下のValidateTest.javaだ。 また、以下のサンプルはそのままでは動作しない。MyErrorHandlerクラスが載ってないからで，ここをコメントアウトするなり自分で実装するなりすれば動くだろう。 見れば解るだろう が，args[0]がスキーマのファイル名，args[1]が検証するファイル名だ。 http://www015.upp.so-net.ne.jp/heyjude/java_xml010.html
1）RELAX NGとXMLを関連付けるにはどうしたらいいか。 DTDでいうDOCTYPEは、RELAX NGの場合どうしたらいいのでしょうか？ ざっと周辺サイトを見る限り，標準的な手法というものは存在しないようだ。 http://www.griffinbrown.co.uk/blog/PermaLink,guid,9aebb083-a961-42b1-9748-a57e06a0f19a.aspx 日付を見ると2007年7月26日の投稿なので現在においてもそれほど期待しない方がよさそうだ。 ちなみに， http://www.xmlmind.com/xmleditor/_distrib/doc/rngsupport/specifying_a_schema.html 等を見ると，各アプリケーションごとに処理命令で対処するような話も出ている。(当然ながらある一つのアプリケーションで検証されても他のアプリケーションでは有効にならないだろう) 2)RELAX NGに対応した妥当性検証ソフトはあるのか。 出来たら、ダウンロードできるサイトも教えていただければ幸いです。 いくつかはあるようだ。自分は使ってみたわけじゃないが， @IT他で知ったMSV等。 https://msv.dev.java.net/ #以下のリンクはリンク切れしている http://www.atmarkit.co.jp/fxml/rensai2/xmltool05/01.html 3)属性の値に一意性を持たせられるのか。 DTDでいう、IDのような指定は出来ないのでしょうか？ 標準的な方法はやはり存在しないんで，datatypeを使え，ということらしい。 http://www.oasis-open.org/committees/relax-ng/compatibility.html#id http://www.ibm.com/developerworks/jp/xml/library/x-custyp/ XML Schemaでいうkey,keyrefも似たような方法でやれってことなのかなあ？ http://www6.airnet.ne.jp/manyo/xml/schema/step35-2.html コレなんか見るとSchematronっていう別なもの導入しているようだが。 http://www.zvon.org/xxl/XMLSchemaTutorial/Output/ser_keys_st5.html
多分CDATAを載せることは出来ないと思う。 自分が混乱しないために諦めて >やはり&lt;に置き換えるしか方法はないのでしょうか？ に慣れることを非常に強く推奨するけど, >では、”>”の記号があるためXML構文がエラーとなります。 本当に？検証してみた？少なくともIE,Firefoxではエラーにならないよ。 属性値のBNFを見ると http://www.w3.org/TR/REC-xml/#NT-AttValue AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'" で [^<&"]だから>は除外されないよ？ <X 計算式="IF(C16<0,0,1)" /> とか不等号が逆向きになったらエラーだけどね。 HTMLの話だけどこれも面白いよ http://www.satoshii.org/markup/notes/2002/02#day24-2
英語がわからなくても http://www.w3.org/TR/XHTMLplusMathMLplusSVG/ のソースコードを追ってみると どういう仕組みになっているかわかると思います。 解説書こうとすると結構難しいので。 ============= ●<![INCLUDE[]]> <![IGNORE[]]> といった書式を取るマーク区間や ●<!ENTITY % hoge "hogefuga"> というように使われるパラメータ実体に関する知識 ●外部解析対象実体に関する知識 ●外部サブセットよりも内部サブセットの方が優先される ●同一サブセット内では先に書かれた宣言が優先される ってことがわかっていれば読めるはずです。 外部解析対象実体に慣れてなければ XHTML 1.1 DTDのFlat版が http://www.w3.org/TR/xhtml11/DTD/xhtml11-flat.dtd http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd を展開したものだとわかれば良いと思う ======================== ああ,そうそう,DTDを使うときの名前空間接頭辞の制約の一つとして 途中で名前空間接頭辞を変更することはできないことを覚えておきましょう。 (XMLとしてはOKだが,DTDでの定義に一致しないから) http://www.w3.org/TR/2001/REC-xhtml-modularization-20010410/dtd_module_rules.html#sec_D.2.4. =========================
これでいいのかは自信がない ==============Q3477885-1.xml(適用するXML)====================== <?xml version="1.0" encoding="UTF-8"?> <?xml-stylesheet href="Q3477885.xsl" type="text/xsl" ?> <foo> <bar xmlns="himajin100000">へんなやつ(終帝)</bar> <bar xmlns="himajin200000">キャット</bar> <bar xmlns="himajin300000">エンリケ</bar> <bar xmlns="himajin400000">マールバラ</bar> <baz xmlns="himajin500000">カプリコーン</baz> </foo> ==============Q3477885-1.xsl(スタイルシート)====================== <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:output method="xml" encoding="UTF-8" omit-xml-declaration="no" indent="yes" /> <xsl:template match="/"> <funya> <xsl:apply-templates /> </funya> </xsl:template> <xsl:template match="*[local-name() = 'baz']" /> <xsl:template match="*[local-name() = 'bar']"> <fuga><xsl:value-of select="./text()" /></fuga> </xsl:template> </xsl:stylesheet> =================Q3477885-2.xml(結果)================== <?xml version="1.0" encoding="UTF-8"?> <funya> <fuga>へんなやつ(終帝)</fuga> <fuga>キャット</fuga> <fuga>エンリケ</fuga> <fuga>マールバラ</fuga> </funya>
===========Q3453815-1.xml=========== <?xml version="1.0" encoding="Shift_JIS"?> <?xml-stylesheet type="text/xsl" href="Q3453815-1.xsl" ?> <LocaleList> <Locale> <LCID>1033</LCID> <Description>USA</Description> </Locale> <Locale> <LCID>1041</LCID> <Description>日本</Description> </Locale> </LocaleList> ==============Q3453815-1.xsl=============== <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <!--　 【重要】xsl:outputのmethodがxmlである状態で encodingを指定。indentは俺の趣味だが, 要素内容でなく混在内容を内容モデルに持つ要素があった場合,結構大きく関わるかも。 --> <xsl:output method="xml" encoding="EUC-JP" omit-xml-declaration="no" indent="yes" /> <xsl:template match="/"> <hoge> <xsl:apply-templates /> </hoge> </xsl:template> <xsl:template match="Locale"> <fuga><xsl:apply-templates select="Description" /></fuga> </xsl:template> </xsl:stylesheet> ==============補足================= ●一応このXMLファイルをMinefield/Geckoに読み込ませ、表示メニューから 文字符号化方式を確認したらEUC-JPになっていた。 ●IEでは表示メニューから文字符号化方式を確認することはできなかったものの(グレーアウト), 結果のテキストはIEでも正常に表示されているから,おそらく文字符号化方式はきちんと認識できていると思う。 ●eXtyleを使ってxmlファイルに書き出して,テキストエディタで開いてみたらEUC-JPであることが確認できた ●出力結果やスタイルシートが意味のないサンプルでごめんなさい
<!-- エラーメッセージを読もう。 Firefoxでは XMLファイルを読み込むとエラーが出た。 Error Parsing XSLT stylesheet,つまりXSLT側に問題があるとわかった。 ・・・ので整形式になってないんだろうな、と予想して XSLTファイルのみを読み込んでエラーメッセージを再確認。 <xsl:template match="Responce/Details"/> 間違えて閉じちゃっている 正しくは・・・ --> <xsl:template match="Responce/Details">
>どこかおかしな点がありますでしょうか？ 指摘しようとしたら実はわからなかったので，敢えて検討せずにごまかしてました。ちぇー許してくれないか。 手元での検証の結果とそれを元にした検証でひとつはっきりしました。 ====================== http://developer.mozilla.org/ja/docs/Introduction_to_using_XPath_in_JavaScript >注意すべきなのは、【XPath では接頭辞のない QName は名前空間が null の要素にのみマッチすると定義されている】という点です。XPath にはデフォルト名前空間を取得する手段はありません。名前空間が null ではない要素や属性にマッチさせるには、接頭辞付きの名前テストを使い、その接頭辞を名前空間にマッピングする名前空間リゾルバを作成する必要があります。詳しくは下記のユーザ定義の名前空間リゾルバを作成する方法を参照して下さい。 ================= だそうです 現に手元の別ソースのamazon名前空間接頭辞をデフォルト名前空間にして取り除いたら結果が異なりました(汗 あとはほとんど影響ありません。前回の回答の地点でわかっていた内容ばかりです 「Item要素の直接の子としてTitle要素は存在しないので，<xsl:value-of select="ItemAttributes/Title" />としないとならない点。 それから，xsl:apply-templatesのselectを省略したときは その全ての子要素(【OperationRequest要素を含みます！！】)にテンプレートルールを適用する ビルトインテンプレートのおかげで、xsl:value-of要素のselect属性でテキストノードを指定しなくてもそのテキストが表示されます http://www.asahi-net.or.jp/~PS8A-OKZK/xml/xslt10_1/builtin_template.html http://www.asahi-net.or.jp/~ps8a-okzk/xml/memo/memo_xslt.html 上記で述べたことを考えると，これはRequestId要素のテキストノードやRequestProcessingTime要素のテキストノードにも適用されていますので注意！
かなり乱暴な説明になりますが。 ・RSSファイルにサイトの更新情報を(XMLで)書いておく。 ・サイトのトップページあたりからそのファイルをリンクしたり、meta情報としてヘッダに書いておき、RSSの所在を明らかにして置く。 手書きでRSSを書くのも大変なので、だいたいの場合は更新情報の管理をCGIなどで行い、RSSファイルが更新されるようにしておく。Blogはこれが一体になったもの。 http://www.itmedia.co.jp/enterprise/articles/0504/08/news051.html こちらはBlogの構成要素としてのRSSの解説ですが、割とまとまっているかな？と思います。
http://www.kanzaki.com/memo/2006/11/06-1 こちらが参考になりますでしょうか？
エスケープしてください(実体参照といいます) < = &lt; > = &gt; <hoge>xが3より大きいことをx &gt; 3とあらわします</hoge> #CDATAマーク区間は好きじゃない
GIZMO ＆ Flash でガジェット を作成したことがある者です。 ？？？ わかっていらっしゃるのかいらっしゃらないのかよくわかりませんが， 「あなたごよみ」 も GIZMO を利用しているのですよ。 GIZMO から有償で専用のガジェットを作成してもらっているのです。 GIZMO は型にはまったガジェットを作成するプログラムやシステムではありません。 Flash で１から作った物を，Web ではなく，デスクトップ上で動かせるようにしたプログラムと，Flashコンポーネントなどの統合ツールです。 ですから，とりあえずは，Flash MX 2004 以上が必要で， それで ガジェット用 Flash を作成します。 その作成する前の段階で，まず Flash に GIZMO コンポーネント を導入しておく必要があります。 そして 作成した Flash（SWF） と XML などを GIZMO 指定の場所にインストール（保存）して， その保存した SWF や XML を GIZMO エンジンでデスクトップ上に表示させるのです。 すると，フワフワ浮遊するようなガジェットなどが作成できます。 GIZMO を使わないとなるなら， GIZMO みたいなものを自分で開発しなければならないでしょう。 また，Windows Vista 限定で，Vista用ガジェットを作成するかです。
XML/XSLド素人ですのでご容赦を。 二重ループで変数に退避した値と比べてマッチングしたみました。 数が多いと時間が掛かりそうなんでつかいものにならないかも。 <xsl:for-each select="test/item"> <xsl:variable name="id"> <xsl:value-of select="@id" /> </xsl:variable> <xsl:for-each select="/test/detail"> <xsl:if test="$id=itemid"> <xsl:value-of select="yomigana" /> </xsl:if> </xsl:for-each> ,<xsl:value-of select="name"/> </xsl:for-each>
>Javaのabstractメソッドは、確か中身がないメソッドということで、オーバーライドし >ないと呼び出すことができないんではなかったでしょうか・・。 確かに、 DocumentBuilder db = new DocumentBuilder(); みたいな書き方はできません。 ただ、例えばDocumentBuilderImplという、「DocumentBuilderを継承した」 (抽象クラスでない)普通のクラスがあったとすると、 DocumentBuilder db = new DocumentBuilderImpl(); みたいな書き方はできます。 javax.xml.DocumentBuilderFactoryクラスのnewDocumentBuilderメソッドは、 これと同じようなことを内部的にやってるのです。 実際に中身がどういうものか分からないけど、DocumentBuilderを継承した クラスのインスタンスを返す、ということをこのメソッドはやってるのです。 何でこんな回りくどいことをしてるかというと、 例えばXMLの仕様が大きく変わり、今のDocumentBuilderImplクラスでは 対応できなくなってDocumentBuilderImpl2というクラスを作ったとします。 すると、このクラスを使ってる人に、 DocumentBuilder db = new DocumentBuilderImpl(); を DocumentBuilder db = new DocumentBuilderImpl2(); という風にすべて変更してもらわないといけなくなります。 APIのようにたくさんの人が使うようなものの場合、これだとうかつに更新できません。 一方、javax.xml.DocumentBuilderFactoryクラスの場合は、 このクラスを使ってる人はnewDocumentBuilderメソッドを読んでるだけです。 なので、中身の部分だけがこっそり差し替わっていれば、 newDocumentBuilderメソッドは何も触らなくてよいのです。 こういうお決まりのテクニックのようなものを「パターン」と呼んでいて、 今回のは「Factoryパターン」という名前がついてます。 「デザインパターン」とか「GoF」とかで調べるとこういうテクニックがいっぱいあります。
あ、すんません。 >xsl:output method="html" になっているけどうそです >xsl:output method="xml" で
実はこう(やや省略形) <script> alert("test"); </script> 理屈の話をするとscriptというタグの中身の値として alert("test"); を保持しているという形になる。 htmlではタグの中身という位置では捕らえないのでコメント化し不可視化する必要が出てくるがxmlでは明示的に出力しなければ描画としては出てこないのでこのようになると思われる。
Q3207219-1.xml <?xml version="1.0" encoding="UTF-8"?> <?xml-stylesheet href="Q3207219-3.xsl" type="text/xsl"?> <empList> <emp> <type id="1" /> <name>鈴木</name> <desc>あああ</desc> </emp> <emp> <type id="4" /> <name>田中</name> <desc>いいい</desc> </emp> <emp> <type id="2" /> <name>田中</name> <desc>いいい</desc> </emp> <emp> <type id="3" /> <name>田中</name> <desc>いいい</desc> </emp> </empList> Q3207219-2.xml <?xml version="1.0" encoding="UTF-8"?> <!-- スタイルシートここはいらないだろう <?xml-stylesheet href="a.xsl" type="text/xsl"?> --> <typeList> <type id="2"> <title>タイプ2</title> </type> <type id="1"> <title>タイプ1</title> </type> <type id="3"> <title>猪突猛進タイプ</title> </type> <type id="4"> <title>遠隔操作タイプ</title> </type> </typeList> Q3207219-3.xsl <?xml version="1.0" encoding="UTF-8" ?> <xsl:stylesheet version="1.0" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="html" encoding="UTF-8" omit-xml-declaration="yes" doctype-public="-//W3C//DTD XHTML 1.1//EN" doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" media-type="text/html" /> <xsl:template match="/"> <html> <head><title>サンプル</title></head> <body> <xsl:apply-templates select="empList/emp" /> </body> </html> </xsl:template> <xsl:template match="emp"> <h2><xsl:value-of select="name/text()" /></h2> <p>タイプ： <xsl:call-template name="hoge"><xsl:with-param name="Id" select="type/@id" /> <xsl:with-param name="Id2" select="document('Q3207219-2.xml')/typeList" /> </xsl:call-template> </p> <p>メモ：<xsl:value-of select="desc/text()" /></p> </xsl:template> <xsl:template name="hoge"> <xsl:param name="Id" /> <xsl:param name="Id2" /> <xsl:for-each select="$Id2/type"> <xsl:if test="$Id = @id"> <xsl:value-of select="title" /> </xsl:if> </xsl:for-each> </xsl:template> </xsl:stylesheet> 【後記】 手元のeXtyleとMinefieldで一応きちんと確認しているが， 正直自信がない。 俺は，XSLTを頻繁に書いている人でもないし どこかで引数や戻り値にノードリストを指定できないとか聞いたような気がするからだ。 (引数に出来ているのはMSXML 6(VB.NET Orcas付属)やGeckoのバージョンが関係して・・・ないか) (そのため、並び替えた後に処理ができないとか、なんかそういう話があったような。
うーん、こっちのFirefoxでは，一応効いているみたい。 a要素の下線が表示されないからね(text-decoration:none;が効いている) ただ， >@import "hinagata/base-weblog.css"; >@import "hinagata/h2l-default/h2l-default.css"; >@import url(./css_custom.css); 正しい記述はどっちだ？ そしてこれらのCSSファイルもstyles-site.cssと同時にアップロードしたかな？
なら　xsltでHTMLへ書き出しをしてみたらどうだろう。 http://www.infoteria.com/jp/contents/xml-data/REC-xslt-19991116-jpn.htm http://www.google.co.jp/search?q=%E5%A4%96%E9%83%A8xml%20xslt&hl=ja&lr=lang_ja
XSLT,XML Schema,RELAX,SOAP等【を除く】XMLの基礎的な範囲は先にやっておいたほうがXHTMLの【構文】は理解しやすいと思う。 DTDやSGMLのある程度の知識は先にやっておいて損はないし、XMLとほぼ範囲が一緒だ。 #同時にStrictなマークアップ、という概念も理解しておいてほしい。XMLだけ勉強すると出てこない範囲だと思うけど。 中級者になったら http://www.w3.org/html/wg/html5/ とかあさったりしてもいいかも
XMLマスター：ベーシック試験とXMLマスター：ベーシックV2では 試験の傾向がかなり変わっているようですので、試験対策としては 新しい本のほうが良いと思います。 V2試験範囲に関しては下記のページを参考にしてみてください。
http://support.microsoft.com/kb/275883 言語パックによって異なるらしい。 KB275883に書かれているのはネイティブサポートだと。
>ファイルをアップロードしてチェックした場合だとSorry! This document can not be checked. 再現した(笑) [原因] どうやらファイルアップロードはXML宣言にShift_JISって書いてあっても us-ascii扱いになってしまうようだ。 で、そのために「ごめんね、マルチバイトの文字は読めないの」って謝られるの。 [回避策] Extended File Upload Interfaceって奴にアクセスすると 色々指定できる。チェックする時にアップロードして Encoding:の欄を(detect automatically) [自動的に検出する→us-asciiと検出される]からshift_jisを明示してあげると検証が行われる。 俺は大抵BOM付UTF-8で文書を作ってきちんと自動認識されていたと思う。(BOMなしだとus-asciiとかその他のエンコードだと思われかねないから) ======================= >This page is not Valid (no Doctype found)! [原因] テキスト入力だと「DOCTYPE宣言書け」って書いてあるくせに、 内部サブセットだとDOCTYPE宣言だと認識できず 要素型宣言等をタグだと思い込みやがるらしい。 (当然終了タグに該当するものがないので「きちんと閉じやがれ」って言ってる) [回避策] なし。多分仕様。
検索したところでは いくつか2GBの制約があるというのを見つけることが出来た。 MS公式情報ではないのでどれだけ信頼性のある情報かわからない。 すくなくともMSDN Library2にはこの件に関する記述はない http://msdn2.microsoft.com/en-us/library/system.xml.xmltextreader.aspx http://www.thescripts.com/forum/thread171942.html http://www.topxml.com/system_xml/system_xml_xmltextreader.asp >Use this class when iterating through or retrieving data from larger documents, and when validation is not required.【However, note that this class does not support files larger than 2GB.】 Below are three simple examples that incorporate the System.Xml.XmlTextReader class. 本当はMSDNあたりからの情報が欲しいんだけどな。 http://www.thescripts.com/forum/thread572092.html >A process can only use up to 2GB memoery on a 32 bit operating system. In this case, you cannot load an xml file larger than 2GB into memory using XmlDocument. In this case, I suggest you use XmlTextReader.【As far as I know, in .NET framework 1.1, it has a 2GB limit also. However, in 2.0 this limit was fixed and no longer exists.】 によれば.NET 2.0ではこの問題は治っているようだ、との記述もあるようだが・・・質問者様が恐らく納品されるであろう先の制限で出来ないんだろうね・・・
#1さんのをもうちょっと砕くと http://forum.java.sun.com/thread.jspa?threadID=694303 多分正確にはXMLが一番先頭以外の場所にあって、 空白行やその他のものが先頭にある状態・・・だね。 結果としてこの「XML宣言もどき」が「処理命令」として解釈されてしまっている。 →「でもXMLやxmlという処理命令は存在してはならないことにXMLの仕様でなっている」→「エラー」 だと思う。
基本的なことを書いて申し訳ないのですが、以下のページ(ログイン要求されます)内の「▼ 記事情報の更新方法」で解説されている、RAID-MAXさんの http://anime-max.net/rss.xml 専用のping送信先URLに送信してますか？ あと、グレーの文字の部分で、 >任意のURLへのping送信ができない場合はここをクリックすることで送信することができます。 とあるように、このページにアクセスして手動更新しなければならない場合もあるようです。 ちゃんとした答えでなく、すみません。
>できればjavascriptは使いたくありません 無理。 動的変更を行う為には「DOM」というのを利用する事になる。 そのDOMはブラウザ経由ではjavascriptという手段でなければ実現できない 又は「java」(アプレット) javaだとpluginだからflashでやっても構わないかも
xsltで　　　とか
xslでhtml出力する時に　<a href=""></a>で囲みたいということでしょうか？ xml記述に属性を追加して <link url="toko.html">文</link> としておいて、xsl側では <?xml version="1.0" encoding="UTF-8"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"><!-- メインtemplate --> <!-- 他は適宜指定 --> <xsl:apply-templates /><!-- 子要素の全てについて、該当templateを探して適用する --> </xsl:template> <xsl:template match="link" > <a> <xsl:attribute name="href"> <xsl:value-of select="@url" /> </xsl:attribute> <xsl:value-of select="text()" /> </a> </xsl:template> </xsl:stylesheet>
<!ELEMENT wsdl (#PCDATA) > って話なんだよね？ そこにそれを埋め込むと#PCDATAじゃなく要素と思われるからエラーと。 でもどの話なのか良く判らないな・・・ ★文字実体参照に変換していく話 ★CDATAマーク区間を使う話 http://www.ne.jp/asahi/minazuki/bakera/html/sgml/markedsection.html.ja.utf-8 を使う(意外と厄介なので注意が必要) ★外部解析対象外実体の話(そもそも俺はほとんど理解していない) http://sdc.sun.co.jp/news/200011/tax01.html
(1)http://www.atmarkit.co.jp/fxml/rensai/w3cread01/w3cread01.html (2)http://www.doraneko.org/xml/xml10/19980210/Overview.html (3)http://www6.airnet.ne.jp/manyo/xml/index.html ってことかな？ 実例があってとっつきやすいのは(3)。 (2)は規格原文の和訳。ただしXMLは(より明確にするために)いくつかの点で文章が修正されたりしてForth Editionあたりまで出てたかも。和訳版があるかわからんので避けたが。 (1)が仕様書の読み方を説明したもの。仕様書をわかりやすく読みたい人向け。
=========source.xml============= <?xml version="1.0" encoding="UTF-8"?> <root> <test> <a>あああああああああああああ<bold>い<strong>い</strong>いい</bold>あああああああ</a> </test> <test> <a>ううううううう<bold>えええええ</bold>ううううう</a> </test> </root> =============transform.xsl=============== <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:output indent="yes" /> <xsl:template match="/"> <xsl:apply-templates/> </xsl:template> <xsl:template match="test"> <xsl:apply-templates select="@*|node()"/> </xsl:template> <xsl:template match="bold"> <xsl:element name="b"> <xsl:apply-templates select="@*|node()"/> </xsl:element> </xsl:template> <xsl:template match="a"> <xsl:element name="p"> <xsl:apply-templates select="@*|node()"/> </xsl:element> </xsl:template> <xsl:template match="@*|node()"> <xsl:copy> <xsl:apply-templates select="@*|node()"/> </xsl:copy> </xsl:template> </xsl:stylesheet> ====================result.xml=================== <?xml version="1.0" encoding="UTF-16"?> <root> <p>あああああああああああああ<b>い<strong>い</strong>いい</b>あああああああ</p> <p>ううううううう<b>えええええ</b>ううううう</p> </root>
いくつか考えられますが、 まずbase.xmlのxml構造としてルート(base)しかないのが気になります。それと <xsl:template match="base"> base:<xsl:value-of select="base" /> </xsl:template> ではなく、 <xsl:template match="base"> base:<xsl:value-of select="." /> </xsl:template> です。 自分のノードにいる場合、 自分を表示するには、「.」を使用します。
補足要求。 (どんな研究かなあ・・・) >良いデータを見つけることが出来ません 質問者さんにとって【「良いデータ」ってどんなデータ】だい？ あるいは「集めたデータ」の【何が不満】なんだい？ (実はValidでないものが多いとか・・・・規格が偏っているとか) >条件としては、日本語のXML文書で、構造は特に指定しません。 具体的に探したわけじゃないが， Webデザイン・開発系のサイトを回ればValidなXHTML 1.0な文書は容易に入手できると思うし， (ただし，ブラウザの実装の問題からDTDに沿わないembed要素やがあったり，XML宣言がないUTF-8の文書に偏るだろう) 最近Blog等が台頭しているからMovable Type等によって生成されたXHTML,RSS,ATOMあたりも入手は容易かと思う。
その認識で問題ないと思われる。 質問の文書では2行目でheaderのnamespaceが宣言されているがその内側は名無し(#default)となっているのでこの場合はheader namespaceのタグでは無い事になる。 headerに属する為には想定した2通りどちらかの形になるが　前者の記述でnamespaceを明確化してある方が正しい書き方だったと思う。
＜Url＞<![CDATA[​ここにURL]]>＜/Url＞ としてみたらどうでしょうか？？ おそらく? = & のどれかが悪さしているのだと思われますが・・・ 違ったらごめんなさい
#2については自己解決しました。後は質問者様の補足待ちです$Idの件も聞きたいし [XML] <title> </title> <!-- ここに文字列を入れました--> [XSLT] <xsl:template match="info/group/page" mode="main"> <xsl:value-of select="title"/> <!-- これのせいだったようです。ここをコメントアウトしたら解決しました。また、p要素等として括ってあげてもうまくいくことを確認しました --> #2のソース、Gooの仕様上，数値文字参照に変換されちゃってますが， XSLTをどうなおせばいいかは質問者様なら想像つきますよね
頑張って考えたけど、ギブアップです。ごめんなさい。 http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.php?topic=17942&forum=9&4 >ITEMでposition()を表示した場合は、ソート順の位置を持っているようですが、X,Yからancestor::DATA/ITEMで指定するposition()は元の文書上の位置のようです。 こんなの知るかあ・・・orz http://www.mothprog.com/prog/xslt2/xslt3.html >このように、段階を踏む処理をするには、 XSLTスタイルシートで結果として構成されたツリーに対して、さらに処理を与える必要があります。ところが、これまでは一つのXSLTスタイルシートで多段階の処理をすることはできませんでした；XSLTの処理結果(result tree fragment)が代入不能だったからです。 うーん。やっぱりfor-eachの後の結果は利用できないorz
UTF-8じゃないなら　<?xml ?>　は必須。 xml文書として最初に出現しなければならないので<!DOCTYPE>より前でなければならない。 <!DOCTYPE>はxmlを検証するためのものなので　そもそもxmlであるという宣言(<?xml?>の事)より先にしてあると正しくない。
どのような言語でどのようなフォーマットのファイルを処理するのがわかりませんが・・・ 一般的にDOMは特定の目的に特化した独自の処理系に比べて動作が遅いです。 入力元と出力先がともにXMLならDOMを使うことでコーディングの量は大幅に削減できると思います。 入力元がXMLで出力先がXML以外フォーマットであるまたは 入力元がXML以外のフォーマットで出力先がXMLであるならば DOMで処理するよりも独自の処理系をもったほうが速いと思います。 コーディングの量はDOMでしたほうが少なくなるとはお思いますが。 入力元と出力先がともにXML以外のフォーマットであればDOMを使う意味はありません。 入力形式からDOMに変換する部分とDOMから出力形式に変換する部分のコーディング量が多くなるので DOMを利用してもコーディング量がそれほど変わらないかもしくは増えてしまうと思います。 またDOMに加え二重の変換処理で大変遅いアルゴリズムになるでしょう。
文書やデータの意味や構造を記述するためのマークアップ言語の一つ。 ＞マークアップ言語の代表としてhtmlがあります。文書やデータを<p>タグで囲ったりしますよね？<p>で挟まれたものは段落という意味になります。 マークアップ言語とは文書やデータに意味や見栄えをつける言語のことです。 マークアップ言語とは、「タグ」と呼ばれる特定の文字列で地の文に構造を埋め込んでいく言語のことで、 ＞文書データに<p>や<table>,<div>などで要素をはさんでいきますよね？ そういうことです。 XMLはユーザが独自のタグを指定できることから、マークアップ言語を作成するためのメタ言語とも言われる。 ＞htmlというのは<p>や<table>などのあらかじめ用意されているタグが存在します。しかしXMLというのはタグ名を自分で自由に作れてしかもそのタグの意味や見栄えも自分で作れるのです。たとえば、名前を表示する表示エリアを<name>というタグにして<name>には名前が入り、こんな見栄えにしますよ（赤にしてボールドにするなど）というのを自分で決めれます。 つまりより自由度がましているということです。 メタ言語というのは、そのようにタグを定義できる言語のことを言います。つまりXMLはメタ言語というわけです。 xmlのことが詳しく知りたければ、下記のサイトがおすすめです。
#1だ。 折角だから http://www6.airnet.ne.jp/manyo/xml/index.html 読んで勉強すると良い。 順番が多少読みにくいが，説明は解りやすいぞ
いろんなことができます。 HTMLが「Webページの表示」を専門としていたのに対して、 XMLは、「データを分かりやすく保存する」ための言語です。 (あくまでコンピュータから見て、です。人間が見ても分かりづらいです) ぱっと見た感じはHTMLに似てますが、かなり違います。 いろんなことができるように、「いろんな書き方ができる」という特徴を持っているのですが、 あまりにもいろんな書き方ができるため、「何をするため」というのがはっきりしにくい面もある気がします。 最近のプログラムでは、設定を保存するためのファイルとしてよく使われているようです。 HTMLのように表立ったものではなく、いろんなプログラムやソフトを影で支える役割を持ったもの、 というのが私の印象です。 それ以外の例などについては、他の方の回答や参考ページを見ていただくといいと思います。
> background-position:center; 背景画像の位置を中央にするだけですよ。 文章とかには影響しません。 margin:auto;/*ブロックレベル要素を中央寄せ*/ text-align:center;/*文字等を中央寄せ*/ とすれば中央にきます。
PHP経験なし。 >※ブラウザはFirefoxを使っています。 >また、不思議なのは上記のhttp://feeds.feedburner.jp/○○○ 部分のURLにアクセスすると正常にRSS情報が表示されます。 であることから http://feeds.feedburner.jp/○○○に誤りはまずない。なので 原因はPHP側。file_get_contentsかprintか知らないが。 俺としてはこれに似たケースに思えるが，先ほども言ったとおり未経験なので自信なし。 http://oshiete1.goo.ne.jp/qa2757771.html >PHPを確認するまえにまず出力されたXMLを検証する所 さらに言うと，俺なら W3C Markup Validatorをかけるんじゃなくて application/xmlをtext/plainにしてどうなっているか見てみると思う。 >In addition, >"application/xml" media type is not specific enough なのでヘッダで文字コード指定しなきゃいけないということはないと思おう。
昔 XML Schema を扱う仕事をしていた時に，JAXBを使って XML Schema からJavaのコードを自動生成した記憶があるのですが…。 http://www.stackasterisk.jp/tech/java/jaxb01_01.jsp や http://www.atmarkit.co.jp/fxml/rensai2/xmltool02/01.html は参考にならないでしょうか？ 後者ではMarshallerを使ってXML文書を出力する例も紹介しているので，もしかしたらお役に立つかもしれません。 ただ， > 全ての構造を網羅したXMLファイルを作成してくれる これは無理だと思います。XML Schema には繰り返しやoptionもあるので，一つの文書で全てのパターンを網羅することは無理だと思います。また，複数の文書であったとしても，例えば繰り返しを何回行うかには無限のパターンがあり得るため，やはり全てのパターンを網羅することは難しいと思います。 ただ，上述のJAXBを使えば，その手間はかなり減らせるかもしれません。 JAXBはJWSDPの一部なので，参考URLでダウンロードできます。
>9行目21文字目は漢字でした だとしたら、思いつくとしたら「文字コード」なんだけどな。 まさかXML宣言のencodingがないとか間違っている(ファイルがShift_JISだったとか。アルファベットは大半の文字コードでASCIIコードが基準になって共通なため、問題が発生しにくい)ってオチはないですよねぇ？
確認: 【入力】 <?xml version="1.0" encoding="Shift_JIS" ?> <?xml-stylesheet type="text/xsl" href="fuga.xsl"?> <oyaji:samp xmlns:oyaji="http://sampsampsamp.co.jp/">abcあいう</oyaji:samp> 【変換】 <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0" > <xsl:template match="/"> <hoge> <xsl:apply-templates /> </hoge> </xsl:template> <xsl:template match="samp">かきく<xsl:value-of select="/" /></xsl:template> </xsl:stylesheet> 【結果】 <?xml version="1.0" encoding="UTF-16"?><hoge>abcあいう</hoge> 【変換改】 <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0" xmlns:himajin="http://sampsampsamp.co.jp/"> <xsl:template match="/"> <hoge> <xsl:apply-templates /> </hoge> </xsl:template> <xsl:template match="himajin:samp">かきく<xsl:value-of select="/" /></xsl:template> </xsl:stylesheet> 【変換結果】 <?xml version="1.0" encoding="UTF-16"?><hoge xmlns:himajin="http://sampsampsamp.co.jp/">かきくabcあいう</hoge> EXTYLEにて実験。
HTMLの話でしょうか・・？ HTMLの話でしたら、ほぼ無効です。 少しでも変化がほしいのならば、<br />タグなどで、ページ下に余白を持たせておくと、対応する<a name="">の部分が上方向位置へ合わさります。
記載URLのPosPos/PCを作ったひゅ～と言います。 スクリプト内では文字列を記述するクォーテーション(シングル、ダブル)の関係をしっかり確認して下さい。どのようなエラーが出ているのかが質問からは読み取れませんが、JavaScriptはプログラムですので雑な記述は通りません。固定文字列を記述するクォーテーションが正しく関係付けられている事が必要です。 質問内のコードでは <img...の前に"が足りていないですし、その中身も混乱しているようです。修正してみると、 + "<img src='./debui.jpg' width='120' height='102' /></a>"; このようになります。文字列を"で始めた場合はその内部では'を使うのが良いでしょう。
こういう方法はいかがでしょうか。 Mozilla Firefoxをインストールし、問題のxmlファイルを表示させます。 表示されたサイトのソース確認したい部分をドラッグして選択し、 「右クリック->選択した部分のソースを表示」 を選ぶと、htmlに変換されたソースを見ることができます。 また、選択せずに 「右クリック->ページのソースを表示」 を選ぶと、xmlソースを見ることができます。
こんな感じでしょうか。 <xsl:choose> <xsl:when test="../../data/num2"> データあり </xsl:when> <xsl:otherwise> データなし </xsl:otherwise> </xsl:choose> 判断にはxsl:choose命令を使います。子要素のxsl:when命令で test属性が真になればその内側を実行します。 (複数のxsl:whenを記述可。最初に真になるもののみ実行) いずれも当てはまらない場合はxsl:otherwiseの内側を実行します。 test属性で要素を指定するとその要素があれば真となります。 質問のとおりのXMLに対して「num2要素があるかどうか」であれば 上記のように指定することで判断できます。 補足ですが、1件分はdata要素でまとめられているので、「次の data要素があるかどうか」判断する場合はtest属性で test="../following-sibling::data" と記述すると、現在処理中のnum1要素を含んでいるdata要素と 同じ階層の後ろにdata要素があるかどうかという条件になります。
こういう話？ http://qa.xml.gr.jp/data/xsl/files/0027.xml
<A Href="ＵＲＬ" Title="説明文">リンク</A> こういう形で如何でしょうか？
[ ]の指定はそれぞれの階層ごとに指定できます。 <xsl:value-of select="//name[position() = 2]/first" /> でいかがでしょう？
１）ご自身でテンプレートやhtml、CSSを編集することで可能です。 ２）上に同様 ３）CSSの知識とMovableType特有のタグを使い表示するコンテンツや内容をデザインしてＣＭＳ化させることができるか否かがキーになると思います。場合によってはプラグインなどの利用も必須です。 ご希望のレイアウト１）２）のレイアウトをCSSもわからないhtmlの素人がすぐ作れるか？という問いならば、残念ながらそれは無謀と答えるしかありません。 MovableTypeをCMS化するための参考書としては ・公式タグリファレンス　シックスアパート株式会社編　オーム社 ・MovableTypeではじめるビジネスブログ・テンプレートブック　中村義和　翔泳社 ・MovableTypeで今日からはじめるカスタムブログ　秀和システム ・スタイルシート（CSS）解説本 などでしょうか。 もちろん、ご自身でプログラムをサーバにアップしたり、それをセキュリティ的にも管理していくことも必要になります。 ロリポップをご利用ならばカラーミーショップ！プロのご利用はいかがでしょうか。 http://shop-pro.jp/ MovableTypeを編集でも、いずれにせよ、テンプレートの編集は必要になりますが、MovableTypeを商用利用の場合の料金＋セキュリティ装備の買い物カゴが必要になりますよね。今どきの店舗はhttpsが使えてないと消費者も避けると思います。（ロリポのサーバは共有ＳＳＬが用意されていないので、買い物カゴを自分の借りたサーバで準備することができません。どこか他に借りるかして自分のサイトに装備することが必要になります。） カラーミーショップ！プロのようなサービスならば、ネット通販に必要なことはほぼすべて揃った状態で、デザインテンプレートもサンプルがいろいろと用意されているのでそれを好きなように改造したりするのに、比較的に楽で取っつきやすいように思います。 http://shop-pro.jp/?mode=template 用意されたテンプレートでも好みに色や部品を改変するだけでかなりいろいろなイメージのサイトが作れます。 もちろん、１からオリジナルで作成することも可能です。 独自ドメインでも運営でき、ブログなども用意されています。
それはXSLTの仕事では無いのでは・・・ 他の処理機構(webならCGIやjavascript)の仕事だと思う
sample.xml <?xml version="1.0" encoding="Shift_JIS" ?> <?xml-stylesheet type="text/xsl" href="huga.xsl"?> <PAGE> <person> <name>himajin100000または暇人拾万。ぶっちゃけどっちでもいいや</name> </person> <person> <name>架空人物</name> </person> </PAGE> huga.xsl <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:my="http://purl.org/himajin100000/" version="1.0"> <xsl:output method="xml" encoding="Shift_JIS"/> <xsl:template match="/"> <my:hoge> <xsl:apply-templates/> </my:hoge> </xsl:template> <xsl:template match="person"> <xsl:choose> <xsl:when test="contains(name,'または')=true()"> <xsl:variable name="data" select="substring-after(name,'または')"/> <!--ここで宣言したdataの変数の有効範囲はここから--> <xsl:value-of select="$data" /> <!--変数の有効範囲はここまで。変数でも関数でも有効範囲のことをプログラミング用語で「スコープ」と言います。--> </xsl:when> <xsl:otherwise> <!--　ためしにコメント外して見てね。スコープ外で変数を使ってみると・・・・ <xsl:value-of select="$data" /> --> 処理 </xsl:otherwise> </xsl:choose> </xsl:template> </xsl:stylesheet> #でもXSLTの変数って後から変更されるような仕様になっていないので(思想の問題だったと思う。文献を探すのが面倒くさいので探さないが)--> #あんまり見てないし役に立つかどうか知らないが、もしかしたら参考になるかもよ？ http://www2.xml.gr.jp/log.html?MLID=xmldesign&TID=3922&F=0&L=10&R=1#M3922
エレガントな方法を知っている人がいればいいんだけど・・・ 以下のような理由からXMLで直接行わず、XSLTを経由するのが早そうな予感。 =========以下は興味があったら読んで欲しい=============== XML規格に含まれる「外部解析対象実体」を IE 7はサポートするが、(IE 6は知らない。) Firefox,Operaではサポートしない。(エラーはでない) http://www-06.ibm.com/jp/developerworks/xml/060407/j_x-ffox2.shtml ちなみにIEが行うXMLインスタンスのDTDによる検証をFirefoxは行わない。Operaは未確認。 ☆外部解析対象実体の動き(IEでrss.xmlを見ること) ================rss.xml================= <?xml version="1.0" encoding="UTF-8" ?> <!DOCTYPE rss [ <!ENTITY contents SYSTEM "contents.xml"> ]> <rss version="2.0" xml:lang="ja"> <channel> <title>RSSのタイトル</title> <link>http://～</link> <description>RSSの説明</description> <language>ja</language> <copyright>RSSのコピーライト</copyright> <lastBuildDate>日付</lastBuildDate> <item> <title>タイトル1</title> <link>http://～</link> <description>タイトル1の説明</description> <category>タイトル1のカテゴリ</category> <pubDate>タイトル２の日付</pubDate> </item> &contents; </channel> </rss> ==============contents.xml=============== <?xml version="1.0" encoding="UTF-8"?> <item> <title>タイトル２</title> <link>http://～</link> <description>タイトル２の説明</description> <category>タイトル２のカテゴリ</category> <pubDate>タイトル２の日付</pubDate> </item> ☆外部解析対象実体には欠点があるようで (よく勉強していないのだが、詳細は上記やhttp://www.atmarkit.co.jp/fxml/rensai/w3cread22/w3cread22_1.htmlあたり、およびそのシリーズが参考になるかも) http://www.xml.com/pub/a/2002/07/31/xinclude.html 等では、XInclude( http://www.w3.org/TR/xinclude/ )なるものも紹介されているが、ブラウザでの対応を期待するのは、無謀と言える ☆で・・・ あまり使ったことはないし、私はよく理解していないのだが、 xsl:includeやxsl:import、だめならdocument関数(http://oshiete1.goo.ne.jp/qa2593455.html )を用いる なんてことも考えている。
私も同じ様なものを考えて次のような手を思いつきました。 Code:A <xsl:if test="position() mod 3 = 1"> <xsl:text disable-output-escaping="yes">&lt;tr&gt;</xsl:text> </xsl:if> もし位置が3で割って1余るなら <tr> を出力する Code:B <xsl:if test="position() mod 3 = 0"> <xsl:text disable-output-escaping="yes">&lt;/tr&gt;</xsl:text> </xsl:if> もし位置が3で割って余りが0ならば </tr> を出力する 上記の二つを <xsl:for-each select="ko"> 全ての ko について繰り返す すべて終わったら Code:B をもう一度呼び出す。 サンプルは、次のページにあります。 http://skyandcloud.homedns.org/software/download.html
Msxml2.DOMDocumentを使用して、loadXMLで読み込めばDOMツリーに展開出来ると思います。 MSXMLのリファレンスは以下のページです。 http://msdn.microsoft.com/library/en-us/xmlsdk/html/b24aafc2-bf1b-4702-bf1c-b7ae3597eb0c.asp?frame=true
rssの構文ルールを守っていない為に発生しているエラーです。 rssには、XML構文ルールに加えて、より厳密なrss構文ルールが適用されます。具体には、「root elementは、<rdf:RDF>である」等。 参考URLにrssの構文ルールを解説しているサイトの載せました。 参照してください。
僕は使ったことないが Javascriptなど最低でもプログラミング言語を使った経験が必要ですが、Ajaxで調べるといいんじゃないかと思いますよ http://shoppers-jp.com/tech/ajax_01.html このサイトでは GETを http://shoppers-jp.com/tech/ajax_01.cgiに対して送っていますが xmlHttp.open('GET', 'http://shoppers-jp.com/tech/ajax_01.cgi?x=' + x + '&y=' + y , true); 投げるところを http://xml-jp.amznxslt.com/onca/xml?Service=AWSECommerceService&SubscriptionId=1QGECTA2WZXXE2VT7N82&AssociateTag=wbooker-1-22&Operation=ItemSearch&Version=2004-10-04&ResponseGroup=Small%2CItemAttributes%2COfferFull%2CImages%2CReviews%2CSimilarities&Keywords=%E3%82%A2%E3%83%9E%E3%82%BE%E3%83%B3&SearchIndex=Books&ItemPage=1&ContentType=text%2Fhtml&Style=http%3A%2F%2Fwww.be-emotion.com%2Fxml%2F1.xml にすればいいだけで。 あとは <input type="button" value="計算" onClick="HttpRequest()"> とかやれば、ボタン押したときにHTTPRequest関数が実行されてくれるので処理ができるでしょう。
table だけ別templateまたはifなどで別処理にして width属性の値は無視して<attribute name="width" value="80%" />で書き出す。 でもそんな事しないで元のXHTMLを置換機能で纏めて"100%"からCSS使用の指定に切り替えた方が楽なのでは？ そしたら次からCSSの1箇所直すだけだし ----------css table {border:solid 1px} table.T_WIDTH {width:100%} ----------xhtml <table class="T_WIDTH">・・・・・・
タブ：\t 改行：\n(\r\nの場合もありますが・・) を、Replaceメソッドを使って取っ払ってやるといいです。 string text = "(TAB)あいう(改行)".Replace("(TAB)", "").Replace("(改行)", ""); こういった形は、多数あるとめんどいので、メソッドにしてしまうと よいかと思われます。 private static string hoge(string text){ string ret = text.Replace("(TAB)", "").Replace("(改行)", ""); return ret; }
ＤＴＤではできないように思います。
例えば、 <xsl:value-of select="//種類[@type='j']/名前[@month='3']"/>
#1>「名前トークンを使用」とはなんですか？ 名前に使用できる文字のことです。 「名前」には先頭に使えない文字があります。 例えば、数字がそうです。 「名前」の先頭には使えないが名前に使える文字を含めて 「名前」の構成文字という意味で「名前トークン」といいます。 つまり NMTOKEN は"NAME TOKEN"というということですね。 "番号" は、数字を意味するようにしたいのですが、 ＳＧＭＬでは NUMBER というのがあるのですが、ＸＭＬではこれがありません（スキーマはまた別の話として）。 それで他のモノを使う必要があるのですが CDATA だと何でもいいということになり ID (「名前」)だと数字で始めることができないので NMTOKEN ということにしました。 こうしておけば、先頭が数字から始められてある程度限定することができます。
例えば <xsl:template match="/"> first node:<xsl:value-of select="name(/data/*[1])" /> </xsl:template>
参考URLから URI Uniform Resource Identifier. 　　リソースを指し示す短い文字列からなる名前/アドレスの総称 URL Uniform Resource Locator. 　　良く知られたURIスキームであるhttp, ftp, mailto などを指す非公式な（技術仕様文書では使われることのない）用語 URN Uniform Resource Name. 　　1. 何らかの組織がその永続性、可用性を保証しているURI。この種類のURIは、URLでもあり得ることに注意。たとえば[PURLs]を参照 　　2. 永続的で場所に依存しないリソース指定のために用意されているスキーム「urn:」のこと。RFC 2141および関連文書で定義される
http://www.kawa.net/works/js/jkl/parsexml.html をお使いになってはいかがでしょうか ”IE・Firefox・Opera・Safari のクロスブラウザに対応しています。” とのことです。
がると申します。 直接的には#1さんの回答で正解なのですが。 有効時間そのものを「データとみなす」のであれば、例えばこういった書式が可能です。 処理できるかどうかは処理側のロジックによりますが。 <?xml version="1.0" encoding="UTF-8"?> <list> 　<sample> 　　<data 有効期間to="2006-9-30"> 　　　<url>/sample/a.asp</url> 　　</data> 　　<data 有効期間from="2006-10-1"> 　　　<url>/sample/b.asp</url> 　　</data> 　</sample> </list>
がると申します。 > DOMはPHPによって生成されるんでしょうか？ ですが。一応念のために補足を。 DOMというのは、データを扱う構造の１形態になります(具体的にはツリー構造の形式でデータを扱う)。 ですので、基本的には「DOM構造のデータは～」という感じになるかと思います。 で、DOM構造のデータ形式(のひとつ)を生成しているのは、直接的には、記述されているコードですと「DOMDocumentクラス」になります。 XMLパーサの機能は、したがって、DOMDocumentクラスが持っていることになります。 とりあえず直接的な質問に対する説明をしましたが。 何か追加で不明点などあったらまた質問などしていただけると。
＃９補足のＸＭＬを使用しても問題なく実行できました。 やはり、"XML read error" になるのですね？ ＸＭＬファイルをアップする時に文字コードが変換されているとか権限として読めないようになっていたりしませんか？ 今回のコードとは別に、日本語を含まない凄く単純なＸＭＬファイルだと読み込めますか？ 例えば <plist><key>XXX</key></plist> のようなもの
<aaa_name>XXX</car_gd_cd>は<aaa_name>XXX</aaa_name>として <?xml version="1.0" encoding="utf-8"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:output method="xml"/> <xsl:template match="@*|node()"> <xsl:if test=".!=''"> <xsl:copy> <xsl:apply-templates select="@*|node()"/> </xsl:copy> </xsl:if> </xsl:template> </xsl:stylesheet>
http://www.lhut32.com/WinXP.html のmanifestファイルってので出来るらしい。 ・・・・manifestファイルの仕様は調べてない #なんでXMLなのか迷ってしまったorz
自信ないけど。適当なフォルダに解凍するだけでいいんではと思う。 j2se～xalan http://www6.airnet.ne.jp/manyo/xml/xslt/step24.html Xerces http://www6.airnet.ne.jp/manyo/xml/sax/home.html CLASSPATH-Xerces http://www.nextindex.net/java/app/classpath.html CLASSPATH-xalan http://msugai.fc2web.com/java/XML/Xalan.html
<xsl:element name="a"> <xsl:attribute name="href">#</xsl:attribute> <xsl:attribute name="onclick">hogehoge('<xsl:value-of select="$prm_test" />')</xsl:attribute> hogehoge rink </xsl:element>
やりかたは、色々あるけど、１つの方法 ---------------------------------------------------------------- XmlNode xmlRoot = xmlDoc.DocumentElement; Console.Write("ルート名は[" + xmlRoot.Name + "]です。\n"); Console.WriteLine(xmlRoot.SelectSingleNode("/server/@maintenance").Value); Console.WriteLine(xmlRoot.SelectSingleNode("/server/database/@providerInvariantName").Value); Console.WriteLine(xmlRoot.SelectSingleNode("/server/database/@connectionString").Value); Console.WriteLine(xmlRoot.SelectSingleNode("/server/database/property/@value[../@key='userName']").Value);
数値なら、計算結果はnull にならずにエラーになると思うので、 数値としての値が有るかどうかを検査する必要があると思いますが、 そうでなければ単純に A + B で合計を出せます。 あるいは、 number(A) + number(B) あるいは、 sum(A|B) の様に合計をだせます。 文字列の連結を言っているのであれば concat(A,B) で連結できます。
(書き方は色々あるけど)とりあえずこんな感じ？ 細部微調整されたい ---------------------------------------------------------------- <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/report"> <html> <head> <title>タイトル</title> </head> <body> <p align="center">適当なコメント</p> <p> <xsl:value-of select="head/editorialOffice" /> </p> <p> <xsl:value-of select="head/additionalInfo/v" /> <xsl:value-of select="head/type" /> </p> <div> <xsl:for-each select="body/warningHead/area"> <p> <xsl:value-of select="@name" /> </p> <p> <xsl:for-each select="kind"> <xsl:value-of select="@name" />　<xsl:value-of select="@level" /><br /> </xsl:for-each> </p> </xsl:for-each> </div> </body> </html> </xsl:template> </xsl:stylesheet>
望みの動作かどうかは、よくわかりませんが、 <abc>1,2,3,4</abc> を <td>1</td><td>2</td><td>3</td><td>4</td> に変換するサンプル (どっちかというと、むりやりXSLT でやるより、スクリプトを使った方が簡明なような気がします。) ---------------------------------------------------------------- <?xml version="1.0" ?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"> <xsl:call-template name="split"> <xsl:with-param name="value" select="abc"/> </xsl:call-template> </xsl:template> <xsl:template name="split"> <xsl:param name="value"/> <xsl:choose> <xsl:when test="substring-after($value,',')=''"> <td><xsl:value-of select="$value"/></td> </xsl:when> <xsl:otherwise> <td><xsl:value-of select="substring-before($value,',')"/></td> <xsl:call-template name="split"> <xsl:with-param name="value" select="substring-after($value,',')"/> </xsl:call-template> </xsl:otherwise> </xsl:choose> </xsl:template> </xsl:stylesheet>
エラーですが、 if(image != "") ではなくて var image = xmlDoc.getElementsByTagName("image")[i].firstChild.nodeValue; のところで起こってませんか？ そうであればfirstChildの中身がnullなのでnodeValueにアクセスできないということです。nullチェックして、nullならimage=""で結構かと。
./test.phpflg=1&amp;file= じゃ駄目かな？ 追記: http://hp.vector.co.jp/authors/VA022006/html/markup.html#CER
<xsl:when test="not(B[C1])">★</xsl:when> みたいな感じで、C1要素を持たないB要素があることを検知できると思います。 （B[C1]は、場合に(その時のカレントに)よっては、A/B[C1]）
No.1のhimajin3500さんが指摘されている問題（<dc:date>の構文エラー。恐らく時分秒の時が0-23の間でないとならない／URLが不正 http:の後のスラッシュは２つです）に加えて、HTTPレスポンスヘッダのContent-Typeで text/htmlを返しているのがまずいです。 このContent-Typeを返すとRSSだと解釈できないRSSリーダが多数存在します。Content-Typeには、現状では application/xml を返してください。 具体的には、PHP内の適当な場所に以下の一文を加えます。 header("Content-Type: application/xml");
#2>nextSiblingを使えばどうにかなるのではないか そうですね、普通、ＤＯＭでは、nextSibling を使うと思います。 試しにnextSibling を使って次のエレメントを取り出そうとしてみましたが、失敗しました。 多分、バグなんじゃないかと思います。 そうも言ってられないですけど #2>出来れば一つの<item>要素のデータを取り出したあと、一つ古い（一つ下の）<item>の情報の<link>要素も取り出したいと考えています。 <item> 要素については、 $items=$doc->getElementsByTagName("item"); でそのノードリストが取り出せるし、 個々の<item> 要素は $items->item(index) で取り出せます。(要するに任意の位置のitem が取り出せる) また、<item> の全体の要素数は $len = $items->length; で取り出せます。 そうすれば、 $items=$root->getElementsByTagName("item"); $len = $items->length; $i=0; foreach($items as $item){ $i++; if($i<$len){ $next=$items->item($i); として、処理している$itemの次の<item> を捕まえられます。
==============hoge.xml=============== <?xml version="1.0" encoding="Shift_JIS"?> <data>○○○○○<color>●●●●●</color>○○○○○○○○○○○○</data> ==============hogehoge.xsl=============== <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="data"> <p><xsl:apply-templates /></p> </xsl:template> <xsl:template match="color"> <font> <xsl:attribute name="color">red</xsl:attribute> <xsl:value-of select="." /> </font> </xsl:template> </xsl:stylesheet> ========hogerake.xml================= <?xml version="1.0" encoding="UTF-16"?><p>○○○○○<font color="red">●●●●●</font>○○○○○○○○○○○○</p>
例えば、こんな感じ ---------------------------------------------------------------- <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="html" version="1.0" encoding="Shift_JIS" indent="yes" /> <xsl:template match="/"> <html> <head><title>sample</title></head> <body> <p> <xsl:for-each select="//table"> <table> <xsl:for-each select="list/row"> <tr> <xsl:for-each select="value"> <td> <xsl:if test="position()=5 and .&gt;=20"> <xsl:attribute name="bgcolor">#FF3232</xsl:attribute> </xsl:if> <xsl:value-of select="."/> </td> </xsl:for-each> </tr> </xsl:for-each> </table> </xsl:for-each> </p> </body></html> </xsl:template> </xsl:stylesheet>
そのような場合 <!ELEMENT あるタグ ANY> と書きます。 （ただし、ＤＴＤの要素型宣言で宣言された要素、でないとＸＨＴＭＬに適合するかチェックできないから）
#1>簡単に言うと、htmlのものをXMLにするのは手間がかかりますか？ ＨＴＭＬ をＸＭＬに適合するように書いたものをＸＨＴＭＬといいます。 タグは小文字で書くとか、必ず閉じタグを書くとか色々ルールはありますけど、基本的にはそれ程難しいことはありません。 最低限体裁さえＸＭＬ様式になっていれば目的としてはいいので。 ＸＨＴＭＬについての書き方の注意なんかは、多分そのようなサイトがあると思います。 ＃１＞・htmlの場合には<div id="tail">を呼び出すことはできないですか。 基本的にＨＴＭＬ＋javascript で別ページの部分は、読込できません。 Ajax と言われる手法では、別ページを読み込むことができます。 その場合、ＸＭＬ様式になっていれば、簡単に、id 指定でエレメント以下の内容を取り出すことができます。 ＸＭＬ形式になっていない場合には、テキストとして読み込んで、必要な部分を取り出すことになるかと思いますが、タグペアの対応を解析するのが難しいので、余程シンプルな形のＨＴＭＬじゃないと難しいと思います。 また、ＨＴＭＬ＋javascript では、 （やはり、ＤＩＶで分けてあることが前提ですが） ＩＦＲＡＭＥなどで、動的に別ページを読み込んでその部分を取り出す。 子ウインドウとして開いてその部分を取り出す。 というのは多分できると思います。 （こちらは、読み込んだ時にブラウザが解析してくれるので楽に取り出せる)
基本的にＵＲＩ指定されたものを読み込むので外部サイトでも読込できると思います。 実際に試してみるのが早いんじゃないでしょうか
こんにちは Amazon Web Serviceとか・・・ Google Map APIとか・・・ http://ja.wikipedia.org/wiki/Webサービス
number 関数を使うと文字列を数値に変換できます。 その時に、数値に変換できない値を指定すると、NaN(非数値)を返しますので、この関数を使って非数値(数値以外)を判定することができると思います。 例えば、 <xsl:when test="'NaN'=string(number(width))"> 数値ではない<br /> 等とできます。 (数値の場合の処理は<xsl:otherwise>で) 注意として、string(NaN)がの表現が'NaN'でない場合も考えられるため 'NaN'= ではなく string(number('NaN'))= の方がいいかもしれません NaN を直接ＸＳＬＴで表現できればいいのですが、それは知りません。 ＭＳのマニュアルなんかを読むとエンティティと書いてあるので、なんらかの表現があるのかもしれませんが・
あまり詳しくないので、一部だけ ＞「ss」という文字が見れるのですが、これはなんでしょうか？ 最初の方に 　xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" とあると思いますけど これは、ＸＭＬの文法的には、名前空間の指定というやつで、 同じような名前、例えばIDとか、が使われる時 ss:ID の様に修飾して、区別するためのものです。 ＞上記のような保存形式は次世代officeでも読めるんでしょうか？ ＸＭＬのテキストで構成されていて、バージョン情報も埋め込まれていますから、余程大きな変更が無い限り読み込めると思います。
(しばらくID取得とか面倒くさがって調べてませんでした) で、悩んでいたんですが原因判明。 http://www.goodpic.com/mt/archives2/2004/10/amazon_ecs_401.html Amazon.co.jphttp://webservices.amazon.co.jp/onca/xml? JPベータ版http://aws-beta.amazon.co.jp/onca/xml? Amazon.comhttp://webservices.amazon.com/onca/xml? Amazon.comではなく【Amazon.co.jpまたはJPベータ版の方で試してみてください】 #1065852で何故かデータとしてPlazma TVが返ってきてたからおかしいなぁと思って見切りを・・・
ごめんなさい。判りませんでした。回答になりません。既に解決しているかもしれませんが・・・ PRB: HRESULT C00CE56E "System Does Not Support the Specified Encoding" Error Message with MSXML http://support.microsoft.com/?scid=kb;en-us;304625&spid=3346&sid=294 >As of version 2.6, MSXML passes all XML documents through Mlang.dll to verify their encoding. If Mlang.dll encounters a non-standard encoding string, it returns an error. によるとMSXMLの文字コード認識はMlang.dllで行われているようなので (もちろんWindows-31JはIANAのキャラセットに存在することを確認しました) そこでMlang.dllを検索して見ました http://msdn.microsoft.com/workshop/misc/mlang/reference/objects/cenumcodepage.asp 等を使って対応文字コードを並べてみるとか・・・
回答が来てないのは多分何が聞きたいのか、が伝わってないからだと思う・・・ RSS -- サイト情報の要約と公開 http://www.kanzaki.com/docs/sw/rss.html#rdf-model とか 窓の杜-RSS作成支援 http://www.forest.impress.co.jp/lib/inet/homepage/rsssupt/index.html ということだろうか？
>代替案とは、例えばC/C++の #if 0 ～ #endif 等に相当する物です。 そういうことであれば、文字通り、C/C++ のプリプロセッサを使えばいいんじゃないかと思います。 もしくは、コメントを <COMMENT></COMMENT>のように表すとしたら、 ＸＳＬＴを使って取り除くこともできます。 ---------------------------------------------------------------- <?xml version="1.0" encoding="Shift_JIS" ?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" omit-xml-declaration="no" encoding="UTF-8" indent="yes" version="1.0"/> <xsl:template match="@*|node()"> <xsl:copy> <xsl:apply-templates select="@*|node()" /> </xsl:copy> </xsl:template> <xsl:template match="COMMENT"></xsl:template> </xsl:stylesheet>
<?xml version="1.0" encoding="Shift_JIS" ?> <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"> <xsd:element name="root" type="rootType" /> <xsd:complexType name="rootType"> <xsd:complexContent> <xsd:restriction base="xsd:anyType"> <xsd:sequence> <xsd:element ref="sub" /> </xsd:sequence> </xsd:restriction> <xsd:complexContent> </xsd:complexType> <xsd:element name="sub" type="subType" /> <xsd:complexType name="subType"> <xsd:simpleContent> <xsd:extension base="xsd:string"> <xsd:attribute name="a" type="xsd:string" /> </xsd:extension> </xsd:simpleContent> </xsd:complexType> </xsd:schema> かな？多分。
ところで。 僕が#2で遭遇したエラーは質問文と何ら関係のないものでしたが、 xsl:output要素の(名前空間の話は省略)method属性の値が htmlの場合、htmlとして出力するので当然出力結果のlink要素は閉じられません。このときHTTPサーバがHTTPヘッダの中で Content-type:text/xml;charset=UTF-8 とか返している場合Firefox等でXMLと判断されて質問文のエラーが出ることがあります META要素が大文字なのは・・・どこなのか詳しくは調べてないです
指定した回数というのは、自分が提供する静的なものなのか、ユーザが指定する動的なものなのか 自分のところでXのコレクション情報を自前で保持してるんだったら<xsl:for-each>をつかって処理 単に連番とかをユーザにあわせて動的に生成するんだったら<xsl:text>にJavaScript埋め込み系？
> 「スタイルシート」だけでは、メニューの共有ができないため、内容が変わるとすべてのページのメニューを変えないといけないのです。 その通りですが、実際にはコピペで挿入しているところがほとんどです。 以下のサイトを見てください。 Fab51: はじめてのスタイルシート http://fab51.com/info/css_design1.html ページ上にメニューがありますが、これはコピペで生成しています。 現在のページの配色が変わるのは、ページ作成者がスタイルシートのクラスを指定しているからです。 # ページの内容も是非、参考にどうぞ。 > フレームに似た画面で、フレームなしでサイトを作って、「メニューを複数のファイルで共有する」ためには「XML」が必要なのでしょうか？ どうしても共有を求めるのなら、何らかのプログラミング言語を習得する必要があります。 Perl, PHP, JavaScriptなど、Web上で扱えるものなら何でも良いです。 ただ、JavaScriptは嫌う方もいるので、止めた方がよいかもしれません。(かくいう私もあまり好きではありません) 仕組みとしては、「メニューのテンプレートファイル」を外部に置き、該当ページで外部ファイルを読み込んで出力する、という形になると思います。 > ...できるページを作るのに必要なことが載っているパソコン本がありましたら　書名・出版社などを教えていただけますか？ これはアンケートに該当しそうですが、どうなんでしょう。 とりあえず、私は「PHPポケットリファレンス」を愛用しています。 どんな参考書でも、基本は Try and Try です。
＞encoding="UTF-8" と指定しているのに、xmlファイル自体をUTF-8以外で保存しているということはありませんか？
＞一般的にどのような機能を持ったファイルなのでしょうか？？ XMLはあくまで書式が規定されたデータでしかありません。 XMLデータを扱うためのAPI(SAX,DOM)が規定されてはいますが、XMLデータ自体が機能を持っているわけではありません。 ＞どういう時ＸＭＬファイルを使い XMLで要件(データ構造や処理速度など)が満たせればXMLでもいいでしょうし、XMLだと要件が満たされないのであれば他の形式や独自の形式を採用すればいいでしょう。 XMLの採用は何らかの目的を果たすための手段の１つに過ぎないということです。
XML中では、 < は、&lt; > は、&gt; を使います
＞<b id="2" />は表示しないものを作ってみました。 <xsl:template match="/"> <xsl:for-each select="//a/b[@id!='2']"> <xsl:sort select="./@id" data-type="number"/> <xsl:copy-of select="." /> </xsl:for-each> </xsl:template> としてみはどうでしょうか
そのままクリックするだけでは基本的にダウンロードになってしまいます。この手のファイルは従来のものとは扱い方が異なるため、手順をふまなければなりません。 例えば、IE6をご使用の場合だとそのままでは活用できません。別途RSSリーダーというものを導入されるか、RSSが読み込めるポータル（Google　パーソナライズホーム）をご利用されることをお薦めします。 他のブラウザ（Firefox、Operaなど）の場合は、標準でリーダーが内蔵されていますので、アドレスバーに表示されるアイコンをクリックすれば、登録できます。
こんにちは。 HTMLとXMLですが、厳密には用途が異なります。 というか、XMLは、ホームページの表示以外の用途にも利用されています。 HTMLは文章などに対して、 与えられたタグを利用して、 修飾することができます。 それに対して、XMLは、 修飾することが目的というよりは、 情報を体系化することができる言語であるといえます。 例えば、以下の文章があったとします。 ------ スケジュール表 5月1日　晴れ 予定 　18:00～19:00　英会話レッスン 　19:30～21:00　○子と夕食 メモ 　切手を購入しておく ------ HTMLで上記を表現する場合、 例えば『スケジュール表』の部分を大文字にしたり、 脚色ができますね。 一方XMLでは、目に見える脚色ではなく、 それぞれの文字がどういった情報であるか ということを管理できます。 『5月1日』は日付ですし、 『18:00』は予定の開始時間、 『英会話レッスン』は予定の詳細です。 それぞれについて、XMLでは、 <日付>だとか<開始時間>だとか<詳細>というタグを 設定して、囲むことで、 その文字が何を意味するのかがわかります。 ホームページを作ろうとすると、 XMLはまどろっこしいものかもしれません。 しかしXMLは、 例えばアプリケーションソフトの設定情報を 管理する手段としても使われています。 また、ホームページを作る際でも、 XMLで体系化してあれば、 レイアウトの変更などをしたい際に、 各項目のタグを変更しなくても、 XSLTを変更すれば、一気に反映できるという意味では、 便利かもしれません。
>IE上で右クリックした時に出るエンコードの項目で、unicodeが選択されています。また、他のShift_JISなどは選択できない状態です。 そういう仕様のようです
この場合で言うなら、こんな感じでいいと思います。 ---------------------------------------------------------------- <?xml version="1.0" encoding="utf-8"?> <xs:schema xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"> <xs:element name="Test"> <xs:complexType> <xs:sequence> <xs:element name="A" type="xs:int" /> <xs:sequence minOccurs="0" maxOccurs="unbounded"> <xs:element name="B" type="xs:int" /> <xs:element name="C" type="xs:int" /> </xs:sequence> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> ---------------------------------------------------------------- complexType がネストできるかどうかでいうと、 <D> <B>0</B> <C>0</C> </D> のような時に <xs:element name="D"> <xs:complexType> … のような形で、ネストはできると思いますが、 質問文のような形ではできないと思います。 ていうか、必要がないし。
質問文のような テンプレート内で定義されるローカルな変数は、 他のテンプレートで参照することはできません。 テンプレートの外で、 <xsl:variable name="na"><xsl:value-of select='//AAA/@value' /></xsl:variable> のようにグローバルに定義する必要があります。 また、その場合、<AAA> にマッチする度に内容が置き換わるのではありません。
http://msdn2.microsoft.com/ja-jp/library/ms256052(VS.80).aspx integer 型の桁数は制限無しです。 xmllint は使ってないですが、 桁数に制限があるようなチェックであるなら、xmllint の方がおかしいと思います。
targetNamespace属性を使用する場合には、 大域要素と属性は、修飾名が必要です。 例えば、次のようにします。 <xsd:schema version="1.0" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:test="test_namespace" targetNamespace="test_namespace" > <xsd:simpleType name="MyByte"> <xsd:restriction base="xsd:byte"/> </xsd:simpleType> <xsd:element name="TestElement" type="test:MyByte"/> </xsd:schema>
＃１補足の内容でテストしてみたところ私の環境では問題ありませんでした。 msxsl index.xml -u 3.0 -pi のようにバージョン指定して実行すると、質問文と同じエラーが表示されました。 msxsl index.xml -u 4.0 -pi で実行した場合にはエラーはでませんでしたので、 MSXML 4.0 をインストールするとＯＫだと思います。 ちなみに、私が使っているmsxsl.exe のバージョンは4.0 です。
<xsl:number />の値を持ってくるということはできないですが 次のように書くことができます。 <xsl:template match="d"> 　<xsl:if test="ナンバーの値 < 10"> 　<xsl:apply-templates /> 　</xsl:if> </xsl;template> を <xsl:template match="//a[position() &lt; 10]/d"> <xsl:apply-templates /> </xsl:template> <xsl:template match="//a[position() &gt;= 10]/d"> </xsl:template> 意味： 10番目までの<a>内の<d>は表示 10番目以降の<a>内の<d>は表示しない
すみません ｍ（＿　＿）ｍ 前の回答の一部が間違っていました。 function tramsform(xmlFile, xslFile, resultNodeID){ var xml, xslt, newDoc; if(document.all){ xml = new ActiveXObject("Microsoft.XMLDOM"); xslt = new ActiveXObject("Microsoft.XMLDOM"); } else { xml = document.implementation.createDocument("", "", null); xslt = document.implementation.createDocument("", "", null); } xml.async = false; xslt.async = false; xml.load(xmlFile); xslt.load(xslFile); if(document.all){ document.getElementById(resultNodeID).innerHTML = xml.transformNode(xslt); } else { var xsltp = new XSLTProcessor(); xsltp.importStylesheet(xslt); newDoc = xsltp.transformToFragment(xml, window.document); document.getElementById('XML').innerHTML = ""; document.getElementById('XML').appendChild(newDoc); } } に修正して下さい。 ---------------------------------------------------------------- その上で、 ＸＭＬ部分について <?xml-stylesheet type="text/xsl" href="all.xsl"?> は、要りません。 ---------------------------------------------------------------- ＸＳＬＴ部分について <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="html" encoding="Shift_JIS"/> にする。 <html lang="ja"> <body> と </body> </html> を削除する これで大丈夫だと思います。
試しに作ってみました。 tramsform(xmlFile, xslFile, resultNodeID) という形で、ＸＭＬファイルとＸＳＬＴファイルそして適用結果を表示するDIV の ＩＤ を指定します。 例： tramsform('data.xml', 'style1.xsl', 'XML') ＩＥとFirefox で動作します。 ＃３のサイトでも書かれているように xml = new ActiveXObject("Microsoft.XMLDOM"); を使うより、ＸＭＬＨＴＴＰリクエストを使う方がいいのかもしれません。 ---------------------------------------------------------------- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <HTML> <HEAD> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <TITLE>ＸＭＬの読込とＸＳＬＴの適用</TITLE> <SCRIPT TYPE="text/javascript"> <!-- window.onload=function(){ tramsform('data.xml', 'style1.xsl', 'XML'); }; function tramsform(xmlFile, xslFile, resultNodeID){ var xml, xslt, newDoc; if(document.all){ xml = new ActiveXObject("Microsoft.XMLDOM"); xslt = new ActiveXObject("Microsoft.XMLDOM"); } else { xml = document.implementation.createDocument("", "", null); xslt = document.implementation.createDocument("", "", null); } xml.async = false; xslt.async = false; xml.load(xmlFile); xslt.load(xslFile); if(document.all){ document.getElementById(resultNodeID).innerHTML = xml.transformNode(xslt); } else { var xsltp = new XSLTProcessor(); xsltp.importStylesheet(xslt); newDoc = xsltp.transformToFragment(xml, window.document); document.getElementById('XML').innerHTML = ""; document.getElementById('XML').appendChild(newDoc); } } --> </SCRIPT> </HEAD> <BODY> <div id="XML"></div> <button onclick="tramsform('data.xml', 'style1.xsl', 'XML')">スタイル１</button> <button onclick="tramsform('data.xml', 'style2.xsl', 'XML')">スタイル２</button> </BODY> </HTML>
javax.xml.transform.*; を使っていったんファイルや文字列として書き出さないとしょうがないんじゃないでしょうか 試しに、 InputSource in = SAXSource.sourceToInputSource(new DOMSource(doc)); とかしてみましたが、ムリみたいでした。 ところで、既にＤＯＭとして保持しているものをＳＡＸで解析しなければならないという理由はなんなんでしょうか？
どんな質問なんでしょうか？
しばらく解らなかったけど、CSSソース見てたら解決しました。 ここでHTMLのソースを見直してみるとlink要素によるCSS指定がないので <script src="js/topstyle.js" type="text/javascript"></script> が怪しいと判断し、このソースを調べることにしました。 見ると共通するcss/all.cssとcss/top.cssと ブラウザやOSごとにCSSを振り分けていることが解ります 最初私はIE6専用CSSを調べに行きましたが特に怪しい部分は見つからなかったのでcss/all.cssを見始めました 解決。 body { text-align:center; /*これですね*/ } IEの「過去互換モード」の別のバグを利用してます(笑) #標準準拠モードでは修正されているようです。 http://www.anslasax.net/css-make/t-a/index.html http://sourcemania.jpn.org/doc/block_center/#wrong 本来text-alignプロパティは【ブロックボックスの位置をそのままに】中のインラインテキストの位置を変えるものですが、IEは【ブロックボックスの位置ごと変更します】 ということで、調べ方と共に、うまく行ってる理由、おw解りいただけましたか？
「たのしいXML」さんのサンプルですね。やや読む順番がわかりにくい気もしますが、非常に解りやすく、私もここで勉強しました。 手元のFirefoxで実験したときに出てきたエラーから推理して × <?xml version="1.0" encording="Shift_JIS"?> ○ <?xml version="1.0" encoding="Shift_JIS"?> を修正したところ、うまく行きました。 蛇足ですが、このXSLTを用いた時にhtml要素に適用される名前空間が「なし」になっているため前にFirefoxでエラーが出たような気がしたんですが...再現しませんねぇ(汗。 一応自分なら <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1999/xhtml"> にしておくでしょう
#5>これがXSLTで簡単に変換できてしまうなら是非ご教示ください。 エラートラップを簡略していますが、こんな感じ。 XSL の部分はオンメモリということで文字列で持っていますが、 ファイルから取り込むのももちろん可。 ---------------------------------------------------------------- import java.io.*; import javax.xml.transform.*; import javax.xml.transform.dom.*; import javax.xml.transform.stream.*; import javax.xml.parsers.*; import org.w3c.dom.*; public class Sample { public static void main(String args[]) throws Exception{ String xsl= //"<?xml version='1.0' encoding='Shift_JIS' ?>"+ "<xsl:stylesheet version='1.0' "+ "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>"+ "<xsl:output method='xml' version='1.0' encoding='Shift_JIS' indent='yes' />"+ "<xsl:template match='/ROOT'>"+ "<xsl:element name='ROOT'>"+ "<xsl:apply-templates select='PARENT1' />"+ "<xsl:copy-of select='PARENT2' />"+ //そのまま "<xsl:apply-templates select='PARENT3' />"+ "</xsl:element>"+ "</xsl:template>"+ "<xsl:template match='PARENT1'>"+ "<xsl:element name='PARENT1'>"+ "<xsl:copy-of select='CHILD_HEAD' />"+ "<xsl:copy-of select='CHILD_PROP' />"+ "<xsl:copy-of select='CHILD_END' />"+ "</xsl:element>"+ "</xsl:template>"+ "<xsl:template match='PARENT3'>"+ "<xsl:element name='PARENT3'>"+ "<xsl:copy-of select='CHILD_HEAD' />"+ "<xsl:copy-of select='CHILD_END' />"+ "<xsl:copy-of select='DETAILS_A' />"+ "</xsl:element>"+ "</xsl:template>"+ "</xsl:stylesheet>"; DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dbfactory.newDocumentBuilder(); Document doc = builder.parse(new File("parent.xml"));//ファイルからDOMを作る、実際は作ってあるはずなのでこの部分は必要ない DOMSource in = new DOMSource(doc); StreamSource ss = new StreamSource(new StringReader(xsl)); StreamResult out = new StreamResult(new File("result.xml")); //ファイルに書き出す TransformerFactory tff = TransformerFactory.newInstance(); Transformer tf = tff.newTransformer(ss); tf.transform(in,out); } }
＞ContentTypeと申しましょうか、それをtext/xmlとした場合です。 参考ＵＲＬ（ＲＦＣ２３７６）で MIMEタイプ text/xml の場合 　charset パラメータが有る場合、 　　encoding 宣言は無視され、charset で指定された文字コードが使用される 　charset パラメータが無い場合、 　　encoding 宣言は無視され、charset のデフォルトであるus-asciiが使用される text/xml の場合 　charset パラメータが有る場合、 　　encoding 宣言は無視され、charset で指定された文字コードが使用される 　charset パラメータが無い場合、 　　encoding 宣言は無視され、charset のデフォルトであるus-asciiが使用される application/xml の場合 　charset パラメータが有る場合、 　　encoding 宣言は無視され、charset で指定された文字コードが使用される 　charset パラメータが無い場合、 　　encoding 宣言の文字コードが使用される という違いがあります。 ＞ファイルの先頭でエラーになります。 <?xml …の部分のエラーというより DOCTYPE のエラーだと思います。 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> に変えたり、 DOCTYPE 自体を削除すると該当エラーはでなくなりますので。 Firefox では問題ないので、ＩＥのバグなのかもしれません。
http://www.ipentec.com/ などどうですか
＃１のことは判った上でのことであれば <xsl:copy-of select="text" /> を試してみてください。
文書エンティティを使うより、こういう場合には、 XSL のdocument関数でファイルの読込をするのが簡単です。 <xsl:template match="TEST"> <xsl:copy-of select="document(concat(@ID,'.xml'))" /> </xsl:template> のように書けます。 どちらかというとこういう場合には <TEST href="A.xml" /> とかの方が意味を表していて良いように思います。 このようにしておけば、 document(@href) だけですみますしね。
http://www.fxis.co.jp/xmlcafe/tmp/wrapper-xml-19980210.html からＸＭＬ規格の日本語訳が読めます。 http://www.fxis.co.jp/xmlcafe/tmp/rec-xml.html の Nameは で、始まる部分の前後を参照してください。 なので、参考ＵＲＬ（２．）に書いてあることは正しいです。 ＩＥ６でエラーにならない理由は良く判りませんが、 おそらく、ＩＥのＨＴＭＬ文書の中では、<XML>要素が使える（ＸＭＬをＨＴＭＬに埋め込むのに使う）ためではないでしょうか（根拠なし）
http://members.aol.com/ksayward/XTML/ これのことですよね？ XMLの本にHTMLのことが書かれているかは不明です。 ですがXMLが何なのか理解できれば さらに理解が深まると思います。
AmazonのWeb ServiceのRESTリクエストにつけるSubscriptionIDは、Access Key IDです。Access Key IDとSecret Access Keyが確認できるページが表示できているのであれば、問題ないと思います。 RESTのリクエストはたとえば、ttp://webservices.amazon.co.jp/onca/xml?Service=AWSECommerceService&SubscriptionId=に、Access Key IDをつければOKです。
#2>node.attributes.item(0).nodeValue = "test>" node.attributes.item(0).nodeValue = "test<" の間違いですね ＞MSXMLの仕様なのかなと ＭＳＸＭＬのリファレンスで According to the W3C DOM specification, an XML parser can completely expand entity references into entities before the structure model is passed to the DOM. When these entity references are expanded, the document tree does not contain any entity references. When Microsoft&reg; XML Core Services (MSXML) validates the XML document, it expands external entities (except binary entities). The nodes representing the expanded entity are available as read-only children of the entity reference. The Microsoft implementation does not expand these entities when it is not validating. とあるので、仕様かと思います。 （英語力が低いので、何ですが、W3C DOM の求めるところで、ＸＭＬパーサーは、ＤＯＭに変換するにあたってエンティティの展開をするべきということかな？、なんにしても、ＸＭＬパーサーとしては、変換するか、エラーにするかしないといけませんが、エラーにしてたら使い勝手の悪いものになると思います。） ちなみに、 xmlDoc.createEntityReference("lt") のようにして&lt;エンティティを作成できます。
if Not IsNull(node.childNodes(i).firstChild.nodeValue) then でなくて if node.childNodes(i).hasChildNodes then とすればいいです
xpathでいうと /html/head/meta/@content かなあと思いますが、 通常meta が複数あるのでxpath で直接指定というのはできないんじゃないかなと思います。 どういう状況で使うのかは判らないですけど、 meta/@content とか ./@content とかでもいいかもしれません。 スクリプトからなら getElementsByName('robots') を使うのが早いかも 状況がわからんので勘違いコメントだったらすみません。
3. 1の試験番号のリストを出題数が多い順にソートして次のように列挙する <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" version="1.0" encoding="Shift_JIS" indent="yes" /> <xsl:template match="/"> <xsl:element name="試験"> <xsl:for-each select="/試験/情報"> <xsl:sort select="出題数" lang="ja" data-type="number" order="descending"/> <xsl:element name="試験番号"> <xsl:attribute name="出題数"><xsl:value-of select="./出題数" /></xsl:attribute> <xsl:value-of select="./試験名/@試験番号" /> </xsl:element> </xsl:for-each> </xsl:element> </xsl:template> </xsl:stylesheet>
xmlはunicodeで書いてますか？ そして保存したファイルを見ているソフトはunicodeを見ることができますか？
原因についてははっきり特定できます。 HTTPのデフォルトのエンコーディングは"us-ascii"で，XMLやHTMLで表現したエンコーディングルールが無視されるわけです。 XML宣言やHTMLの<meta>でエンコーディングルールを明記すれば，指定したエンコーディングで送信されるように勘違いされる方が多いのですが，優先されるのはHTTPヘッダ情報Content-Typeフィールドの値です。 zutさんがお調べになった限りでは，HTTPヘッダを出力するには，”?contenttype=text/html”をURLに付けないと無理のようですね。 ということで，HTTPヘッダをコントロールしない限りは，スタイルシートをいくら変更してもうまくいきません。
>全商品数HASH(0x8ad6604)アイテム のようになるということは、 アクセスしている部分がハッシュの参照になっており、デリファレンスがうまくいってない（理解していない）ということだと思います。 私は、ＤＷＳって使ってないので、その辺に関しては良くわかりません（ＩＤがないと試せない？）が アクセスした時のＸＭＬをローカルに保存して、 ローカルのＸＭＬファイルに関して色々テストしてみるといいんじゃないですか。 そのデータとスクリプトを補足して貰えるならこちらでも試してみることができます。 多分、XML::Simpleで作成されるデータツリーが良くわかってないだけだと思うので my $tree = XMLin($xml); とかしてたら use Data::Dumper; print Dumper($tree); としたら、読み込んだＸＭＬがどういう風に構成されているか良くわかると思います
こんな感じですかね。 ---------------------------------------------------------------- <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"> <html> <head> <title>test</title> </head> <body> <p align="left">test </p> <table border="1" width="500" align="left"> <tr> <th width="18%" align="left">title</th> <th width="60%" align="left">name</th> <th width="40%" align="left">mail</th> </tr> <xsl:apply-templates select="root" /> </table> </body> </html> </xsl:template> <xsl:template match="root"> <xsl:for-each select="data"> <xsl:sort select="kana" lang="ja" /> <tr> <td><xsl:value-of select="name" /> </td> <td> <xsl:element name="a"> <xsl:attribute name="href"> <xsl:value-of select="sname/@surl" /> </xsl:attribute> <xsl:attribute name="target"> _blank </xsl:attribute> <xsl:value-of select="sname"/> </xsl:element> </td> <td> <xsl:value-of select="mail"/> </td> </tr> </xsl:for-each> </xsl:template> </xsl:stylesheet>
えーっと。具体的なソースがないと指摘できないんだけど... とりあえず...(1.1ってのは、XMLのバージョン？それともXHTMLのバージョン？とりあえず後者で仮定します) ------------------------- <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja"> <head> <title>XHTML 1.1サンプル</title> </head> <body> <p>こうやって書きます。</p> </body> </html> -------------- ...って感じなのはOK？
そのとおりです。RSSリーダーはRSS（RDFまたはXML形式）やAtom（XML形式）などのフィード内に書かれた日時データを読み込みます。 したがって、配信側が過去の日時でも将来の日時でも指定できてしまうので、受信側が「あれ？」って思うことってよくあるんですね。
RSSナビ ～RSSの総合情報サイト～ http://www.rssnavi.jp/ RSS-search　～RSS情報サイト～ http://www.toktok.serio.jp/rss-s/ I know.（RSS生成サービス） http://i-know.jp/
RSS自動作成サービスを利用するとか http://blog.myrss.jp/archives/000175.html RSSで配信したい内容をblogに書いて、そのblogのRSSを告知するとか http://oshiete1.goo.ne.jp/kotaeru.php3?q=1648267
やっぱＭＳＤＮ http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnanchor/html/anch_xmlprod.asp http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/d051f7c5-e882-42e8-a5b6-d1ce67af275c.asp
XMLは完成度の高いパーサ(フリーのものを含む)が多数出回っているので、いろんな分野のアプリケーションで応用されています。 アプリケーションの設定ファイル、データベースのファイルインタフェース、各種メタデータ(ブログで有名なRSSなんかもXML(正確にはXML拡張のRDF)です)など数えると切りがありません。 有名どころでは次期Microsoft OfficeのファイルフォーマットはXMLになるとのことです。 あと、すみません、私の知識が古かったのですが、XHTML1.1から「見栄え」を指定するタグが軒並み廃止され(見栄えはCSSで指定)主に文書構造を指定する仕様になったようです。(本来のHTMLの働きに近いですね)訂正します。 データ構造を指定するXMLのうち、文書の構造を指定するものをXHTMLという感じですかね。
>アプリケーションあるいはプログラムが必要でしょうか？ とりあえず、ＩＥでそれらしいサンプルを作ってみました、 どれほどの意味があるかどうかはわかりません。 >MySQLやPostgre ちょっとやったことがないので、わかりませんが、 ＸＭＬをデータベースとして扱うことができるデータベースがあったような気がします。 その場合、現在の様な構造だとダメなような気がします。 -------------------------------------------------------------------- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html> <head> <meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=SHIFT_JIS"> <title>Sample for IE</title> <script language="VBScript"> <!-- sub makeTable() dim root dim FD, RD dim record, field dim newTR, newTD dim i, j set root=xmldata.documentElement if root.hasChildNodes() then FD=root.getAttribute("fd") RD=root.getAttribute("rd") record=Split(root.text, RD) for i=0 to UBOUND(record) set newTR = list.insertRow field=Split(record(i), FD) for j=0 to UBOUND(field) set newTD = newTR.insertCell newTD.innerTEXT = field(j) next next else set newTR = list.insertRow set newTD = newTR.insertCell newTD.colspan=4 newTD.innerTEXT = "データなし" exit sub end if end sub '--> </script> </head> <body onload="makeTable()"> <xml id="xmldata"> <data fieldname="none" fd=" " rd=" "> 1 abc jiro taro 2 exe tosi sabu </data> </xml> <TABLE style="border:solid 1px yellow"> <col style="color:crimson;text-align:center"><col><col><col> <THEAD STYLE="background-color:lightSkyBlue;text-align:center"> <TR><TD>No</TD><TD>種類</TD><TD>名</TD><TD>姓</TD></TR> </THEAD> <TBODY ID="list" STYLE="background-color:lightcyan;"> </TBODY> </body> </html>
＞何か問題があるのでしょうか？ 何が問題で片方で取れて片方で取れないのか ちょっとよくはわからないのですが、 とりあえず NodeList contentList = element.getElementsByTagName("content:encoded"); Element contentElement = (Element)contentList.item(0); String content = contentElement.getTextContent(); のようにgetTextContentを使ってみるとうまくいきました。
参考ＵＲＬと同様で NodeList contentList = element.getElementsByTagName("content:encoded"); のように指定して（後は同様に）取り出せます
参考書の受け売りでスイマセン。O'Reilly から出ている "XML in a nutshell" というリファレンス本に、XML パーサのエンコーディング想定処理についての記述がありました。以下、拙訳ですが、当該部分の引用です。 -- * -- * -- (略) XML パーサは、文書の最初の数バイトからその文字セットの想定を試みるだろう。パーサによる基本的なチェックは以下の処理を含む： ・もし最初の２バイトが #xFEFF の場合、パーサはそのバイト列をユニコードのバイトオーダーマーク(BOM)と認識するであろう。そして、その文章はビッグエンディアンのユニコードの UCS-2 (訳注; UTF-16)で記述されていると想定される。その知識に基づいて、残りの文章を読み進める。 ・もし最初の２バイトが #xFFFE の場合、パーサはそのバイト列をユニコードのバイトオーダーマーク(BOM)と認識するであろう。そして、その文章はリトルエンディアンのユニコードの UCS-2 (訳注; UTF-16)で記述されていると想定される。その知識に基づいて、残りの文章を読み進める。 ・もし最初の４バイトが #x3C3F786D の場合、つまりこれは ASCII 文字の "<?xml" だが、その場合そのファイルは ASCII 文字の上位セットで記述されていると想定される。特にユニコードの UTF-8 で記述されていると仮定するかもしれない。仮にそれが間違いだったとしても、この情報は、どの文字セットを実際に使っているかの宣言に辿り着く迄は、残りの文章を読み進める上では十分と言えよう。 -- * -- * -- 他にも、XML パーサは UTF-8 と UTF-16 には対応していなければならないような記述もありますので、上記のような UTF-16 を前提とした処理も必要なのではないでしょうか。
こんにちは、なんか、変な風にとられてもいやなので、他の人の回答が付くのを待ってましたが、付かないようなので、また回答しておきます。 （また！）勘違いコメントだったらすみません。 * <xsl:for-each select="document（'取り込むXMLファイル'）//z:row"> <xsl:value-of select="@取り出したい属性の名前" /> </xsl:for-each> <xsl:for-each select="//z:row"> <xsl:value-of select="@取り出したい属性の名前" /> </xsl:for-each> の部分を <xsl:for-each select="//z:row|document（'取り込むXMLファイル'）//z:row"> <xsl:value-of select="@取り出したい属性の名前" /> </xsl:for-each> のように、まずは、１つにまとめることができます。 そうすることで、xsl:sortでまとめてsortできます。 xsl:sortについては、既知かもしれませんが <xsl:for-each select="//z:row|document（'取り込むXMLファイル'）//z:row"> <xsl:sort select="ソートキー" lang="ja" data-type="text" order="ascending" /> <xsl:value-of select="@取り出したい属性の名前" /> </xsl:for-each> のように書きます。 ソートキーが数値の場合、data-typeにはnumberを 降順にするには、orderをdescendingにします。
MSXML (Microsoft XML Parser) 3.0 Software Development Kit (SDK) http://www.microsoft.com/downloads/details.aspx?FamilyID=2cf40ae6-368c-4b6b-a185-2dfa92fb7993&DisplayLang=en は、ダウンロード済みでしょうか？ 上記をインストールしたフォルダのincフォルダの中に msxml2.h はあります。
私も最近勉強し始めいろいろと助けて頂いてますので、 参考になるか分かりませんが以下のサイトなんてどうでしょうか？ http://www.cityfujisawa.ne.jp/~yanai/xml/ http://www.atmarkit.co.jp/fxml/rensai/msxml03/msxml03.html http://www.parkcity.ne.jp/~chaichan/src/htmlxml.htm
>removeAllメソッドがありませんでした そんなことはないはずです。 以下のＭＳのサイトでＭＳＸＭＬ３以降で（Ｃ／Ｃ＋＋で）使えると書いてあります。 http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/f313fcf1-1ec1-4438-88f5-0f2154d6c2e9.asp 参考ＵＲＬによると Applies to IXMLDOMSelection と書いてありますから IXMLDOMSelection を使う必要があります。（メンバーにremoveAllがあります） selectNodesからIXMLDOMSelectionをセットするサンプルが以下にあります http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/665e4039-40d1-4aa8-9b98-dd7494dd8268.asp
状況が再現し、一応除去もできるようにはなりましたけどなんか釈然としません。 やってみた方法は、ＸＳＬを２段階適用するというやり方で transformNodeToObjectを使って別のＸＭＬ（output method="xml")に変換し （ＸＳＬで一行分のレコードをxsl:elementで１つのエレメントにする） transformNodeで <xsl:value-of select="translate(., ' ', '')" /> みたいにして作成したエレメントから空白文字を取り除く＋<xsl:text> </xsl:text> （output methid="text"） するというようなやり方です。 でも、いちいちこんなやり方するなら、別に一行に書けばいいんじゃないかとか思えて釈然としません。 ところで、 std::string s = pXMLDOMDoc->transformNode(pXSLDOMDoc); replace(s, std::string("\r\n"), std::string("\n")); ってうまくいきますか？ こういう置換がプログラムでできるなら、 transformNodeで出力したものからタブと取り除くのも難しくないと思うのですが、 スタイルシートで、:CR:観たいなものをレコード区切りとして付与して スペース、タブ、改行を取り除いた後 :CR:を改行に置換するというような手順でいいような気がします。 どっちかというと、そういうプログラムで（整形）処理するのが、簡単でいいような気がするのですが。
Web上のxmlファイルでしょうか？ それとも御自分で作成されたxmlファイルを、ということでしょうか？
<xsl:value-of select="translate(商品/値段,'０１２３４５６７８９','0123456789')" /> のように、translate関数を使うことで可能です。 サンプルでは、 値段の内容を全角数字を対応する半角数字に置き換えます
＃１>"c:\windows\system32\msxml3.dll"にしなければいけないのではないか あんまり詳しくはないのですが、私は、ＩＥ６で動作確認しています。 ＩＥ６は、msxml3.dllは使ってなかった（別途ダウンロードしてインストールしなければいけなかったような気がします）と思います。 質問文のXSLで欲しい結果にならない理由がＤＬＬだという意味なら、 それは、違うと思います。 select="//z:row[not(@COUNTRY = preceding-sibling:://z:row/@COUNTRY)]"> でセレクトされるのは、それまでとCOUNTRYがことなるもの つまり JAPAN,TARO CHINA,SABURO の２つのデータをセレクトすることを意味していると思われるからです。 ＃１＞XMLのデバッグにはどのような方法があるのでしょうか？ この時のこの値という意味なら、開発環境でインスペクトすればいいと思いますが、 構文エラーが表示されるので、まずは、ＩＥで動作させてみるのがいいと思います。 例えば、質問文のＸＳＬであれば、 xmlns:xsl="http://www.w3.org/TR/WD-xsl"に「xsl:keyがない」 ネームスペース「z:」が定義されていないとか表示されます。 あとついでに言えば、<xsl:key>宣言は、xsl:templateの中で使われていないので必要ないと思います。
値がなければタグはいらないと思います。 というよりも普通は既成のパーサーを利用するのでこのようなことで悩む機会は少ないと思います。 既成のパーサーを利用できないようなシステムということなのでしょうか？ システム間で送られてくるXMLはいわゆる規格上のXMLではなく数多の制限を加えているXMLなのでしょうか？ もしも一般的な規格に沿ったXMLを利用しているのでしたらパーサーの利用を考えた方がいいと思います。そうでなければもう一度システム間でXMLの仕様に関して打ち合わせをした方がいいと思います。
RSS+XSLなページだけどIE5で見れません。
たぶん一番難しいのは「コンテンツ」でしょう。 XOOPS本体のインストールは難しいものではありませんので、 サーバーのスペックで利用可能であればそれでＯＫです。 すでに入っているレンタルサーバーでも、結局モジュール等は自分でインストールしていかないといけないので、 できれば全部自分でやれるタイプのほうがいいと思いますよ。 モジュールのインストールができれば、XOOPS本体のインストールも難しいものではありません。 ただ、オリジナルデザインで、機能もデフォルトから変えて、となると プログラムがある程度できないとつらいと思います。 XOOPSって結局「枠組み」しか提供してくれていませんからね。 あとはやる気だけです。一度自分のＰＣにインストールしてみてはいかがでしょう？ 案ずるよりなんとやら、けっこうラクラクにいけるかもしれませんよ。プログラミングの知識がなくても、じーっとプログラムをみていると、何をやっているかだいたいわかるようになってきます。個人でやるのであれば、楽しみながらやっていくといいですよ。
問題ないですね。
>文字コードが「ＵＴＦ－８」かどうかを確認するにはどうすればいいですか？ 色々な方法があると思います。 例えば、適当に、内容を変更してＨＴＭＬとしてＩＥで表示して、 表示～エンコード～ＵＴＦ－８で化けずに表示されたらＵＴＦ－８ ですかね。 私の場合は、文字コードを変更できるエディタで概ね文字コードが確認できます。 わけわからん、化けてしまっている文字は、Ｐｅｒｌで適当にコード変換して表示できるものというようなツールを作って確かめたりしてます。 この場合で言えば、書かれている文字はサッカー！だと判明しているので、 ダンプして SHIFT_JIS:83548362834A815B8149 JIS :25352543252B213C212A EUC :A5B5A5C3A5ABA1BCA1AA UTF-8 :30B530C330AB30FCFF01 のような並びになっていたらそれぞれどのコードになっているか解ります。 とりあえず、手軽な方法として encodingの指定の部分を適当にSHIFT_JISとか変更してみて文字が化けずに表示できるか試してみたらどうでしょう。
msearchとかNAMAZUとかを使うのでは駄目なのでしょうか？
EXSLTはどうでしょう？EXSLTの中にmathモジュールがあるので、累乗はmath:power()、平方根はmath:sqrt()で実現できると思います。 http://www.exslt.org/math/index.html 参考URLはEXSLTの紹介記事です。 (専門じゃないので自信なし)
日本語全文検索「なまず」というフリーのソフトがあります、アパッチなどのフリーのＨｔｔｐ　サーバ上（サーバーと言っても使わなくなったぼろパソコンで稼動します。）で動作し、モジュール追加でｐｄｆファイルなどの中も検索します。 かなり強力な検索エンジンです。 日本語全文検索システムの構築と活用
以下のように修正 ---------------- <?xml version="1.0" encoding="Shift-JIS" ?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"> <html> <head><title></title></head> <body> <table border="1"> <xsl:for-each select="links/site"> <tr> <td> <img> <xsl:attribute name="src"> <xsl:value-of select="banner" /> </xsl:attribute> </img> <b><xsl:value-of select="name" /></b> </td> </tr> </xsl:for-each> </table> </body> </html> </xsl:template> </xsl:stylesheet>
具体的に質問を絞り込まないと回答は難しいですね。 ・サーバーでXMLファイルを配布する方法 ・クライアントプログラムがXML文書を読み取る方法 ・指定日時にプログラムを実行する方法 ・Webサイトを開く方法 など複数の質問が出てくるので絞り込んではいかがですか？ 考えられているプログラムはJava + XMLでなくても実現できます。
初書き込みです。 時間がったているので解決したかと思いますが、レスしますね。 以下のテンプレートを使用すれば、出来るのかなと思います。 <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:template match="/"> <html> <body> <xsl:apply-templates select="purchase-order" /> </body> </html> </xsl:template> <xsl:template match="purchase-order"> <xsl:variable name="total_sum"> <xsl:call-template name="culc_sum"> <xsl:with-param name="tanka" select="book/price" /> <xsl:with-param name="suryou" select="book/count" /> </xsl:call-template> </xsl:variable> <xsl:text>合 計</xsl:text> <xsl:value-of select="format-number( $total_sum div sum(book/count),'#,###')" /> </xsl:template> <xsl:template name="culc_sum"> <xsl:param name="tanka" /> <xsl:param name="suryou" /> <xsl:choose> <xsl:when test="not($tanka) or not($suryou)"> <xsl:value-of select="0" /> </xsl:when> <xsl:otherwise> <xsl:variable name="sum_data"> <xsl:call-template name="culc_sum"> <xsl:with-param name="tanka" select="$tanka[position()>1]" /> <xsl:with-param name="suryou" select="$suryou[position()>1]" /> </xsl:call-template> </xsl:variable> <xsl:value-of select="number($tanka[1]) * number($suryou[1]) + $sum_data" /> </xsl:otherwise> </xsl:choose> </xsl:template> </xsl:stylesheet>
いきなりXMLにしようとしていますけど、まずは「どんな情報があれば回路を表わすことができるか？」が問題ではないでしょうか？ XMLで表現しようが、独自フォーマットで表現しようが、プログラムで必要なのは持っている情報であって、それがプログラムで処理する上で必要な要件を満たしているかどうかです。 まずはXMLうんぬんの前に、どんな情報があれば回路を表現できるのかを洗い出してみてください。 それらの情報が揃えば、XMLのスキーマも見えてくるのではないでしょうか？
DTDとはXMLのルールが書いてあるものです。 単純なテキストファイルだと思うので、メモ帳やお好きなエディタで見てください。 私がリファレンスとして見ているサイトは http://www.parkcity.ne.jp/~chaichan/src/htmdtd.htm http://www.kanzaki.com/docs/html/read-dtd.html です。だいたいこれで用は足ります。
　お示しになった XHTML では，DOCTYPE 宣言で「XHTML 1.1」を宣言しています。ここで，XHTML 1.1 には lang 属性はありませんので（廃止されました），質問のお答えは「正しくない」となります。すべて xml:lang 属性を使用します。 　ちなみに，XHTML 1.0 でしたら，lang 属性を持っています。
こんな感じ -----8<-------8<-------8<-------8<-------- <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/TR/WD-xsl"> <xsl:template match="/"> <xsl:for-each select="Books/book"> <xsl:if test="@name[.='title']"> <title><xsl:value-of select="@value"/></title> </xsl:if> </xsl:for-each> </xsl:template> </xsl:stylesheet>
そのXSD定義がどの程度のものか分からないのでなんともいえませんが、 簡単なものなら、EXCEL2003とかの機能でもできたと思います。 参考URLを記しておきます。 無償のツールではないですが。 見当違いの回答であればすみません。ご参考までに。
私のオススメとしては、分からなくてもいいからリンク先の「ごく簡単なHTMLの説明」を読んでみることです。 これを読んでみて、こんなことがあるんだな、っていうことを頭の片隅に置いてもらうのがいいと思います。 それから色々なサイトでHTMLのソースを見れば、それがどんなに汚いかとか読みやすいかとかが見えるんじゃないかなと思います。 ブラウザ（InternetExplorerとかFireFoxとか）は、ある程度文法に沿っていなくても見れるものを作ってくれたり、 またWordやホームページビルダーなどのソフトでは、不要で見づらいHTMLタグ（<body>とか<font>とか）の組み合わせを作成してしまったりするので、基礎は必要です。 （基礎というのは、"タグは、開始タグと終了タグがセットである"という大前提のこと） 手っ取り早く始めるなら汚くてもとりあえず書いて表示してみる、どんなに汚くてもブラウザは大抵認識しますから。 でも、たとえばあなたが「私のサイトにもっと人が来て欲しい」と思えば、XHTMLを使って構造化されたソースのほうが検索ロボットが見つけてくれやすいですし、改修もしやすいです。 読みにくい文章になりましたが、要は「XHTMLの基礎を分かった上でHTMLを始めるのが、後々便利だし、それほど難しくない」ってことでしょうか。 初めての方ならなおさら余計な情報なしに吸収できるので、かじったことがない人のであれば是非、まずは参考URL「ごく簡単なHTMLの説明」を分かる範囲で読んでみてください。 とほほさんサイトも便利ですが、私のイチオシサイトです。
私の私見と、私も少し知りたいので書き込ませて ください。 アマゾンのアソシエイトのために、ｘｍｌを少し 勉強しましたが、ちと難しいです。 私の無理無理に見いだした利点は、 ・データをブラウザで操作できる事。 ・データがレイアウトと分かれているので、編集が簡単。 ・また、わかりやすく書けば、データを見るだけで、 　それが何に所属しているデータなのかが、分かる事。 ・サーバの負荷も軽くなる。 ・信頼性がある。 ・XLink(拡張リンク)は、確かに魅力がある。 他にも、 ・他のソフトと、互換性を意識している、の？ ・他にもタグが厳密になった、とか、いろいろ。 欠点としては、 ・対応しているソフトが少ない。 　データ形式を作成するために、ＰＨＰでスクリプトを 　作ったりした。(笑 　手動で多くのデータの移行は困難。 ・拡張子が変わる。 ・ＸＳＬＴやら似たような言葉の概念が分かりづらい。 ・書籍がまだ、少ない。 　Ｘｐａｔｈが詳しくのってたのは、 　「webコンテンツ作成のためのＸＳＬＴ入門」だけ 　だった。 　okwebでもｘｍｌの質問はまだ回答が少なめですね。 アマゾンの本のデータの受け渡しも、ラインでくれた方 がよっぽど簡単なのに～、と思っちゃいました。 データーベースだけを考えたなら、下手をするとＳＱＬ の方が、わかりやすいですよ。
<xsl:template match="/"> 　　<xsl:for-each select="A/*/*"> 　　　　<xsl:value-of select="."/> 　　</xsl:for-each> </xsl:template> こんな感じでどうでしょうか？ for-eachのselectで繰り返したい全てのノードを選択し、 value-ofのselectで出力したいノードを一つだけ指定しています。 ポイントはvalue-ofは条件に当てはまるすべてのノードに有効ではなく 条件に当てはまる最初のノードに対してのみ有効である ということです。 また、簡単に書くなら <!--これはxsl:transform直下に書く--> <xsl:strip-space elements="A B Z"/> <xsl:value-of select="A"/> でもいいと思います。 strip-spaceで空白の除去を設定しています。 value-ofでAを設定するとAの子孫テキストノードを全て出力してくれます。 （〃▽〃）がんばってください
ＣＳＳっていうかスタイルシートは使えません。 BackColorとTextのカラー属性を変更できるのみです。 また、Frameset、Tableも使えません。 なんて不便なんだろうと思う今日この頃です。 いざとなったら、 Flashしかないと思います。
　まず，XML と XHTML の関係をはっきりさせておきましょう。「XHTML は XML からつくられたもの」ということです。 　経緯を説明すると，まず，ウェブで HTML が普及したわけですが，そのうちに HTML では不足が生じてきました。HTML はタグ群で文書を記述するのですが，要素の種類が固定されていて柔軟な運用ができなかった（具体的には，文書：ウェブページを記述する以外の用途につかえなかった）のです。もっと抽象的な言語をつくって，それから用途に応じてさまざまな言語をつくれるようにしようということになりました。こうして誕生したのが XML です。 　XML は抽象的な言語（メタ言語）で，簡単に言えば「タグ群でデータを記述する」という文法規則をもちます。しかし，HTML のように要素の種類は定義されていません（ですから，「XML タグ辞典」なるものは存在しないのです）。XML から「具体的な言語（XML アプリケーション）」をつくって運用することになります。 　かくして XML は普及するところとなったのですが，すると，HTML にまた問題が生じました。HTML は XML の文法規則にのっとっておらず，XML 時代を生き残れないという点です。そこで HTML を XML の枠組みの中で作り直すことにしました。これが XHTML です。XHTML は XML アプリケーションということになります。 　ちなみに，HTML と XML の背景には SGML というものがあります。SGML もメタな言語で，要素の種類などは定義されていません。XML よりはるかに古いものです。SGML は主に文書交換を想定して作られました。HTML は（いちおう）SGML アプリケーションです。 　XML は，SGML のサブセット（部分集合）という位置付けになります。実は SGML は処理が難しく，処理を思い切って簡単にするために XML では文法規則が改められています。 　以上をまとめると， 　- HTML は SGML アプリケーション 　- XML は SGML のサブセット 　- XHTML は XML アプリケーション 　- XHTML は HTML を XML の枠内で作り直したもの ということになります。
HTMLを国際化する方法は幾通りもあります。 その方法として http://www-6.ibm.com/jp/developerworks/web/010720/j_wa-xslt.html この方法を使いたいということでしょうか？ --具体的に言いますと-- (1) まず、データとなるXMLドキュメントを作ります。 (2) 国際化したい単語のXMLディクショナリーを作る。 (3) (1)で作ったXMLのHTML変換規則をXSLTというXMLドキュメントに記述する。このとき、国際化したい単語は(2)で作ったXMLディクショナリーからひいてくる。 (4) (1)で作ったXMLの頭（XML宣言がある場合は2行目）に<?xml-stylesheet type="text/xsl" href="(3)で作ったXSLTのURL"?>を挿入する。 こんな感じです。 --XSLTがわからない場合-- ↓で勉強するか、別に質問してください。 ■たのしいXML http://www.cityfujisawa.ne.jp/~yanai/xml/
ＸＭＬで全角「～」扱う時の制限はなかったような気がするのですが・・・ どのような状況で文字化けしてるのかを記述したほうがいいと思います。 ＸＭＬをテキストで表示した場合は正常で、ＩＥなどで表示した時に文字化けしてるのでしたら、エンコードが違うとかですかね？
簡単に言っちゃうと、HTMLはホームページ専用ですが、XMLは様々なファイルを記述できます。 あんまり詳しくはないんですが、元々SGMLというものがありまして、これは、ホームページに限らず様々なファイルを記述できたりするものです。これをホームページ用に特化させた、一種の派生型がHTMLです。それに対してXMLはSGMLの単純な発展版でして、様々なファイルを作ることができます。また、XMLで定義されたホームページ用の言語で、XHTMLというものもあります。 また、もうひとつの違いとして、見た目に関する情報を定義できるか否かということが上げられます。SGMLやXMLなどのマークアップ言語は、元々、文書内の情報が何を意味しているかを示すためのものです。HTMLも元はその意向に沿っていたのですが、段々<font>や<center>などの文書の見た目を定義するタグが追加されてきました。最新のHTMLではこれらのタグは使用するべきではないとして、これらの代わりにCSSを使うことが推奨されていますが、実際には使用され続けているのが現状です。それに対してXML及びXHTMLでは、基本原則どおりに、文書中の情報の意味を定義するタグのみが使えます。
基本的に、<p>タグで段落を作るときに、勝手に一行開けてくれると考えていいかと思います。 そして、<br>は行をあけない普通の改行ということになります。 つまり、一行あけるときは <p>あいうえお</p> <p>かきくけこ</p> 行をあけないときは <p>あいうえお<br /> かきくけこ</p> となります。 ＊余談ながら、xhtmlでは<body>の直下に普通のテキストを書くことができませんので、文章を書くときはそれを<p>で囲ってやることが必要となります。
ＦｉｒｅＦｏｘはどうでしょう。 10.1.ｘに対応しています。 ただ、10.1.ｘはバグも大石安定も悪い なんといっても遅いですのでＯＳの有償バージョンアップを考えても良いかと思います。
タグの値の有無（空か否か）を判断したいのであれば <xsl:when test="value=''">hogehoge</xsl:when> でいいでしょう タグの有無を判断するなら <xsl:when test="count(value)=0">hogehoge</xsl:when> ですね <value></value>のような空要素と、タグが無いというのは同義語ではないです。どちらを指していたのでしょうか？
実際にはマークアップとして解釈される文字が含まれていなくても、Javascript 内では < や > が含まれる場合があるので、CDATA部　として記述するのが習慣なのだと思います。
＃１です。 結局、ＴＡＢＬＥタグ使うのが楽です。使っちゃダメって訳では無いし（現時点では）、殆どのブラウザで対応していますから。 で、その場合のソースですが、 　<td><div class="item">～</div></td> とした場合は枠線が<td>の枠と<div>の枠で二重に表示されますよね。その辺りは適宜修正を加えてください。 また、CSS未対応ブラウザに対応させる為に、<table width="～" border="～" class="～">という様に、CSS未対応のブラウザの為に要素の指定も必要です。
質問を以下の2つと解釈します。 1)改行がノードとして取り出されるのは正しいのか／なぜか？ 2)要素ノードnameの次に属性ノードtype，テキストノードabcが取り出せないのはなぜか？ まず1ですが，改行がノードとして取り出されるのは，DOMの正しい仕様です。これがちゃんと取り出されないと，DOMからXMLに書き戻す時に改行が消去されてしまいます。 次に2についてですが，まずJAXPにもそのほかにもgetNodeList()というメソッドは見当たらなかったので，org.w3c.dom.Node.getChildNodes()のことと考えます。 要素ノード<talkset>でgetChildNodes()した時，NodeListの中に属性ノードtypeやテキストノード"abc"が出現しない理由は，それらが要素ノード<talkset>からみて子ノードではなく孫ノードに当るからです。 属性ノードtypeやテキストノード"abc"は，要素ノード<name>でgetChildNodes()して得られるNodeListの中から取り出すことができます。 参考： http://java.sun.com/j2se/1.4/ja/docs/ja/api/org/w3c/dom/class-use/NodeList.html http://java.sun.com/j2se/1.4/ja/docs/ja/api/org/w3c/dom/Node.html
transformNodeToObjectの解説には以下のようにあります。該当しませんか？ The transformNodeToObject method always generates a Unicode byte-order mark, which means it cannot be used in conjunction with other Active Server Pages (ASP) Response.Write or Response.BinaryWrite calls.
#content #main table2 　↑　　　↑　　↑ 　ID　　　ID　　クラス？ クラスを指定する場合には　クラス名の前にドット（.）が必要です > と「table」をsccで指定しているので... というのは、クラスを指定せずに全てのtableに対して　ということになります ということで、 #content #main .table2　（tableでなくても反映される） とするか #content #main table.table2　（tableのみ） という記述になります クラスを明示したテーブルは、幅も指定通りになるはずです（ie6ではokでした）。階層の指定も大丈夫みたいです
ＸＭＬはあんまりいい参考書ないですねぇ。 というのが実感です。サンプル集の方がいいですね。 ＣＱ出版社 「ＸＭＬ＋ＸＳＬＴ　実用スーパーサンプル集」 ちょっと古いですが大型書店などには置いてるかも。 「OPEN DESIGN」での連載をまとめたものです。 サイトでは・・・基本的な内容ですが参考ＵＲＬをどうぞ。
CMSとはコンテンツ・マネジメント・システムのことでしょうか。 CMSのユーザーインターフェースは主にHTMLですが、一般にデータ・定型文書・非定型文書・ワークフローなどを管理したりするもので、動的に情報を抽出したりする部分、システムを運用保守する上でXML設定ファイルは便利です。 簡単に言うと、設定情報をXML形式で登録するだけで、CMSシステムが出来上がるようになっています。HTMLもわざわざ作る必要がありませんし、XMLは知らなくても、登録はマニュアルに従えば簡単です。 運用保守も可能です。例えば、画面上の表形式を変えるのも、HTML等のコーディングなしに、XMLファイル（テキストファイル形式）の値を変えるだけで画面表示が変わったりします。 一般的なXMLの利点は参考URLをご覧下さい。
TextクラスはNodeクラスを継承しているのでsetNodeValue()/getNodeValue()を利用できます。Textクラス特有のメソッドsetData()/getData()でも動きは同じです。 前回のコードでは、メモリ上のDocumentは、すでに文字列変換されています。 ただ、これをファイルに書き出す（保存する）場合は、もう一つ手順が必要です。 　　　　File file = new File("test2.xml"); 　　　　Transformer t = TransformerFactory.newInstance().newTransformer(); 　　　　DOMSource source = new DOMSource(document); 　　　　StreamResult result = new StreamResult(file); 　　　　t.transform(source, result); このコードを実行すると、ファイル"test2.xml"に変換後のXMLが書き出されます。
> 入力側のIN1,IN2が複数回繰り返された場合、 > 出力側もOUT1が複数回繰り返されるって感じです。 IN1とIN2が必ず１対１に対応するという条件でいいなら（複数の組が存在しても可）これでいけるでしょう。 IN1およびIN2以下の構造はオリジナルのまま出力されます。 <xsl:template match="INPUT"> 　<OUTPUT> 　　<xsl:apply-templates /> 　</OUTPUT> </xsl:template> <xsl:template match="IN1"> 　<xsl:text disable-output-escaping="yes">&lt;OUT&gt;</xsl:text> 　　<xsl:copy-of select="." /> </xsl:template> <xsl:template match="IN2"> 　<xsl:copy-of select="." /> 　<xsl:text disable-output-escaping="yes">&lt;/OUT&gt;</xsl:text> </xsl:template>
「条件付でNodeListは取得できない」ではなく 「NodeListを取得するのに条件を与えられない」です。 こういった処理を望むのであれば、自分で処理を記述しなければならないということです。 childNodesプロパティで得られる情報は、当該ノードの子、全てをコレクションとして含むNodeListということになります。 「”氏名○○”のリストのみ取得する」という処理をしたいのであれば、『childNodesプロパティを使用して<個人>ノードを全て取得した後、さらに<氏名>ノードを取得して判断』という流れになるでのしょう。 この件に関して言えば、ネームスペースは『自分で判断する』必要があります。
　CSS で外部文書リソースを特定の位置に突っ込むことは仕様的には可能と読み取れますが，こちらで試したところ，ブラウザが実装していないので，現在はできないとお考えください。 　iframe 要素をお使いになったようですが，「以降のデータが出力されない」とのことで，もしかしたら iframe の終了タグをお忘れになっていないでしょうか。iframe 要素の基本書式は， <iframe src="***.html"> （iframe 要素が使用できないときの代替コンテンツ） </iframe> となります。 　それから，XHTML をお使いになっているということで，iframe 要素は XHTML 1.1 で消滅することにご注意ください。より一般的な object 要素を使用することになります。 <object type="application/xhtml+xml" data="***.html"> （処理できないときの代替コンテンツ） </object> ただし，この方法での外部ドキュメント挿入は，Internet Explorer ではサポートされません（Netscape 6 以降，Opera 7 以降でのサポートを確認しました）。 　以上，ご参考になりましたでしょうか。
とりあえず、掲示されたHTMLおよびCSSをfirefoxで試してみたらきっちり画像がくっつきました。 もし確認に使っているブラウザがIEだとすると、IEの不具合かも。
encoding方式をUTF-8としているのにも関わらず、 実際の文字はShift_JISが使われているのが問題であると思われます。 > と宣言して、XML文書を書いたのですが、 どの方法(ツール)で書いたのかによって解決策は異なりますが、 仮にWin2000以降のメモ帳でXML文書を書いたとしますと、メニュから ファイル→名前を付けて保存→文字コード→UTF-8 と選択してから保存してみて下さい。 Internet Explorer等でXML文書を開いても問題なく閲覧できると思われます。 秀丸で書いている場合も、保存の際に文字コードが選べたと思いますのでそこでUTF-8を選択して下さい。 他のテキストエディタでも同じような手順でUTF-8を選択できるかもしれません。 お使いのツールでUTF-8により保存する方法がどうしても分からない場合は、一旦Win2000以降のメモ帳で開いてUTF-8で保存しなおして下さい。
> このgoo RSSリーダーの仕様は、RSS1.0の仕様に基づいたものとは思えませんが、 RSS 1.0の仕様は、データのフォーマットの仕様であって、データの管理方法や、データの表示方法を定めた仕様ではありません。 ですので、goo RSSリーダーが1itemしか表示しないという動作とRSS 1.0の仕様は無関係です。 また、ユーザの利便性を考えても、goo RSSリーダーの動作に何か問題があるとは思えません。むしろ、これはこれで使いやすい、と考えることもできます。 例えば、こんな考えです。 linkが示すURLが同じでしたら、それが示すコンテンツも同じと考えます。 同じコンテンツを示すitemが複数あるということは、どれか一つのitemが最新の正しい情報を示し、残りのitemは古い(そして既に正しくない)情報を示している、と考えたとします。 そうなると、最新と思われる情報を1つだけ表示し、残りの情報は表示しない、という動作は自然なように思えます。 というわけで、goo RSSリーダーに問題があるとは思えません。 今回の問題の根本はここです。 > 自分のサイトの更新情報を載せるべく、RSSファイルを作ろうと考えていました。 RSSは、サイトの更新情報を配布するための仕様ではありません。サイトの要約を配布するためのフォーマットです。 つまり本来の目的外のことに使用しようとしているわけです。無理がでるわけです。 サイトの更新情報ではなく、サイトの要約をHeadline-Editor LiteでRSSファイルとして作成し、それを配布することをお勧めします。 サイトを変更したときに、RSSファイルも変更後の内容に合わせて変えましょう。 大抵のRSSリーダーは、RSSファイルの変化を分かりやすくユーザに提示するようになっていますので、結果的にサイトが更新されたことがユーザに伝わるはずです。
　IDとclassが混用されている様ですが。参考サイト↓ http://www.tohoho-web.com/css/basic.htm#Class 　意図されているページがわからないのでサンプルタグを書いてみましたので、ご参考に <html> <head> <title>Style Sheet</title> <style TYPE="text/css"> <!-- #contentBody {text-align: center; font-size: 20pt; margin: 0px;} #headArea {font-size: 14pt; margin: 10px;width: 600px;float: left;} #mainContentArea {text-align: center;font-size: 14pt; margin: 0px;width: 600px;float: left;} #contentMenu {color: green; font-size: 14pt; margin: 0px;float: left;} #pageContent {margin: 0px;width: 600px;float: right;} .entryBody {font-style: italic; text-align: center;font-size: 10pt; margin: 10px;} #footArea {color: red; margin: 0px;width: 600px;float: right;} --> </style> </head> <body> <div id="contentBody"> contentBody </div><!-- /#contentBody --> <div id="headArea"> headArea </div><!-- /#headArea --> <div id="mainContentArea"> mainContentArea </div><!-- /#mainContentArea --> <div id="contentMenu"> contentMenu </div><!-- /#contentMenu --> <div id="pageContent"> pageContent </div><!-- /#pageContent --> <div class="entryBody"> entryBody </div><!-- /.entryBody --> <div id="footArea"> footArea </div><!-- /#footArea --> </body> </html>
#1です。 XmlSerializerは、クラスの内容をそのままファイルに書き出すクラスです。 ですので、VCとVBで同じ構造のクラスをイメージすれば、すんなり行くような気がします。 >パラメータ変更の頻度が多い というのは、XMLのタグの名前が変わったり、タグ自体を追加するということですか？ パラメータ変更の対応を考えると、 XmlSerializerの場合はクラスの構造が変わることになり、DOMの場合、プログラム内部はファイルの読み方が変わることになると思います。
XML自体はプログラミング言語ではなく、データを保持・記述するドキュメント（拡張可能マークアップ言語）なので、XMLで「文字列を分割し配列に格納する」ことはできないでしょう。 Perlについては、全く知らないので何とも言えませんが、 Perlを使って、XMLのデータを抽出できるなら、"h o g e"の部分に抽出したデータを持ってくれば可能でしょう。
2種類を交互にということでしたらこんな感じでどうですか？ <xsl:for-each select="hoge"> 　<xsl:if test="position() mod 2=0">赤</xsl:if> 　<xsl:if test="position() mod 2=1">青</xsl:if> ： </xsl:for-each>
実行環境がないので試していませんが、一番簡単なのは @root.getElementsByTagName("node").length　を @root.getElementsByTagName("question_solution_tree/node").length に すれば可能と思います。
xlmnsじゃなくて、xmlnsですよ。
一般的には間違いになるはずです。 デフォルトにたとえば"AAA"という文字を設定した場合、 下の場合は当然"AAA"が入りますが、うえの場合は明示的に""（空の文字）を設定しているため、""が入るはずです。
IEを使っている場合、 xslの中でVBScriptが使えます。 それで、FileSystemObjectでファイルの有無を調べられるのではないかと思います。 その場合調べたいファイルは、ローカルのファイルなので、サーバーでスクリプトを動かす場合には、 ASPで動かす必要があります。 あと、拡張関数宣言をしてやれば、 OSのコマンドを実行することができるので これを使ってもファイルの有無を確かめられると思います。 環境にもよると思うので、 実際にテストしていないので自信はないです。
xsl:ifで、中身がある時と無い時の記述を変えることができます。 <xsl:if test="data[.='']"> <span>中身が無い時の記述</span> <td>&nbsp;</td> </xsl:if> <xsl:if test="data[not(.='')]"> <span>中身がある時の記述</span> <td><xsl:value-of select="data" /></td> </xsl:if>
リストボックスの座標位置というのがよくわかりませんが、こんな感じではどうでしょうか？ ・XMLファイル（list.xml） <?xml version="1.0" encoding="utf-8" ?> <data> <item>A</item> <item>B</item> <item>C</item> </data> ・XSLファイル（list.xsl） <?xml version="1.0" encoding="utf-8" ?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="html" encoding="Shift_JIS" indent="yes"/> <!-- 文書全体のテンプレートルール --> <xsl:template match="/"> <html> <script language="javascript" src="select.js"></script> <body onload="SelectList(0);"> <center> <form name="F1"> <xsl:apply-templates select="data" /> </form> </center> </body> </html> </xsl:template> <!-- <data>のテンプレートルール --> <xsl:template match="data"> <select name="S1" OnChange="SelectList(this.selectedIndex);"> <xsl:apply-templates select="item" /> </select> </xsl:template> <!-- <item>のテンプレートルール --> <xsl:template match="item"> <xsl:element name="option"> <xsl:attribute name="value"><xsl:value-of select="." /></xsl:attribute> <xsl:value-of select="." /> </xsl:element> </xsl:template> </xsl:stylesheet> ・フレーム定義htmlファイル（index.html） <frameset cols="50%,50%"> <frame src="left.html" name="left"> <frame src="right.html" name="right"> </frameset> ・フレーム左側htmlファイル（left.html） <script language="JavaScript"> <!-- var XmlFile = "list.xml" ; var XslFile = "list.xsl" ; var xmldoc ; // XML DOM オブジェクト // XMLファイル読込 xmldoc = new ActiveXObject("Microsoft.XMLDOM") ; xmldoc.async = false ; xmldoc.load(XmlFile) ; // XSLファイル読込 xsldoc = new ActiveXObject("Microsoft.XMLDOM") ; xsldoc.async = false ; xsldoc.load(XslFile) ; document.write(xmldoc.transformNode(xsldoc)); //--> </script> ・フレーム右側htmlファイル（right.html） <html> <body> <center> <form name="F2"> <input type="text" name="txtKekka"> </form> </center> </body> <html> ・Javascriptファイル（select.js） function SelectList(p) { parent.right.F2.txtKekka.value = p ; } index.htmlをダブルクリックして起動してみてください
#1さんの補足で XMLファイル <?xml version="1.0" encoding="utf-8" ?> <item name="jikou"> <text>==================================================== <break />　日　程：2004年03月28日(日) <break />　　※変更となっております。 <break />=================================== </text> </item> XSLファイル <?xml version="1.0" encoding="utf-8" ?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="html" encoding="Shift_JIS" indent="yes"/> <!-- 文書全体のテンプレートルール --> <xsl:template match="/"> <html> <body> <xsl:apply-templates select="item" /> </body> </html> </xsl:template> <!-- <item>のテンプレートルール --> <xsl:template match="item"> <xsl:apply-templates select="text" /> </xsl:template> <!-- <text>のテンプレートルール --> <xsl:template match="text"> <xsl:apply-templates select="node()" /> </xsl:template> <!-- <break>のテンプレートルール --> <xsl:template match="break"><br /></xsl:template> </xsl:stylesheet> XML宣言のencodingは実際のファイルの保存するコードに 書き換えてください。 なお、#2さんテキスト修飾用のタグ？についても 「再帰呼び出し」という方法を使用することで可能です。 例えば、上記XMLの＜break />の変わりに改行コードを <BR>に変換したい場合などに使用します。
#2です。 もう少し正確に書くと、ブラウザによるのは、ＨＴＴＰの場合です。 ですから、ＸＭＬへのリンクをftpにしておけば、多分うまくいきます。 （もちろん、ＸＭＬファイルは、ＦＴＰサーバーになければなりません。） ただその場合、ｆｔｐサーバーを公開する必要がありますし、 公開しながら書き込みを禁止にできるのかなどの問題があります。 残念ながら、私はその辺は詳しくないのでお答えはできません。 他には、ダウンロードした後に拡張子を変えるとかですかねえ。
Webサービスクライアントの開発ですね。 Java, VB.NET, C#等で行います。 .NETで開発するのであれば、こんな感じです。 http://www.microsoft.com/japan/msdn/vs/webapplication/vbtchAccessingGooglewithVB.asp http://www.atmarkit.co.jp/fdotnet/netdict/netdict002/netdict002_01.html VS.NETという開発ツールを使うとクラスとして扱えます。
>eXtyleをつかいHTML化しています eXtyleというソフトは、 (1)元となるファイル(XMLファイル)に ↓ (2)スタイルシート(XSLTファイル)を適用し ↓ (3)お好きなファイル(HTMLファイルなど。それ以外でもよい)を出力 するソフト。 つまり、たとえば HTMLファイルを出力したい場合は そのための「XSLTファイル」が必要であるし、 また、たとえば XHTMLファイルを出力したい場合は そのための「XSLTファイル」が必要。 つまり、「XSLTファイル」というやつを、 あなたの好きに取り変えたり、書き変えたりすればよい。 XSLTファイル次第ってこと。 -------------------- XSLTの書法(書き方)はご存知なのかな？ HTMLファイル出力用のXSLTが自力で書けるならば、 あとは「XHTMLの記述法」を知ってさえいれば、 XHTMLファイル出力用のXSLTもすんなり書けると思うよ。 (検索キーワード：XML XHTML XSLT サンプル) ■XHTMを出力するためのXSLTサンプル： http://frog.raindrop.jp/knowledge/archives/000100.html http://msugai.fc2web.com/java/XML/XSLTelements.html http://www.atmarkit.co.jp/fxml/tanpatsu/xslt/xslt06.html ■XHTMLの記法入門 http://tohoho.wakusei.ne.jp/ex/xhtml.htm http://www.cityfujisawa.ne.jp/~yanai/xml/struct/step3.html http://www.cityfujisawa.ne.jp/~yanai/xml/struct/step2.html -------------------- つまり、 >HTMLでなくXHTMLにするにはDTDを付け加えれば出来てしまうということなのですか？ そうではなく、 XHTMLを出力したいのであれば、(スタイルシートである)XSLTファイルを XHTML専用のものに変える必要があるということ。 そして基本的にはそれは自力で書く必要がある。
グーグル http://www.google.com/ で、キーワード "Microsoft XML notepad" を指定して検索して、 海外のサイトから見つけるよりほかないかな？ ~~~~~~~~~~~~~~~
使える文字： 　半角英数*（下記注）漢字　ひらがな　カタカナ　アンダースコア　:（コロン）** *半角数字は先頭で使えない ** :（コロン）は名前空間で記述されるため、避ける 使えないもの： 　半角カタカナ 　全角英数字 　<xml は予約語で利用不可（XML xMl など大小文字のいかなる組み合わせも同じ） ２文字目以降は、エクステンダー（文字間に使用されるーなど）、結合文字（アクセント記号）、ピリオド(.)、ハイフン(-) ＜＞　＆など（実際には半角）は、表記したい場合は実体参照を利用（＆ｌｔ；　＆ｇｔ；　＆ａｍｐ；　など　）
XSLファイルは、XMLの変換ルールを記述した 『テキストファイル』です。 XSLの<xsl:output>で、method="text"とすればＯＫです。拡張子が気になるのであれば、xx.xslとすればＯＫでしょう。 ちなみに、XMLやXSLはテキストファイルで、 XSLで出力できる形式はテキストとHTMLです。
異なるアプリケーション間のデータ交換用として注目されています。特にインターネットを利用したB2B取引上で異なる基幹データベースシステムを採用している企業同士で、それぞれのシステムを更新する事なくデータの整合性を保つためにXMLを使おうと言う動きが有ります。 そのためには各システム上で共通化されたのメタデータを定義しないと行けない訳でそこが問題になっています。 質問で、書かれている例は、XSQLとかを見ると面白いかもしれません↓
こんにちは。 dir要素とfile要素は不規則に現れるんですよね！？ どちらにしても次のでいいんじゃないでしょうか？ ・//dir[not(dir)] ・//dir[dir]
んー。問題が漠然としすぎていて何とも…。 まず、質問の題が「XMLとUMLの相違点」となっていますが、 この二つは「国語」と「数学」ぐらいに違いがあります。 「ソフトウェア技術」という点では共通しますが、 使用場面も目的も違い、「比べる」という作業ができないものです。 まあ、問題を出す側ではそれをわかっていて、単に、 「この二つについてレポートを書け」ということなのかもしれません。 ただ、一番の「環境」(ビジネス)というのはどういう事なのでしょうか？ 環境ビジネスのこと？　環境としてのビジネス？ よくわかりません。 UMLもXMLも、原理は簡単です。 極端に言えば、UMLは「絵の描き方」、XMLは「書類の書き方」であり、 小学生にもできるものです。 ここはやはり、UMLとXMLについての入門書を買って勉強した方が、 遠回りのようでいちばん手っ取り早いと思う… …と、その友人にお伝えください。 ネットなら、UMLは「UML　オブジェクト指向」で調べるといろいろ出てくると思います。 XMLについてはわかりません。
　全く初めてなら、まずこちらなんかいかがですか？ 　　　　　　　　　　　　↓
試していないのでなんともいえませんが参考URLにいれたGalatea ProjectのGalatea ToolkitのLinux版ではVoiceXML による対話記述が可能のようです。これを利用してデモできませんかね。他商用製品もあるらしいですがちょっとわかりません。 http://hil.t.u-tokyo.ac.jp/~galatea/galatea-jp.html それとhttp://www.egroups.co.jp/の方にvoicexml-jpがありますので質問したりログを参照してみてもいいかもしれません。他参考になりそうなURLを以下にあげておきます。 http://www.voizi.net/voizies/index.html http://www.zdnet.co.jp/news/0107/23/e_voice_m.html
両方の条件を満たすものを検索するなら， <xsl:when test="@エリア='新宿' and スープ='醤油'"> で OK です。 少なくとも一方の条件を満たすものを検索するなら， <xsl:when test="@エリア='新宿' or スープ='醤油'"> です。
ＨＴＭＬ等は、プログラム言語ではありません。 文章表現をするための言語です。 それに、プログラミング言語に不可欠な繰り返しや分岐などもありませんから。
XMLの中のRDFでは？ RDFという形で利用するXMLということかと。
●ＸＭＬのソース 　<解説> 　　　用語の説明。詳しくはリストを参照のこと。 　</解説> ↓ ●ＸＭＬのソース 　<解説> 　　　用語の説明。詳しくは<link url="http://www.hoge.org/hoge.html">リスト</link>を参照のこと。 　</解説> のようにしておき、 表示するというのであれば、 XSLTを利用したり、ブラウザならPHPなどを通す必要があるかと。
時間差回答ですが..。 私は参考URLのサイトをよく利用していました。simple-useとadvanced-useに分かれているので，順を追って学ぶには良いのではないでしょうか？ ただちょっと情報屋向きかもしれません。
<a />は、<a></a>と等しいから、 あ）は、<a></a> い）は、<a></a><b></b> ――というところだからでは。
http://www.cityfujisawa.ne.jp/~yanai/xml/struct/home.html このサイトは、やさしいですよ。
↓参考になれば、、、
私は、XMLって何？って感じなのですが、 興味があって調べてみました。 http://www.microsoft.com/downloads/details.aspx?displaylang=ja&familyid=3144b72b-b4f2-46da-b4b6-c5d7485f2b42 ここを見る感じでは、CEは入っていないようなのですが・・・。 見るところ違ってましたかね？ まとを外していたらごめんなさい。
印刷・出版業界で > 「大手電機部品メーカーなど大量の部品を扱っている > 企業に、マニュアル等をデータベース化し管理します。 > 膨大なデータから、印刷したいリストののみを簡単に > 検索できます！修正なんかも楽々です！」 というと、Content Management System (CMS) や Digital Asset Management (DAM) を利用した、"one source, multi use" の実現を指すのではないでしょうか？ コンテンツ（テキスト、画像、音声等）をデータベース化して管理し、必要に応じてそれらを組み合わせ、出力するというのが、最近の印刷出版業界のディジタル化の流れだと思います。 例えば、印刷用、Web用、放送用といった異なるメディア向けの作品を、同一の素材の組み合わせを変えるだけで出力できる、というようなことです。 これらを実現するためのシステムのデータ形式として、特に重要なのが、supercalさんも触れられているXMLです。 XMLはもともと、主に出版業界向けに文書構造の統一的フォーマットとして制定・利用されていたSGMLをもとにして、複雑すぎる部分を排除し、かつWebへの対応を考慮して制定されたフォーマットですから、もともと出版印刷業界との親和性は高いのです。 ただ、supercalさんが書かれているようなことをやりたいのであれば、XMLデータベースだけでは難しく、冒頭に挙げたDAMやCMSが必要になってくると思います。 これらのシステムとして有名な製品としては、CumulusとかAdobe Document Serverとかがあるようですが、詳しいことはよく知りません。この↓ http://www.atmarkit.co.jp/fbiz/reference/software/cms.html ページで関連製品のリストを扱っているようです。 またXMLデータベースと整形ツールを組み合わせて、DAM/CMS的なものを自前で組み上げることも不可能ではないでしょう。 いずれにせよ、「Content Management System (CMS, コンテンツ管理システム)」「Digital Asset Management (DAM, ディジタル資産管理)」などをキーワードに、業界内で情報収集されてはいかがでしょうか？
そもそも、 具体的な店名をタグの名前にしてしまっているのがおかしいですね。 以下のようにしては？ (もしくは、店名を電気店の属性にする) <電気店リスト> 　<電気店> 　　<店名>K&apos;電気</店名> 　</電気店> 　<電気店> 　　<店名>小島電気</店名> 　</電気店> </電気店リスト>
ご存知かもしれませんが、 とりあえず＠ITにあったリンク集を。。。
最も最適なサイトだと思います。 http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/htm/sdk_intro_6g53.asp http://www.microsoft.com/japan/msdn/xml/default.asp
ここがとりあえず初心者向けなやさしい解説をしています。ごらん下さい。 http://www.cityfujisawa.ne.jp/~yanai/xml/intro/step2.html HTMLとXMLの大きな違いは、XMLはタグを自由に自分で好きなようにつけられるところです。HTMLの決ったタグに縛られることがないのです。じゃ～、HTMLのように表示しないんじゃない？って思いますよね？実は、好きなタグは、別にHTMLではどんなスタイルにするかという定義を自分でしてあげるんです。だから、HTMLとXMLとは全く別物というわけではありません。これは、HTMLでは表現しにくい部分や冗長な部分など簡素化できるメリットがあります。その他、いろいろな拡張がXMLでされています。 じっくり勉強してみてください。
一年ぐらい前から、私が作るプログラムでは内部のデータ構造はＸＭＬで全部やってます。 もはや、欠かせません。 以前であれば Collection クラスをいくつも積み重ねて実装していたような複雑な データ構造がＸＭＬのツリー構造に一元化できるのが便利です。 ちなみにJAVAでJDOMを使ってますが、JavaでなくてもＸＭＬは使うと思います。
保護は ＶＢのマクロのプロジェクト単位でかけます。 そのプロジェクトを選択し、右クリックでなんたらのプロジェクトプロパティを選択します。 それで 保護をクリックし、プロジェクトのロックに チェックを入れて、それからパスワードを入れてください。
Javaでxalanを利用する方法もありますね。 コマンドは以下のような感じになります。 % java org.apache.xalan.xslt.Process -in hello.xml -xsl hello.xsl -out out.html 参考URLのリンクにある「今日から始めるXSLT入門」が参考になるかと思います。
ドキュメントやチュートリアルもネット上に豊富にありますし私も翔泳社の赤本(CSS)と青本(HTML)を一応持ってますがあまり見ませんね。 >ＣＳＳの本を買うにあたって、気をつけること、 またどんな本（？）が初心者にはわかりやすいか、 これはズバリあなたが読んで「これならわかりそうだ」と思う本を購入し勉強されることです。 急ぐ気持ちはわかりますがHTMLをまず覚えてからCSSを覚える…というように順を追う方がよいでしょう。 HTMLをだいたい覚えてレイアウトに懲りたくなってきたらCSSの学習を始めてよいと思います。 時にHTMLで書体を太字にする方法とCSSでする方法があるように重複するような内容がありますがHTMLを先に覚えておくと何故CSSでやるのがよいのか、など先にHTMLを覚えておくことでCSSの学習が促進されます。
◎日本気象協会、ウェザーニュース http://www.jwa.or.jp/ 日本で気象データを提供している二大ベンダーは、気象協会とウェザーニュース社です。 しかし２社（法人）とも、この世界では唯二無比(?)のトップブランドであることから、 社内利用とはいえ、予報データを二次利用する契約となると、かなり高額の契約料になると予想されます。 ◎HBCウェザーセンター http://www.hbc.co.jp/weather/index.html 国内で唯一、独自の気象予報（オリジナルの観測気象データは気象庁ですが）をしているＴＶ局がＨＢＣ（北海道放送）で、局の気象予報士が作る独自のきめの細かい予報を配信することで、その世界では有名です。 組織が小さい分、契約などフレキシブルに対応してくれそうな気がします。 ◎国土環境株式会社 http://www.metocean.co.jp/weather/ もう一つ、独自予報を提供している会社です。 ここはまだあまり名前は知られていませんが、予報精度は悪くないと思います。
こんにちは。 直接回答ではないですが、nsgmlsのsxは使わないのですか？ ただSGML->XMLの変換だとしたら、あれでも結構つかえるかと。
> これらすべてを合わせてDTDと呼べばいいのでしょうか？ DTDは"Document Type Definition"つまり文書型定義の略なので、文書型宣言にDTD(=文書型定義)が含まれるという認識で良いと思います。 > 文書型定義はたいてい一行で、それ以下の外部エンティティ参照のほうが行数が増えるのでしょうか？ これは、書き方しだいです。ただ、外部にDTDを記述しておいてそれを参照するだけならば、その場所には確かに短い記述だけになります。 > 整形式だとこの、文書型宣言、文書型定義と、XML宣言が省略できるということでしょうか。 まず、XML宣言については、検証済み文書であっても省略できます。ただし、UTF-8またはUTF-16以外のencodingを使う場合、省略しない方が良いです(厳密には省略できる場合もありますが、その方が無難)。 文書型宣言および文書型定義については、整形式であっても属性のデフォルト値やエンティティ宣言を記述する場合がありますが、それらが必要なければ省略できます。
#1の方のおっしゃられるとおり、これだけの内容では判断しにくいのですが、何かに必要なファイルがUTF-8でなければならないと仮定して話を進めます(もし違っていたら、補足して下さい)。 まずエンコーディングについて、ここでは、以下にあるような意味です。 http://www.atmarkit.co.jp/aig/01xml/encode.html もう少し分かりやすく要約すると、文字をコンピュータで扱えるようにコード(数値)を割り振ることです。 この割り当て方にはいくつかの種類があり、WindowsではShift_JISが、UNIX系ではEUCが一般的に使われます。UTF-8もその1つです。 例えばWindowsで普通にファイルを作ると、エンコーディングはShift_JISになっているので、それを変換する必要があります。 Windows 2000またはXPならば、メモ帳でファイルを開いてから、「名前を付けて保存」でUTF-8を選ぶことで変換できます(Windows NTはどうだったか忘れてしまいました)。 それ以外の場合、他のテキストエディタで変換する必要があります。例えばWindowsならば、参考URLにあるTeraPadで開いてから、「漢字/改行コード指定保存」でできます。 さらに、そのファイルがXMLファイルであって、先頭に以下のような記述がある場合、 <?xml version="1.0" encoding="Shift_JIS"?> 以下のように正しい記述に直す必要があります。 <?xml version="1.0" encoding="UTF-8"?> (参考) 本当は、UTF-8の場合は、encoding="UTF-8"を省略しても構いません
なるほど。補足していただいた説明で、質問の意味は分かりました。 XSLTの仕様上は、xsl:stylesheetの子要素としてxsl:param要素を置いた場合、そこから後ろのxsl:templateでは参照できるはずです。 そこで、以下のような短いXSLTスタイルシートを用意して、 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> <xsl:param name="n" select="test"/> <xsl:template match="abc[@attr=$n]"> <xsl:value-of select="."/> </xsl:template> <xsl:template match="@* | text()"></xsl:template> </xsl:stylesheet> 以下のXMLファイルに適用してみたところ、 <data> <abc attr="test1">item1</abc> <abc attr="test">item2</abc> <abc attr="test2">item3</abc> </data> Xalanでは正しく item2 と出力されました。 しかしXTでは、何も出力されず、XTのオプションで n=test のようにパラメータを設定すると、正しく出力されました。 私の解釈では、Xalanの動作の方が正しいような気がします。 したがって、もしXTを使っているならば、この実装上の違いが原因かと思われます。 この場合、XTの作者に直してもらうか、Xalanなど別のXSLTプロセッサを使うしか、解決方法はないかもしれません。
SGML や XML は文書を構造化するための言語です。 HTML をご存知ならそれを考えると一番わかりやすいと思います。 ごく簡単にいうと、文書はタイトルや見出し、章、段落といった要素で、 「構造化」されているわけです。それをタグ付けにより明確にするのが HTML です。 XML はそれよりももっと汎用性のある構造化言語で、 構造を自分で決めることができます。 そのため、新しいデータの形式として認識されているわけです。 たとえば、社員名簿を XML 形式で作りたいとすると、 <社員名簿> <社員> <名前>だれだれ</名前> <部署>どこどこ</部署> <住所>...</住所> <電話>...</電話> </社員> <社員> <名前>... ... </社員> </社員名簿> のような形式が考えられるわけです。ここで <> でくくってある部分をタグといいます。 この形式をとることで、データを階層的に構造化させることができ、 扱いが楽になります。 以下に、初心者向けに XML, XHTML などを わかりやすく解説したウェブサイトを挙げておきます。 参考になれば幸いです。
XMLでデータ交換することには、利点と欠点があります。 利点としては、それがスタンダードであるということです。 XML化するということは、簡単に言えば、データを 標準フォーマットで記述する、ということです。 たとえば、仮に文書はWordで書くのが「標準」である、 と決まったとすると、Wordの文書は誰もが開けることになります。 このとき、ナイアガラとかマイナーな（？）ソフトで 書いた文書は、別の文書と統合できませんが、 Word形式に改めれば、誰の文書とでも統合が可能になります。 XML化するとは、このたとえで言う、Word形式にする、 ということと同じ事です。 つまり、重要なのは、XMLがスタンダードである （スタンダードたりえた）ということなのです。 また、同時に欠点もあります。 欠点としては、タグなどをやたらとつけなくては いけないので、データが冗長になること。それから、 仕様もツール類も「枯れて」いないので、いろいろ 覚えたり、試行錯誤するのが面倒なこと。 勉強するのに書籍代がかさむこと。 英語のドキュメントが読まなくちゃいけないケースが 増えること。結局プログラマに苦労のしわ寄せが来ている ような気がすること。その他いろいろ。 しかし、 欠点より利点が勝っているために、XMLWebサービスは 現在、騒がれているわけです。 基本的にWebサービスが想定しているのは、インターネットの ようなグローバルな環境で、データ交換を行うことです。 そのためには、XMLのようなスタンダードなフォーマットを 採用する必要があったわけです。 グローバルな環境を想定せずに、 単に「異なるプラットフォーム上のアプリケーションを統合する」 という視点からでは、XMLが採用されねばならない理由は とても小さくなります。 スタンダードなフォーマットでなくても管理できてしまう場合も 多いからです。 もっとも、そういう場合であってもXML化しておけば、 後々役立ちそうというホケンになるという考え方もありますが。
HTML TransitionalやXHTML 1.0ではform要素の内容としてブロック要素とインライン要素両方置けますが、HTML StrictやXHTML 1.1ではインライン要素を置けません。(img要素はインライン要素) Strictを指定してたりしませんか？ 一般的な話として、トラブルを避けるため、なるべくStrictでも通用するように記述することをお奨めします。div要素の中にimg要素を置くだけですので。 見当違いな回答だったら、すみません。
> これで、ブラウザで確認するとテキストノードに［］がついて表示されて > しまいます。 それは、以下の行に原因があるのでしょう。 > if(nodeScan.hasChildNodes()) al.add(scanEach >　　　　　　　　　(nodeScan.getChildNodes())) ; scanEach() の返り値は ArrayList ですから、ArrayList に ArrayList を追加していることになります。 ArrayList#addAll() メソッドを使いましょう。 if(nodeScan.hasChildNodes()) { 　　al.addAll(scanEach(nodeScan.getChildNodes())); } ＃ 確認してません　(^^;
回答というよりもアドバイスですが、おそらく > replaceChildメソッドだと、「既存のノード」しか > 置き換えれなくて文字列が指定できません。 というところが勘違いの元で、要素の内容のテキストは、その要素ノードの子供にあたるテキストノードとして(DOMでは)表されます。試しに、テキストだけを内容とする要素ノードに対してgetFirstChild()を呼び出してみると、そのテキストノードが得られるはずです。 したがって、No.1の方が回答なさっているようにそのテキストノードを別のテキストノードで置き換えてもよいですし、replaceChildにこだわらなければ、そのテキストノードに対して直接CharacterData#setData()を使ってテキストの文字列だけ書き換えてもよいです。 この手の話は、XML自体の仕様というよりはDOMの仕様なので、参考URLなどでDOMの概念的なことだけでも抑えておくことをお奨めします。
一番楽なのは、Internet Explorerを6にバージョンアップすることです。 それ以外の方法として、代表的な方法を紹介しておきます。いずれも無料です。 (1) Microsoftのparserにこだわる場合 http://msdn.microsoft.com/xml/ のページの右上"MSXML 3.0 SP 2"というのがあるので、そこからたどってダウンロード・インストールして下さい。(これを書いている時点での話ですので、もしページ構成が変わっていたら、"MSXML Parser"などで検索してみて下さい。 (2) Javaの実行環境が整っている(もしくは整えるのが面倒でない)場合 http://xml.apache.org/xalan-j/index.html からたどって、Xalanを使いましょう。 代わりに、http://www.blnz.com/xt/index.html にあるXTを使ってもよいと思います。 IE6をインストールするか(1)の方法をとる場合、ブラウザで直接表示できるので、プログラマでなければ使いやすいと感じるかもしれません。ご質問の主旨に一番合いそうですし。しかし、IE6のインストールもMSXML 3.0のインストールも、トラブルが起こらない保証はないので、自己責任でお願いします。 XalanやXTを使う場合には、直接表示するのではなく、HTMLファイルに変換して、それをブラウザで表示します。したがって、ブラウザが今のままでも問題なく表示できますが、変換する手間があります。また、Javaの実行環境を整える必要があります。 あなたの好みや状況によって、選んで下さい。
#1です。 ＞この方法だと、例えば「ルート要素の２番目の子ノードのそのまた子ノードの情報を全て取り出す」とか指定したりできるのでしょうか？？ Beanにしているから簡単にできます。 Beanでしなければ、毎回、長々とコーディングしなければならなくなり、後から見れば、何をさせているかわからなくなります。 JSPでBeanを使う場合、ディレクティブの次に、 <jsp:useBean id="lbn" class="jp.co.sei.system.izumi.bean_list" scope="page" /> のような、Beanが使えるように記述を行います。 この例の場合、簡単に言えば、jp.co.sei.system.izumi.bean_listを、このJSPでは、lbnと省略？させる事を唄っています。 で、、 DOMParser prs = new DOMParser(); FileReader fr = new FileReader(application.getRealPath(xml_path)); BufferedReader br = new BufferedReader(fr); InputSource src = new InputSource(br); prs.parse(src); Document objDoc = prs.getDocument(); と、Rootになる、Documentオブジェクトだけを先にJSPに処理させておけば、 後は、Beanを呼び出して、「何階層目の、Nodeのさらに次のNodeの情報がほしい」と簡潔に指定するようにします。 例えば、 <?xml version="1.0" encoding="Shift_JIS"?> <listsadm> 　　<member id="1"> 　　　　<subject>システムXXXX</subject> 　　　　<path>/section/sysgi/listsinf.xml</path> 　　　　<cmt>XXXX技術部　CSVファイルリスト</cmt> 　　　　<usr>listsadm</usr> 　　　　<datapath>D:/WEBDATA/zikkenn</datapath> 　　</member> 　　<member id="2"> 　　　　<subject>XXXXXグループ</subject> 　　　　<path>/section/zikai/listsinf.xml</path> (1)→　　<cmt>TEST</cmt> 　　　　<usr>listsadm</usr> 　　　　<datapath>D:/WEBDATA/zikkenn</datapath> 　　</member> </listsadm> のようなファイルから、(1)のTESTを呼び出すには、 Beanの public Node xmlObjNod2(Document objDoc, int intItem0, int intItem1){ Node objNod2 = xmlClnNod2(objDoc, intItem0).item(intItem1); return objNod2; } をJSPから、 lbn.nmlObjNod2(objDoc,1,2).getValue() （ご存知とは思いますが、カウントは０から始まります。） で、StringでTESTを返してきますよ。 全てほしいなら、 for(int n=0, n<lbn.xmlClnNod2(objDoc, iln).getLength(); n++ ){ out.println(lbn.nmlObjNod2(objDoc,1,n).getValue()); } のようにすれば、lbn.xmlClnNod2がNodeListを返すように成っているので、このgetlength()分くるくる回せば、取得できますよ。
通常は、Javaの環境が問題なくインストールできていれば、Windows 98でも問題なく使えるはずだと思います(Windows 98だからJAXPが使えないという事態に遭遇したことはありません)ので、"XML Pack"をダウンロードして使えばよいと思います。 以下は、参考のための蛇足です。 JAXPは、parserの名前ではなく、JavaからXMLにアクセスするためのインターフェイスにすぎません。つまり、JAXPをimplementしているparserならば、差し替えて使うことができます。 JAXPに準拠したparserは、Apacheの最新のXercesを使った方が良いと思います。http://xml.apache.org/xerces2-j/ からだどれるので、最新版(現時点ではXerces-J-bin.2.2.1.zip, 4.7MB)をダウンロードして展開します。 ちなみに、参照URLからだと、他とパックになっていない旧版のparserが入手できますが、JAXP 1.0.1をimplementしたもののようです。もし、Sunのページから入手することにこだわって、余計なパックになっていないものがよければ、そちらをどうぞ。 また、No.1の方が回答されているように、Java SDK 1.4を入れると、JAXPに準拠したparserが標準で入っています。ただ私は、妙なバグっぽい動作を見つけてしまって、それ以来信用できずに、1.4を使っているにもかかわらずXercesをダウンロードして使っています。
No.1の補足というか訂正です。 userconfig.xml(userconfig-ja.xml)で指定された相対パスは、このファイルの位置を基準とするのではなく、current directoryを基準とするようです。訂正します。 この仕組みでは扱いにくい気がするので、絶対パスで指定しておいた方が良いかもしれません。
答えは「Yes」と「No」です：） XMLファイルをHTMLみたいに表示する、ということは、一般的には、XMLファイルを元にHTMLファイルに変換、変更するということです。　この変換の手段をXSLT（eXtensible Stylesheet Language Transformation)といいます。 ここでは、とくに"Transformation"（変換）がポイントとなります。 この「変換」を何を用いって行うかが、ご質問だと思います。　通常は、"XSLTプロセッサー"の類のソフトを使います（例：XMLをプロセスしてHTML変換する）。　Xalanはそのなかの一ソフトです。　他にもプロセッサーはありますが、コマンドライン処理でいいのか、それともプログラム言語を使っておこなうのか（Javaなど）によって、どのプロセッサーがいいのかが決まってきます（ちなみに、英語のサイトではありますが、プロセッサー一覧がリストされているサイトを参考URLにつけておきました）。 ただし、この「変換処理」は、通常２ステップで行います。　(1)XMLを読み込み、各パーツに区分けする（parsing: パーシング）、(2)読み組んだものを変換する（processor: プロセッサー）。　ですので、このパーシングする「パーサー」というソフトも必用となります。　Javaですと一般的には、Xercesというものが使われます。 最後に、JAXPの位置づけですが、今説明したとおり、パーサーもプロセッサーも何種類かあり、必ずしも同じ構文を使ってプログラムできるわけではありません（バージョンによって機能も違います）。　ただ、プログラマーとしては、パーサーが変わったから構文も変えなくてはいけないとなると、大変ですよね。　そこで、JAXPは、下のレベルで実装されているパーサー及びプロセッサーの上に「かぶさる」APIで、常に同じAPIのインターフェースをプログラマーに提供します。ようするに、プログラムを変えなくても、パーサーとプロセッサーをプラグ・アンド・プレイできるということです（対象となるソフトは、JAXPと互換性がある必用があります）。 長くなりましたが、「Xalan等は必用なくHTMLみたいに表示することは可能か」ですが、Javaなどをご利用になるのでしたら、必要ですね。 ただし、今ですと、IEの6以降は、パーサーとプロセッサー機能を組み込んでいるので、XML文にXSLを指定すれば、変換もしてくれます（IEの5くらいから一部サポートがありましたが、チョット不安定です）。　ちなみに、IEもパーサーが必要で、XML Parser 3.0というのが一緒に配布されています。 Hope that helps. -mp
沢山あります。で、どれがいいのかは自分で使ってみるしかないですね。無料ですし（笑 http://www.so-net.ne.jp/download/win/net/htmledit/xml/
No.2で回答した者です。 とりあえず、java.net.MalformedURLException: no protocol: book.xslとメッセージが出ているのだから、XSLTの書き方を疑うよりも、URL(つまりパス)を疑うべきだと思います。 以下の実験をしてみたところ、同じエラーが出ました。 (1) 問題なく動作するXSLTスタイルシートを用意 (2) 日本語の名前の付いたフォルダを作り、そこにファイルを入れてみる (3) Xalanを呼び出す 日本語の名前の付いたフォルダに直接含まれていなくても、パスの途中に日本語の名前のフォルダがある(「デスクトップ」とか)とエラーになるようです。 したがって、パスの途中に日本語の名前のフォルダがないかどうか、チェックしてみて下さい。 ちなみに私は、日本語名や空白を含んだ名前のフォルダがパスに含まれない位置に、ファイルやツールをなるべく置くようにしています。コンピュータを使う場合の心がけのようなものです。
XML→PDF出力は私もやったことがあります。 いちばん簡単なのはJakartaにあるCocoon2を使うことです。 これが出た手の頃、私は英文のドキュメントを読みながらサンプルをいじって理解しました。 Cocoon2というのは単なるservetでして、これにXMLとXSLTを食わせるとHTMLでもPDFでもラスタ画像でもなんでも変換してくれます。 SVGでグラフも簡単に描けます。 もちろんノーコーディングでです。 最近日本語の書籍でこの解説書が出ました。ご参考までにどうぞ。 http://www.src-j.com/book_no/173.htm あと、Cocoon2に含まれているFOPも単独で使うことができます。PDF生成しか考えていないならまずこのサンプルをコマンドラインで使って体感すると便利さがわかります。 ただしFOPには一つ問題があります。 Javaの中にFOPシェルを実行できるようにするとになり、バックエンドで動作しますので、PDF生成タイミングを検知できません。（勿論PDFをただ作ってどこかのディレクトリに置くだけが目的ならいいのですが） 次のように実行します。 Runtime rt = Runtime.getRuntime(); Process proc = rt.("XX.sh")　←　XX.shの中はFOP.shの中を適宜書換えてパスが通ったところに置いてください。 もしこれで上手く生成できない場合はまたご質問ください。
んー、XMLはデータそのものなので、HTMLでのようなブラウザ表示を求めるとすれば、XSLTやDOMで整形することが必要になるのではないでしょうか？ それともXHTMLでの表記方法ということを尋ねられているのでしょうか？もしそうであれば、 <input type="text" value="xx"/> と、XML的にきちんと閉じてあげるのがXHTML的な書き方だとは思うのですが・・・。 参照１）XHTMLについて http://www.exln.co.jp/xmlinfo/index.html 参照２）XSLTによる XML -> HTML変換 http://www.atmarkit.co.jp/fxml/rensai/rexml07/rexml07.html http://www.atmarkit.co.jp/fxml/tanpatsu/xslt/xslt01.html
XML Schemaには、"Schema for Schemas"というものがあります。これはまさに、XML Schema文書自体がXML Schemaとして正しいかどうかをvalidationするためのスキーマ文書です。 これは、仕様書(XML Schema Part 1)にも添付されてますが、 http://www.w3.org/2001/XMLSchema.xsd にあります。 これを使って、スキーマ文書のxsd:schema要素で xsi:schemaLocation="http://www.w3.org/2001/XMLSchema http://www.w3.org/2001/XMLSchema.xsd" とすれば良いはずです。 しかし、試してみたところ、Xerces-Java 2.2.0では、エラーが出て失敗しました。これは、"Schema for Schemas"が通常のスキーマ文書と異なって自己言及的であるためで、Xercesは特別に扱ってくれないようです。 対処方法としては、一応以下の2通りでしょうか。 (1) Xerces以外で探す W3CのXSVというXML Schema Validatorがあるのですが、http://www.w3.org/2001/03/webdata/xsvにあるウェブ版で試してみたところ、ちゃんとうまくvaidationしてくれました。ローカル版もあります(参考URLからたどって下さい)。 (2) XMLSchema.xsdをローカルにコピーして変更を加えたものでvalidationする anySimpleTypeから派生している型の宣言をコメントアウトすると、うまくvalidationできるようになりました。ちなみに、XMLSchema.dtdを探しにいってしまうので、DOCTYPE宣言もコメントアウトしておいた方が楽です。 Xercesで"Schema for Schemas"を使ったvalidationをするモードみたいなものがきっとあるはずと思っていろいろ探したことがあったのですが、見つけることができていません。
XML 1.0では、validationしないプロセッサのDTDに対する動作に関して、以下のような記述があります。(5.1 Validating and Non-Validating Processorsより) Non-validating processors are required to check only the document entity, including the entire internal DTD subset, for well-formedness. つまり、internal DTD subsetの中ならば、validationしなくてもデフォルト値などは使わなければならず、externalの中ならば必須ではない(もしかしたらやってくれる場合もあるかもしれないのですが)、ということになります。 一方、XML Schemaの具体的な記述は見つかりませんでしたが(なにしろ量が多いので)、デフォルト値のような情報追加について、以下のような記述があります。 (2.3 Constraints and Validation Rulesの、Schema Information Set Contributionの定義より) Augmentations to post-schema-validation infosets expressed by schema components, which follow as a consequence of validation and/or assessment. これを読む限り、validationを行なわないとデフォルト値は追加されないように読めます。 XML Schemaを使いつつ、validationしない時にデフォルト値だけは埋めたい場合には、デフォルト値を与える宣言だけを記述したinternal DTD subsetと組み合わせるしかないかもしれません。冗長になりますが。 ※載せた英文は、以下の2つのURLから引用しました。 http://www.w3.org/TR/2000/REC-xml-20001006 　　　XML 1.0(Second Edition) http://www.w3.org/TR/2001/REC-xmlschema-1-20010502 　　　XML Schema Part 1: Structures
エディタであれば基本的になんでもよいですが、UTF8で編集できないと問題が発生することがあります。 UTF8対応となるとどれでもよしというわけには行かなくなります。 DreamWeaverMXやXMLSpyは大丈夫だったように思いますが、XSLTやSVGの編集は必要ないのでしょうか？ その場合は上記のようなツールがあると便利でしょう。 Schemaに対応しているのはXMLSpyの方だったと思います。
Webサービスが今実現できているかどうかですが、国内では一部の系列企業間以外ではまだ利用されていません。 また殆どがJavaでして.NETによるものは大規模システムで利用されることは今後も少ないと思います。 .NETのサンプルには私は興味がないのですが、技術評論者のJAVAPressやIDGのJavaWorldにはAXISによるものやWSTKやWebSphereによるものが載っています。ただしSoapにおいてSignatureはかかりますが、Encryptionはほぼ不可能です。XKMSは当分実用にはならないのでこれでビジネストランザクションするにはSSLを使うしかありません。(現状では残念ながら) 私はいじったことはありませんが、.NETに関しての解説記事は日経BP別冊「Webサービス完全ガイド」があります。 ただし、書籍情報は基本的に古いのでMSのサイトのサンプル(URLは探せば分るでしょう)を使った方がよいのではないでしょうか？
>XMLを用いてWebページを作るということができるのでしょうか？ 出来ます。 その１）XHTMLで記述する。 XHTMLとは、HTMLをXML構文で再定義したもの、すなわちXMLです。 XHTMLで記述すれば、XMLを用いてWebページを作ることができます。 XHTMLを使用しているページですが、＃１の方も書かれていますが、 以下のページがそうです。 http://www.xmlmaster.org/ その２）XSLTを使用する。 一般的なXMLデータは、ブラウザに表示を行うためのスタイル情報 を持っていませんので、HTMLのようにブラウザに表示することは できません。 ただ、XSLTといわれる、やはりXMLで記述された言語を使用して、 元のXMLデータとXSLTで記述したスタイル情報を掛け合わすことで HTMLを生成し、ブラウザで表示することができます。 こんなとこでしょうか？
えっと… エラーメッセージを見ると xsl:stylesheet is not allowed in this position in the stylesheet! ("xsl:stylesheet"をこんなとこに書いちゃいかん)とハッキリ言っているわけなので、XSLを見直すのがまず第一じゃないかと思うんですが。 以下の環境でちょっと試してみた限りでは、"xsl:stylesheet"が２箇所記述されているような不正なXSLでないと上記エラーは出せませんでした(^^; OS:Windows98SP1 Java:1.4.0_01 Runtime Xalan:2.4.D1 (但しjarをlib/endorsedにcopy) 実行方法:コマンドラインよりjava org.apache.xalan.xslt.Processを起動 (何故 "SystemId Unknown; Line -1; Column -1;" なのかは判りませんが...。コマンドラインからだとXSLファイル名と行位置、桁位置がちゃんと表示されるので。) 環境とか実行方法とかXSLは間違ってないぞ～とかIEならちゃんと表示できるのに～とかXalan付属のサンプルはOKなのに～とかもっと書いた方がいいですよ(^^;。このエラーメッセージだけだと「XSLが間違ってます」としか答えられないので...。
ホントだ、何も表示されないですね(^^; 根拠はありませんがXMLを直接には表示出来ないような気がします。ダイアログだし(?^^;) なのでJavaScriptで表示してはいかがでしょうか。 （例） <HTML> <HEAD> <TITLE></TITLE> </HEAD> <BODY> <SCRIPT language="JavaScript"> <!-- xml = new ActiveXObject("Msxml2.DOMDocument"); xml.async = false; xml.load("～.xml"); xslt = new ActiveXObject("Msxml2.FreeThreadedDOMDocument"); xslt.async = false; xslt.load("～.xsl"); xslTemp = new ActiveXObject("Msxml2.XSLTemplate"); xslTemp.stylesheet = xslt; xslProc = xslTemp.createProcessor(); xslProc.input = xml; try { xslProc.transform; document.write(xslProc.output); } catch(e) { document.write(e.description); } //--> </SCRIPT> </BODY> </HTML>
XML関連のソフトで有名な「インフォテリア」社で XMLのラーニングシステムが始まります。 ご参考にどうぞ。 インフォテリア・プレスリリース http://www.infoteria.com/jp/news/press/pr020724.jsp XMLトレーニング http://www.infoteria.com/jp/training/
hello2?:<xsl:value-of select="parent::*/@hello" /><br /> または hello2?:<xsl:value-of select="../@hello" /><br /> です。
簡単なものは@ITに紹介されていましたね。 他にPostgreとかIBM製のものなどもあったように思いますが 忘れてしまいました。とりあえず参考にしてみてください。 SQL Server 2000を利用して、XML文書を入出力する方法 http://www.atmarkit.co.jp/fxml/tanpatsu/15mssql/mssql01.html ネイティブXMLデータベース　Xindice http://www.atmarkit.co.jp/fxml/tanpatsu/18xindice/xindice01.html
私も初心者だったころ、本には手ごろなものがなく困っていました。 そこで重宝したのが、工学研究者さんの「ゲーム作りで学ぶＸＭＬ入門」という本です。 たいしたゲームではないんですが、解説が超初心者向きで大変分かりやすかったです。その他の本は一般の業務で使う方法とかが書いてあり、素人の私には分かりませんでした。 しかし、ＸＳＬという知識を身につけると面白いホームページとかが自分で作れるようになり、勉強も進みます。そうなったら、ある程度本格的な本を呼んでも身につけることが出来るようになります。 あと、ＳＯＦＴＢＡＮＫ社の「やさしいＸＭＬ（高橋麻奈）」という本も分かりやすいです。やっていて楽しくはないですが。。。 では、がんばってください。
Xalan を使ったことがないので、よく分かりません。 検索サイトで、適当に探してみると、英語圏以外で、その問題に相当するページが 幾つか引っかかります。 よく分かりませんが、言語を英語圏 (環境変数 LANG を C に設定) にして、やって みたらどうでしょう？ Xalan のページ（→参考URL）になんかあるかも ＃ 頼りない回答で申し訳ない
質問の中で <!DOCTYPE html [ <!ENTITY nbsp " "> ]> (document element typeがhtml)と書かれているため、&nbsp;をスタイルシート内で使いたいのか、それとも出力される文書の中にentityの宣言を含めたいのか、よく分からないのですが。 もしスタイルシートの中で使いたいだけならば、FlossenEngelさんの回答のとおりで解決するはず(べき)です。XTではスタイルシートの中で&nbsp;を使えるようになることを確認できました。本当に正しい書き方をしているのにパーサがエラーを吐くならば、他のパーサを使って下さいとしか... ただ、XSLTでは(正確な書き方をすればXPathのデータモデルでは)、entity referenceの形であっても、参照される文字を入れたのとまったく同等に扱われ、entity referenceを使う代わりに半角スペースを入れてもまったく同等なので、あまり意味がないです。もちろん、他のentity referenceを考えていて、この質問では簡単のためにnbspでの例を使ったならば、私の指摘はまったくのおせっかいですが。
正しいやり方かどうかわかりませんが、参考まで... <xsl:template match="/"> <!-- root --> <xsl:for-each select="./*"> <xsl:value-of select="name()"/><br/> </xsl:for-each> <!-- top --> <xsl:for-each select="./*/*"> <xsl:text>　</xsl:text><xsl:value-of select="name()"/><br/> </xsl:for-each> <!-- second --> <xsl:for-each select="./*/*/*"> <xsl:text>　　</xsl:text><xsl:value-of select="name()"/><br/> </xsl:for-each> </xsl:template>
サーバサイドJavaの技術に、「Mailet」というのがあります。 （Javaとメールシステムとの連携のための技術のようです） これだと考えられているシステムもある程度簡単に実現できそうです。 ＃ ただし、Javaの技術を使っているのでJavaプログラマがいる必要がありますが。。。 調べてみてはいかがでしょうか。
<xsl:value-of select="//datadocument/setteivalue/*[name()=$foo]/*[name()=$bar]/text()"/> で表示できると思いますが、XMLのsitemのテキストが例示どおり改行を含んでいるのなら <xsl:variable name="foo" select="normalize-space(text())"/> とする必要があると思います。
MSXML以外はどうだか判りませんが、タブコードは で出力できます。 <xsl:text> </xsl:text><xsl:value-of select="～"/> とか。
参考URLの中をいろいろ見ればきっと見つかると思います。 「XML eXpert eXchange」 http://www.atmarkit.co.jp/fxml/
すみません、 >XSLのファイル内でJavaScriptを記述し というので勘違いしていました。 例示されているのは単にタイトルを出力しているだけなんですね(^^; JavaScriptでXMLの要素を取得操作したいのであればDOMしかないでしょう。単純な表示ならその必要はないでしょう(単に埋め込むだけ)。
　方手落ちでした。すいません。 <xsl:template match="*" name="foo"> 　あは </xsl> は、 <xsl:apply-templates select="*" name="foo" /> 　でいけたと記憶してます。 　検証をしておりませんので、間違っている可能性が ありますが、取り急ぎ。 　うまくいかなかったら、りぷらいをお願いします。
Xmethods について比較的わかりやすく説明されているページがありましたので、一度ご覧になってみてください。 「リモート・ストレージ・サービス － インターネット上のストレージをWebサービスとして使う」
同じApache XMLにあるFOP(参考URL)ならば、コマンドラインでXMLをXSLを使ってPDFを出力することが可能です。 ただし、日本語フォントを使いたい場合には、設定をしなければならなかったはずで、ドキュメントに方法が書いてあったと思います。とりあえず試してみるだけならば、まずは英数字のみを含む文書で、試してみて下さい。 Cocoonを使って...という意味でしたら、申し訳ありませんが分かりません。
<xsl:stylesheet xmlns:xsl="http://www.w3.org/TR/WD-xsl"> とありますが、これはバージョンが古いから"{","}"が使えないだけかもしれませんね。 そのままのバージョンで使うなら <xsl:element name="a"> <xsl:attribute name="href"><xsl:value-of select="@href" /></xsl:attribute> こちら </xsl:element> などとするといいようです。 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"> 私が使っているバージョンなら"{","}"は使えていますよ。
なんかすごい漠然とした質問ですけど、なぜ普及したのか「あなたの考えを聞かせてください」という意味だと解釈して、自分なりの考えを書いてみます。 XML自身がすごく画期的というわけではないが、誰もがある程度納得できる仕様になっていると思います。つまり、標準化がうまくいったと言えるのでは。 もちろん、みんなが乗っかることができる枠組みを多くの人が望んでいた、ということも背景にあると思います。 標準化が成功したおかげで、あえて別の仕様を使うメリットが薄れたのが、良い方向に向かっています。XMLに大きな不満がないんだったら、XMLを使わないメリットはないよね、という感じで。 あとは、XMLが基本的な枠組みだけであることも、普及の要因だと思います。XMLという同じ土俵の上で、要素や属性などのmarkup vocabularyの仕様に関して競争を促したことで、企業側も積極的に採用したのだと思います。 今のところ、XMLが普及することによって、XMLの関連技術も普及しやすくなり、それによってXMLのメリットが増す、というサイクルがうまく機能している感じですね。
わりと陥りやすい問題なので、もうどこかで探して解決しているかもしれませんが一応。 http://www.w3.org/TR/WD-xsl を使っているところが間違いです。 http://www.w3.org/1999/XSL/Transform に置き換えて下さい。xsl:variableを使えるようになります。 [以下、経緯を簡単に] working draftの段階で、Internet Explorerが標準化途中のものを実装したので、そのIE独自版を使いたい場合には"http://www.w3.org/TR/WD-xsl"とします。古い本などを参考にすると、これを使った例しか載っていないかもしれませんね。 最終的な仕様に基づくならば"http://www.w3.org/1999/XSL/Transform"を使わなくてはなりません。今となってはIE独自版を使うメリットはありません。 あと、IEは確かに簡単ですが、怪しげな部分もあるので(偏見？)、これからさらにいろいろ試してみる際には、XTやXalanといった類でも試してみることをお奨めします。 ついでに、何を使っているかを書いた方が回答しやすいですよ。今回のアドバイスも、IE6でないと、少し面倒な作業が必要になります。
とりあえず、どんな出力がお望みかよく分からないのですが、 ice_cream/*[position() > last() - 3] というようなXPathを使えば、最後の3つを選択することができると思うのですが。 出力結果も書いた方が、的確な回答を得やすいと思います。
こんにちわ。 もう1ヶ月以上たっているから、遅いかもしれませんが 現在私も同じような勉強をしていて、難しいことはわからないけど 質問内容を見て「私もこのレベル！！」と思ったので参加してみます。 まず、XMLってそのままではブラウザーに表示できないようです。 HTMLと違って表示機能はもっていなくて、質問に書かれていたものは 単なるデータのみのようですね。 　他に方法はたくさんあるのかもしれませんが、私の勉強したところによると XMLをブラウザーに表示する為には、他にXSLと言われるスタイルシートを 用意して、XML（データ）＋XSL（スタイルシート）の２ファイル（この場合は） を元に、XSLT(extensible Stylesheet Language Transformation)と呼ばれる 変換ツールを使って、HTMLや他の形式に変換して初めて表示できる （スタイルシートによっては、音声として聞ける）状態のファイルに なるようです。 　このXSLTというツールは、無料でダウンロードできるものが多数あるようです。 ちなみに私はApache（アパッチ）のサイトからダウンロードしました。 質問のXMLには、以下の２行と、下の１行をかぶせて、 <?xml version="1.0" encoding="Shift_JIS" ?> <PAGE> ・・・・・・・・・・・・・・・・・・・・・・ </PAGE> 別に用意するスタイルシートは以下のような感じに作るのかなぁ。。。。 <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/ 1999/XSL/Transform" version="1.0"> <xsl:output method="html" encoding="Shift_JIS"/> <xsl:template match="/"> <xsl:apply-templates/> </xsl:template> <xsl:template match="PAGE"> <HTML> <BODY> <xsl:apply-templates/> </BODY> </HTML> </xsl:template> <xsl:template match="cars"> <xsl:apply-templates/> </xsl:template> <xsl:template match="car"> <xsl:value-of select="name"/><BR/> <xsl:value-of select="price"/><BR/> </xsl:template> </xsl:stylesheet> そして、XSLTツールで変換するとHTMLができると思いますよ。 http://www.atmarkit.co.jp/fxml/tanpatsu/xslt/xslt00.html には、XMLをHTMLに変換する方法について、サンプルをもとにやり方とか 書かれています。結構参考になるので覗いてみてはいかがですか？
> 「a.dtdというファイルからではなく、文字列としてDTDの定義を > 　保持しておき、文字列とXMLデータとの妥当性をチェックする」 質問は、ばっちり理解しましたが、回答できるだけの力量がありません　(^^; 「何か知っていることがあれば」とのことなので、できる範囲で。 参考URLのひとつめ apache プロジェクトのマニュアルから SAXParser のページを見ると AbstractSAXParser クラスの startDTD() というメソッドがオーバーライドされて います。 こいつには XMLLocator というのを受け取ります（参考URLのふたつめ）。 それを適切に置き換えれば、何か出来そうな気が… 後、DTDGrammar というクラスもちょっと気になります。 ＃ と言いつつ、マニュアルをあさってみましたが、いまいち有効な手段が見当たりません　m(_ _)m
表示させたくない<name>タグの部分は、<xsl:template match="name"/>という具合に閉じてしまうだけでできますよ。 <xsl:stylesheet> <xsl:template match="/"> <html> <xsl:apply-templates /> </html> </xsl:template> <xsl:template match="name"/> <xsl:template match="age"> <body> <xsl:value-of select="."/> </body> </xsl:template> </xsl:stylesheet>
マッチしたものを全部出力すればいいだけなら、for-each とか使わなくても、 apply-templates を繰り返していけばいいと思います。例えば次のように。 というか、match したものに対して、その中でいろいろ繰り返すのが for-each なので、template の中に for-each が出てくるのが基本です。 <?xml version="1.0" encoding="shift_jis"?> <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" > <xsl:template match="/"> <xsl:apply-templates/> </xsl:template> <xsl:template match="root"> <html><xsl:apply-templates /></html> </xsl:template> <xsl:template match="first"> <xsl:apply-templates/> !!!!<br/> </xsl:template> <xsl:template match="second1"> <xsl:value-of select="."/><br/> </xsl:template> <xsl:template match="second2"> <xsl:value-of select="."/><br/> </xsl:template> <xsl:template match="third1"> <xsl:apply-templates/> ----<br/> </xsl:template> <xsl:template match="fourth1"> <xsl:value-of select="."/><br/> </xsl:template> <xsl:template match="fourth2"> <xsl:value-of select="."/><br/> </xsl:template> </xsl:stylesheet>
参考ＵＲＬはすごく為になりますので紹介します。 ＞また、タグというのは、ＣＳＶの「フィールド」や、固定長レコードファイルの桁数のように、 ＞あらかじめ決めておかなければデータ交換できないように思うのですが、 ＞間違っているのでしょうか？ ＣＳＶの場合、項目が増えたり順番変わったりしたらもうダメですよね。ＸＭＬだと項目が増えようが順番変わろうが大丈夫です。一旦決めたタグより新しいタグを追加したら、それを受ける方はそのタグは処理できませんが少なくとも従来からあるタグは処理できるわけです。 受け側の処理プログラムがうまく設計されていれば、送り側プログラムのバージョンが変わったりしてＸＭＬのタグが増えてもも柔軟に対応できそうな気がします。少なくともエラーでいきなり停止せざるを得ないというような状況は回避できそうな気がします。 「気がします」ばかりで申し訳ない。実際にはＸＭＬでまだプログラミングしたことないので…。 今回は「一般人」ということで失礼します…（＾＾；
私も正確にはお答えできないと思いますが、 XMLとはHTMLみたいな形式で表記するデータの集合体みたいな感じといった方がいいでしょうか。ただ、HTMLとは異なり、独自のタグでデータ項目名を１つ１つ書いてあることでしょうか。 　DTDとは、XMLファイルの中で、以降に書いてあるデータの構造を記載した部分です。 　DTD部分がなくても、XMLデータの要素がちゃんと記載されていれば通常処理できます。ただ、DTDがあれば要素の並び順や、階層関係、省略の可否、などについてもチェック出来るということです。 　ただ、他の人と共通に使うものについては、ある決まった形式、並びでデータのやりとりをしたほうが便利なので、各分野別に使われていたり、提唱されているDTDがあります。 >ブラウザ上で編集したものがXMLに反映されるか？ 　どうでしょう、ブラウザ上で直接編集？わかりません。 　今の私の知るところでは、そのような処理を見かけませんが。Excelをwebの中で動かすことによりそのようなことが出来るかもしれませんが。 　
一般的にいうウォークスルー関係のコンテンツのことですね。 web3D関係の書籍やサイトを検索するとよいかもしれません。 最近では色々似たようなのがありますので。 VRMLなどもありますがAdobeではAtomosphiaというウォークスルー のチャットシステムや松下が改築のシミュレーションを行う ソフトなどをリリースしています。 すべてを網羅したような解説は見たことがありませんがJava3D などもあります。 差異に関しては専用のプラグインの必要性やレンダリングの精度、 コンテンツの容量などがあげられます。
質問の内容を誤解していました。 かみあってませんでしたね。すみません。 >結局、DTDファイルは、クラスパスによる検索はできないということ >なんでしょうか？ #2の回答で削除を申し出た「DTDをライブラリに追加する」の部分にあたりますが、 「実装する」＝「クラスを生成する」方法ならありますけどね。 ●Oracle XML Class Generator for Java のように、DTDに基づいて各要素一種類ごとにクラスを生成するわけです。 下記URLの図2はわかりやすいですね。 http://www.atmarkit.co.jp/fxml/rensai/xdk01/xdk01.html >例えば、XMLに<!DOCTYPE>宣言を記述せず、XMLパーサープログラム側で >DTDの指定とかする方法はないのですかねぇ？ 上記方法から考えてみて下さい。あると思います。 ただ、念のために書いておきますが DTDの内容はELEMENT宣言とATTLIST宣言だけではないですよね？ ENTITY宣言もDTDの一部ですが、ファイル毎に異なる記述をするケースもあるのです。 <!DOCTYPE section SYSTEM "../program/section.dtd" [ <!--要素宣言と属性宣言は外部ファイル参照　↑（変更は不可）--> <!--記法名--> <!NOTATION TIF SYSTEM "C:\Program Files\Adobe\Illustrator 8.0J\Illustrator.exe"> <!--実体宣言ここから（ファイル毎に記述）--> <!ENTITY CJG70210 SYSTEM "C:\images\CJG70210.tif" NDATA TIF> <!ENTITY CYH50260 SYSTEM "C:\images\CYH50260.tif" NDATA TIF> <!ENTITY CYH50310 SYSTEM "C:\images\CYH50310.tif" NDATA TIF> <!ENTITY CYH50390 SYSTEM "C:\images\CYH50390.tif" NDATA TIF> ・ ・ ・ <!--実体宣言ここまで--> ]> <!--DOCTYPE宣言終わり--> みたいなXML文書の場合もあるので「<!DOCTYPE>宣言を記述せず」がいいかどうかはわかりません。 もちろん、外部エンティテイの扱いも処理系に実装すればいいのですが。 ちなみに、今この外部エンティテイを使用禁止にすべく改造中です（苦笑）。 スキーマ言語はDTDだけではありませんし、 人によって（XMLに）求めるものも違いますので、このへんで。
可能です。 XMLの経験がないのでしたら、DOMリファレンスの著者のサイト http://www.nurs.or.jp/~h_ozawa/kenheya/index.xml からツールをダウンロードしてくるのが一番はやいです。 http://www.nurs.or.jp/~h_ozawa/kenheya/xml/dev-ms/index.xml に ●Excel→XML ●XML→Excel などがあります。 ＃当方Office XP環境は知りませんので、少し古いやり方になるかもしれません。
XMLに関してのサイトを紹介します。 http://www.atmarkit.co.jp/fxml/ ↑このアットマークITのサイトは情報が盛りだくさんで、初心者の私にも大変役に立っています。リンク集もありますよ。 日本XMLユーザーグループ（http://www.xml.gr.jp/）も、XML技術者の方々の生の意見が聞ける場なのでお薦めします。
インフォテリアから出ている 「XSLT 1.0 / XPath 1.0 勧告仕様全文日本語翻訳版」なんて、どうでしょう？ ただし、この本は、WEB上で内容が載っている所があります。 私は、忘れましたが。。 がんばってください。
　だいぶ経ってしまっているので、回答が役に立つのか分かりませんが、 一応書いておきます。 　正確な意図が分かりにくいので、この回答が見当違いかもしれません。 <xsl:for-each select="//title"> 　<P><xsl:value-of select="."/></P> 　<xsl:for-each select="../P"> 　　<P><xsl:value-of select="."/></P> 　</xsl> </xsl> と記述しようとしている場所に <xsl:apply-templates select="//title | //P"/> と記述しておいて、 <xsl:template match="title"> 　<!-- title要素に対する処理 --> </xsl:template> <xsl:template match="P"> 　<!-- P要素に対する処理 --> </xsl:template> というテンプレートを呼び出すようにすれば良いのでは？ 　もちろん、apply-templatesでtitle要素とP要素を区別しない点が 意図と異なるかもしれませんが。 　この場合のデータ構造があまり良くないので、例えば <Group> 　<title>タイトルA</title> 　<P>no1</P> 　<P>no2</P> 　<P>no3</P> 　<P>no4</P> </Group> <Group> 　<title>タイトルB</title> 　<P>no5</P> 　<P>no6</P> 　<P>no7</P> 　<P>no8</P> </Group> のようにデータ構造をより良いものにしてから、 という手もあります。 こうするとだいぶ処理が楽になります。 　最後に、余計な忠告かもしれませんが、 xsl:for-eachにこだわり過ぎないで柔軟に考えた方が良いのでは、 と私は思います。
>NAME:A attr:3 >NAME:B attr:1 >NAME:B attr:2 >という結果が得られました。 この結果は正しいのでしょうか？ 結果から逆算するとデータは <ALL> 　<EX attr='1'><NAME>B</NAME></EX> 　<EX attr='2'><NAME>B</NAME></EX> 　<EX attr='3'><NAME>A</NAME></EX> </ALL> の書き間違いですね。 -- ●preceding-siblingとkey関数を使ってみる <xsl:key name="NAME" match="EX" use="NAME" /> <xsl:template match="ALL"> <xsl:for-each select="EX[not(NAME = preceding-sibling::EX/NAME)]"> <xsl:sort select="NAME"/> <dt>NAME: <xsl:value-of select="NAME"/> <xsl:for-each select="key('NAME', NAME)"> <xsl:sort select="@attr"/> <dd>attr: <xsl:value-of select="@attr"/></dd> </xsl:for-each> </dt> </xsl:for-each> </xsl:template>
まず、ソートする時にはB要素で繰り返さなくてはなりませんよね。 <xsl:template match="A"> 　<table border="1"> 　　<xsl:for-each select="B"> 　　　<xsl:sort select="." data-type="number"/> 　　　<tr> 　　　　<td><xsl:value-of select="position()"/></td> 　　　　<td><xsl:value-of select="."/></td> 　　　</tr> 　　</xsl:for-each> 　</table> </xsl:template> このようにすると昇順で表示されます (この例の場合は数字としてソートした方が自然なので、 data-type="number"を指定しました) 一応、HTMLでの出力を想定しています。 昇順にする方法が分かっていれば、最小値最大値を取得するのも容易です。 昇順に並んでいるのですから、その1番目の要素に最小値が、 その最後の要素に最大値が、それぞれ入っていることになります。 それを条件指定で取り出せば良いと思います。 <xsl:template match="A"> 　<table border="1"> 　　<xsl:for-each select="B"> 　　　<xsl:sort select="." data-type="number"/> 　　　<xsl:if test="position() = 1"> 　　　　<tr><td>min</td><td><xsl:value-of select="."/></td></tr> 　　　</xsl:if> 　　　<xsl:if test="position() = last()"> 　　　　<tr><td>max</td><td><xsl:value-of select="."/></td></tr> 　　　</xsl:if> 　　</xsl:for-each> 　</table> </xsl:template> 実際はたぶんもっと複雑な事例だとは思いますが、 ここから工夫してみて下さい。
SVGに関しては詳しくありませんが、 SVGの表示にはブラウザにプライグインが必要ですよね。 直接SVGのコードをブラウザに送って表示させるには、 ブラウザがSVGに対応している必要があります。 IE5.xとか対応していませんよね？？ そのため動的に表示させるには、インターネット経由で参照できるディレクトリに 一時的な名前で（例えば"tempname00.svg"など一回のアクセスごとに変わる） SVGのファイルを作成し、 <EMBED src"tempname00.svg"> というようなタグをもつHTMLをブラウザに返して表示させるしかないのではないでしょうか。 あくまで現状ですが。
リプライがないようなので。 ><dummy name="ENDRECORD"></dummy>を追加して xslで一件分のデータの終わりを認識させています の意味がよくわかりませんでしたので、データから削除してしまいました。不都合ならば加えて下さい。 必要ないと（私は）思うのですが。 position()がわかるということは、ワーキングドラフト（MSXML）仕様だけでいいですよね。 >どなたかワーキングドラフト仕様でも勧告後の仕様でも動くような 私には無理です（笑）。最近は勧告仕様オンリーですね。 ■XMLファイル #変更あり <?xml version="1.0" encoding="Shift_JIS"?> <?xml-stylesheet type="text/xsl" href="CSV.XSL"?> <root> <data> <record> <aaaa>1234</aaaa> <bbbb>5678</bbbb> <cccc>9abc</cccc> </record> <record> <aaaa>1122</aaaa> <bbbb>3344</bbbb> <cccc>5566</cccc> </record> </data> </root> ■XSL #ワーキングドラフト仕様 -csv.xsl- <?xml version="1.0" encoding="Shift_JIS"?> <xsl:stylesheet xmlns:xsl="http://www.w3.org/TR/WD-xsl" version="1.0"> <xsl:template match="/"> <xsl:apply-templates select="root/data/record" /> </xsl:template> <xsl:template match="root/data/record"> <xsl:apply-templates /> </xsl:template> <xsl:template match="record/*"> <xsl:value-of select="."/>,</xsl:template> <xsl:template match="record/*[end()]"> <xsl:value-of select="."/><br/> </xsl:template> </xsl:stylesheet> --------------------- <br/>は変更して下さい。
jo-jiさんも書かれてますが、XML自体にテーブル表示する機能があるわけではないです。しかしながら線（セルのボーダー？）が出る、出ないという質問になるということは、、、 ●なんらかの入力支援ツールを使用している。 ●ツールが自動生成したXSLを使用している。 ●自動で関連付けされているため、XMLに表示機能があると誤解してしまった。 という推測で書き込みます。推測で書いてますので、外してたらごめんなさい。 ＃どうしてもセルのボーダーが必要なら、XSLファイルを変更しましょう。 多分、生成されたXMLファイルと同じフォルダ内に、xxx「.xsl」というファイルがあると思います。テキストエディタで開いてみて下さい。 XML文書を表示するための処理が書かれています。 この中から、HTMLの<td>要素の中の<xsl:value-of />を探します。 <table> 　<tr> 　　<th> 　　</th> 　</tr> 　<tr> 　　<td> -------------------- 　　　<xsl:value-of /> -------------------- 　　</td> この一行のみを、下の4行と入れ替えます。コピペして使って下さい。 <xsl:choose> <xsl:when test=".[text()]"><xsl:value-of /></xsl:when> <xsl:otherwise>空白です</xsl:otherwise> </xsl:choose> これで空のセルには全て「空白です」が入るはずです。 動作を確認できたら、あとは「空白です」を「全角スペース」に変更すれば出来上がり。 ＃識者の方に怒られそうな解答だな、我ながら。 ＃仕様を無視した気分。
困り度3なのに誰も答えていないようなので。 拡張子"dtd"はアプリケーションに関連付けされていないのが普通だと思いますので、アイコンがWindowsマークであっても気にする必要はありません。メモ帳などのエディタで編集するだけでOKです。 毎回「アプリケーションから開く」をするのが面倒ならば、お使いのエディタに関連付けをしておけばよいと思います。 どのような本なのかは存じませんが、本のサンプルに書かれている通りにファイルを作成および編集し、以下のようにXMLファイルに記述すれば大丈夫だと思います。(文書要素型がabcでDTDファイルへのパスがhoge.dtdである場合) <!DOCTYPE abc SYSTEM "doctype_test.dtd"> この辺は読まれている本にも書かれているとは思うのですが、一応。
閲覧者の側からすれば、 あまりメリットはないかもしれませんね。 ただ、下の方が書いておられるように、 外部データベースとの連携が簡単になるので、 たとえば、簡単な個人サイトでも、これが使われていれば、 多少検索が早くなる、等のメリットはあるかもしれません。 いずれにせよ、作成者側の技術です。 ブラウザも一応いくつか対応していますが、 見てもなんの違いも感じないと思います。 更新が楽、記述がすっきり、データベースとの連携が楽、 ただそれだけの話ですから。 …あっ、閲覧者がソースを見ても、そこになにが書いてあるか、 　わかるってのもメリットですかねぇ。 　いまはソースを見ても、わけのわからない文字が並んでるだけですし。 　なんか違う？(^^；
要素や属性などのmarkupをそれぞれが勝手に定義していては、XMLのメリットは確かにあまりありません。定義できる可能性があるというだけで、実際には用途に応じた業界などで標準化されていた方がずっと便利です。 しかし、そのような各標準がXMLという同じ土俵の上に乗ることに意味があると思います。どの標準を使う際にも、XMLに関する知識や経験それにプログラムなどを活用することができます。 また、XMLからXMLへならば、XSLTというものを使って、変換することができます。 つまり、あるデータ形式みたいなものが業界や企業などによって定義される際、これまで見たことがないような形式になるよりも、XMLに基づいたものになる方が、定義する側にとっても利用する側にとってもメリットがあることになります。 XMLを分かりやすく説明するために<名前>jo-ji</名前>みたいな例がよく使われますが、実用的な観点ではあまり意味がない(それだけでは)と考えた方がいいと思います。あなたのおっしゃる通り、約束事があってはじめて役に立つのです。
とりあえずインフォテリアさんの XML資料室で調べてみてはどうでしょうか？ XSLやDOMの翻訳版へのリンクもありますし。 他にもありますが、とりあえずお薦めします。
　風邪大丈夫でしょうか？(^_^; 　データベース系のＷＥＢ作成は今需要多いです。もちろん、これからもデータベースはずっとなくならないでしょう。 　ただ、ＷＥＢ作成の仕事がいつまでも需要があるかどうかは、怪しいところだと個人的に考えてます。 　今はまだ意識してる人ほとんどいませんが、ＩＴブームだっていつかは終わります。今はインターネット乱用時代ですが、本当にＨＰやりたい人間だけがＨＰを開き、誰もが的確に、必要最低限インターネットを使う、そんな時代です。（その時代には「インターネットする」という動詞はなくなります。なぜなら、インターネットは情報収集・交換の手段であり、目的ではないからです） 　そうなったとき、ＷＥＢ制作の需要がどうなるか想像も付きません。まあ、インターネット自体がなくならない限りデザインの仕事ならなくなりはしないでしょうけど。 　ただ美大出身ということですから、デザイナーとしてそれは強みにはなるでしょう。 　それに俺だって２桁の足し算もできないくせにプログラマーやってるんですから、算数ができるんだったら数学苦手でも大丈夫じゃないでしょうか(笑)　必要な知識は必要に応じて勉強すればいいんですし。 　あと、これはponponさんがすでにＩＴ業界でプロとしてやってる、という前提で言うことなのですが、はっきり言ってこの業界、必要な知識はあらかじめ詰め込んでおく、というやり方は感心できません。なぜなら、そんなことしたら覚えることが多すぎですよね(笑)
