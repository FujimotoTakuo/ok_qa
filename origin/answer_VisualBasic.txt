以下でいかがでしょう。 Sub Example() Dim MyLastRow As Long, MyLastColumn As Long Dim i As Long MyLastColumn = Cells(3, Columns.Count).End(xlToLeft).Column '3行目の備考以降右にデータのあるセルがある場合Columns.Countをデータのあるセルの左のセルを指定 'たとえばK3にデータがある場合　Cells(3, "J").End(xlToLeft).Column MyLastRow = Cells(Rows.Count, "B").End(xlUp).Row 'B列の必要なデータがある行以降にデータがある場合Rows.Countを列の場合と同じように適宜変更してください。 For i = 4 To MyLastRow If Left(Cells(i, "B").Value, 3) Like "ABC" Then Cells(i, MyLastColumn + 1).Value = "○" ElseIf Left(Cells(i, "B").Value, 3) Like "*XX*" Then Cells(i, MyLastColumn + 1).Value = "A" End If Next End Sub
No1です B1にデータがあったのを見落としてました .SetRange Range(Cells(3, "A"), ActiveCell.SpecialCells(xlLastCell)) これでいかがでしょう。
> でも今回のはやはり別シートを作らなければいけないですよね。 RemoveDuplicatesを使う場合だと別シートか既存のシートの利用しないところで一時的に作業をしないとダメっぽいですね。 RemoveDuplicatesを使わない方法だと http://www.eurus.dti.ne.jp/~yoneyama/Excel/vba/vba_jyufuku.html 上記のページで紹介されている一番最後の「Dictionaryを利用する」を基にしてA,B,Cの3列をカンマ区切りの文字列として結合し、Dictionaryに登録後にSplit関数で3つにわける方法でも。(No1の時には時間がなかったので簡単な方法のみ紹介しました) 以下のような感じで Dim myDic As Object, myKey As Variant Dim c As Variant, varData() As String, rdData As Variant Dim i As Long, j As Long Set myDic = CreateObject("Scripting.Dictionary") With Worksheets("Sheet2") For i = 1 To .Range("A" & Rows.Count).End(xlUp).Row ReDim Preserve varData(i) varData(i) = .Cells(i, "A") & "," & .Cells(i, "B") & "," & .Cells(i, "C") Next i For Each c In varData If Not c = Empty Then If Not myDic.Exists(c) Then myDic.Add c, Null End If End If Next myKey = myDic.Keys .Range("A:C").ClearContents For i = LBound(myKey) To UBound(myKey) rdData = Split(myKey(i), ",") For j = LBound(rdData) To UBound(rdData) .Cells(i + 1, j + 1) = rdData(j) Next j Next i End With Set myDic = Nothing
> D列に"合計"という文字、E,F列にA列の同文字に対しそれぞれに合計値 説明と画像で列が違いますけど、コードは画像の方の列に合わせています。 なんか汚いコードですけど・・・一応動きます。 Sub Example() Dim MyDSum As Long, MyESum As Long, i As Long Sheets("Sheet1").Activate Application.ScreenUpdating = False i = 2 MyDSum = Cells(i, "D").Value MyESum = Cells(i, "E").Value Do If Cells(i, "A").Value = Cells(i + 1, "A").Value Then MyDSum = MyDSum + Cells(i + 1, "D") MyESum = MyESum + Cells(i + 1, "E") Else Cells(i + 1, "A").EntireRow.Insert Cells(i + 1, "C").Value = "合計" Cells(i + 1, "D").Value = MyDSum Cells(i + 1, "E").Value = MyESum MyDSum = Cells(i + 2, "D").Value MyESum = Cells(i + 2, "E").Value i = i + 1 End If i = i + 1 Loop Until Cells(i, "A") = "" Application.ScreenUpdating = True End Sub
私は、「新規プロジェクト」でウィンドウが開き、「インストール済み」の中の「Visual Basic」を選んだだけで、一番上に「Windowsフォームアプリケーション」があります。 確認してみてください。
以下のコードでいかがですか。 なお、都度利用しているエクセルのバージョンを記載しておいてください。 Sub Example() Dim MyLastRow As Long, i As Long Dim EVStr As String Sheets("SheetX").Activate MyLastRow = Cells(Rows.Count, "B").End(xlUp).Row '2007以降ならこちら ' For i = 2 To Cells(Rows.Count, "F").End(xlUp).Row ' Cells(i, "H") = WorksheetFunction.SumIfs( _ ' Range(Cells(2, "D"), Cells(MyLastRow, "D")), _ ' Range(Cells(2, "B"), Cells(MyLastRow, "B")), Cells(i, "F"), _ ' Range(Cells(2, "C"), Cells(MyLastRow, "C")), Cells(i, "G")) ' Next i '2007ここまで '2007よりまえならこちら For i = 2 To Cells(Rows.Count, "F").End(xlUp).Row EVStr = "(B2:B" & MyLastRow & "= F" & i & ") *(C2:C" & MyLastRow & "= G" & i & ") * D2:D" & MyLastRow Cells(i, "H") = WorksheetFunction.SumProduct(Evaluate(EVStr)) Next i End Sub
No1の追加です。 もし、加藤1とか1加藤などのような行も削除対象でしたら Sub Example2() Dim i As Long, j As Long Dim MyNumeric As Boolean For i = Cells(Rows.Count, "A").End(xlUp).Row To 1 Step -1 MyNumeric = True For j = 1 To Len(Cells(i, "A").Value) MyNumeric = Mid(Cells(i, "A").Value, j, 1) Like "[!0-9]" If MyNumeric = False Then Exit For End If Next j If Cells(i, "A").Value = "自分" Or MyNumeric = False Then Cells(i, "A").EntireRow.Delete End If Next i End Sub
No1です。とりあえず参考までに(最低限の指定) 2007より前のバージョンで実行する可能性がある場合は以下のコードで(2016は不明) With Sheets("Sheet1") '↓もしくは.Range("A3:C11").Sort .Range("A3").Sort _ Key1:=.Range("A3"), Order1:=xlAscending, _ Key2:=.Range("B3"), Order2:=xlAscending, _ Key3:=.Range("C3"), Order3:=xlAscending, _ Header:=xlNo End With 2007以降だとこちらでも(2016は不明) With Sheets("Sheet1").Sort.SortFields .Clear .Add Key:=Range("A3"), Order:=xlAscending .Add Key:=Range("B3"), Order:=xlAscending .Add Key:=Range("C3"), Order:=xlAscending End With With Sheets("Sheet1").Sort .SetRange Range("A3:C11") .Header = xlNo .Apply End With なお、最終行が不特定な場合は(A列の最終行を求める場合) Dim MyLastRow As Long MyLastRow = Sheets("Sheet1").Cells(Rows.Count, "A").End(xlUp).Row 上記を最初に追加して .SetRange Range("A3:C11") を .SetRange Range(Cells(3, "A"), Cells(MyLastRow, "C")) に変更してください。
バッチファイルを書くのが初めての方なのでしょうか…。引数云々の前に、変数に値を設定できているのかをまず確認しましょう。 set Drive = F echo %Drive% とかで。 それで値が表示できなければ、渡せるはずがありません。なぜこの2行で間違っているのかよく考えてください。 仮にバッチファイルを書くのが初めてだとしても、あまりにも初歩的過ぎる間違いなのであえて直接的には書きません。
こんにちは、No1です。 問題無さそうですね。 　　Set mySh = CreateObject("Shell.Application") 　　Set myPath = mySh.BrowseForFolder(&O0, "フォルダを選んでください", &H1 + &H10, "C:\") 　　If myPath Is Nothing Then WScript.Quit 　　myFLD = myPath.Items.Item.Path 　　Set mySh = Nothing 　　Set myPath = Nothing 　　On Error Resume Next 　　Set myFS = CreateObject("Scripting.FileSystemObject") 　　For Each myCSV In myFS.GetFolder(myFLD).Files 　　　　If LCase(myFS.GetExtensionName(myCSV)) = "txt" Then 　　　　　　With myFS.GetFile(myCSV).OpenAsTextStream(1) 　　　　　　　　myDAT = .ReadAll 　　　　　　　　.Close 　　　　　　End With 　　　　　　With myFS.GetFile(myCSV).OpenAsTextStream(2) 　　　　　　　　.WriteLine myFS.GetFile(myCSV).Name 　　　　　　　　.WriteLine myDAT 　　　　　　　　If Err.Number <> 0 Then 　　　　　　　　　　Msgbox myCSV & ":" & Err.Description 　　　　　　　　　　Err.Clear 　　　　　　　　End If 　　　　　　　　.Close 　　　　　　End With 　　　　End If 　　Next 　　Set myFS = Nothing 　　Msgbox "完了" これで、エラーになった時のファイル名とエラー内容を確認して下さい。 中身がテキストファイルではないｔｘｔファイルが含まれていたりしないか。
図をリンク オブジェクトではなく図として挿入するには、Pictures.Insert メソッドではなく、Shapes.Add メソッドを使用してください。 とのことです。 こちらを参考にしてください。 https://support.microsoft.com/ja-jp/kb/2396509
こんにちは 該当フォルダ、データシート名、指定シート等は適宜変更して下さい。 Sub test() 　　Dim r As String 　　Dim s As Worksheet 　　Dim データブック As Workbook 　　Dim データシート As Worksheet 　　Dim 指定シート As Worksheet 　　 　　Const シート名 As String = "データシート" 　　Set 指定シート = ThisWorkbook.Worksheets("Sheet1") 　　 　　r = Dir(ThisWorkbook.Path & "\*.xls*", vbNormal) 　　Application.ScreenUpdating = False 　　On Error Resume Next 　　Do While r <> "" 　　　　If r <> ThisWorkbook.Name Then 　　　　　　Set データブック = Workbooks.Open(ThisWorkbook.Path & "\" & r, , True, , "") 　　　　　　If Not データブック Is Nothing Then 　　　　　　　　Set データシート = データブック.Worksheets(シート名) 　　　　　　　　If Not データシート Is Nothing Then 　　　　　　　　　　データシート.UsedRange.Offset(9).Copy _ 　　　　　　　　　　　　指定シート.Range("A" & Rows.Count).End(xlUp).Offset(1) 　　　　　　　　End If 　　　　　　End If 　　　　　　データブック.Close False 　　　　End If 　　　　r = Dir() 　　Loop 　　On Error GoTo 0 　　Application.ScreenUpdating = True End Sub
#1です。 もともと "CMD /C START Acrobat.exe /A page=3 C:\～～～～.pdf" というのが文字列ですから、「3」も文字列です。 例えば、コマンドプロンプトでは文字列と数値を区別しませんから、それと同じようなものではないでしょうか。 余計なお世話かもしれませんが、フォーム上のコントロールからページ数を取得する場合はこうできます。 Page と言う名前のテキストボックスにページ番号が書いてあるとすると、 x=Me![Page] Shell "CMD /C START Acrobat.exe /A page=" & x & " C:\～～～～.pdf" もちろん、変数xを介さずに Shell "CMD /C START Acrobat.exe /A page=" & Me![Page] & " C:\～～～～.pdf" としてもいけます。
置換リストブック.xlsmのSheet1のA列→検索語 その右隣のB列→置換する文字列 置換するブック.xlsmのSheet1のA列→検索して置換する範囲 とします。 ※最右端の列と、その左隣の列を、関数を入れる列として一時的に使用します。 xl2013の場合、XFC:XFD列を使います。 Sub 複数の置換() Dim bk1 As Workbook Dim bk2 As Workbook Dim LR1, LR2, AD, V Set bk1 = Workbooks("置換リストブック.xlsm") Set bk2 = Workbooks("置換するブック.xlsm") LR1 = bk1.Sheets("Sheet1").Cells(Rows.Count, 1).End(xlUp).Row LR2 = bk2.Sheets("Sheet1").Cells(Rows.Count, 1).End(xlUp).Row bk2.Activate AD = Cells(1, Columns.Count).Address(False, False) bk2.Sheets("Sheet1").Cells(1, Columns.Count).Resize(LR2, 1).Formula = _ "=INDEX([" & bk1.Name & "]Sheet1!B$1:B$" & LR1 & _ ",MATCH(a1,[" & bk1.Name & "]Sheet1!A$1:A$" & LR1 & ",0))" With Cells(1, Columns.Count - 1).Resize(LR2, 1) .Formula = "=IFERROR(" & AD & ",a1)" V = .Value .Resize(, 2).ClearContents End With Cells(1, 1).Resize(LR2, 1) = V End Sub
>どこが間違っているか分からず困っています。 KENLikeが変数でなく文字列になってるからでしょう。 Me.RecordSource = "select * FROM テーブル WHERE (名前 like" & KENlike &") or (所属 like " & KENlike & ")"
空白を数えなければいいのですね If C.Font.ColorIndex = color Then のところを If C > "" And C.Font.ColorIndex = color Then に変えればいいです。
「ソリューションエクスプローラ」 Visual Basicの管理ツールですね。 "Visual Studio にはソリューション・エクスプローラ・ウィンドウがあり、このウィンドウを使用してソリューションとプロジェクトを探索、管理できます。このウィンドウを開くには、[表示 > ソリューション エクスプローラ] を選択します。 " http://www.microfocus.co.jp/manuals/ED22U2/html/GUID-8CEFC695-F644-450A-AFB0-4768A022D17F.html 表示されていない場合は、 "ローラとよく似た階層構造で表示されます。既定では、ソリューション エクスプローラは IDE の右側に表示されます。ソリューション エクスプローラが表示されていない場合は、[表示] メニューの [ソリューション エクスプローラ] をクリックして開くことができます。" https://msdn.microsoft.com/ja-jp/library/bb384482(v=vs.90).aspx "ソリューションが表示されない状況になっていることがあります。 たとえば、Visual Basic の開発設定など、既定の環境設定のいくつかでは非表示になっています。 … この状況でソリューションを再表示する (または、非表示にする) 場合は、[ツール] – [オプション] – [プロジェクトおよびソリューション] – [全般] の順にクリックし、[Always show solution] (常にソリューションを表示) チェック ボックスをオンにします。" https://blogs.msdn.microsoft.com/vstipsjpn/2008/11/25/12-21/ 参照設定ならば、 "参照設定を追加する方法" http://homepage1.nifty.com/rucio/main/kiso/Kiso13Reference.htm "１）ソースのプレビュー機能 VS2012では、ソリューションエクスプローラ上で、 ファイルを選択しただけで、ソースを表示できるプレビュー機能が追加になりました。" http://www.ilovex.co.jp/blog/system/systemdevelopment/visualstudio2012.html こちらも参考に "「ソリューションエクスプローラ」に関する回答" http://sp.okwave.jp/search?auth_token=62a503fd39fea4a2648e2cff68834f348394e199&word=%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%97%E3%83%AD%E3%83%BC%E3%83%A9 よい開発ができますように！ 参考になれば幸いです。
こんにちは Set RS ～ はループの外でいいです。 商品コードが数値なら、Cells(i, 1)の前後のシングルコーテーションは不要です。 [shohin$]に別名（例えば「a」）をつけて、a.商品コード とします。 転記するフィールドはRS.Fields("商品名")のようにします。 　　Set RS = New ADODB.Recordset 　　 　　For i = 2 To 最終行 　　　　RS.Open "SELECT * FROM [shohin$] AS a WHERE a.商品コード = " & Cells(i, 1) & " ", CN 　　　　If RS.EOF Then 　　　　　　Cells(i, 2) = "???" 　　　　Else 　　　　　　Cells(i, 2) = RS.Fields("商品名") 　　　　End If 　　　　RS.Close 　　Next とすると出来ますでしょうか？
> フォームボタンを作りマクロ登録したのですが反応 ありませんでした。 画像のシートにボタンを作成しましたでしょうか。 画像のシートのシートモジュールにコードを記載しましたでしょうか。 また、〇は画像のシートからコピーしてコードの該当部分に記載して下さい。
Webシステムということは、システムコールでこのバッチを実行しているということですよね。 ということは　非ウィンドウ環境下なので、 connectに　　/v を付けないと teratermのウィンドウを開こうとしてそこで止まるんじゃないですか？
上の行から順次下で繰り返し判別する。それは 「現在のセルの値」が、「Ａ２から現在行までにおいて」ＣＯＵＮＹＩＦで数を出し、１の場合はＣ列に持って行き、２以上なら持っていかないようにすれば仕舞。 最近これと同系統の質問が続くが、これがいちばんやさしい。 関数だけでも答えを挙げる人もいるだろう。 Sub test01() lr = Range("A100000").End(xlUp).Row j = 2 For i = 2 To lr x = WorksheetFunction.CountIf(Range("A1:A" & i), Cells(i, "A")) If x = 1 Then Cells(j, "C") = Cells(i, "A") j = j + 1 Else End If Next i End Sub
>Visual C++ がたくさんインストールされていますが、ここに原因があるのでしょうか？ Microsoft Visual C++ * Redistributable が多数インストールされていること自体は普通です。 Microsoft Visual C++ 2005で作成されたアプリケーションはMicrosoft Visual C++ 2005 Redistributableが必要ですし Microsoft Visual C++ 2008で作成されたアプリケーションはMicrosoft Visual C++ 2008 Redistributableが必要ですし 以下略 また2005,2008,..毎に、それぞれが複数ある事もありますが、本体と修正パッチで個別になるのでそのようになります。 ただし修正パッチでの影響で、それを使用していたアプリケーションが動作しなくなる事もなくはないです(とはいっても私の知っている事例は1件だけですが)。
ここに質問をする前に、自分でいろいろ考えて、手段（ロジック）を考えること。 その後VBAコードでどう実現するか、自分のVBAの経験に照らしてやる。そのコードが判からなければ、したいロジックを文章で書いて質問するようにすべきだ。 ＝＝＝ 下記は 「ある行の１セルの値が、その列全体の中に、２件以上あれば１件分だけ書き出す」というロジックでやってみた。これならだれでも思いつくだろう。 まずA列でソートー＞コードは略 その次に Sub test01() i = 2 j = 2 lr = Worksheets("Sheet1").Range("A10000").End(xlUp).Row MsgBox lr p1: x = Worksheets("Sheet1").Cells(i, "A") c = WorksheetFunction.CountIf(Worksheets("Sheet1").Range("A2:A" & lr), x) MsgBox c If c >= 2 Then Worksheets("Sheet2").Cells(j, "A") = x j = j + 1 i = i + c Else i = i + 1 End If If i > lr Then Exit Sub GoTo p1 End Sub ーーー 例データ　Sheet1のA1:A15 項目 a a b c d d d f g q q s s v ーー 結果　Sheet2のA1以下に a d q s
こんにちは ループする必要が無いです。 Sub test() 　 Range("T3", Range("T" & Rows.Count).End(xlUp)).Sort _ 　 Key1:=Range("T3"), Order1:=xlAscending, Header:=xlNo 　 Range("T3", Range("T" & Rows.Count).End(xlUp)).RemoveDuplicates _ 　 Columns:=1, Header:=xlNo End Sub
こんにちは CountIfも遅いですし、一個一個セルにアクセスするのも遅い原因かと思います。 Sub test() 　　Dim i As Long 　　Dim v As Variant 　　Dim d As Object 　　 　　Set d = CreateObject("Scripting.Dictionary") 　　With Range("X1", Range("X" & Rows.Count).End(xlUp)) 　　　　.Offset(, 1).ClearContents 　　　　v = .Resize(, 2) 　　　　For i = 1 To UBound(v, 1) 　　　　　　If d.Exists(v(i, 1)) Then 　　　　　　　　d(v(i, 1)) = d(v(i, 1)) + 1 　　　　　　Else 　　　　　　　　d.Add v(i, 1), 1 　　　　　　End If 　　　　Next 　　　　For i = 1 To UBound(v, 1) 　　　　　　v(i, 2) = IIf(d(v(i, 1)) > 1, "●", "") 　　　　Next 　　　　.Resize(, 2) = v 　　End With End Sub
Cells(行の変数,列の変数) と記述すれば列の指定部分を変数で指定できます。ただし、列の変数の値はA,B,Cではなく1,2,3といった列番号になります。 Dim MyCoulmn As Long MyCoulmn = 1 'A列 With Cells(Cells(Rows.Count).End(xlUp).Row, MyCoulmn) '略 End With
ConnectionStringを作成するのに便利なヘルパークラスのOracleConnectionStringBuilderクラスを使ってみてはどうでしょうか。 文字列だと1文字でも間違っているとエラーになるので、上記のクラスであればそういったことも減りやすいかと。 ただOracle10Gの時にサポートされていたかがわかりません。 頑張ってみてください。
これでいかがですか。 Sub Example() Cells(Rows.Count, "A").End(xlUp).Offset(0, 1).Value = Cells(Rows.Count, "A").End(xlUp).Value End Sub
画像添付したものが真っ黒で、全く内容が見えないのではないか？ そうなら質問をやり直したらどうですか。 文書でも書ける内容ではないか。 「ある列の最大値の入っている行の左列の値を取得したい」、ではないのか。 文章でも目的を表現する力を付けてください。 ーー 書いているままの Sub test01() Set ret = Range("B:B").Find(Application.Max(Range("B:B"))) piyo = ret.Offset(0, -1).Value MsgBox ret.Value & " " & piyo End Sub ではだめなの？
参考までに http://dobon.net/vb/dotnet/beginner/floatingpointerror.html などを読んでおくとよい。 ＞SingleやDoubleのような浮動小数点数型は、値を2進数で格納しています。しかし、ほとんどの10進数の小数は2進数で表現することができません。そのためこのような値はSingleやDouble型では近似値でしか表現することができず、その誤差が上記のような非常識的な計算結果として現れます。 ーー ・浮動小数点数型に変換する（言語内部で）ときの問題点（本件） ・浮動小数点数型を使いだしたら、繰り返し演算を重ねたりすると、途端にむつかしい問題に直面する。（さらに関連した問題点） ーー 参考　その他目についた記事 http://qa.atmarkit.co.jp/q/9838 http://dangerous-animal141.hatenablog.com/entry/2014/05/10/000000
ODBCはOracle製のものを使っていますか？ もし、Oracle製のものを使っているなら、Microsoft ODBC for Oracle ドライバ も試してみてください。
こんにちは。 差し当たり、 > Worksheets("A").Range(Cells(y + 2, C_Arr(x - 1)), Cells(y + 2, C_Arr(x - 1) + 1)).Copy この記述（２ヶ所）でのセル参照では、 　Cells(y + 2, C_Arr(x - 1)) 　Cells(y + 2, C_Arr(x - 1) + 1) の親オブジェクト（シート）指定が漏れています。 シート[A]がアクティブな場合、または、シート[A]モジュールでの記述であった場合、 にだけ正しい参照を得られる記述ですし、 そうした特定の条件が担保されているという前提だとしても、少しおかしいです。 　Range(Cells(y + 2, C_Arr(x - 1)), Cells(y + 2, C_Arr(x - 1) + 1)).Copy で十分なケースだとすれば、Worksheets("A"). と敢えて書くこと の意味が読む人の理解を遠ざけてしまいます。 このような特定の条件下でないのなら、 普通の標準モジュールの記述として直訳すると、 　Range(Worksheets("A").Cells(y + 2, C_Arr(x - 1)), Worksheets("A").Cells(y + 2, C_Arr(x - 1) + 1)).Copy のように書くことになります。 この場合、シート[A]へのアクセスを繰り返していて読み難いので、簡素に意訳して 　Worksheets("A").Cells(y + 2, C_Arr(x - 1)).Resize(, 2).Copy のような書式で参照した方が、却ってミスが少なくなると思いますが、如何でしょう。 ただ、ここで指摘したことが問題になる場合は、結果として実行時エラーに繋がりますから、 今回ご質問の主題とは直接関わりません。 けれど、やりたいことの説明を端折って、うまく動いていないコードを部分提示するのは、 読む者にとってはパズルを解くような難題になってしまいます。 題意へのこちらの理解が至っていないようであれば、すみません。 問題解決へのステップとして、 一旦、ご提示の記述を整理してみます。 ' ' /// 　　For y = 1 To UBound(B_Arr) 　　　　For x = 1 To UBound(A_Arr) 　　　　　　Worksheets("A").Cells(y + 2, C_Arr(x - 1)).Resize(, 2).Copy 　　　　　　Worksheets("B").Cells(B_Arr(y - 1), A_Arr(x - 1)).PasteSpecial _ 　　　　　　　　Paste:=xlValues, _ 　　　　　　　　Operation:=IIf(A_Arr(x) = 22, xlPasteSpecialOperationAdd, xlPasteSpecialOperationNone) 　　　　Next x 　　Next y 　　Application.CutCopyMode = 0 ' ' /// 細かい点で求める結果と異なる（書式をコピーする？処理後の選択範囲は重要？） 可能性がありますので、このスクリプトはそのまま使えるかは疑問ですが、 デバッグし易いようにという意図で書き換えたものです。 ご提示のコードから推察した前提として、 　B_Arr(0 To yy)　…　シート[A]の行位置 　A_Arr(0 To xx)　…　シート[A]の列位置 　C_Arr(0 To xx)　…　シート[B]の列位置 　何れの配列も、0 origin（最小の添え字が 0）の一次元配列、 　何れの配列も、Excelシートの[行/列]を指す整数としての要件を満たす、 　A_Arr(), C_Arr() は、同じサイズ（最大の添え字が共通）（？）の配列 　　または、C_Arr()のサイズがA_Arr()のサイズより小さいことは無い、 　A_Arr()の各要素のうち、隣り合った要素は連続数ではない（差が2以上）、 　コピー元のセル範囲は、単行２列、貼付け先も同様、 という条件で考えています。 注意して確認するべきポイントを挙げておきます。 １）カウンタのスタート値 　> For y = 1 To 　> For x = 1 To 　スタート値はそれぞれ、1、です。？ ２）コピー元の行位置 　> y + 2 　y の 2 行下 です。？ ３）コピー元の列位置 　> C_Arr(x - 1) 　配列C_Arr() のインデックスは x - 1 です。？ ４）ペースト先の行位置 　> B_Arr(y - 1) 　配列B_Arr() のインデックスは y - 1 です。？ ５）ペースト先の列位置 　> A_Arr(x - 1) 　配列A_Arr() のインデックスは x - 1 です。？ ６）[値貼付け/値加算貼付け]判別の比較対象 　> A_Arr(x) 　配列A_Arr() のインデックスは x　　 です。？ 現物ブックの事情や作意を知らない者として、パッと見に違和感があるのは、 　２）コピー元の行位置　だけが　配列とは無関係 　６）判別の比較対象　だけが　x　他２ヶ所では　x - 1 あたりでしょうか。 勿論、配列のサイズや中身がどんなものか知らないので、 　３）C_Arr(x - 1) ... ４） ... ５） ... おもむろにカウンタから1引いて C_Arr(0) を参照するのも 正しいのかどうかこちらには判りませんが、 ひとつ前の数値を見る、という意味なのかな、と思っています。 他に、 　B_Arr(),A_Arr()に重複した貼付け先を参照する組合わせが在るせいで 　または、 　A_Arr()の隣り合った要素が連続数になっているせいで（単行２列に貼付けするので） 　一旦加算貼付けした部分に、重ねて（非加算）貼付けしてしまっているケース 等、 状況・条件についても確認した方が良さそうです。 > ... エラーにはならないのですが、値が足し込まれず最後のコピー値が上書きされる ... メソッド（コピー、ペースト）部分が原因ということは考え難いので、 上記のように、 　カウンタの扱いや、各種参照、配列の要素（取得/設定の仕方）、について、 　意図した通りに書けているか まずは確認してみて下さい。 こちらで実際にサンプルシートとサンプル配列を作ってテストした限りでは、 コードに記された命令通りに処理されることは確認できています。 > うまくいく方法を教えて下さい。 どういう結果を得られれば「うまくいった」ことになるのか、 知っているのは今の処、質問者さんだけです。 今の所の直感では、方法というより、 状況・条件と方法が噛み合っていないのかな？というのが有力と思います。 尚解決に至らない場合は、 どの場合に期待通りの結果が得られないのか、そちらでも問題の切り分けに努めて貰って ３つの配列だけでも、具体例を挙げるなど、補足してみて下さい。 以上です。
SendKeys で Numlock が外れるのは昔から。 API で IME のOn/Off を切り替えれば良いかと。NumLock が外れることもありませんし。 以下３行を VBA の標準モジュールに記述 Public Declare Function ImmGetContext Lib "imm32.dll" (ByVal hWnd As Long) As Long Public Declare Function ImmSetOpenStatus Lib "imm32.dll" (ByVal himc As Long, ByVal b As Long) As Long Public Declare Function ImmReleaseContext Lib "imm32.dll" (ByVal hWnd As Long, ByVal himc As Long) As Long ThisWorkbookの方には Private Sub Workbook_Open() Dim himc As Long Dim hWnd As Long 'IMEをOn himc = ImmGetContext(Application.hWnd) Call ImmSetOpenStatus(himc, 1) Call ImmReleaseContext(hWnd, himc) End Sub これでIME が ON になるかと思います。 Excel2013 は持ち合わせていないので、2010と2016（ともに32Bit版）で試しました。 参考にしたところ http://www.alato.ne.jp/kazu-/vb/tip09.htm 蛇足？ですが、時間があったら読んでみてください。 NUM を切り替えるにはロック、CAPS LOCK キー、およびスクロール ロック キー方法 https://support.microsoft.com/ja-jp/kb/177674 NumLock操作を制御する方法 - Windows APIの使用：SampleFile214 http://www.accessclub.jp/samplefile/samplefile_214.htm
こんにちは、No1です。 Microsoft ActiveX Data Object x.x Library を参照設定して リンク先のコードの'接続文字列 connectionString = "Driver={MySQL ODBC 5.1 DRIVER};" _ 　　　　& " SERVER=localhost;" _ 　　　　& " DATABASE=cocoadb;" _ 　　　　& " USER=root;" _ 　　　　& " PASSWORD=admin;" のlocalhostをサーバー名、またはサーバーのIPアドレスに変更して cocoadbを実際のDB名に変更して、 ユーザー名、パスワードの、root、admin を実際のものに変更。 'SQL文 sqlStr = "select * from ms_usr" のms_usrをデータ数の少ない適当なテーブル名に変更して、 実行してみてはどうですか？ SERVER名と DATABASE名を変更するだけでもms_usrの内容が 取得出来るとは思いますが、実際のDBから取り敢えずデータが抜けるか 試してみた方がいいですよ。 道一のPC上にサーバー立ててるならSERVER名もlocalhostでいいと思います。
既出回答でよいのかもしれない。 しかし、質問者の考えに、引きずられ過ぎと思ったので下記を書いてみた。 ＞初歩的なことですが、マクロ初心者なので これは初心者向けの課題ではない。VBAの経験やビジネス経験が問われるむつかしい課題だと思う。 ＞マクロボタンを押して、mainを選択したら、"商品を選択してください こういう誘導があるとApplication.Inputboxの利用にいってしまうが、 この処理の実行のトリガをどう考えるかが、（自分のVBAの力量と相談してやらざるを得ないので）むつかしいと思う。この点は、経験（実務経験とVBAと両方）を積まないとよいものはできないと思う。 ーー 小生の試案は （１）シート（Sheet1)の上に、図形の１つ四角形を張り付ける。（これはエクセルが想定する方式でないかもしれない。ユーザーフォームなどを使うのが正道なのかも。質問者の意図を尊重してやってみた） ＞mainを選択したら 他の言語ではMainは、入口として、重要な概念として出てくるが、エクセルVBAでは場違い。 イベントプロシージュアーを使う場合はそう思う。 （２）（１）の図形のクリックイベントに処理を入れる。 この「シートの上！に」貼りつける図形には、初心者的にはクリックイベントしか無いようだ。 イベントを何にするか、ということが質問者には明確に意識されているかな。 ーー 最後に、質問表現だが （１）エクセルの質問では、＞A,1に分類、と書かずA1と番地を表現する場合が多い（A1形式） （２）シート（名）を、はっきり書いて（仮定じてでも）質問すること。 ＞sheet1のB列のは、＞A,1にぶんるいの前に書くべきだし。結果はSheet2などを明記すべきだ。 ブックーシートーセル番地の構成を、質問では常に明確に説明すること。 ーーー Sheet1とSheet2を用意する。 Sheet1のA-F列に(仮に）テストデータを用意。本番ではF列を修正のこと。 シートＳｈｅｅｔ１に「図形の四角」を１つ貼り付け。 その図形上で、右クリックすると、「マクロの登録」が出るから、クリックする。 VBE画面になる。シートのクリックイベントです。 そこには下記が現れる。 Sub 角丸四角形1_Click() End Sub その間の行に下記を書く。 ＝＝＝ Sub 角丸四角形1_Click() rf = Selection.Cells(1).Row MsgBox rf re = Selection(Selection.Count).Row MsgBox re x = Worksheets("Sheet2").Range("A10000").End(xlUp).Row MsgBox x Worksheets("Sheet1").Range(Cells(rf, "a"), Cells(re, "F")).Copy Worksheets("Sheet2").Activate Worksheets("Sheet2").Cells(x + 1, "A").Select ActiveSheet.Paste Application.CutCopyMode = False End Sub やっていること ・Sheet1のコピーするデータ範囲を操作者が選択する。 ・その最初行と最終行を割り出し ・Sheet2のすでにあるデータのA列の最終行を取得 ・その次の行からに貼り付け。 Ｍｓｇｂｏｘの行は、テストで納得で来たら削除すること。 新しい範囲で連続操作が可能です。 ーー ・選択したセルが空でないか ・範囲が過去の選択範囲と、ダブっていないか などを入れるとむつかしくなって、骨子を見失うので略。 どうしても必要というのであれば、この課題素のものが、初心者には過ぎた課題だということ。 他人に操作をやらせたり、仕事で使う場合は、それらチェックも必須であろうが、そういうことにプロの場合は苦労するのだと思う。
イミディエイトウィンドウ（VBE画面で Ctrl + G）での確認ですが ?ActiveSheet.PivotTables.count ?ActiveSheet.PivotTables(1).name などで値が取得できるので（当方Excel2010） これを利用してFor ～ Next ループで処理出来ないかな？ ご参考まで。
質問文に書いてあるコードの意味がわかりません。 質問事項である 「"コマンドボタン1" を押したときに ListBox へ登録する」 だけではだめなのでしょうか。 変な入力仕様を実装するよりは、「5つのテキストボックスにデータを入力してから登録ボタンをクリックする」 というシンプルなほうがいいと思います。 Private Sub SetList() 　With ListBox12 　　.AddItem 　　.List(.ListCount - 1, 0) = TextBox175.Text 　　.List(.ListCount - 1, 1) = TextBox176.Text 　　.List(.ListCount - 1, 2) = TextBox177.Text 　　.List(.ListCount - 1, 3) = TextBox178.Text 　　.List(.ListCount - 1, 4) = TextBox179.Text 　End With End Sub 現状の仕様では、おそらく一件目のデータ入力は登録ボタンのクリックを省略できるようにしたいのだと思いますが、それが故に各テキストボックスの値が変化するたびに ListBox へ値を登録するコードが必要となり、その都度 ListBox12.Clear の呼び出しが必要となっているようです。 2件目以降もテキストボックスに値を入力する必要があるため、1件目登録のために作ったロジックが 2件目以降の邪魔になってしまいます。
まず社員情報一人分の集計シートのひな形(画像の集計シートのA1からE1の所)を作ってから以下のコードを試してみてください。例示したコードはひな形がデータシートのA1からE3にあるものとしています。社員情報が可変という事なので後ろに継ぎ足していくのではなく実行ごとに集計シートをクリア(AからE列まで削除)し、その後データシートのG列2行目からのデータを毎回転記しています。実行速度は遅いです。 Sub Example() Dim DS As Worksheet, SS As Worksheet Dim i As Integer, j As Long Application.ScreenUpdating = False Set DS = Worksheets("データ シート") Set SS = Worksheets("集計シート") SS.Columns("A:E").Delete Shift:=xlToLeft j = 1 For i = 2 To DS.Cells(Rows.Count, "G").End(xlUp).Row With DS .Range("A1:E3").Copy SS.Cells(j, "A") SS.Cells(j, "A") = .Cells(i, "G") Union(.Cells(i, "H"), .Cells(i, "J"), .Cells(i, "L")).Copy SS.Cells(j, "C").PasteSpecial Paste:=xlPasteValues, Transpose:=True Union(.Cells(i, "I"), .Cells(i, "K"), .Cells(i, "M")).Copy SS.Cells(j, "E").PasteSpecial Paste:=xlPasteValues, Transpose:=True End With j = j + 3 Next Application.CutCopyMode = False Application.ScreenUpdating = True Set DS = Nothing Set SS = Nothing MsgBox "終了", vbInformation End Sub
inputboxを使用し、とおっしゃっているので、vba記述可、ということで回答します。 >品名を入れるとSheet1のA1セルを起点とした表のA列「品名」から部分一致で検索し、検索結果のA列からE列までのデータ この手順は、通常のEXCELのフィルター機能でできるかと思うので、マクロで記録してみてください。 (最初にフィルターの設定をしておいて、品名の条件指定をするところから行の抽出が終わったところまでで終了。) 参考：http://officetanaka.net/excel/vba/tips/tips155.htm 作成されたマクロの、条件指定をしているところにinputboxで取得した文字列を使用するように加工し、抽出結果をsheet3にコピーする記述を追加すればよいかと思います。 コピー後、フィルタのクリアも必要かと思います。状況によってはフィルタ設定そのものも解除が必要でしょうか。 また、sheet3にコピーしフィルタのクリアをするところまでをマクロ記録してもよいかもしれません。 その際、抽出結果を選択する際は、マウスで行うとセル値を指定してしまうことになりますので、起点のA1を選択してから、「Ctrl+Shift+→」続けて「Ctrl+Shift+下」をすることで、セル値を指定しない方法で記録されます。 もしくは、Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible).Copy Worksheets("Sheet3").Range("A1") に書き換えるか。 複数の条件を指定したいのであれば、「フィルターの詳細設定」という手もありますが、 これをマクロ記録してみましたら、セルの範囲指定が必要でしたので、inputboxで取得した値を抽出条件にできなそうでした。 VBAでの組み方が分からない場合、通常のexcel機能でどうすれば実現するかを考え、それをマクロ登録して、加工して使うという手が有効だと思いますよ。
回答No.1です。 こちらの読み方が間違っていましたね。 > 他のブックを参照するにはどういった記述にすれば > よろしいでしょうか。 変更は３ヶ所です。 [シート区間先頭セル]に指定したセル範囲 の存在する ブック の シート区間 を集計の対象にします。 Public Function CountIfAcross(シート区間先頭セル As Range, シート区間後尾セル As Range, 検索条件 As String) Dim sRef As String, sRefE As String, c As Range, cnt As Long, i As Long 　　sRef = シート区間先頭セル.Address(0, 0) 　　sRefE = シート区間後尾セル.Address(0, 0) 　　If sRefE <> sRef Then sRef = sRef & ":" & sRefE 　　With シート区間先頭セル.Worksheet.Parent　'　★追加 　　　　For i = シート区間先頭セル.Worksheet.Index To シート区間後尾セル.Worksheet.Index 　　　　　　For Each c In .Sheets(i).Range(sRef)　'　★１文字追加 　　　　　　　　If c.Text Like 検索条件 Then cnt = cnt + 1 　　　　　　Next 　　　　Next i 　　End With　'　★追加 　　CountIfAcross = cnt End Function
そういう「書き方」は出来ません。 なので「共通モジュールは、ボタンクリックイベントのsubプロシージャからしか呼ばない」という決まりを作り、その通りに書くしかありません。 「共通モジュールは、ボタンクリックイベントのsubプロシージャからしか呼ばない」という決まりを作れば「共通モジュールが呼ばれた時は、絶対にボタンがクリックされた時だけに限られる」ので「if文で判定する必要なんか無い」です。 なお「複数のボタンのイベントから、共通のモジュールを呼び出す」というのなら「引数に、誰から呼ばれたのか、指定すれば良いだけ」です。 例えば、以下のようにします。 Private Sub 足すボタン_Click() 共通演算(1) End Sub Private Sub 引くボタン_Click() 共通演算(2) End Sub Private Sub 掛けるボタン_Click() 共通演算(3) End Sub Private Sub 割るボタン_Click() 共通演算(4) End Sub Public sub 共通演算(計算モード As Integer) If 計算モード=1 Then ’足し算の処理 Else If 計算モード=2 Then ’引き算の処理 Else If 計算モード=3 Then ’掛け算の処理 Else If 計算モード=4 Then ’割り算の処理 Else MsgBox ”計算モードが誤っています" End If End Sub
こんにちは 多分、保護の解除がうまくいってないのでは？ Sub Macro2() 　　Dim wbk1 As Workbook 　　Dim wsh1 As Worksheet 　　Dim tsh As Worksheet 　　 　　Application.ScreenUpdating = False 　　 　　Set tsh = ActiveSheet 'ThisWorkbook.Worksheets(1)? 　　 　　Set wbk1 = Workbook.Open("K:\共有\○○○.xlsm") 　　Set wsh1 = wbk1.Worksheets(1) '○○○.xlsmのシートが1枚ならこのまま。複数ならシート名指定に変更 　　 　　wsh1.Unprotect 　　 　　tsh.Range("D4:G20").Copy wsh1.Range("E7") 　　 　　wsh1.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True 　　wbk1.Save 　　wbk1.Close 　　 　　Set wbk1 = Nothing 　　 　　Set wbk1 = Workbook.Open("C:\Users\Desktop\×××.xlsm") 　　Set wsh1 = wbk1.Worksheets(1) '×××.xlsmのシートが1枚ならこのまま。複数ならシート名指定に変更 　　 　　wsh1.Unprotect 　　 　　tsh.Range("D4:G20").Copy wsh1.Range("AF18") 　　 　　wsh1.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True 　　wbk1.Save 　　wbk1.Close 　　 　　Set wbk1 = Nothing 　　 　　Set wbk1 = Workbook.Open("K:\共有\□□□.xlsm") 　　Set wsh1 = wbk1.Worksheets(1) '□□□.xlsmのシートが1枚ならこのまま。複数ならシート名指定に変更 　　 　　wsh1.Unprotect 　　 　　tsh.Range("D4:G20").Copy wsh1.Range("AF18") 　　 　　wsh1.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True 　　wbk1.Save 　　wbk1.Close 　　 　　Set wbk1 = Nothing 　　 　　Application.ScreenUpdating = True 　　 　　MsgBox " 『○○○』と" & vbCrLf & "『×××』と" & vbCrLf & "『□□□』の" & vbCrLf & "規格を変更しました。" End Sub 動作確認してないですけど、これで試してみて下さい。
＞doloop前の「Me.text2.Value = Me.text1.Value」を正さないといけないようです。（課題です） ＞これがないと入力された数字そのものが入らなくなってしまうのですが… ここでtext2に入れるのではなく、Do～Loop内で入れるようにすればすっきりします。 Dim I As Variant I = Me.text1.Value 'Me.text2.Value = Me.text1.Value　←この行は不要 Do Until I = 0 Me.text2.Value = Me.text2.Value & " " & I　’数字を区切るため” ”で空白を挿入 I = I - 1 Loop
こんにちは。 > 何が間違ってますか？ コードの問題ではなくて、実行環境の問題です。 VBIDEのオブジェクトへのアクセスについて Excelでは、セキュリティを重く見て、 初期設定ではアクセスできないように設定されています。 設定変更手順 （例えば、Excel2010の例で） [ファイル]タブ ┗[オプション]┅『Excelのオプション』 　┗[セキュリティ センター] 　　┗[セキュリティ センターの設定]┅『セキュリティ センター』 　　　┗[マクロの設定] 　　　　┗「開発者向けのマクロ設定」 　　　　　┗ (チェックボックス チェック) VBA プロジェクト オブジェクト モデルへのアクセスを信頼する 　　　　　　　↑チェックする 　　　　　┅[ＯＫ] 　┅[ＯＫ] 以下のページでも説明はあるようです。 『2回目からはマクロの警告しません』 http://officetanaka.net/excel/excel2010/008.htm 設定変更直後は、最初の実行の際に、 「信頼」をとうような形で１回だけエラー（警告）ダイアログがでるようです。 最近の私は使い始めからＶＢＥの各種設定を移植してしまうので、 ご指摘のようなエラーを経験したのはExcel2000の頃でした。 勿論、Excelのバージョンによって設定の手順は変わります。 『VBEを操作するための準備』 http://officetanaka.net/excel/vba/vbe/01.htm
No1訂正です 毎回同じデータ ↓ 毎回始まりが同じで新しく追加されたデータを含む範囲のデータ
一発でやる方法はないかと思います。 CSVにして出す時点で、データとしてカンマがあるケースを想定すると、データの始まりと終わりを表現するためにダブルクォーテーションが必要になっていると思います。取り込んだ時点ではダブルクオーテーションはついていると思うので、データを使うときに関数化したReplace構文でダブルクォーテーションをはずしてはいかがでしょうか。 strBの内容からダブルクオーテーションを削除してstrAに格納するには以下のようにします。chr(34) はダブルクオーテーションのASCIIコードです。直接 ”””という表現ができないためこうします。 strA = Replace(strB, Chr(34),””) データ中にダブルクオーテーションがある場合の逃げを考えておかないとはまりそうなのであれば、カンマの位置をInstrで得てその前後の文字がダブルクオーテーションだったらReplaceするというようなことを考えないといけないかもしれませんね。
ファイルの拡張子が.csvで作成されるが、.txtで作成したいって話でいいんでしょうか？ | '初期値設定 | filePath = ActiveWorkbook.Path & "\経費計算エクセル（CSV保存）.csv" ↓ filePath = ActiveWorkbook.Path & "\経費計算エクセル.txt" だけでＯＫだと思いますが。
Sheets(”記録用紙”).Unprotect Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _:=False, Transpose:=True Sheets(”記録用紙”).Protect Contents:=True 要するに、貼り付ける前に一度シート保護を解除して、貼り付けてからまたシート保護をすると言うことです。
VBAはアプリケーションに付属しているスクリプト。WSHはWindowsに付属しているスクリプト。 だからVBAはExcelとかWordのオブジェクトを扱うのに特化していて、WSHはサービスを操作したり、タスクを管理したり、ユーザー管理したり、ログを管理する。Windowsを操作するのに特化しているということ。要するにどうしても双方を合わせないと出来ない、例えばログをExcelに吐き出したいとかそういう場合には双方で呼び出す。 適材適所で使うのが正しいです。
> ret = xlFunc.Match("12345", rTemp , 0) Arg1:検査値がArg2:検査範囲に見つからない場合はエラー値を戻す という意味で、[Arg3:照合の種類]に、[0:一致]を指定しているので、 見つからなかった結果のエラーなのでは？ なぜ見つからないのか、ということですが、 excel.WorksheetFunction.Matchメソッドや excel.WorksheetFunctionに用意されたメソッドの殆どは、 [文字列値]と[数値]は厳密に区別する、 という前提を見落としているのではないでしょうか？ [文字列値]なら 　ret = xlFunc.Match("12345", rTemp , 0)　→数値12345しか無ければエラー [数値]なら 　ret = xlFunc.Match(12345, rTemp , 0)　→文字列値"12345"しか無ければエラー csvテキストの段階では勿論すべて文字列値ですが、 Excelシート（セル）に文字列値"12345"を展開したなら、 シート上では数値12345になるのが普通に一般的な処理ですので、 そこら辺のことじゃないでしょうか。 前後の処理過程を知りませんから、見当違いでしたらすみません。
>Win10 + IE11 環境ではそもそも Win7(64bit) IE11では動きましたが Option Explicit Dim objIE, objShell, objWshShell, objWin Dim linknum, spurl linknum = Inputbox("リンク番号を入力してください。") spurl="https://xxxx" & linknum 'Shell.Applicationオブジェクトの作成 Set objShell = Wscript.CreateObject("Shell.Application") '既に起動しているIEを検索 Set objIE = Nothing For Each objWin In objShell.Windows If TypeName(objWin.document) = "HTMLDocument" Then '見つかればobjIEオブジェクトに格納 Set objIE = objWin Exit For End If Next If objIE is NothIng Then '起動しているIEが無ければ新たに作成 Set objIE = Wscript.CreateObject("InternetExplorer.Application") With objIE .Visible = True .Navigate spurl End With Else 'IEが起動しておれば最終タブを取得 objIE.Navigate2 spurl, &H800 WScript.sleep 250 Set objIE = objShell.Windows.Item(objShell.Windows.Count - 1) Do While objIE.Busy = True Or objIE.readyState <> 4 WScript.Sleep 250 Loop Set objWshShell= Wscript.CreateObject("Wscript.Shell") objWshShell.AppActivate objIE WScript.Sleep 1000 objWshShell.SendKeys "%( )" WScript.Sleep 250 objWshShell.SendKeys "x" End If
regsvr32でのCOMコンポーネント登録は適用済みですか？
いろいろ、問題がありますね。 まず、何よりも「"ym"」としていることです。 「"ym"」とした時点で、「ym」という文字列になってしまいます。 変数を「"」で囲ってはいけません。 また、「ym = Range("Z1")」って何ですか？ それから、ファイル名は文字列ですから、「Dim ym As String」とします。 他にも、「Windows」にはファイル名として使えない文字があります。 半角の「？」や「￥」マークなどですが、半角の「／」もその一つです。 したがって、半角の「/」は全角にする必要があります。 結果、私が作るなら、 Option Explicit Sub コピー保存() Dim ym As String ym = Range("A1").Value ym = Replace(ym, "/", "／") ThisWorkbook.SaveAs Filename:="F:\" & ym & ".xlsm" End Sub となります。
以下のようにしておけばいかがでしょう。 Book1のSheet1のデータをマクロのあるブックにコピーすると仮定してます。 Sub example() ActiveSheet.Unprotect Workbooks("Book1.xlsm").Sheets("Sheet1").Range("E6:AI73").Copy Range("E6").PasteSpecial ActiveSheet.Protect End Sub また、Book1のSheet1に対してコピー以外の操作をする可能性がある場合には、以下のようにしておくといいでしょう。 With Workbooks("Book1.xlsm").Sheets("Sheet1") .Range("E6:AI73").Copy End With
こんにちは まずは、コマンドボタンを右クリックしてイベントのビルドでコードビルダーを 表示して、 Private Sub コマンド1_Click() 　　Dim s As String 　　Select Case Me.フレーム1.Value 　　　　Case 1: s = Me.ラベル2.Caption 　　　　Case 2: s = Me.ラベル4.Caption 　　　　Case 3: s = Me.ラベル6.Caption 　　End Select 　　Me.テキスト2.Value = Me.テキスト1.Value & s End Sub みたいにしてはどうですか？ コマンド1とか、フレーム1とか、ラベル2とかはそれぞれ実際の環境に 合わせて変更して下さい。 あまり最初から高度なコードを書こうとせずに 少しずつ動くコードが書けるようにしていくといいと思います。
とりあえず一つ明らかな間違いを指摘しておくと dtSaveFineNameではなく dtSaveFileName でしょうね 今のままだと必ずファイル名が空になってしまいます。 変数名は手で書くのは絶対やめた方がいいですよ。必ずコピーをしましょう。 他にも間違いがあるかもしれませんがとりあえず。
> DIM SNo As Integer > With UserForm2 > SNo = .ComboBox1.value > End Withとしてマクロを実行したときに > 「実行時エラー’13’: 型が一致しません」とエラーが出てしまうことです コンボボックスで数値を選択してると思いますのでエラーが出るのは変ですが(こちらでテストしたところ全角の１、２、３で設定してもエラーにはなりませんでした) とりえず以下のように強引に数値型に変更するという手もあります。 SNo = Val(.ComboBox1.Value)
Googleドキュメントで使えるAPIがあるみたいですので、 それを使ってVB.NETからHTTP経由でダウンロードできると思います。
次辺りかなと思います。 http://www.oracle.com/technetwork/topics/dotnet/utilsoft-086879.html の中のODAC 11.2 Release 2 and Oracle Developer Tools for Visual Studio (11.2.0.1.2)かなと。 但し、ダウンロードするためにオラクルアカウントが必要かと思います。
検索で見つかった情報はどうでしょう？ Set the URL property of the WMP ActiveX control to the path of the file to play. For example: this.axWindowsMediaPlayer1.URL = "file path"; In addition, if you want to stop playing the file, simply set the URL property to an empty string or call the close method of the WMP control: this.axWindowsMediaPlayer1.URL = ""; -or- this.axWindowsMediaPlayer1.close(); https://social.msdn.microsoft.com/Forums/ja-JP/33dabcb3-2d27-4e2a-9ee1-9702816661de/windows-media-player-contoll-in-c?forum=winforms
まず、質問するのだから、読者（回答者）にどういうことをしたのか、文章で説明するのが礼儀だろう。 ーーー たとえば ユーザーフォームを使う。そこへ コンボボックス１つ テキストボックス３つを貼りつける 当然コマンドコマンドボタンを１つ貼りつける ーーー 私の実験例では そのコンボで選択した文字列について シートのセル範囲B列B2:B50を検索する。 見つかった場合、見つかったセルを検索語で置換し 同行のとなり１列目、２列目、３列目をテキストボックスの値で置き換える。 ーー 下記が、ＶＢＡ的に参考になる点があれば。 該当データが、複数回出現しないデータなら Private Sub UserForm_Initialize() UserForm1.ComboBox1.AddItem "a" '.AddItem="a"じゃないよ UserForm1.ComboBox1.AddItem "b" UserForm1.ComboBox1.AddItem "c" End Sub ーー Private Sub CommandButton1_Click() Dim obj As Object x = UserForm1.ComboBox1.Text MsgBox x Set obj = Worksheets("Sheet1").Range("B2:B50").Find(x, LookAt:=xlWhole)　'xlPartがよいかも If obj Is Nothing Then MsgBox x & "は見つかりませんでした。" Else 　　’テスト時の確認用 rw = obj.Row cl = obj.Column MsgBox x & "は、" + CStr(rw) + "行目の" _ + CStr(cl) + "列目にあります" End If '--シートデータ加工 obj.Replace What:="a", Replacement:="aXXX", LookAt:=xlPart '部分的置換 obj.Offset(0, 1) = UserForm1.TextBox1.Text '質問の仕様から obj.Offset(0, 2) = UserForm1.TextBox2.Text obj.Offset(0, 3) = UserForm1.TextBox3.Text End Sub 実行前 Ｂ１：Ｂ４ データ a b c ーー 実行後Ｂ１：Ｅ４ データ aXXXxvb b c ーーー ＞Sheets("ＡＡ") シート名に.空白を含めているということか。 質問のようなときに、余り特殊な例は出さないようにしてほしい。 メインでない、問題点が拡がってしまう恐れがある。 http://www.excel.studio-kazu.jp/kw/20060814154532.html シート名の中に空白を含めるのはお勧めじゃない。
＞X = Cells(i, 1)はなぜ1回しか実行されないのでしょうか。 ループの外の「１回しか通らない所に書いた」からです。 ＞ループ内でX = Cells(i, 1)を使うたびに、i = i + 1を利用することになるので ＞X = Cells(4, 1) → Cells(5, 1) → Cells(6, 1) ＞となるんではないかと思ったのですが。 なりません。 「代入文」は「左辺の変数＝右辺の式」と言う形ですが「今の『右辺の式』の値を『左辺の変数』に代入する」ことしかしません。 「代入した後で、右辺の式の値が変わったら、自動的に左辺の変数の値も変える」と言う事はしません。 「一回やったら、それっきり」なのです。 例えば「一回前のiの値を、Yに保存しておく」という場合 i = 3 Y = i i = i + 1 と書きます。 「Yへの代入は、一回やったら、それっきり」ですから「i を変える前に、Yに入れておく」という方法で「一回前のiの値を、Yに保存しておく」ことが出来ます。 もし、これで「iの値を変えたら、勝手にYの値も変わる」のであれば「iを変える前の値をYにとって置く事が出来なくなってしまう」という問題が発生します。 あなたのプログラムの「X」も同じように「Xへの代入は、一回やったら、それっきり」なのです。 ですから「iの値を変えたら、X = Cells(i,1)の代入文を、毎回やり直ししないといけない」のです。
Inputbox関数を利用されてはいかがでしょうか。 (1) Dim sName as String 'シート名の変数の宣言 (2) Fname = Dir(ThisWorkbook.Path & "\*.xlsx*")　の下に、以下を追加 sName=Inputbox("シート名を入力して下さい。")　’シート名を入力 (3) Wbm.Worksheets("2016.03").Copy after:=～ 　　↓変数に変更 Wbm.Worksheets(sName).Copy after:=～ ※Inputboxに存在しないシート名を入力した時のエラー処理も必要です。
　(1)のVBAの一例としては以下の様なVBAとなります。 Sub QNo9157101_VBA_アクティブセルに対しての作業に関して1() Const OffsetValueCell = "O1991" Dim buf As Variant, myOffset As Long buf = Range(OffsetValueCell).Value If buf <> "" And IsNumeric(buf) Then _ myOffset = Int(buf) With Application .ScreenUpdating = False .Calculation = xlManual End With If buf = myOffset And myOffset + ActiveCell.Row >= 1 _ And myOffset + ActiveCell.Row <= Rows.Count Then ActiveCell.Offset(myOffset).Value = ActiveCell.Value Else MsgBox OffsetValueCell _ & "セルに入力された値が、現在選択されている" _ & "セルの行番号に対して有効な範囲にありません" End If With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub 　(2)のVBAの一例としては以下の様なVBAとなります。 Sub QNo9157101_VBA_アクティブセルに対しての作業に関して2() Const OffsetValueCell = "O1991" Dim buf As Variant, myOffset As Long buf = Range(OffsetValueCell).Value If buf <> "" And IsNumeric(buf) Then _ myOffset = Int(buf) With Application .ScreenUpdating = False .Calculation = xlManual End With If buf = myOffset And myOffset + ActiveCell.Row >= 1 _ And myOffset + ActiveCell.Row <= Rows.Count Then Range(ActiveCell, ActiveCell.Offset(myOffset)).Value = ActiveCell.Value Else MsgBox OffsetValueCell _ & "セルに入力された値が、現在選択されている" _ & "セルの行番号に対して有効な範囲にありません" End If With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
こんな感じでは？ ※定数の宣言部分は省略しています。 Dim oFS Dim oApp Dim oZip Dim oZipItem Dim oZipTo Dim retVal Dim DTpath DTpath = CreateObject("Wscript.Shell").Specialfolders("DeskTop") & "\" toZipPath = "D:\_zipTestFolder" Set oFS = CreateObject("Scripting.FileSystemObject") Set oApp = CreateObject("Shell.application") Set oZip = oApp.NameSpace(DTPath & "test.zip") 'デスクトップにtest.zipがあるとして '解凍先をセット If oFs.FolderExists(toZipPath) = False Then oFS.CreateFolder (toZipPath) End If Set oZipTo = oApp.NameSpace(toZipPath) '解凍 oZipTo.CopyHere oZip.Items, FOF_NoConfirmation + FOF_Silent oApp.shellExecute toZipPath '確認用
「ファイルのコピー」は「Windowsのエクスプローラー」で行なったと思います。 「EXCELのマクロの記録」は「EXCELの中でやった事のみ」が記録されます。EXCELの画面の外でやった事は記録されません。 で、ファイルのコピーですが FileCopy "コピー元ファイル名" "コピー先ファイル名" とやれば可能です。 ＞マクロの記録ができない操作があるのでしょうか、あるとすれば記録できないものはどのような操作でしょうか？ 「EXCELの外でやった事」はマクロ記録できません。 また、FileCopyなどの「ステートメント」と言われる命令文のうち、一部のステートメントは「マクロの記録」では生成不可能です。
PC 用 Java アプリケーションでは環境に依存するよなプログラムは作れませんが、Java FX は環境に依存したプログラム言語だとオラクル様は"宣伝"しております(あくまで"宣伝"ですので、実際は どれほどのモノか分かりませんが…) 。
#1です。 ＞元シート名（当日）に(2)が残ってしまいます。 ってあるから、残っちゃいけないのかと思いました。 シートをコピーした後は、そのコピーした先のシートがアクティヴになっていますから、そこでシートの名前を変えればいいです。 つまり xlSheet.Copy , xlBook.Worksheets(stSheetName1) のあとで、 xlApp.activesheet.Name = "複製シートの新しい名前" をとします。
APIで閉じるとか。 '宣言の追加 Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr Const WM_COMMAND = &H111 IE.Script.setTimeout "javascript:returnConfirm();", 200 Dim hwnd As Long While hwnd = 0 DoEvents Sleep 1& hwnd = FindWindow("#32770", "Web ページからのメッセージ") Wend SendMessage hwnd, WM_COMMAND, vbOK, ByVal 0&
変数名が日本語の読みそのままのローマ字表記になっている。 しかもヘボン式じゃないとか。 Gyou とか Tetu とか Syokiti とか。。。
こんにちは。お邪魔します。 > プロなら、このように数が多い場合、 > どのようにアプローチするのでしょうか？ どの分野の「プロ」をお望みなのかよく判りませんが、 私は「エクセルマクロのプロ」や「プロのプロブラマー」 ではありませんので、 答える資格はないのかな？と思ってはいますが、、、。 とりあえず、設計上の話から。 ページを表示させる必要がないのであれば、 IEやWebBrowserコントロール等を経由させずに、 WinHTTP(Microsoft WinHTTP Services, version 5.1) や MSXML2(Microsoft XML, v6.0) を使って、HTMLだけを取得して MSHTML(Microsoft HTML Object Library) で、DOM操作で処理するとか、 VBScript_RegExp_55(Microsoft VBScript Regular Expressions 5.5) で、正規表現を使って必要なデータだけを抽出するとか、 必要なHTMLタグだけを探しておいて、 MSForms(Microsoft Forms 2.0 Object Library)のDataObject 経由で、HTMLタグをクリップボードへコピーして シートに貼り付けする 等の方法があります。 > 60件もあるからなのか、 > 終わるまで10分ぐらいかかります。 ページを表示させる必要がないのであれば、 HTMLを取得するだけに留めることで無駄な時間を省けます。 条件にもよりますが、 概ね、0.1～0.2秒/件、前後が目安になる感じです。 WinHTTPやMSXML2にしても レスポンスをひとつずつ待機していると時間が掛かるので、 非同期で複数同時にリクエストしておいて クラスモジュールにてレスポンス取得したタイミングの トリガ（イベント）を受けとって、 responseTextやresponseBodyなどでHTMLを取得し、 必要な情報だけを抽出します。 具体性のないご質問ですので、質問スレの紹介に留めます。 WinHTTP（非同期）、MSHTML、の組合わせで クラスモジュールを使った例（の簡略版（約７割省略））です。 「'エクセルでXMLHTTPを用いて株の経常益を取得」 http://okwave.jp/qa/q9123746.html 先の解答・説明にある通りの準備をすれば動作の確認は出来ます。 配達状況の確認は私もよく使いますが、 "xxx.com/xxxx/=123456789" というようなURLを扱ったことはありませんし、 こちらからは、ページソースを見ることも叶わない予感がします。 必要なデータだけを抽出する為には、 ページソースを見る事が必須になりますので、 DOM操作に関しては、 実際にページソースを見ることが出来る方に相談なさるか、 事前にそちらで検討の上、ページソースを抜粋したサンプル を添えて質問なさるか、ということになるかと思います。 興味をお持ちでしたら、 リンク先質問文にあるＵＲＬのページについて、 IEで開いて、 [ページ]→[ソースの表示] または [F12]→[DOMExplorer] などで、 HTMLソースの中から必要な情報だけを探す為の手掛かりを見つける 練習などしておくと、 具体的な答えを得られるような具体的な質問が書ける ようになるかと思います。 個別のオブジェクトについての部分的な扱い方や クラスモジュールの使い方については、 Web上にも多数の情報がありますので、学び取ってください。 追加質問として、具体的にあなたの実際の必要に応えるような 応用に関する相談について、 追加回答をするつもりは（今回のスレッド（質問）では）ありませんが、 こちらから提示した回答内容に関する実践上の疑問については ご質問あれば出来る範囲でお応えするつもりはあります。 職場での「プロ」意識に則れば、 通信環境や配送会社側の各種サービス（交渉）などについても 確認・検討は必要でしょうし、 質問文にその旨書き添えてあるかどうかで回答の質も変わってくるでしょう。 また、10秒/件、というのは、やはり遅いですから、 IEを使うにしても、複数のIEタブを非同期で並行処理する、とか、 或いは複数のWebBrowserコントロールを事前に用意しておく、等、 工夫の余地はあります。 いずれにしても、現状を打破するには、 クラスモジュールを使用することになるかと思います。 取得する内容によっては（確率は低いですが）、 Webクエリ等でも、更新をＶＢＡから実行することで 多少の時短に繋がるケースもあるかも知れません。 さしあたり、以上です。
運用面でカバーしつつ行うのが現実的かなと思います。 各営業員に 『１行目には成約件数だけを記入』 その他は２行目以降に、 として dim v as variant V = split(MailItem.Body,vbnewLine) Range("A1") = v(0) で成約件数を取得。 全角数字とか行ずれ、12件などの余計な部分（件）のお掃除は考えておいた方が良いかも？ もちろん営業員に『１行目には成約件数だけを記入』を守ってもらうのが第一ですけど。 以上ご参考まで。
　一応、仕様としては、変数等で確保されたメモリーは、その実体への参照が無くなった時点で開放されることに、なっています。 　おそらく、実際には、参照が無くなり、Excelのシステムがガベージコレクションを行う機会があった時に開放されるだと思われます。 　さて、仕様ではこうなっていて、大概、このように動いているわけですが・・・デバッガーによるプログラムのブレークは、かなり特殊な状態です。 　多分、メモリーがリークしていると思われます。 　デバッグ中のプログラムを終了させた時点で、そのメモリーへのアクセスの手段は完全に失われていますので、これをイレースすることも当然出来ないですね。 　多分、Excelの再起動が、もっとも現実的な処理だと思います。これなら、確実にメモリーは解放されます。普通の運用状態では起こりえない状態ですから、これをエラー処理の一環として組み込むというのは、ちょっと非現実的かなと思います。
VBAもWinAPI使わなくても shutdownコマンドとタスクスケジューラを 組み合わせれば簡単にできます。 　 http://www.atmarkit.co.jp/ait/articles/1103/18/news103.html 　 もちろんshutdownコマンドで遠隔シャットダウンもできます。
こんにちは 二つ目のリンク先の 使い方 •下のソースをmdb2text.vbsとして保存する •mdbファイルをmdb2text.vbsにドラッグアンドドロップする って、読みましたか？
A1セルの隣に結果が出るのでよろしければ、B1セルに ＝RIGHT(A1,LEN(A1)-FIND(CHAR(10),A1)) でOKです。 CHAR(10)が改行コード、FIND(CHAR(10),A1)が、A1の左側から検索して改行コードが難文字目にあるかを探しだし、最終的にRIGHT関数でA1の右側から改行コードの手前までの文字列を抜き出しています。
こんにちは myObj.alt を myObj.Title にするのはダメなのですか？ alt 属性はimg、area、applet、inputに対して付くものでそれ以外には無い？ 属性のようなので。 後は、On Error Resume Nextでスキップするとかでしょうか？
・ファイル名は配列(やコレクション)に入れてループさせる。 ・コピー元ファイルが無かった場合は例外FileNotFoundExceptionが発生するのでこれをcatchする。 とかすれば良いんじゃないでしょうか。 コードは、MSDNの例が結構きれいだったのでとりあえずこれ見てみると良いです。 File.Copy メソッド (String, String) (System.IO) https://msdn.microsoft.com/ja-jp/library/c6cfw35a%28v=vs.110%29.aspx?cs-save-lang=1&cs-lang=vb#code-snippet-2
Drop の戻り値が Shape オブジェクトへの参照なら hoge = Drop(省略) ではなく Set hoge = Drop(省略) だと思います。
質問のコードの中の式は正しいのですか？。 その一部の Sub test2() Range("f17").Formula = "=IF(OR(R2=""新規用"",R2=""継続用""),"""",IF(COUNTIF(D10,""*改定*""),78,39))" End Sub は実行してそれらしく動きました。 ただ(+D10の部分はセル範囲を記述する引数部分ですが、+D10のような高等？な技があるか 私にはわかりません。Ｄ１０の１セルでもＤ１：Ｄ１０のように書いてもエラーにはならないことは確認しました。１セルを対象の場合に、COUNTIFを使うの？と思いましたが、高等な技ですか？ ーー もう一つ If Not IsNumeric(Range("F17").Formula) Then はなぜ必要なのか、どういう場合のために必要なのか、小生には判りません。 FormulaがNot IsNumericとは？？。 Not IsNumeric( Range("F17").Value)ではだめなのですか？
C:\\Windowsフォルダは特別なフォルダなのでアクセス権限の問題でのエラーだと思います。
フィルターで処理をしているのでレコードを更新するたびにレコード群の顔ぶれが動的に変化してしまっている。 全権取得してからフィルターを掛けるのではなく、RS.Open の段階で WHERE を使ったレコードセット取得を行えばよい。 またはわざわざ1件ずつループ処理せずとも、条件に合うレコードを一気に更新するよう UPDATE を発行してしまう。
こんにちは Sub a() 　　Dim mPSet As Long 　　Dim o　　 As Object 　　Dim b　　 As Workbook 　　 　　Set o = CreateObject("Excel.Application") 　　o.Visible = True 　　Set b = o.Workbooks.Open(freesoft) ～ こんな感じですけど、試して下さい。
＞新しい情報が現れた時、をどのように定義するのかがよく分かりません 「前回取得した情報」と「今回取得した情報」を比較すれば良いでしょう。 「新しい情報が現れた」のであれば「前回取得した情報の１行目」が「今回取得した情報に無い」かまたは「今回取得した情報の２行目以降のどこかにある筈」です。 「今回取得した情報に無い」という場合は「今回取得した情報の、全部の行が新しい情報」になります。 「今回取得した情報の２行目以降のどこかにある」のであれば「その行よりも前にあるものが、新しい情報」になります。例えば「前回の１行目が、今回の３行目にある」のであれば「１行目と２行目が、新しく増えた分」と判ります。 なお、当然ですが「今回取得した情報が、前回と変わってない場合」は「情報が増えてない」と言う事です。
＞APIを使ったマクロを書いたことがないので、Declare Function~Sub辺りの運用がわかりません。 Declare Functionで「使いたいAPI関数、そのAPI関数を収納しているDLL、関数の引数と戻り値などの仕様」を定義します。 例えば Declare Function GetPixel Lib "gdi32.dll" (ByVal hdc As Long, ByVal nXPos As Long, ByVal nYPos As Long) As Long は GetPixelという関数が、gdi32.dllに収納されていて、第一引数hdcはLong、第二引数nXPosはLong、第三引数nYPosはLongで、関数の戻り値はLong を意味します。 これは「宣言」ですから、グローバル変数を宣言するのと同じように「Sub～End Sub」「Function～End Function」の外に書きます。 で、宣言したAPI関数を呼び出す時は Sub Macro1() 'ローカル変数を定義 Dim hdc As Long, Color As Long Dim pt As POINTAPI 'マウスカーソルの位置を変数ptに取得 Call GetCursorPos(pt) ’画面のデバイスコンテキストをhdcに得る hdc = GetDC(0) 'hdcで示した画面の、pt.X、pt.Yの位置のピクセルの色を拾う Color = GetPixel(hdc, pt.X, pt.Y) '使い終わったhdcを後始末する Call ReleaseDC(0, hdc) MsgBox "色は" & Color & "です。" End Sub のように、普通に呼び出します。
こんにちは 　　Dim u As Long 　　For u = 4 To 15 　　　　入力フォーム.Controls("CommandButton" & u).ForeColor = RGB(0, 0, 0) 　　Next u こんな感じでしょうか？
条件付き書式を設定して、条件に該当分は書式で、一応目立つようになっていると思うが、さらに装飾を加える必要があるのかな。自分がやれるなら存分にやればよいが、質問までして、他人に教えてもらって、まる写しして、やるべきことか疑問。 質問者で達成済みの書式は、セルの「塗りつぶし」だとして、その詳細は、質問には書いてないので、それはそのままに、その塗りつぶしのあるセルを割り出し、その後に丸を追加するようなことを考えてみた。 小生の思い違いでうまく行かない場合は捨ててください。 ーー エクセルには「書式による検索」機能があるのはご存じか？ それを使ってみた。「書式による検索　ＶＢＡ」ＷＥＢ照会すれば記事が相当出てくる。それをアレンジしたもの。 （１）まず小生のテストでは、塗りつぶしの色は黄色でやった。質問者の条件付き書式で付けた色（コード）と下記のコードの下記部分合わせてください。 .Interior.Color = 65535 の部分。 （２）丸の形と塗りつぶしの色は、好みに変えるなら、下記コードを修正のこと （３）シートに乗せた図形は、セル幅などを利用者が変えると、その変動に連れて変動させる方法仕組みが、エクセルにあるが、その部分までは考慮してない。 （４）丸の位置はセルの左位置にしてあるが、真ん中だと、（セルの左辺位置）＋（セル幅÷２）ー（円の幅÷２） とでもするのかな。 数字だと右詰めであり、下記のままでよいのかな、と思うが、セルの文字列の場合は、丸が中央では、丸と地の文字列が衝突して見にくいのでは無いかと思う。透過など考えるのは面倒くさいので略。 Sub test03() Dim myRng As Range Dim cl As Range '--.FindFormatの設定 With Application.FindFormat '書式検索条件を初期化 .Clear 'セル背景色を設定（黄色） .Interior.Color = 65535 'フォントスタイルの設定（イタリック体） '.Font.Italic = True End With '-- '書式で検索、値はワイルドカードを指定 Set myRng = Range("A2:I22").Find(What:="*", SearchFormat:=True) If myRng Is Nothing Then MsgBox "該当データはありません" Exit Sub Else MsgBox myRng.Address With myRng ActiveSheet.Shapes.AddShape(Type:=msoShapeOval, _ Left:=.Left + 2, Top:=.Top + 2, Width:=20, Height:=.Height - 2).Select End With firstAddress = myRng.Address End If '--第２件該当以後 Set Rng = myRng Do Set myRng = Range("A2:I22").Find(What:="*", _ After:=myRng, _ SearchFormat:=True) If myRng Is Nothing Then Exit Do If myRng.Address = firstAddress Then Exit Do MsgBox myRng.Address With myRng ActiveSheet.Shapes.AddShape(Type:=msoShapeOval, _ Left:=.Left + 2, Top:=.Top + 2, Width:=20, Height:=.Height - 2).Select End With Set Rng = Union(Rng, myRng) Loop End Sub ＶＢＡでの検索では、該当第１発見と、その後の該当発見を分けなければならないので、初心者にはややこしいので、あまり勧めないが、本件はやむを得ない。 参考 もし上記の丸以外に、張り付けている図形などが、すでにない！場合は、テストしていて、丸を消して、変えたコードを実行して、何度もやりたいことがあろう。その場合は Sub test04() ActiveSheet.DrawingObjects.Delete End Sub で一遍に図形を消せる。
あらかじめ〇を図形で作成しておき見えないところに配置しておきます。 セルD3の最初の文字を囲みたいのであれば ActiveSheet.Shapes.Range(Array("Oval 1")).Select Selection.Copy Range("d3").Select ActiveSheet.Paste このようなコードでセルの一番左の文字を囲むことができます。 Oval 1は必ずOval 1になるとは限らないのでマクロの記録で実際にコピペしてみてその図形が何になるのかは調べてください。
キーを他のアプリに送るのは、実はけっこう面倒です。以下がそれをやってるサンプルですが、初心者には難しい気が・・・これを見てわからないと言われてしまったら、終了です。もっと勉強して理解できるようになってから再チャレンジしましょう、としか言えません。 http://mt-soft.sakura.ne.jp/web_dl/vb-parts/key_sendinput/ 以下はマウス操作も送れるようにしてあるサンプルです。 http://homepage2.nifty.com/nonnon/SoftSample/VB.NET/SampleSendInput.html
> ・VBAのカレントパスは > 　　ChDrive Left(ThisWorkbook.Path, 1) > 　　ChDir ThisWorkbook.Path > で変更しております。 どういうタイミングでですか？ DLL宣言時には、まだ呼ばれてないのでは。もっとも、実行時にDLLファイル探しに行くのか、よくわからんですが。 あるいは、ChDirの前に、そもそもカレントパスCurDirがどこになってるか確認とか。 対症療法だと、いっそのこと絶対パスでDLLの場所指定してしまうとか。 Declare Function hoge Lib "D:\Documents\VBA_TEST\Test4.dll" ～ 理屈の上だと、カレントパスや環境変数%PATHに記載されている場所からTest4.dll探すハズなので、Excel実行時の環境変数の方も確認してみるとか。
　LastRowの値を求める際に、 LastRow = .Range("A150").End(xlUp).Row + 1 とA150を基点にしている事や、行番号を+1にしている事は何故なのか意味が解りません。 　全て一律に LastRow = .Range("A" & Rows.Count).End(xlUp).Row で処理してしまえば良いのではないでしょうか？ 　処理に時間がかかる原因は、計算方法のモードが自動モードになっているため、VBAでセルの値を入力したり、書き換えたりするたびに再計算が行われるためですから、VBAのマクロ上で計算方法のモードを一旦、手動モードに切り替えてから値の書き換えを行う様にされると良いと思います。 Sub QNo9129440_EXCEL_VBA_早く処理をする() Dim i As longe, LastRow As Long With Application .ScreenUpdating = False .Calculation = xlManual End With For i = 1 To 12 With Worksheets(i) LastRow = .Range("A" & Rows.Count).End(xlUp).row .Range("A8:G" & LastRow).Sort Key1:=Range("A8"), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal .Range("G8:G" & LastRow).FormulaR1C1 = "=R[-1]C+RC5-RC6" With .Range("A" & LastRow) .Offset(1, 4).Resize(3, 3).ClearContents .Offset(1, 3) = .Parent.Name & "合計" .Offset(2, 3) = "前月繰越" .Offset(3, 3) = "次月繰越" .Offset(4, 3) = "合計" .Offset(1, 4).Resize(1, 2).FormulaR1C1 = "=SUM(R7C:R[-1]C)" .Offset(2, 4) = .Range("G7") .Offset(4, 5) = .Offset(2, 4) .Offset(4, 4) = .Offset(2, 4) + .Offset(1, 4) .Offset(3, 5) = .Offset(4, 4) - .Offset(1, 5) .Offset(4, 6) = .Offset(0, 6) End With With .Range("C7").End(xlDown).Offset(0, 2).Resize(1, 3) .Borders(xlEdgeTop).Weight = xlHairline With .Borders(xlEdgeBottom) .Weight = xlThin .LineStyle = xlContinuous End With With .Offset(4) .Borders(xlEdgeTop).Weight = xlHairline .Borders(xlEdgeBottom).LineStyle = xlDouble End With End With End With Next i With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
どこでエラーになるかはわかりませんが、気になるのはシートを選択しているところです。 Sheet2やSheet3という名前のシートが無いとエラーになるので、確認してみてください。
　失礼しました。 >A3からA39に日付、B列に曜日が固定で入力。 >※他ブックに転記する為に縦の曜日固定カレンダーにしています。 という条件を見落としておりました。 　曜日が固定という事であれば、曜日のセルの文字色は固定で済ます事が出来ますから、条件付き書式を使わなくとも、通常のセルの書式設定だけで文字色の設定は出来ますし、 >前月の日付と翌月の不要な日付が入った時は非表示になる という件は関数だけで実現出来ますから、VBAも条件付き書式も使わずに済ます事が出来ます。 　それで確認したいのですが、 >A3からA39に日付、B列に曜日が固定で入力。 となっていて、尚且つ、質問者様が添付されている画像ではB4セルに「月」(曜日)が入力されているという事は、B列に固定で入力されている曜日とは、B3セルに入力されていると思われる「日」(曜日)から始まっていると考えれば宜しいのでしょうか？ 　それと、特定の年の特定の月のカレンダーを表示させるためには、何年の年の何月の月のカレンダーであるのかを指定しておかねばなりませんが、その指定方法はどうなっているのかという事が御質問文には説明が御座いません。 　特定のセルに西暦年と月を入力する事で指定するのでしょうか？　それともワークシート関数のTODAY()関数やVBAのDate関数を使って現在の月を指定するのでしょうか？ 　そう言った事が不明ですので、取りあえず仮の話として、曜日は日曜日から始まっていて、A1セルに西暦年を、B1セルに月を入力する事で、何年何月のカレンダーを表示させるのかを指定するものとした場合に関して回答させて頂きます。 　まず、A3セルに次の関数を入力して下さい。 =IFERROR(DAY($A$1&"/"&$B$1&"/"&ROWS(A$3:A3)-WEEKDAY($A$1&"/"&$B$1&"/1")+1),"") 　次に、B3セルに次の関数を入力して下さい。 =IF(ISERROR(DAY($A$1&"/"&$B$1&"/"&$A3)),"",TEXT($A$1&"/"&$B$1&"/"&$A3,"aaa")) 　次に、A3～B3セルの書式設定の表示形式を[標準]に設定して下さい。 　次に、A3～B3のセル範囲をコピーして、A4～B39のセル範囲に貼り付けて下さい。 　次に、B3セルから7行ごとの曜日のセルの文字色を赤色に設定して下さい。 　次に、B9セルから7行ごとの曜日のセルの文字色を青色に設定して下さい。 　以上です。 　尚、セルに何年何月を入力するのではなく、ワークシート関数のTODAY()関数を使って年月を指定する場合には、A3セルに入力する関数を =IFERROR(DAY(TEXT(TODAY(),"yyyy/m/")&ROWS(A$3:A3)-WEEKDAY(TEXT(TODAY(),"yyyy/m"))+1),"") に、B3セルに入力する関数を =IF(ISERROR((TEXT(TODAY(),"yyyy/m/")&$A3)+0),"",TEXT(TEXT(TODAY(),"yyyy/m/")&$A3,"aaa")) に、それぞれ変更して下さい。
答えになってないといわれそうだが、参考までに上げます。 この質問を見ていて、すっきりとご存じの方は教えてください。 （１）ワードで表を作り、下記ＷoｒｄＶＢＡで表の第１列を３センチに設定して、印刷します。 物差しで測ると、３ｃｍです。今までの経験でも、ワードではセンチ指定が使えると思っています。 Sub retuhaba() ActiveDocument.Tables(1).Columns(1).Width = Application.CentimetersToPoints(3) End Sub ワードの表にＶＢＡでデータを持っていって、それの大きさを設定して、印刷する方法はあると思います。 ーー （２）一方この質問のエクセルでは Sub test03() Range("E7").RowHeight = Application.CentimetersToPoints(5#) End Sub などをやって印刷しても５ｃｍにならない。これは今までも経験していて、判らないままです。 ーー http://www.excel-excel.com/tips/vba_205.html 行高さと列幅をセンチメートル単位にする ： Excel(エクセル） などの記事があるのですが。 ーーー http://dukicco.hatenadiary.jp/entry/2015/03/03/225051 セルの行高さや列幅をmmで指定する ここらあたりの説明が真相のようだが、正確な変換は説明はあきらめている。 ー 文書やシートの左右の印刷の用紙の余白のセンチ指定は上記のような指定でもうまくゆくのかも。 -- シート素のものでなくて、シートに貼りつけた四角形でも同じだった。 ーー 邪道かもしれないが Sub 　test05() w = Application.CentimetersToPoints(5#) * 50 / 46 ActiveSheet.Shapes.AddShape(msoShapeRectangle, 96.75, 31.5, w, 54.75). _ Select End Sub のように 50 / 46のような、実測から割り出した調節項を入れて印刷する手もあるかも。 これで５ｃｍ丁度に印刷した。
　失礼しました。 　以下の様なマクロでは如何でしょうか? Sub QNo9115488_VBAエクセルNowより以前のデータ削除_改() Const DateColumn = "B" '日付が入力されている列 Const FirstRow = 31 '削除の対象となる可能性がある最初の行 Dim LastRow With ActiveSheet LastRow = .Range(DateColumn & Rows.Count).End(xlUp).row If LastRow <= FirstRow Then MsgBox "処理すべきデータがありません。" _ & vbCrLf & "マクロを終了します。" _ , vbExclamation, "データ無し" Exit Sub End If With Application .ScreenUpdating = False .Calculation = xlManual End With With .Range(DateColumn & FirstRow - 1 & ":" & DateColumn & LastRow) If Application.WorksheetFunction _ .CountIfs(.Offset(1), "<=" & Now, .Offset(1), ">1904/1/1") > 0 Then .AutoFilter Field:=1, Criteria1:="<=" & Now, _ Field:=1, Criteria2:="", Operator:=xlOr .Offset(1).Resize(.Rows.Count - 1) _ .SpecialCells(xlCellTypeVisible).EntireRow.Delete .Cells.AutoFilter MsgBox FirstRow _ & "行目以下に存在する現在の日時以前のデータを削除しました。" _ , vbInformation, "処理完了" Else MsgBox DateColumn & FirstRow _ & "セル以下には現在の日時以前の日付が見つかりませんでした。" _ & vbCrLf & "マクロを終了します。" _ , vbInformation, "削除対象無し" End If End With End With With Application .CutCopyMode = False .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
　何故、 >途中まで作ったこのプログラムを生かして という条件を付けておられるのか意味が解りません。 　Findメソッドは使わずに例えば以下の様にされると良いと思います。 Private Sub CommandButton1_Click() Dim c As Range, myRange As Range With Sheets("Sheet1") Set myRange = .Range(Cells(5, 1), _ Cells(5, .Cells.SpecialCells(xlCellTypeLastCell).Column)) For Each c In myRange If Not c.Value Like "*あああ*" Then c.ClearContents Next c On Error Resume Next myRange.SpecialCells(xlCellTypeBlanks).EntireColumn.Delete On Error GoTo 0 End With End Sub
＞Executeメソッドの実行件数を知りたいのですが、 ＞selectの場合は、抽出件数、updateの場合は更新件数を ＞０件なのか、１件以上なのかを知りたいのですが Select文を実行した場合は、ExecuteからRecordsetが返されるので、 set objRS = objADO.Execute(sql) ってやったら、objRSにRecordsetが入っています。 RecordsetオブジェクトにはRecordCountプロパティがありますから、このプロパティでレコード数が判る場合があります（デフォルトでは判りません） デフォルトのカーソルタイプが、レコード数が判らないタイプになっているので、デフォルトではRecordCountプロパティが-1になります。 ですので、 objADO.Open "Provider=SQLOLEDB;" & _ （以下略） の次の行に connect.CursorLocation = 3 ' クライアントサイドカーソルに変更 を入れて下さい。これで「objRS.RecordCount」に、セレクトしたレコード数が（レコードが無いなら０が、あるならレコード数が）入ります。 なお、Updateした件数は判らないので、事前に同じ条件でSelect文を発行して、上記の方法で対象が何件あるか調べるしかありません。 但し、ただSelectしただけでは「AをAに更新する」など、実質的に更新が入らない場合も更新件数に数えてしまうので、更新済みのレコードは返さないように、事前のSelect文を工夫しないといけません。 例えば「update テーブル set field1 = 123, field2 = 456 where column = パラメータ」をするのであれば「select * from テーブル where column = パラメータ and (field1 <> 123 or field2 <> 456)」のように、更新済みのレコードはSelectしないようにします。
=SUMPRODUCT(SUMIF(INDIRECT("'"&{1,2,3,4,5,6,7,8,9,10,11,12}&"月'!C8:C100"),J4,INDIRECT("'"&{1,2,3,4,5,6,7,8,9,10,11,12}&"月'!F8:F100"))*1)
Ｇｏｏｇｌｅででも 「エクセル 緑色の三角」で照会したら判ることでは。または「エクセル 緑色の三角　消す」 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1155267306 など多数。エクセルの有名トッピクスです。 ＶＢＡまでやるというのに（エクセルのことも、ほぼ判っているべき）、ＷＥＢの照会もして無いようだが、コード作成で行き詰まったときどうするの。 （エクセルが普及して２０年以上たち、最近では、普通人の思う疑問などＷＥＢで見つかると思って用語を工夫して照会のこと）
　「TODAY()以前」や「Date以前」ではなく >Now以前 と仰っておられるという事は、B列に入力されているデータとは「2016/01/22」などの様な「日付」データではなく、「2016/01/22 20:44:56」などの様な時刻も含んだ「日時」のデータであり、Now関数が返す値が例えば「2016/01/22 20:44:56」である場合には、「2016/01/22 20:44:55」や「2016/01/22 20:44:56」などの様な「2016/01/22 20:44:56」以前の日時が入力されている行は削除し、「2016/01/22 20:44:57」の様な「2016/01/22 20:44:56」以前の日時が入力されている行は残すという事で宜しいのでしょうか？ 　それでしたら以下の様なVBAとなります。 Sub QNo9115488_VBAエクセルNowより以前のデータ削除() Const DateColumn = "B" '日付が入力されている列 Const FirstRow = 31 '削除の対象となる可能性がある最初の行 Dim LastRow With ActiveSheet LastRow = .Range(DateColumn & Rows.Count).End(xlUp).row If LastRow <= FirstRow Then MsgBox "処理すべきデータがありません。" _ & vbCrLf & "マクロを終了します。" _ , vbExclamation, "データ無し" Exit Sub End If With Application .ScreenUpdating = False .Calculation = xlManual End With .Range(DateColumn & FirstRow - 1 & ":" & DateColumn & LastRow) _ .AutoFilter Field:=1, Criteria1:="<=" & Now, _ Field:=1, Criteria2:="", Operator:=xlOr .Range(DateColumn & FirstRow & ":" & DateColumn & LastRow) _ .SpecialCells(xlCellTypeVisible).EntireRow.Delete .Cells.AutoFilter End With With Application .CutCopyMode = False .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
VBAの本を数冊読んだぐらいで、この程度の課題には、無力感を感じると思う。 普通の人は、それだけ勉強や経験に時間がかかるものと思う。 ーー 課題は３つと思う。 ２０００のブックが作られるなんて、このシステムの設計ミスだろうと思う。個人などのエクセル利用では数十が普通だろう。 （１）フォルダ内のすべてのエクセルBookを１つずつ掴むコード （１）’（普通はブックに複数シートある場合が多いが）本件ではWorksheets(1）だけらしいので、それだけ簡単。そのシートを掴む。 （２）そのシートの、データのあるセル範囲をつかむ。コピーする。 （３）貼りつけるシートの（コピーを繰り返して集積した、その時々の）現状の）データのあるセル範囲の最終行を掴む。 そこを起点にして、データを張り付ける。 ーー コードを作る道具立ては （１）はVBScripyのFor　Eachを使うのがよかろう （２）はUsedrange、CurrentRegionが使えると思う。 （３）End(xlup).Rowでデータの最終行をつかむ ーー （１）は先日も質問があった。 Sub test02() ScreenUpdating = False Dim sh As Worksheet Set objFs = CreateObject("Scripting.FileSystemObject") Set objfolder = objFs.GetFolder("C:\Users\xxx\Documents\計数例１") For Each fl In objfolder.Files sn = fl.Name 'MsgBox sn Workbooks.Open "C:\Users\xxx\Documents\計数例１" & "\" & fl.Name Workbooks(sn).Activate '--シート For Each sh In Workbooks(sn).Worksheets 'MsgBox fl.Name & "の" & sh.Name '--処理 r = Workbooks("各ブックシート集約.xlsm").Worksheets("Sheet1").Range("A100000").End(xlUp).Offset(1, 0).Row 'MsgBox r sh.Activate sh.Range("A1").CurrentRegion.Select '第1行目は見出し行としてコピー範囲から省く sh.Range("A2:" & Selection(Selection.Count).Address).Copy Workbooks("各ブックシート集約.xlsm").Worksheets("Sheet1").Range("A" & r) 'MsgBox r Next '-- Workbooks(sn).Close Next ScreenUpdating = True End Sub １０－２０個のブックぐらい処理したら終わるコードを加えて入れてテストをして、かかる時間が耐えられるものか見てください。内容が正しいかは勿論チェック必要。 上記はシートの第1行目は見出し行という仮定でやっている。 ScreenUpdating = False　　に不満あるが、とりあえず上げてみます。 参考 上記では計数例１フォルダには、 計数例１１．ｘｌｓｍ　シート２つ 計数例２１．ｘｌｓｍ シート２つ 計数例２２．ｘｌｓｍ　シート３つ 計数例３１．ｘｌｓｍ　シート２つ　　を作ってテスト （質問者の場合では１各ブック１シートであることは読んでますが） フォルダ内にエクセルブック以外のファイルがないとか前提としている仮定はあります。
完全に経験則になってしまいますが、個人的には維持した方がいいに一票です。.NETのライブラリ的にも、古いソースをビルドする必要が出たときなどにも手間無くできる環境があるに越したことはありません。 https://msdn.microsoft.com/ja-jp/library/3za98wx7(v=vs.80).aspx こんな感じで動作的な互換は有りますが、原則として新しいフォーマットに変換されて一方通行になります。そして移行出来ない.NETの壁とかもあります。 また最近のVisualStudioは単にコードを書いてビルドするだけ以外のツールも特盛りなので上手く切り分けられるとメンテが楽かなと思います。最低限のビルド環境だけでも維持するのは価値があるかと思います。
ちょっとWEB照会すれば、みつかる事項だ。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q118638926 質問者が初心者で、（Visual StudioとOracleデータベースでのプログラムといった）簡単でないプログラムの作成をしたいなら、まずWEBの照会（Googleなど）まずやるべきだ。 また「XXアプリケーション」という用語は安易に使わないようにすべきと思う。
追記。 UsedRangeには、データが入ってないが罫線だけは入っていたり、データが入っていないが塗り潰しされているなどのセルも範囲に含まれてしまう、という欠点があります。 なので「データは一切入ってないが、罫線が引いてある」とかだと、失敗します。 一方、 Destination:=dWS.Cells(Rows.Count, 1).End(xlUp).Offset(1, 0) は「罫線などを無視し、データが入っている行の、最後の行」を指定できますが「データが足りない列では失敗する」という欠点があります。 なので「それぞれの欠点に合わせて、どちらか一方の処理をうまく選ぶ」必要があります。 例えば「B列は、必ずすべての行が埋まっている状態にして、B列を基準に、最後の行を求める」とか「罫線や塗り潰しを入れてないシートではUsedRangeを使う」とか、欠点が結果に影響しない方法を選ぶ必要があります。
こんにちは >別の人に聞いてみたのですが、変数名は違うけれど、 >アドレスが同じところを見ているので、こういう現象になるのでは？ >という指摘がありました。 こちらの話が正しいような気がします。 参照型について調べてみてはどうでしょうか？ http://homepage1.nifty.com/rucio/main/dotnet/shokyu/standard34.htm
＞if ** then （AAA と BBB） ＞のように１行で記述したいのですが、可能でしょうか？ 以下のようにします。 if ** then AAA : BBB また、以下のようにすると、複数行に分けて書く事も出来ます。 if ** then 　AAA 　BBB end if 以下のようにelseも使えます。 if ** then AAA : BBB else CCC : DDD if ** then 　AAA 　BBB else 　CCC 　DDD end if 上記のように複数行にする時は、Cのように「インデント」をすると良いでしょう。
四角形の中点（CX、CY）は？ CX=SX+(EX-SX)/2 CY=SY+(EY-SY)/2 SX=0 EX=4 SY=1 EY=3 よって、 CX=0+(4-0)/2=2 CY=1+(3-1)/2=2 つまり、中点の座標は(2,2)であることが判ります。ところで、この中点とX0、Y0との関係は、 X0=CX-(CY-SY)=2-(2-1)=1 Y0=CY+(CX-SX)=2+(2-0)=4 同じやり方で座標(X1,Y1)も計算できます。 X1=中点+X=2+=3 Y1=中点-Y=2-2=0 よって、 X1=3 Y1=0 という関係です。
エラーメッセージの通り、データアクセスプロバイダ(データベースドライバ)をインストールしていないためでしょう。 ACCESS自体は不要ですが、以下のいずれかをインストールする必要があるはずです。 https://www.microsoft.com/ja-jp/download/details.aspx?id=23734 https://www.microsoft.com/ja-jp/download/details.aspx?id=13255 JETはWindows XP のSP2かSP3あたりからOSに標準で付属しているので特別なインストールが不要ですが、ACCESSデータプロバイダについては標準では入っていないかと思います。
No3です。 >シート2の検索文字列がシート1の検索文字列と一致した場合で、 >シート2のE列に〇があった場合に、〇をコピーするのではなく、 >シート2のG列をシート1のF列へコピーするのは こちらでは問題なく処理されていますが 'シート2のC列の文字とシート1のD列の文字が一致した場合 If Not IsError(myR) Then 　　'C列の二つ右隣(E列)の値が〇の時 　　If c.Offset(, 2).Value = "〇" Then 　　　　'シート1のF列にシート2のC列のに四つ右隣(G列)の値をコピー 　　　　.Cells(myR, "F").Value = c.Offset(, 4).Value 　　Else 　　　　.Cells(myR, "F").Value = c.Offset(, 2).Value 　　End If End If >シート2のE列に〇が 〇 が正しく記載されていないのでは (セルに書かれている"〇"とコードの"〇"を確認してください。) 〇 ○ 0 o O
　失礼しました。先程のVBAには End Ifが抜けておりました。 Sub QNo9101090_EXCELVBA_複数シートパスワード設定解除() Dim ws As Worksheet For Each ws In ThisWorkbook.Worksheets If Not ws.Name Like "*集計*" Then ws.Unprotect Password:="AAAA" '(途中でやりたい処理) ws.Protect Password:="AAAA", _ DrawingObjects:=True, _ Contents:=True, _ Scenarios:=True End If Next ws End Sub
Rows(Mdata & ":" & Mdata).Select で良いです。 「Formula =」に与える文字列とは違うので「素直にそのまま」で良いです。 前回の質問の「Formula =に文字列として指定する」のとは違いますから、頭を切り替えましょう。
　一例です。 　但し、 >書き換えたシート名が、"１．○○○" や、"２．△△△"などになっているのですが、"."より前の値で並び替えられる は完全には実現しておらず、例えば "１0．○○○" と "２．△△△" があった場合などには、先頭の文字は "1"よりも"2"の方が大きいため、 "１0．○○○" よりも "２．△△△" の方が後になります。 Sub Macro() Dim temp As Variant, i As Integer, n As Integer, j As Integer, _ SN() As String, UnavailableName As String, _ myActiveSheet As Worksheet, myActiveCell As Range Set myActiveSheet = ActiveSheet Set myActiveCell = ActiveCell n = Sheets.Count ReDim SN(1 To n) For i = 1 To n SN(i) = Sheets(i).Name Next i With Application .ScreenUpdating = False .Calculation = xlManual End With For i = 1 To n With Sheets(i) temp = .Range("A1").Value On Error Resume Next .Name = temp On Error GoTo 0 If temp <> "" And Not .Name = temp Then UnavailableName = UnavailableName & vbCrLf & .Name & " → " & temp .Tab.Color = RGB(255, 0, 0) End If End With Next i If UnavailableName <> "" Then For i = 1 To n Sheets(i).Name = SN(i) Next i MsgBox "各シートのA1セルに入力されている文字列の中に、" _ & "シート名として使用出来ない文字が含まれている文字列か、" _ & "或いは既に他のシートで使用済みのシート名と同名の文字列" _ & "のものがあるため、シート名の変更が出来ません。" & vbCrLf _ & "シート名の変更が出来ないのは下記の変更箇所です。" & vbCrLf _ & UnavailableName & vbCrLf & vbCrLf _ & "マクロの実行を一旦中止しますので、上記のシートのA1セルに" _ & "入力されている値をシート名として使用可能なものに訂正してから、" _ & "本マクロによる処理をやり直して下さい。" _ , vbInformation, "シート名不適切" GoTo labelE End If For i = 9 To n For j = n To i Step -1 If Sheets(i).Name > Sheets(j).Name Then Sheets(j).Move Before:=Sheets(i) End If Next j Next i labelE: myActiveSheet.Activate myActiveCell.Activate With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub
手差し印刷をマクロの記録をしても、トレイ情報は残りませんか？ プリンターダイヤログを表示させて、sendkeyでトレイ選択する方法もあるようです。 http://oshiete.goo.ne.jp/qa/4166031.html アクセスVBAのpaperbinで可能かのかは知りませんが、念のため添付します。 http://www.happy2-island.com/access/gogo03/capter70105.shtml
" & "対象外" & " や " & "対象" & " の前後の半角スペース付きの「 & 」が余計です。 Range("L" & Mdata).Formula = "=IF(ISERROR(VLOOKUP($E" & Mdata & ",☆集計!$C:$D,2,FALSE))," & "対象外" & ",IF($D" & Mdata & ">=VLOOKUP($E" & Mdata & ",☆集計!$C:$D,2,FALSE)," & "対象外" & "," & "対象" & "))" ではなく Range("L" & Mdata).Formula = "=IF(ISERROR(VLOOKUP($E" & Mdata & ",☆集計!$C:$D,2,FALSE)),""対象外"",IF($D" & Mdata & ">=VLOOKUP($E" & Mdata & ",☆集計!$C:$D,2,FALSE),""対象外"",""対象""))" として下さい。
これはVBの勉強の際の個人的質問ですか。実際のケースでは、該当箇所を探知した後、どう表現（説明）するか（アウトプットするか）が大事で、凝るとプログラム的にむつかしい（こちらの方がむつかしいケースが多い）。 質問には目的や、どうアウトプットするのか書かないとダメでしょう。 下記では、一番簡単なMessageBox表示で手を抜いているので、それ以上は質問者が勉強してください。 下記は個別レコード処理方式ですが、データを集合的に扱うＳＱＬのような解法ではありません。 ーーー >C:\testフォルダ以下にある複数のtextファイルから 同一フォルダにあって、サブフォルダ関係にないものとする。 下記のコードを参考に上げておくから、自分の望みのファイルを選別するのは間気て見て。 Public Sub FileList() '指定のフォルダー内のファイルを全て列挙する Dim FolderName As String Dim FileName As String FolderName = "C:\Users\ＸＸＸ\Documents\" Dim i As Integer Dim strext As String 'フォルダー名が取得できたら If FolderName.Length > 1 Then 'フォルダー内の全てのファイルのパスを取得 ’i = 1 For Each FileName In System.IO.Directory.GetFiles(FolderName) '指定の拡張子のファイルだけ取得する場合 'i = i + 1 strext = System.IO.Path.GetExtension(FileName) If strext = ".txt" Then ' MessageBox.Show(System.IO.Path.GetExtension(FileName)) MessageBox.Show(System.IO.Path.GetFileName(FileName)) '<--ここ以下に処理のコードを入れる End If 'Massageボックスにファイル名を表示 'MessageBox.Show(System.IO.Path.GetFileName(FileName)) 'If i > 10 Then Exit For 'テスト用 Next End If End Sub '----処置のトリガー　簡単なので、Ｆｏｒｍ１のクリックにした Private Sub Form1_Click(sender As Object, e As EventArgs) Handles Me.Click FileList() End Sub End Class 処理の部分に ２つのやり方を挙げる （１）Instr利用　コメントアウトした行のコード Private Sub Form1_Click(sender As Object, e As EventArgs) Handles Me.Click ' StreamReader の新しいインスタンスを生成する Dim cReader As New System.IO.StreamReader("C:\Users\惇\Documents\クエリ例.csv", System.Text.Encoding.Default) ' 読み込んだ結果をすべて格納するための変数を宣言する Dim stResult As String = String.Empty Dim p As Integer ' 読み込みできる文字がなくなるまで繰り返す While (cReader.Peek() >= 0) ' ファイルを 1 行ずつ読み込む Dim stBuffer As String = cReader.ReadLine() ' 読み込んだものを追加で格納する 'stResult &= stBuffer & System.Environment.NewLine’ 'MessageBox.Show(stBuffer) ' p = InStr(stBuffer, "山田") 'If p <> 0 Then 'MessageBox.Show(Mid(stBuffer, p + Len("山田") + 1, Len(stBuffer) - p - Len("山田") - 1)) 'MessageBox.Show(Mid(stBuffer, p, Len(stBuffer) - p)) ' End If p = stBuffer.IndexOf("山田") If p > 0 Then MessageBox.Show(stBuffer.IndexOf("山田")) End If End While ' cReader を閉じる (正しくは オブジェクトの破棄を保証する を参照) cReader.Close() ' 結果を表示する 'MessageBox.Show(stResult) End Sub （２）.IndexOf　の利用 Ｉｎｓｔｒと同じようになるので、位置のみ求めている。 ーーー 処理の流れは、 （１）フォームのクリックイベント （２）ファイルを見つける（選別する） （３）文字列のあり場所を見つける （４）結果表現 該当が多数あればどう表現するか。 また他の処理が後に控えているのか。 ーー 上記はWEBで出てくる記事の解説のコードを一部修正したもので、質問者でもＧｏｏｇｌｅ等で調べられるはずです。
>' 貼り付け先行を+1 > targetCol = targetCol + 2 ' 貼り付け先行を+1 参考に If targetCol >= 13 Then 　　targetCol = 7 　　targetRow = targetRow + 2 Else 　　targetCol = targetCol + 2 End If
簡単です 一回目に実行された時に C2 の文字が置き換わって、さらに置き換わったことに関して再度同じイベントが起きて・・・・・ この繰り返しでこの部分が無限に繰り返されているからです こう書きかえればすぐにわかると思います Private Sub Worksheet_Change(ByVal Target As Range) 　　If Target.Row = 2 And Target.Column = 3 Then 　　　　Range("C2").Value = StrConv(Range("C2").Value, vbProperCase) 　　End If 　　If Target.Row = 2 And Target.Column = 4 Then 　　　　Range("D2").Value = StrConv(Range("D2").Value, vbProperCase) 　　End If Msgbox "事象発生" Stop End Sub C2 だけに関しては下記のように書き換えればオッケイと思います Option Explicit Private Sub Worksheet_Change(ByVal Target As Range) If Target.Row = 2 And Target.Column = 3 Then If Range("C2").Value = StrConv(Range("C2").Value, vbProperCase) Then Exit Sub Range("C2").Value = StrConv(Range("C2").Value, vbProperCase) End If End Sub さらに、 D2 のセルに関しても同じ事象が発生していますから、そのあたりは Flag を立てるなりして問題解決してください。
Q、どのようなコードになりますか？ A、下記の計算式を表現したコードになる筈です。 X2=(X1+X3)-X0 Y2=(Y1+Y3)-Y0
　回答No.5の続きです。 myDefault = Format(Date, "yyyy/m") label1: myDate = Application.InputBox("年月を下記のいずれかの形式で入力してください" _ & vbCrLf & vbCrLf & Year(Date) & "/1" & vbCrLf & Year(Date) & "/01" _ & vbCrLf & Year(Date) & "-1" & vbCrLf & Year(Date) & "-01" _ & vbCrLf & Year(Date) & "年1月" & vbCrLf & Year(Date) & "年01月" _ & vbCrLf & Format(Year(Date) & "/1/1", "ggge年m月") _ & vbCrLf & Format(Year(Date) & "/1/1", "ggge年mm月") _ & vbCrLf & Format(Year(Date) & "/1/1", "gge年m月") _ & vbCrLf & Format(Year(Date) & "/1/1", "ggge-m") _ & vbCrLf & Format(Year(Date) & "/1/1", "gge-m") _ & vbCrLf & Format(Year(Date) & "/1/1", "ge-m") _ & vbCrLf & Format(Year(Date) & "/1/1", "ge.m") _ , "年月の指定", myDefault, Type:=2) If myDate = vbNullString Or myDate = False Then temp = MsgBox("値が入力されていません。" & vbCrLf _ & "年月の入力をやり直しますか?" & vbCrLf & vbCrLf _ & "[はい]:年月の入力をやり直します" & vbCrLf _ & "[いいえ]:処理を中止してマクロを終了します", _ vbYesNo + vbExclamation, "年月未入力") If temp = vbNo Then GoTo labelE Else GoTo label1 End If End If If myDate Like "*?年*?月" And IsDate(myDate & "1日") Then _ myDate = Format(myDate & "1日", "yyyy/mm/dd") For i = 1 To 3 temp = Mid("/-.", i, 1) If myDate Like "*?" & temp & "*?" And IsDate(myDate & temp & 1) Then _ myDate = Format(myDate & temp & 1, "yyyy/mm/dd") Next i If Not (myDate Like "####/##/##" And IsDate(myDate)) _ Or myDate = "9999/12/01" Then GoTo label2 Nen = Year(myDate) Tuki = Month(myDate) If Nen < 1904 Then GoTo label2 myDefault = Format(myDate, "yyyy/m") temp = MsgBox("入力された年月は " _ & Format(myDate, "ggge年(yyyy年)m月") & " です。" & vbCrLf _ & "この年月で処理を実行しますか?" & vbCrLf & vbCrLf _ & "[はい]:この年月で処理を実行します" & vbCrLf _ & "[いいえ]:年月の入力をやり直します" & vbCrLf _ & "[キャンセル]:処理を中止してマクロを終了します", _ vbYesNoCancel + vbQuestion, "指定年月の確認") Select Case temp Case vbCancel GoTo labelE Case vbNo GoTo label1 Case Else myMsg = "" End Select With Application .ScreenUpdating = False .Calculation = xlManual End With Range("A:H").Clear With Range("B1") .Value = DateSerial(Nen, Tuki, 1) .NumberFormatLocal = "yyyy""年""m""日""" End With With Range("B2") .Resize(, 7) = Split("日,月,火,水,木,金,土", ",") myOffset = Weekday(DateSerial(Nen, Tuki, 1)) - 2 For i = 1 To Day(DateSerial(Nen, Tuki + 1, 0)) .Offset(Int((myOffset + i) / 7) + 1, (myOffset + i) Mod 7).Value _ = DateSerial(Nen, Tuki, i) Next i .Resize(7, 7).HorizontalAlignment = xlCenter .Offset(1).Resize(6, 7).NumberFormatLocal = "d" .Resize(7).Font.Color = RGB(255, 0, 0) .Offset(, 1).Resize(7).Font.Color = RGB(0, 255, 0) .Offset(, 6).Resize(6).Font.Color = RGB(0, 0, 255) End With AssociatedCells = "" n = 0 With DataSheet For i = 5 To 500 For j = 1 To 5 temp = .Range(DataColumn(j) & i).Value If temp Like "*#/*#/*#" And IsDate(temp) Then If Year(temp) = Nen And Month(temp) = Tuki Then n = n + 1 AssociatedCells = AssociatedCells & "," & i With Range("B2").Offset(Int((myOffset + i) / 7) + 1, (myOffset + i) Mod 7) .Interior.Color = 65535 With .Font .Bold = True .Size = 30 End With End With Exit For End If End If Next j Next i If n = 0 Then MsgBox Format(myDate, "ggge年(yyyy年)m月") _ & "分のデータは見つかりませんでした。" & vbCrLf _ & "マクロを終了します。", vbInformation, "該当データ無し" GoTo labelEnd End If AssociatedCells = Mid(Replace(AssociatedCells, ",", "," & DataColumn(0)), 2) i = 0 For Each c In .Range(AssociatedCells) temp = "" i = i + 1 For j = 1 To 5 temp = temp & ItemName(j) & " : " & .Range(DataColumn(j) & c.Row).Value & vbCrLf Next j temp = MsgBox( _ temp & vbCrLf & ItemName(0) & " : " & .Range(DataColumn(0) & c.Row).Value, _ vbInformation + vbOKCancel, _ Nen & "年" & Tuki & "月のData　[" & i & "/" & n & "]") If temp = vbCancel Then Exit For Next c End With GoTo labelE label2: MsgBox "入力された値は年月として扱う事が出来ません。" _ & vbCrLf & "年月の入力をやり直して下さい。", _ vbOKOnly + vbExclamation, "入力値不適切" GoTo label1 labelE: MsgBox "マクロを終了します。", vbInformation, "終了" labelEnd: With Application .Calculation = xlAutomatic .ScreenUpdating = True End With End Sub 　以上です。
こういう程度の内容の質問は、Googelででも、 「エクセル　VBA　数値データか」で照会すれば、説明例が出てくる。 http://excelnavi.livedoor.biz/archives/2958665.html http://officetanaka.net/excel/vba/function/IsNumeric.htm など。 今は（VBAが使われて２０年経ち）WEBの記事が充実して、WEB照会で回答は得られる場合が多いことを覚えておいて。 ーーー それよりも ＞指定したセルがひとつのとき反応する ＞With Target の記述から、シートのイベントのChangeイベントやSelectionChangeイベントのことではないかと思うが、それを質問に書くべきです。 TargetはそのRangeのことなので（エベントが発生したとき、渡してくれる引数にTarget As Rangeとあるでしょう）、If .Count = 1 Then は１セルだけが選択されている場合に限って、処理対象にしているということ。 そのセル（Target）が数字の場合に、何か処理をしたいなら、 If .Count = 1 Then '>なおかつ,なので If IsNumeric(Target) Then 　（処理のコード）かまたは「とび先のサブルーチン名」を書く Else "選択セルは数字ではありません"　とかその場合の処理を書く End If End If こういうコーナーに質問して回答させるのも良いが、回答を理解できない程度だと意味がない。本やWEBで勉強して、理解できるよう備えておかないと回答が無駄です。 ーー 複数セルのChangeやSelectionChangeは少し複雑です。 イベントを察知する範囲を限定する（チェックする）のは、たとえば Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Application.Intersect(Target, Range("B1:B5")) Is Nothing Then Else MsgBox "B1:B5 の範囲のイベントです。" End If End Sub ーー 質問と関係ないですが参考に どういう現れ方をするか体験してみて。 Private Sub Worksheet_Change(ByVal Target As Range) MsgBox "Change " & Target.Count End Sub Private Sub Worksheet_SelectionChange(ByVal Target As Range) MsgBox "Selection " & Target.Count End Sub ーー 質問の表題が「数値の時ではなく、データがあるとき 」で、質問の中での文章で 、「数値データがあるときに実行するにはどのように」と書くのは、わかりにくいよね。
本件に関し素人ですが、記してみます。以下個人的な見解ですから、博学の人には、「そうはいえない」、と思う部分もあるでしょう。 ＶＢＡの解説本のなかでは、ほとんど解説はないと思います。ＶＢＡの本は初心者むけの本しか販売されないからでもありますが、ＶＢＡ（エクセルに限られるのが実情）＋正規表現の単独本もないと思います。むしろ正規表現が少々取り上げられているのは、ＶＢＳＣＲＩＰＴの本の中です（ＲｅｇＥｘｐ．それも数本ですが）。 正規表現は、ＵＮＩＸ系のなかで、学者の発想から出て、普及しており、ＶＢＡではワイルドカードやＬＩＫＥ演算子に似た発想が見られます。 Ｍｉｃｒｏｓｏｆｔは言語的なものは、Ｂａｓｉｃから始まっており、元からそういう発想をあまり取り上げてこなかったと思います。ＶＢＳＣＲＩＰＴやＶＢ．ＮＥＴ（ＶＢ２００２以後）、サーバー関係の処理言語には、世の中の正規表現の普及（ＷＥＢ処理の普及）に合わせて、取り上げているように思います。 正規表現の発想・ニーズは、時々必要と思いますが、実現（パターン作成）には、閃き・アイデアが必要で（難しく）、ＶＢＡをやる程度の小生には馴染めません。デバッガ的なものもないようです。文字列をつくって一気に実現する（Ｅｘｅｃｕｔｅ）のでなく、（小生は）ステートメントをならべて、順次処理で実現する方式に馴染んだせいもあります。 （例　ＶＢＡのＩｎｓｔｒ関数利用） 事務系の文字情報を扱う場合は、小生はワイルドカードやＬＩＫＥ演算子、Ｉｎｓｔｒ関数利用でほぼ賄えるとおもってます。質問者は、文章解析などをするのでしょうか。 プログラム言語（処理系）を離れて、表題に「正規表現」と入った本は数本あります。 ＷＥＢで「ＡＭＡＺＯＮ　本」でサイトをだし、書名に「＊正規表現＊」と入れると出版された本・古本が出てきます。（背景としてＰＨＰなどを念頭に解説されているなど。） ＷｏｒｄのＶＢＡだと、少し様子が違ったように思いましたが、小生は突き詰めていません。ＷｏｒｄＶＢＡの本も稀少です。
>２つブックを開いていて、ブック名も同じ名前で との事ですが、Excelでは、例え別のフォルダーにあるファイルであっても、全く同名のブックは、例え読み取り専用モードであっても開く事は出来なかったと思います。 　ですから、その2つは一見するとブック名が同じである様に見えても、例えば片方の拡張子が.xlsのBookで、もう一方が.xlsxの拡張子を持つBookであると言ったように、厳密には異なるファイル名のBookではないかと思います。 　その場合は以下の様なVBAを使う事で、現在、読み取り専用モードで開いている全てのBookを、名前を付けずに閉じる事が出来ます。 Sub QNo9088918_Excel_VBA_ワークブック閉じる() Dim i As Long For i = Workbooks.Count To 1 Step -1 With Workbooks(i) If .ReadOnly = True Then .Close SaveChanges:=False End With Next i End Sub
処理速度を上げるには画面更新停止する事が効果的です。 効果があるか不明ですが、データのある最終行を検索しセル範囲を設定し変数に格納後sumif関数に指定しています。 記載コードではmyCnt7をloop前で１を足していないのでmyCnt7は2のまま変動しません、よって無限ループで終了しないはずです。本当に終了して結果がでたのでしょうか？ 確認はしていませんので、デバックして修正下さい。 Sub test() Dim i, j As Integer Dim M, MaxR1, MaxR2 As Long Dim MyBR, MyRR, MyBC, MyCC As Range Dim ws1, ws2 As Worksheets Set ws1 = Worksheets("◆") Set ws1 = Worksheets("★") '画面更新停止 Application.ScreenUpdating = False 'Worksheets("◆")("★")B列の最終行取得 MaxR1 = ws1.Cells(Rows.Count, 2).End(xlUp).Row MaxR2 = ws2.Cells(Rows.Count, 2).End(xlUp).Row 'sumifのセル範囲を設定 Set MyBR = ws1.Range("B1:R" & MaxR1) Set MyRR = ws1.Range("R1:R" & MaxR1) Set MyBC = ws2.Range("B1:C" & MaxR2) Set MyCC = ws2.Range("C1:C" & MaxR2) myCnt7 = 2 With Sheets("●") Do For j = 4 To 10 Step 3 .Cells(myCnt7, j).Value = WorksheetFunction.SumIf(MyBR, .Cells(myCnt7, j - 1), MyRR) - WorksheetFunction.SumIf(MyBC, .Cells(myCnt7, j - 1), MyCC) Next myCnt7 = myCnt7 + 1 Loop While myCnt7 > 201 End With '画面更新再開 Application.ScreenUpdating = True Set ws1 = Nothing Set ws2 = Nothing Set MyBR = Nothing Set MyRR = Nothing Set MyBC = Nothing Set MyCC = Nothing End Sub
質問意図をちゃんと捉えられているか若干微妙なところがありますが。。 おそらく、insertでレコード登録した際に、DB側で主キーの値が自動採番されるなどするのでその値を取得してローカルの情報を更新したい、というような内容かと想像します。 TableAdapter自体では無く、そのINSERT/UPDATE等で利用されるCommandクラスにはデータ登録の際に情報を戻す仕組みがあります。 それらの概要については以下などが参考になるかと思います。 https://msdn.microsoft.com/ja-jp/library/ks9f57t0%28v=vs.110%29.aspx https://msdn.microsoft.com/ja-jp/library/59x02y99%28v=vs.110%29.aspx ただ、上記に記載されている内容は少々状況が特定的過ぎて、すぐにはわかりずらいかと思いますので多少一般化した(つもりの)補足を記載します。 まず、CommandクラスのParametersにはParameterDirection.OutputやParameterDirection.ReturnValueのパラメータによって(もちろんクエリ側も値を戻すように書いて)出力値を取得する事が出来ます。 また、ParameterはDataColumnと対応させることができます。(DataTableなどでUpdate()をする場合、ParameterDirection.Inputのパラメータでは普通に行っているかと思います) 上記に加え、CommandのUpdatedRowSourceプロパティにてOutputParametersを設定することで、クエリの出力をDataTable(DataRow)に取り込むことが出来ます。 質問者さんが現在利用しているINSERT/UPDATEに利用しているストアドが具体的にどのように値を返すかわかりませんが、戻り値とあるのでもしかするとParameterDirection.ReturnValueを使うパターンかもしれません。 ちなみに当方は、returning句を利用してDB側で採番したIDとCREATEやMODIFY日時などを登録と同時に取得する、といった形で良く利用しています。 また、ついでに記載しておきますと、UpdatedRowSourceにFirstReturnedRecordを指定すると、出力パラメータではなくselect結果によるデータの反映(取得)を行うことが出来るようです。(実際に自分で使ったことはないですが) これは、INSERTのクエリで「insert into **** values(**); select **** from ***;」といった感じで、1つのコマンドで更新したレコードをselectして値を戻す(あるいは良く知りませんがそのほかの方法でレコードが返るようなクエリを指定する)といったような使い方になるようです。 またあるいは、ラウンドトリップ数の多少の増加やデータ転送量が気にならないような場合で、必要なデータを特定出来るのであればselect(Fill)し直す手もあるかとは思います。
「RDT」ではなく「RTD」の間違いではありませんか？ https://support.office.com/ja-jp/article/RTD-%25E9%2596%25A2%25E6%2595%25B0-e0cc001a-56f0-470a-9b19-9455dc0eb593?ui=ja-JP&rs=ja-JP&ad=JP&fromAR=1
質問者は、VBA以外の他言語などで、熟練されているようですが、 ＞美しくない とはどういう点ですか。それを書かないと質問の内容が伝わらない。 小生も、エクセル関数を使ったものに取って、セル範囲をRange（）などで 示さないといけないのは、うっとうしく感じるが。 言いたいことを想像すると、 （１）セル範囲をRangeなどを使わないで示したい。 Sub test01() Range("D2") = [SUM(A1:A3)] End Sub （２）Evaluateを使わないーー＞普通のVBAでのワークシート関数の使い方。 Sub test02() Range("D4") = WorksheetFunction.Sum(Range("a1:A3")) End Sub （３）Application.WorksheetFunctionを付けるのが長い文字列になる （複数の箇所で関数を使う場合など） Sub test04() Set wf = Application.WorksheetFunction [D8] = wf.Sum(Range("a1:A3")) End Sub （４）範囲指定を操作者（利用者）が行う場合 Sub test03() Set a = Application.InputBox("加算する範囲", Type:=8) Range("D6") = WorksheetFunction.Sum(a) End Sub （５）その他 オブジェクト階層を別記法とセル番地の記法の簡略化 Sub test05() Set wf = Application.WorksheetFunction [D10] = wf.Sum([a1:A3]) End Sub ーー 他言語は別として、 VBAにおける、Evaluateは、Excel4.0マクロの中の１つで、今では使用を 推奨されていないと思う。エクセルにVBAが使えるようになった、１９９５ 年以前の関数とマクロの合いの子みたいなものだ。VBの文法を取り入れる VBAのできる前のもの。VBAではややこしい記述になるがExcel4.0マクロでは できるものがあって、たまに質問にでる。 （１）ブックを開かないで、セルの値を取る （２）本件の文字列式を与えて、関数や代数式計算 ーーーー WEB記事 http://excel-ubara.com/excelvba4/EXCEL219.html ーーー 表題の＞代用する この意味は？何を代用するのか？ ーー 質問全般について、なぜEvaluate利用なのと思ってしまう。
「テキスト」ボックスというように、入力表示や結果は文字列（テキスト）で処理されます。 だから「テキストボックス」の書式設定は、設計されていません。 「書式」は、エクセルでは、「数」に関するもので、文字列に対してものは１，２しかなく（＠など）、余り役立つものではない。エクセルでは、「日付」も数字なのをご存じか。 （書式は１．数　２．日付　３．文字列について考えることができる。日付はその１つ。） （エクセルの書式はNumberFormatといいます) だから無理難題を言わず、VBAでは諦めるべきと思う。 ーーー ただ疑似的な、突破の方法は、下記ではどうかな。 （１）ユーザーフォームを挿入 （２）そこにテキストボックス１つと、コマンドボタンを１つ設ける。 テキストボックスは１行とし（MultiLineはFalse)、横幅は入力桁数＋α分を適当に。 Dim w Private Sub CommandButton1_Click() MsgBox TextBox1.Value TextBox1.Text = "" w = "" End Sub Private Sub TextBox1_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) w = w & Val(Chr(KeyCode)) TextBox1.Value = Format(w, "currency") End Sub これで１数字文字を入力するごとに、テキストボックスに、今までに入力した集合数字について、先頭に￥と３桁ごとカンマが入ったものが出る。 コマンドボタンを押すと、最終のそのテキストボックスの窓の文字が表示される。（変数に入れれば、その後使える） TextBox1.Valueでなくて、変数ｗを使えば「￥」、や「,」なしの数字集合文字列が使える。 あと、入力文字が数字かどうかのチェックを入れるのも必要かと思う（VAL()したものを IsNumeric)でチェック） ー この方法は小生が思いついたもの（WEBから引いてきたものではない）なので、使用者は十分テストして、困ったケースがないか吟味が必要です。 イベント・プロシージュアーというものは、入力者が何をするか判らず、扱いはむつかしいと感じる。 ーー コンボも同じことは考えられると思う。
やろうと思えばできないことはないでしょう。 ただし、重要なデータが詰まったSQL Serverをインターネットに晒すなんていうのは恐ろしくて考えられません。 ASP.NetなどのWebアプリケーションが一般的なのは、データベースそのものを見せることなく、中のデーターの必要な部分だけを必要な人に見せることができる(ように作ることができる)からではないでしょうか。
いろいろなやり方（構想というかメソッドというか）が考えられる。下記はあくまで簡単そうな１案。 「多対多」行データを、一遍でマッチングして、存在の有無を検出できる方法は、多分ないと思うので、繰り返し法を使うことになるだろう。 もしFind（メソッドという）を使わないないなら、２重ループの繰り返しで処理する。（初心者に一番わかりやすい方法とは思う。Find≫メソッドはむつかしい） 両データを各々ソートして、データマッチング法で、あり場所＝行を割り出す方法もある。 ーーー 下記は　Sheet2のA列に 2015-0002 2015-0003 などを、あらかじめ入れておく場合です。 ほかに配列に入れる、プログラムコードに書くなどいろいろな方法が考えられる。 どこに置くか、それを質問に書いておかないと、質問として不十分だろう。 小生は、うっかりSheet1のG列に削除すべきデータを入れて、うまくできたと思って、誤って回答を上げてしまうところだった。削除するデータ行（G列データ）がRows(i).Delete で削除されてしまう場合がありうるので要注意。（データ削除問題は初心者には、むつかしいと言いたい） 下記のような方法は、毎行ごと繰り返し法といえるが、下の行から上に駆け上がるように 処理するのがコツ。なぜか考えてみて。経験からおみつく思いつくものだが、初心者には思いつくかな。 ーーー 標準モジュールに Sub test01() lr = Worksheets("Sheet1").Range("B100000").End(xlUp).Row '元データ最終行番号 lrb = Worksheets("Sheet2").Range("A1000").End(xlUp).Row '削除データ列（A列にあるとする）最終行番号 MsgBox lr '確認用 Dim x As Range For i = lr To 2 Step -1 'データ最下行から上へ （第２行目からデータ開始とする） Set x = Worksheets("Sheet2").Range("A2:A" & lrb).Find(Worksheets("Sheet1").Cells(i, "B")) 'G列にあるか If x Is Nothing Then '見つからなければ（何もしない） Else '見つかれば Worksheets("Sheet1").Rows(i).Delete '行削除 End If Next i End Sub ーー 元データのおおよその行数なども書いておいてほしい。１万以下、１０万台、１００万台 など。方法により、処理に時間がかかる場合もありそうなので。 ーー ほかに ＞特定の文字（文字？） ＞数値があります（数値？） ＞ランダムに40（ランダムとは？） に引っかかったが、深追いしていない。
ワークシートに対するADO操作は結構速いと思っていたのですが、 12万行強の郵便番号辞書から、1000件の郵便番号リストに該当するものを抽出したら、 25.7分かかりました。（Win7Home(64)、xl2010、Core i5、3.2GHz) INNER JOINでやってみたらどうかと思いましたが、複数ワークシート間の結合は出来ない様です。 そこで、連想配列でやってみると、下記の様な例で2.4秒前後で出来ました。 ADOだと、元のデータ件数m×照合データ件数nのかけ算的になると思いますが、連想配列を用いると、元のデータ取込m件＋照合n件の足し算で出来る違いだと思います。 なお、ループを回す前にセル範囲→Variant配列に入れる様な高速化手段も取っています。 ご参考まで。 Declare Function GetTickCount Lib "kernel32" () As Long '抽出対象の元テーブルのキーとなる項目はユニーク、即ち１行しか抽出されない事が前提 Sub myDic() Dim myDic As Object Dim myTable As Range Dim srcColumn As Variant Dim startTime As Long Dim refTable As Variant Dim i As Long Dim destRange As Range startTime = GetTickCount Application.ScreenUpdating = False Application.Calculation = xlCalculationManual 'Sheet1!$A$1:$O$123428 2013年頃取り込んだ郵便番号辞書 12万行、3列目が郵便番号 Set myTable = Sheets("Sheet1").Range("A1").CurrentRegion '郵便番号辞書の3列目を配列に取込 srcColumn = myTable.Columns(3).Value Set myDic = CreateObject("Scripting.Dictionary") 'コピー先 Set destRange = Sheets("Sheet5").Range("A1") For i = 2 To UBound(srcColumn, 1) myDic.Item(CStr(srcColumn(i, 1))) = i Next i '抽出するキーのリスト　1000行 refTable = Sheets("Sheet4").Range("A1").CurrentRegion.Value For i = 1 To UBound(refTable, 1) myTable.Rows(myDic.Item(CStr(refTable(i, 1)))).Copy Destination:=destRange Set destRange = destRange.Offset(1, 0) Next i Application.Calculation = xlCalculationAutomatic Application.ScreenUpdating = False Debug.Print CStr(GetTickCount - startTime) End Sub
エクセルのファイルごと渡せばいいのでは？
ANo.1です。 Case &H2 _start = True Str = "" Return では？
デザイン部に関する変更がないのであれば、 Form1.Designer.vb内のクラス名を変更するだけでできそうですが・・・ どうでしょうかね？ やる前にバックアップを取ってくださいね。
ＡＤＯで、エクセルのデータを使っていますが、ご参考にしてください。 ポイントは、下記モジュールのＳＱＬ分の、strSql⁼の部分です。 データベースの指定部分は、.mdbなりに変えてください。 例データ　 SheetIのＡ１：Ｄ８に 社員no氏名所属年齢 12山田総務23 34木村総務34 56笠原工事36 78吉田人事41 63池田サービス26 33鈴木工事41 38今井工事41 があり、この中の最高齢のレコードを探します。 結果は４１歳の３人（吉田、鈴木、今井）です。 ーー 標準モジュールに Private Sub test16() Dim adoCON As New ADODB.Connection Dim adoRS As New ADODB.Recordset Dim strSQL As String Dim odbdDB As Variant 'データベースのパスを取得（ExcelブックをDBとする） odbdDB = ActiveWorkbook.Path & "\SQL例１.xlsm" 'データベースに接続する Set adoCON = New ADODB.Connection adoCON.Open "Driver={Microsoft Excel Driver (*.xls, *.xlsx, *.xlsm, *.xlsb)};" _ & "DBQ=" & odbdDB 'カーソルをクライアント側に設定 adoRS.CursorLocation = adUseClient '--- strSQL = "SELECT A.氏名,A.所属,A.年齢 FROM [Sheet1$] AS A WHERE A.年齢 = (SELECT MAX(B.年齢) FROM [Sheet1$] AS B);" '---- 'レコードセットを開く adoRS.Open strSQL, adoCON, adOpenDynamic 'テーブルを読み込む Do Until adoRS.EOF MsgBox "氏名=" & adoRS.Fields(0).Value & ",所属=" & adoRS.Fields(1).Value & ",年齢=" & adoRS.Fields(2).Value adoRS.MoveNext Loop 'クローズ処理 adoRS.Close Set adoRS = Nothing adoCON.Close Set adoCON = Nothing End Sub 結果はMsgboxの行に出ますので、変数にでも入れて（x=adoRS.Fields(0).Value ，など）、何かに使ってください。 ーーー 上記例の、４１歳の３人のレコードを捉えました。ＡＣＣＥＳＳにもご存じのように、集合関数のＭＡＸ関数はあります。しかし MAＸ(年齢）では、最高齢は４１歳ということは、簡単にＳＱＬで組めて求まりますが、 質問者のニーズでは、レコード的に、誰（氏名）で、その他情報（所属など）はどうなっているか、必要でしょう。 ＳＱＬは集合論的に処理するが、結局レコード処理に行き着かざるを得ないニーズが多いだろうとおもう。 ＳＱＬの処理系により、欠課が画面に出ても、それをその後の処理で何かに使いたいときは、はたと困ってしまうのでは。 ーー またＳＱＬでむつかしい点は、 SQLでは、 SELECT A.氏名,A.所属,A.年齢 ,MAX(A.年齢）FROM ・・というような書き方はできませんので上記のようになります（「相関クエリ」（第１法）） そのほかのやり方（書き方）もあるようです。InnerJoinを使う（第２法） ーー 質問ではＳＱＬを使いたいようだと解して上記をやってみましたが、 （第３法）いっそのこと各レコードを１つづつ（MoveNext)捉えて（シーケンシャルに）、今までの年齢の最大値と今回の年齢値を比較して、今回のものが大きければ、今までの年齢の最大値を今回のものに置き換えて,最後のレコード（rs.EOF)までそのロジックを繰り返す（最大値を求めるアルゴリズムを使う)方法もあると思います。 ーー エクセルの関数なら簡単なのに、と思ったものです。 ーー Googleなどで「sql 最大値」で照会して、出てくる記事を読んでください。
これじゃないですかね。 http://stackoverflow.com/questions/12965032/excel-vba-controlling-ie-local-intranet
http://bbs.wankuma.com/index.cgi?mode=al2&namber=69301&KLOG=118 に出てる様な DEVMODE 構造体のプライベート領域で設定になってるからではないでしょうか。 情報が公開されてる事は余りないでしょうから、 UI(ダイアログ)に対してウィンドウメッセージを送信して、ウィンドウ操作する他ないのではと。
なぜDSUM関数なのか？ 余談だが、ＶＢＡでやるなら（泥臭いが）繰り返し加算方法が標準だろう. 参考 Sub test01() s = 0 dr = ActiveSheet.Range("A10000").End(xlUp).Row For i = 1 To dr If Range("A" & i) >= #9/4/2015# And Range("A" & i) <= #9/7/2015# And Range("B" & i) = "b" Then s = s + Range("C" & i) End If Next i ActiveSheet.Range("G" & dr) = s End Sub ’－－－ 本題に入って、 関数でやるならＳＵＭＩＦＳではないか？ むつかしい関数に注目して分からないからといって大勢の 読者を煩わさなくてもい良いだろう。 例データ 処理日科目計数１計数２計数３ 2015/9/1a1 2015/9/2b2 2015/9/3b3 2015/9/4c4 2015/9/5a1 2015/9/6a2 2015/9/7b3 以下略 標準モジュールに Sub test02() d1 = Format(#9/4/2015#, "yyyy/mm/dd") MsgBox d1 d2 = Format(#9/7/2015#, "yyyy/mm/dd") MsgBox d2 Range("G25") = Application.WorksheetFunction.SumIfs(Range("C3:C25"), Range("A3:A25"), ">=" & d1, Range("A3:A25"), "<=" & d2, Range("B3:B25"), "=" & "b") End Sub ＶＢＡのWorksheetFunction.では、「セル範囲を Range("B3:B25"),式 で書く」など大まかなルールはあるが、引数の特に日付や比較演算子（文字列で書かせる場合が多い）は、ＶＢＡの達人でないと、やってみないとわからないのであないか。小生もいろいろやって時間を相当使った。 ｄ１とｄ２を滅行にしているのは質問者に取って許されるのか。式の中に組み込むのは質問者はできるだろう。 質問者もいろいろやってみたのか？。 ーー エクセルでＳＱＬを扱えば、Ｂｅｔｗｅｅｎなんてのも使えるが、それは誰もやらない。 （ＶＢＡにはＢｅｔｗｅｅｎ演算子のようなものはないということ。） ＞ACCESSのDSUM関数のような記述ができませんでしょうか？ エクセルの方からの発想の方が普通だろう。（エクセルのように、Ａｃｃｅｓｓでも ○○はできませんか？） ーー （１）関数式をセルに埋め込む方法 （２）Ｅｖａｌｕａｔｅを使う方法（興味があればＷＥＢ照会せよ） その他もあるかもしれない。
> １）アプリＡを最小化するメッセージを送る これは成功しているんでしょうか？ > ２）アプリＡの目的のボタンを通信で押す。 これは成功しているんでしょうか？ > ３ａ）アプリＡを元のサイズにするメッセージを送る なぜ元のサイズに戻すんでしょうか？ Ａメニューが表示されない？ 順番としては、 (1)アプリＡを最小化 SendMessage (2)アプリＡの目的のボタンを押す AppliObj.DoButton( TARGET_BUTTOM ) (3)Ａメニューを最前面に表示する SendMessage（最小化されていれば元のサイズに。いらないかも） SetForegroundWindow（最前面に）
回答No.1、追記です。 書き忘れたことが２点ありました。 > C列とD列のデータを結合して、B列に入力 ●「C列とD列のデータ」を連結する際に、 セル内区切り文字が必要な場合は、 Const DLMinCELL = "-"　　'　区切り文字　"-"　の場合 Const DLMinCELL = vbLf　　'　区切り文字　セル内改行　の場合 等の様に指定を書き直してください。 現状は、 Const DLMinCELL = ""　　'　区切り文字　なし　の場合 セル内区切り文字が必要ない場合、になっています。 [名前を付けて保存] ダイアログにてオペレーターが、 [キャンセル]を選択した場合の処理、を添えておくのが一般的なのですが、 うっかり忘れてしまっていましたので、書き加えて再掲載しておきます。 [名前を付けて保存] ダイアログで、 不適切なファイル名（使うことの許されていない文字とか）を指定される 可能性もありますが、これについてのエラートラップは省略します。 また、既存のファイル名を指定してしまった場合には、 上書きすることになりますが、 そういう仕様を求めているので構わない、とか、 これを回避する必要がある、とか、 詳しく示されていない点については現時点で対策しようがありませんので 留意しておいてください。 以下、回答No.1のコードに１行加筆したものですが、差換えてください。 ' ' /// specA.ver0.01　[名前を付けて保存] ダイアログ　/　タブ区切りテキスト出力 Sub ReW9070410A() Const DLMinCELL = ""　'　「C列とD列のデータを結合」する場合セル内に区切り文字が必要なら要指定 　　With Sheets("Sheet2") 　　　　' ' 「C列とD列のデータを結合して、B列に入力」 　　　　.Range("B1:B100").Value = .Evaluate("C1:C100&""" & DLMinCELL & """&D1:D100") '　　　　.Columns("B").AutoFit　'　B列の列幅を調整（オプション）必要なら、、、 　　　　.Range("A1:B100").Copy　'　「A1～B100のデータを」コピー 　　End With Dim sBuf As String 　　With CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")　'　New DataObject 　　　　' ' 「A1～B100のデータを１つのテキスト」としてDataObjectに取得 　　　　.GetFromClipboard 　　　　' ' 「A1～B100のデータを１つのテキスト」としてDataObjectから文字列変数に取得 　　　　sBuf = .GetText 　　End With 　　Application.CutCopyMode = 0　'　コピーモードを解除 　　' ' （オプション）★ダイアログ初期表示のフォルダを指定する場合（既存のフォルダ） '　　Dim sFdr As String　'　★ '　　sFdr = CurDir　'　★ 現在の（元の）フォルダパスを確保 '　　ChDir "D:\Work"　'　★ フォルダの変更　初期表示のフォルダを指定 　　' ' 「ファイル名はその都度指定する。」→ユーザーがファイル名を指定する目的で、[名前を付けて保存] ダイアログ ボックスを表示。 Dim sFile 　　sFile = Application.GetSaveAsFilename( _ 　　　　InitialFileName:="*.txt", _ 　　　　FileFilter:="テキスト (タブ区切り) (*.txt), *.txt") 　　If VarType(sFile) = vbBoolean Then MsgBox "キャンセル": Exit Sub　'　ver0.01 追加　[名前を付けて保存] [キャンセル] Dim nFree As Integer 　　nFree = FreeFile　'　空きナンバー取得 　　Open sFile For Output As #nFree　'　開く 　　Print #nFree, sBuf　'　テキスト出力 　　Close #nFree　'　閉じる '　　ChDir sFdr　'　★ 元に戻す End Sub
１、一般的な採番手法。 私は、テーブル「主キー管理表」や「id管理表」等を用意して管理するんだろうと認識しています。 Public Function NewID(ByVal strIDName As String) As Long On Error GoTo Err_NewID 　　Dim N　　　As Long 　　Dim strSQL As String 　　Dim cnn　　As ADODB.Connection 　　Dim rst　　As ADODB.Recordset 　　 　　Set cnn = CurrentProject.Connection 　　Set rst = New ADODB.Recordset 　　strSQL = "SELECT final_value FROM id管理表 WHERE id_name='" & strIDName & "'" 　　cnn.Errors.Clear 　　cnn.BeginTrans 　　With rst 　　　　.Open strSQL, _ 　　　　　　　cnn, _ 　　　　　　　adOpenDynamic, _ 　　　　　　　adLockOptimistic 　　　　If Not .BOF Then 　　　　　　N = .Fields(0) + 1 　　　　　　.Fields(0) = N 　　　　　　.Update 　　　　End If 　　End With 　　cnn.CommitTrans Exit_NewID: On Error Resume Next 　　rst.Close 　　cnn.Close 　　Set rst = Nothing 　　Set cnn = Nothing 　　NewID = N 　　Exit Function Err_NewID: 　　N = -1 　　If cnn.Errors.Count > 0 Then 　　　　ErrMessage cnn.Errors(0), strSQL 　　　　cnn.RollbackTrans 　　Else 　　　　MsgBox "プログラムエラーが発生しました。システム管理者に報告して下さい。(NewID)", _ 　　　　　　　 vbExclamation, " 関数エラーメッセージ" 　　End If 　　Resume Exit_NewID End Function ２、安直な採番手法。 それは、テーブルの最後のレコードの列[id]の値ではなく最大値を求める手法。もちろん、列[id]で逆順に ORDER BY して先頭のレコードを参照する手もあります。しかし、安直な普通のやり方は最大値を求める手法です。 Public Function DBLookup(ByVal strQuerySQL As String, _ 　　　　　　　　　　　　　Optional ByVal ReturnValue = Null) As Variant On Error GoTo Err_DBLookup 　　Dim DataValue 　　Dim rst　　　　 As ADODB.Recordset 　　Set rst = New ADODB.Recordset 　　With rst 　　　　.Open strQuerySQL, _ 　　　　　　　CurrentProject.Connection, _ 　　　　　　　adOpenStatic, _ 　　　　　　　adLockReadOnly 　　　　If Not .BOF Then 　　　　　　.MoveFirst 　　　　　　DataValue = .Fields(0) 　　　　End If 　　End With Exit_DBLookup: On Error Resume Next 　　rst.Close 　　Set rst = Nothing 　　DBLookup = IIf(Len(DataValue & ""), DataValue, ReturnValue) 　　Exit Function Err_DBLookup: 　　MsgBox "SELECT 文の実行時にエラーが発生しました。(DBLookup)" & Chr$(13) & Chr$(13) & _ 　　　　　 "・Err.Description=" & Err.Description & Chr$(13) & _ 　　　　　 "・SQL Text=" & strQuerySQL, _ 　　　　　 vbExclamation, " 関数エラーメッセージ" 　　Resume Exit_DBLookup End Function （注意）テーブルの並びは、必ずしも登録順、あるいは主キー昇順ではない。その状況は、変化する。 ＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊ 　PS、主キーの追加、参照とCnnExecute() ＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊ ? CnnExecute("INSERT INTO id管理表 VALUES ('Test2', 2);") True ? DBLookup("final_value", "id管理表", "id_name='Test2'") 2 ? CnnExecute("INSERT INTO id管理表 (id_name, final_value) VALUES ('Test3', 3);") True ? DBLookup("final_value", "id管理表", "id_name='Test3'") 3 ? CnnExecute("DELETE FROM id管理表 WHERE id_name='Test2';") True ? DBLookup("final_value", "id管理表", "id_name='Test2'") NULL ? CnnExecute("DELETE FROM id管理表 WHERE final_value=3;") True ? DBLookup("final_value", "id管理表", "id_name='Test3'") NULL このように私はSQL文を実行する関数（CnnExecute、）でもって主キーの参照、追加を行っていました。 Public Function CnnExecute(ByVal strSQL As String) As Boolean On Error Goto Err_CnnExecute 　　Dim isOK As Boolean 　　Dim cnn　As ADODB.Connection 　　 　　isOK = True 　　Set cnn = CurrentProject.Connection 　　With cnn 　　　　.Errors.Clear 　　　　.BeginTrans 　　　　.Execute strSQL 　　　　.CommitTrans 　　End With Exit_CnnExecute: On Error Resume Next 　　cnn.close 　　Set cnn = Nothing 　　CnnExecute = isOK 　　Exit Function Err_CnnExecute: 　　isOK = False 　　If cnn.Errors.Count > 0 Then 　　　　ErrMessage cnn.Errors(0), strSQL 　　　　cnn.Rollbacktrans 　　Else 　　　　MsgBox "プログラムエラーが発生しました。" & _ 　　　　　　　 "システム管理者に報告して下さい。(CnnExecute)", _ 　　　　　　　 vbExclamation, " 関数エラーメッセージ" 　　End If 　　Resume Exit_CnnExecute End Function
カテゴリと内容から、言語はVB.NETということですよね？ 環境(バージョン等)についての情報が書かれていませんので、今であればVisualStudio2015の世代であろうものとして回答を記載します。 (C#党なので、VB.NETはどのバージョンでどの程度のサポートがあるのかあまり詳しくないというのもあります) .NETで任意の構造のXMLを扱うクラスとしては2種ありますが、現在であればLINQ to XML(System.Xml.Linq名前空間およびその関連)クラスのみを覚えれば良いと思います。 XPathを利用したいということで、System.Xml.LinqとSystem.Xml.XPathの名前空間をインポートして、質問文の内容であればたとえば以下のような形で属性値を取得することが出来ると思います。 Dim xmlPath = "Path/to/file.xml" Dim xmlDoc = XDocument.Load(xmlPath) Dim tarouPen = xmlDoc _ .XPathSelectElements("/ABC/tarou[@id='pen']") _ .Select(Function(node) CType(node.Attribute("value"), String)) _ .FirstOrDefault() ちなみに、XPathを使わずにLINQメソッドを利用してたとえば以下のような書き方もあります。(VBではC#に比べてラムダが美しく書けないのでXPathとどちらが便利か微妙ですが) Dim xmlPath = "Path/to/file.xml" Dim xmlDoc = XDocument.Load(xmlPath) Dim tarouPen = xmlDoc _ .Elements("ABC") _ .Elements("tarou") _ .Where(Function(node) CType(node.Attribute("id"), String) = "pen") _ .Select(Function(node) CType(node.Attribute("value"), String)) _ .FirstOrDefault() また、この回答の記載中に知りましたが、VB.NETでは「XML 属性軸プロパティ」という記法でLINQ to XMLに対する特別な記述も行えるようですね。 XPathを利用する版の例で、XML 属性軸プロパティと2015で追加された「?.」演算子も組み合わせたら以下のような感じにも書けるようですね。 Dim tarouPen = xmlDoc.XPathSelectElement("/ABC/tarou[@id='pen']")?.@value
プログラムコードを見る限り、動作上の問題はないように見えます。 となると、動作しないという点はプログラム以外が原因とみる必要があります。 まず、VBマクロの実行は確実に行われている。かの確認が必要となります。 Windowsアップデートの関係でVistaにおいてVBマクロが動作不可になっている可能性があります。また、PCが変わっていることが原因として考えられるものは、VBマクロの作成場所というのも考えられます。 そのため、VBマクロ内において要素要素でブレークポイントをおいて動作確認をしてください。 ブレークポイントを置いても反応することがなく終了してしまう場合は、マクロが実行されていません。 実際、VBはコード以外にも確認をしてみないとわからないので詳細回答はできないのですが、要素を一つずつ潰しながら調べるのがいいと思います。
この手の質問ではエラー内容を記述するようにしましょう。 >myPath = "C:\Users\Users\DeskTop\PHOT" >myFile = myPath & Range("D3").Text & ".jpg" 原因は上記箇所にあります。 例えば、このmyPath（フォルダパス）で、D3に「TEST」と入力すれば myFileの中身は「C:\Users\Users\DeskTop\PHOTTEST.jpg」このようになります。 目的は「C:\Users\Users\DeskTop\PHOT\TEST.jpg」でしょうから以下の修正の何れかの方法で修正してください。 （注）(1)～(3)の全て行うのではなく3(+1)通りありますので、 　　　何れかのお好きな方法で修正願います） (1)コードをそのままで使用する場合 　D3セルのファイル名の先頭に「\」を付けて入力する。 　上記例だと「\TEST」と入力してください。 (2)フォルダパスの最後に「\」を付けて設定する 　>myPath = "C:\Users\Users\DeskTop\PHOT" 　　　　　　　　↓ 　myPath = "C:\Users\Users\DeskTop\PHOT\" としてください。 (3)変数、セルの内容はそのままにコードで対応する（2通り） 　>myPath = "C:\Users\Users\DeskTop\PHOT" 　>myFile = myPath & Range("D3").Text & ".jpg" 　上記コードの「間」に以下のコードを追加してください。 　If Not myPath Like "*\" Then myPath = myPath & "\" 　または、 　>myFile = myPath & Range("D3").Text & ".jpg" 　　　　　　　　　↓ 　myFile = myPath & "\" & Range("D3").Text & ".jpg"
VB6の標準コントールで使えないものもあったはずです。また64ビットには対応していませんよね。将来的にはリプレイスは必要になると思います。そんな話をお客様にして、少しづつ.NETへの移行をしてもらってます。 リプレイスするなら早いほうが良いと思いますよ。そのうちVB6を知っている技術者もいなくなってきますから、そうなってからでは余計に予算もかかると思います。
2段階に分けて考えましょう。 1.Oracleからデータを抽出してDataTableに保存。 2.DataTableの中のデータをCSVファイルに保存する。 そこで次のサイトが参考にならないでしょうか。 1.http://www.oborodukiyo.info/ADONET/VS2008/ADONET-HowToAccessOracle.aspx 2.http://www.oborodukiyo.info/CSharp/VS2010/CS-SaveDataTableToCSV.aspx 1ではDataTableにデータを入れた後、DataGridViewで表示していますが、ここは省略してみて考えてください。 頑張ってください。
とりあえず、objWorksheetが唐突なので、一応、 Set objWorksheet = objWorkbook.Sheets("Sheet1") ' ' ↑要指定◆シート名。例示はシート名"Sheet1" のような記述があるものとして、、、。 例えば、こんな感じで。 ' ' ↓シートがひとつしかないと保証されるならこの行は不要。 objWorksheet.Select ' ' ＝＝ 先頭行の固定 ＝＝ With objExcel.ActiveWindow ' With objWorkbook.Windows(1) .SplitRow = 1 .FreezePanes = True End With ' ' ＝＝ 「データーのある最下行+2にデーターの合計」SUM関数で合計を求める例 ＝＝ With objWorksheet ' ' ↓要指定◆最下行基準列。例示"A"はＡ列を基準に最下行を取得する場合 nRow = .Cells(65536, "A").End(-4162).Row ' 最下行 ' ' ↓要指定◆合計を出す列範囲。例示は"A:C"列に合計を出す場合 .Range("A:C").Rows(nRow + 2).FormulaR1C1 = "=sum(r2c:r" & nRow & "c)" End With
ANo.2です。 こちらでは動いていますよ。 正しいコードかどうかはわかりませんが＾＾； 新しいプロジェクトに、コードをコピペしてやってみてくださいな。
まず、デバッグモードと実行モードとはどう違うんでしょうか？ わからないの私だけかもしれないですが・・・・＾＾； 速度差が、OSとExcelのバージョンが異なることで発生するのか、 同じ環境で、デバッグモードと実行モードによって発生するのか、 ちょっと曖昧ですので、補足ください。 以下で、Excel2003とExcel2007での速度差を検証されています。 ご覧になりましたか？ http://excel.syogyoumujou.com/vba/speed_up_12.html その他にも「VBA 高速化」などで検索すると、いろいろ出てくるようですよ。
VB.NET系の言語でアプリをくみたいのなら、.NET Frameworkを「理解する」のイメージで想像される、域まで行かなくても良いと思う。 概念的な仕組みの解説を読んで、「そうか」とおもえれば、済ましてよいのでは。 縁の下で働いてくれるものなんだと思うから。 ーー いままで、小生は長い人生で、基礎から理解しないと、と深く迂回するタイプの（少数の）人を見かけたが、周りから見ると奇異で、上司もそんな暇があったら、早く課題を済ませろ的な受け取り方だったと思う。大げさ者的に思う。 ＞ｖｂ．ｎｅｔを学べば、 おのずと、.NET Frameworkも理解できますか？ それはないでしょう。例えは悪いが、５０年車を運転していれば、車の構造がわかるか、というようなものか。 ほかに、プログラムを組むとか、処理ロジックを考えるとか、習得アルゴリズムを増やすとか、エラーが少ないしくみや、わかりやすい設計書を作るとか、データ設計、テスト技法など、他の分野の勉強がいっぱいあるのにこれにこだわるのはどうかと思う。 VB.NETの解説書に解説されている、NET Frameworkの記事程度で、学習をスタートしてよいのでは。 ーー 「.NET_Framework」でWEB照会すれば記事がたくさんある。ウイキでは、 .＞NET Frameworkにおける最も重要な概念は共通言語基盤 (CLI) に含まれている。CLIの目的は言語に依存しない開発環境および実行環境を提供することである。マイクロソフトによるCLIの実装は共通言語ランタイム (CLR) と呼ばれる。 ーー Javaのアイデアで先行されたこの考えを後追いするように、MSはVB（６．０）の次から、今世紀に入って、.NETを出した。「中間言語」というものを、途中に「かます」ことにより、色んなコンピュターでも、「中間言語ソフトー＞そのコンピュタのマシン語」のソフトの備えをすれば、１からソフトを作らなくても良い。表面的には、多種のコンピュターで動くように見えるようになる。
もしかして TableAdapter.Update() でしょうか・・・・
以下、DOCファイルの「組み込みプロパティ」を列挙するマクロです。 Private Sub Macro1() Dim OpenFileName As String Dim WordApp As Object Dim WordDoc As Object Dim PropertyList As Variant Dim PropertyValue As Variant Dim PropertyName As String Dim LineCount As Integer OpenFileName = Application.GetOpenFilename("Microsoft Word 文書,*.doc") Set WordApp = CreateObject("Word.Application") Set WordDoc = WordApp.Documents.Open(OpenFileName) Cells(1, 1).Value = "Name" Cells(1, 2).Value = "Number" Cells(1, 3).Value = "Value" LineCount = 1 On Error Resume Next For Each PropertyList In WordDoc.BuiltinDocumentProperties Cells(LineCount + 1, 1).Value = PropertyList.Name Cells(LineCount + 1, 2).Value = LineCount Cells(LineCount + 1, 3).Value = PropertyList.Value LineCount = LineCount + 1 Next WordDoc.Close WordApp.Quit Set WordApp = Nothing Set WordDoc = Nothing End Sub 上記では、For Eachで列挙していますが、単純に Private Sub Macro1() Dim OpenFileName As String Dim WordApp As Object Dim WordDoc As Object Dim CreateDate As Variant OpenFileName = Application.GetOpenFilename("Microsoft Word 文書,*.doc") Set WordApp = CreateObject("Word.Application") Set WordDoc = WordApp.Documents.Open(OpenFileName) CreateDate = WordDoc.BuiltinDocumentProperties(11).Value WordDoc.Close WordApp.Quit Set WordApp = Nothing Set WordDoc = Nothing MsxBox CreateDate End Sub でも構いません。
ANo.1です。 とりあえず、やりたいことができたということで、良かったです。 さて、新たにご質問されるのであれば、一旦、この質問は閉じてくださいね。 あらためて、質問したらよろしいかと思います。 ただ、新たな質問の内容は、既にあなたが身に着けていなければならない内容です。 今回のコードを、1行1行見なおして、なにをやっているのか理解してください。 また、「Excel VBA」でGoogleなどで検索すれば、VBAのプログラミング入門サイトは かなりの数、出てきます。まずはそちらで勉強されることをお奨めします。 そこで大半の答えは得られるでしょう。
No2です。 あなたがやりたいことは、 「プログラムAからプログラムBの画面位置を変更したい。」 ということだと思います。 条件としては、 「プログラムBは起動時にその画面位置を読み込んで設定する。」 ということですね？ だとすると、 ・プログラムAはどこかに画面位置情報を保存する。 ・プログラムBはプログラムAで保存された画面位置情報を読み込んで設定する。 ということが解決策だと思います。 であれば、その画面位置情報をやり取りする手段を講じる必要があるわけです。 それは、レジストリであってもいいし、XMLファイルであってもいいし、単なるテキストファイルでもいいわけです。 手段を決めたら、自分で調べて勉強して実現すればいいです。 「VB.NET レジストリ」とか 「VB.NET XML」とか 「VB.NET ファイル入出力」とか ネットで調べれば、詳しい情報はいくらでも出てきます。 それにチャレンジした上で、どうしてもわからないことがあれば、質問したらいいかと思います。
（１）URLの文字列としてだけの形式チェック （２）アクセスして、実際にWEBサイトが出てくるか（閉鎖サイトの古いURLもある） ーこれはアクセスをやってみないとわからないだろう。 （３）出てくるとして、そのサイトのセキュリティ面などの危険度（「url チェック」で照会すると記事が出る） などの観点からのことが話題としてあるが、（１）だけなら、「正規表現」（VBAに親和性のあるのはVBscriptのRegExpですが）などを使ってチェックする記事がある。 Googleででも「url 文字列チェック」「url 　チェック 正規表現」（記事はPHPのが多い）などで照会すれば記事が出てくる。 質問者の立場や技量は、質問に説明されていないが、エクセルVBAだけしか首を突っ込んでいないレベルでは、新たに正規表現（.NETぐらいでないとMSは正面切って正規表現に力を入れてない感じがする。オフィスではワイルドカードどまり。）の学習はむつかしく時間がかかり、（上記（２）の問題があり、形式だけチェックしても完全でないので）ほどほどにしておいてはどうかと。広範囲なコンピュター技量獲得を目指すなら別です。
No1に追加です >または、Excel上でも簡単に上記の事が出来るのでしたら、その方法も教えて下さい。 例えば、P列を作業列として使用し、セルP2に以下の数式を入れて データの行数分オートフィルします。 =(1<=N2)*(N2<=3)+(1<=O2)*(O2<=3) 1行目（項目列）を選択し、データからフィルタを選択。 P列のフィルタ「▼」を選択して、「0」のチェックボックスを外す。 抽出したい範囲を選択して右クリックからコピーの後に、対象シートのセルを右クリックして「形式を選択して貼り付け」より対象データの貼付け。 P列の値は上記数式では、N及びO列が1～3の数値の場合は2、N又はO列が1～3の数値の場合は0、どちらも当てはまらない場合は0となります。
あなたのPCに共有フォルダを作成し適宜設定します。 http://www.atmarkit.co.jp/ait/articles/1406/12/news097.html "C:\DB.xlsx" を "\\あなたのPC名\共有名\DB.xlsx" にすればOKです。 あなたが自PCにログオンしている必要はありませんが起動中でなければなりません。 そのDB.xlsxもファイルサーバーに上げておいた方が良さげな気がしますけど・・・。
こんにちわ。 参考URLのソースが参考になると思います。 大まかには以下のような処理の流れになります。 -- 1. downloadClient_DownloadProgressChanged プロシージャを用意しておく 2. downloadClientインスタンスを作成した後に、以下のようにAddHandler(delegate)で呼び出すプロシージャを設定 > AddHandler downloadClient.DownloadProgressChanged, _ > AddressOf downloadClient_DownloadProgressChanged 3. downloadClient.DownloadFileAsync でダウンロードを開始 -- すると、donwloadClientからdownloadClient_DownloadProgressChangedが呼び出されるようになりますので、以下部分は不要になるかと思います。 >If InvokeRequired Then >Invoke(New MyDelegate(AddressOf DownloadProgressA)) >'終わり >Else
以下の手順で救出できる可能性があります。 ポイントは問題の EXCEL ファイルから VBA コードのデータを取り出し、別の EXCEL ファイルに移植して開くところです。 1. 問題の EXCEL ファイルの拡張子を zip に変える 2. 1. で拡張子を変えたファイルを右クリックし、[プログラムから開く] 　→[エクスプローラ]を選択。zip ファイルの中身が表示される。 　※ここで表示が失敗する場合は救出手段はありません…。 3. 2.で開いた画面中の xl フォルダ内にある vbaProject.bin ファイルを、 　何処か適当なフォルダに DRAG & DROP。 　 vbaProject.bin ファイルが取り出せたら、2.で開いた画面は閉じる。 4. 新しい EXCEL ファイルを作り、VBA の入力画面を開いて以下の 　コードを書きこみ、拡張子 xlsm で保存。 　　Sub A() 　　End Sub 5. 4.で保存したファイルの拡張子を zip に変える。 6. 5. で拡張子を変えたファイルを右クリックし、[プログラムから開く] 　→[エクスプローラ]を選択。zip ファイルの中身が表示される。 7. 3. で取り出した vbaProject.bin ファイルを、6. で表示している画面の 　 xl フォルダ内にある vbaProject.bin ファイル上に DRAG & DROP して 　 上書き。上書きできたら 6. で表示した画面は閉じる。 8. 5. で zip に変更した拡張子を、xlsm に戻す。 9. 8. で拡張子を戻したファイルをEXCELで開く。 　 さて、VBA コードは救出できているでしょうか…？
以下のようにします。 -----ここから '配列の要素を「１から使う」ので「Option Base 1」が必須 Option Base 1 Sub test() Dim C As Variant 'Dを「動的配列」として定義 Dim D() As Variant Dim i As Long Dim j As Long Dim k As Integer '「どれか１つに一致してしまった」を示すフラグを定義 Dim f As Boolean Dim List As Variant List = Array("山田", "佐藤", "田中") '6000行ではなく60000行の間違い C = Worksheets("Sheet1").Range("A1:B60000") j = 1 'Dを「２次元配列」として再定義 ReDim Preserve D(2, 1) For i = 1 To 60000 'フラグを立てておく f = True 'Listの要素数だけループする For k = 1 To UBound(List) 'Listの１つと一致するか調べる If C(i, 1) = List(k) Then 'どれかに一致したらフラグを消す f = False 'それ以上Listを調べる必要はないのでForを抜ける Exit For End If Next 'フラグが立ったままならどれにも一致しないので処理する If f = True Then 'データが増えるので配列の「一番下の次元」を拡張する 'ReDim Preserve D(2, j) 'データをコピーする（行と列が逆になる事に注意） D(1, j) = C(i, 1) D(2, j) = C(i, 2) j = j + 1 End If Next 'Dの配列は「行と列を逆に作った」ので、行と列を入れ替える D = WorksheetFunction.Transpose(D) 'Dの配列の要素数を確認するメッセージボックスを表示 MsgBox UBound(D, 1) & "," & UBound(D, 2) '確認の為、C列、D列に配列の中身を代入してみる Worksheets("Sheet1").Range("C1:D" & j - 1) = D End Sub -----ここまで ＊＊注意＊＊ 動的配列の「D」は D(2,1)→D(2,2)→D(2,3)→D(2,4)→D(2,5)→D(2,6)→……D(2,60000) のように「一番下の次元」しか変更できません。 そのため「行と列を逆に作成」する必要があります。
＞以下のように、iCndではなくて、Buttonの作成待ちにしたら、うまくいきました。 なるほど。こちらが勉強になりました。 ありがとうございました。
#2です。 もう一度私の手元のパソコンのデータで、下記を実行しましたが、エラーが出ず、うまく行くようです。 原因追及の前に、＃１の回答のシートのデータを使うこと（質問者の実際のデータを使わず）で、下記を標準モジュールに貼り付けて（下記をコピペして、そっくりそのままで）、もう一度実行してみてもらえませんか。 実行前に、aaa.Fなどの間のカンマについて（A列ある行で漏れていないか）チェックしてみてください。 Sub test06() Dim st(10): Dim pr(10) x = 0: y = 0 Dim rng As Range Dim d As Variant lr = Worksheets("DATA").Range("A1000").End(xlUp).Row 'MsgBox lr '----- For i = 1 To lr 'MsgBox Cells(i, "A") d = Split(Cells(i, "A"), ".") 'Ａ列各行セルのデータをスプリット '---st について For j = 1 To x If st(j) = d(0) Then GoTo p1 '探索終り Else '何もしない End If Next j '最終的にd(0)はst()に見つからず、配列に追加 x = x + 1 st(x) = d(0) p1: '---prについて For j = 1 To y If pr(j) = d(1) Then GoTo P2 '探索終り Else '何もしない End If Next j '最終的にd(0)はpr()に見つからず、配列に追加 y = y + 1 pr(y) = d(1) P2: '---次行データへ Next i '---処理終了 For i = 1 To x MsgBox "stの" & i & "=" & st(i) Next i For i = 1 To y MsgBox "prの" & i & "=" & pr(i) Next i End Sub すぐに思い当たるエラーが、みつけられずで、すみません。 結果をお聞かせください。
　VBAでやらなくても、[区切り位置]機能を使えば済む話ではないでしょうか？ 【参考URL】 　Be Cool Users 2007 > Excel・エクセル > 入力・編集 > 区切り位置でデータを分割 　　http://www.becoolusers.com/excel/text-to-columns.html 　もしVBAを使って行うのであれば、次の様なものになります。 Sub QNo9045688_VBAの文字列分割() Range("A1").TextToColumns Destination:=Range("B1"), DataType:=xlDelimited, _ TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=True, Tab:=False, _ Semicolon:=False, Comma:=False, Space:=True, Other:=False End Sub
＞set w0 = activesheet アクチブシートオブジェクトをW0と名前付け。 >worksheets.add after:=w0 ワークシートについて、（Ｗ０シートのタブの右側に）１シートを挿入。 ＞range("A1:G1") = array("苗字","名前","住所","TEL","〒","好きなスポーツ","性別") 配列６項目を作り（右辺の処理）、それを同一行の横方向セルA1:G1の５つのセルに１度で値をセット。 ＞a = split(replace(application.trim(replace(replace(h, "　"," "),"：",":")),": ",":"), " カンマで目印にして、文字列を「区切り」り、配列に入れる。 Replaceは各セルの文字列について、３段構えで、ネストして置換している。 スペースと：と：（半角）の３段。Ｒｅｐｌａｃｅ関数の第１引数に３つ文字を１度に指定できないので、ネストして１文字ずつＲｅｐｌａｃｅして３段で置換。 for each h in w0.range("A1:A" & w0.range("A65536").end(xlup).row) Ａ列の最終行のせるまでについて各セルを順次処理対象セルｈにする。 ＦｏｒＥａｃｈで対象の各セルについての処理の繰り返し。 ＞cells(r, "A") = split(a(0), ":")(1) a(0)の文字列を：で分割し、最初の部分をセル（ｒ行目のＡ列）に代入する。 （１）は卑劣配列に入ったものの第１番目。 以下cells(r, "F") ＝の部分は同じ。 a()そのまま代入しているのは cells(r, "F") = a(5) cells(r, "G") = a(6) の行。
(1)A.xlsでAlt+F11よりVBEを開き、挿入から標準モジュールを作成 (2)最下のVBAコードを貼付て右上の「×」でVBEを閉じる (3)Alt+F8より「Sample」マクロを実行 現在表示されているA.xlsの表示シートにご提示の仕様でデータがコピーされます。 （CSVファイルの名前に関係なく、A.xlsと同じフォルダにある全てのCSVファイルを対象とします） ■VBAコード Sub Sample() Dim buf As Variant, cnt As Integer, mySt As Worksheet 　　Set mySt = ActiveSheet: cnt = 1 　　'同一ディレクトリのcsvファイル一覧を取得 　　buf = Dir(ActiveWorkbook.Path & "\" & "*.csv") 　　'作画の停止 　　Application.ScreenUpdating = False 　　'CSVファイルの数だけ繰り返し 　　Do While buf <> "" 　　　　'CSVファイルを開き処理 　　　　With Workbooks.Open(buf) 　　　　　　'ファイル名を書出し 　　　　　　mySt.Cells(1, cnt) = .Name 　　　　　　'CSVファイルのA列をコピー 　　　　　　.Worksheets(1).Columns("A").Copy mySt.Cells(1, cnt).Offset(0, 1) 　　　　　　'CSVファイルのB列をコピー 　　　　　　.Worksheets(1).Columns("B").Copy mySt.Cells(1, cnt).Offset(0, 2) 　　　　　　'起点セルのオフセット 　　　　　　cnt = cnt + 3 　　　　　　buf = Dir() 　　　　　　'CSVファイルを閉じる 　　　　　　.Close 　　　　End With 　　Loop 　　'作画の開始 　　Application.ScreenUpdating = False 　　MsgBox "終了しました" End Sub
画像も何もないので良くわかりませんが、メニュー[表示]→[ソリューションエクスプローラ]で復活しますか？ Visual Studio .NET の画面は メニュー[表示] 配下のサブメニューからだいたい表示できるので、違うようであれば色々選択してみると良いかと。
＞If Month(Range("H" & i)) <> Month(Range("H" & i + 1)) Then 後ろのRangeの引数だけど 最初は、i=2 なので「"H" & i」は「"H2"」になる。 それに「+ 1」するのだけれど、「"H2" + 1」はデータの型が違うので計算できないのでは？ もし"H"に（i+1）を付け足したいなら Range("H" & (i + 1)) としないとだめです。 もっと厳密に言えば、数値変数を＆演算子で付け足すのはデータ型を無視した書き方なので 以下のようにしてほしい。 If Month(Range("H" & CStr(i))) <> Month(Range("H" & CStr(i + 1))) Then
#2です。 複雑そうで、回答はあきらめるべきかと思うが、最後に。 Excelで散布図と回帰直線（多分これと思うが、手作業で作成者がグラフ作成後に、見繕った直線を入れることもできなくはない）を作成したのかどうか、質問者が再試行してみて、突き止められませんか。 グラフのもとになった、数値データそのものは質問者には見えているのですか？。 見た目の直線数は何本ですか？３系列で３本ですか。 ーーー http://hs-www.hyogo-dai.ac.jp/~kawano/HStat/?2011%2F6th%2FExcel2 などを見て。 そして系列番号を割り出せませんか。 「b.FullSeriesCollection.Countが3になており」なら、３つしかないのかもしれないが。 もし割り出せるようなら、私の回答の.SeriesCollection(2).Deleteの（）内の数字を、系列番号を適当にセットすれば、その系列の分の線は、消えると思いますが。 ーー あるいはもっと複雑なのかな。
実行結果は正しいです。 サンプルプログラムを実行すると、最初に処理されるのはMain()という関数です。 ですから、 Sub Main()　　　　　　　　　<=ここから実行されます Dim SUJI As Integer = 3　　　<=SUJIという変数を宣言して、3を代入します If SUJI = 3 Then　　　　　　　<=もし、SUJIという変数が3であれば、以下の処理を実行 Console.WriteLine(mName)　　<=画面にmNameという変数の内容(YOSHI)を表示 End If　　　　　　　　　　　　<=ここまで '-> Console.ReadLine()　　　　　<=標準入力(多くの場合はキーボード)から１行入力 End Sub　　　　　　　　　　<=Main()関数の終わり Main()関数の処理を終えると、アプリケーションは終了します。 Main()関数以降に書かれているDispMsg()という関数は、上の処理の流れのどこからも呼び出されていないので、実行されることはありません。 '->　という部分にDispMsg()と書けば、DispMsg()という関数を呼び出すことになるので、 Console.WriteLine("Hello {0}", mName) が実行されて Hello YOSHI と画面に表示されるようになると思います。 Sub,Module,NameSpaceの意味がわからないのであれば、Google検索で調べたほうが早いと思います。
＞　idNameってないんですか https://msdn.microsoft.com/ja-jp/library/system.xml.xmlelement%28v=vs.110%29.aspx 無さそうですね。 Name プロパティじゃないでしょうか。
こんにちは。 それほど詳しくないのですが、偶々今仕上げているＶＢＡがwinHttp関連でしたので 解答してみます。 Charset の扱いが微妙に違うようですね。 softbank の方は 　.Charset = "_autodetect_all のように、自動判別でデコード出来ないみたいです。 ごく普通の対応として、ADODB.Streamを介して、 UTF-8を指定して読込む方法が広く知られています。 一応、以下のようにすれば、問題なく読み込めました。 （※ADODBの参照設定など、必要な準備はそちらで適宜お願いします。） ' ' =================================== Option Explicit ' ' ■ クラス：ADODB　　参照設定：Microsoft ActiveX Data Objects 6.1 Library '　　[VBIDE.references].AddFromGuid Guid:="{B691E011-1797-432E-907A-4D8C69339129}", Major:=6, Minor:=1 ' ' ▼ レイトバインディング：　Set obj = CreateObject("ADODB.Stream") Sub Re9037558w() Dim http As WinHttp.WinHttpRequest Dim oAdodbStrm As ADODB.Stream　'　★ Dim vBinBody　'　★ Dim sURI As String Dim sHTML As String 　　Set http = New WinHttpRequest 　　Set oAdodbStrm = New ADODB.Stream　'　★ 　　sURI = "http://www.softbank.jp/" '　　sURI = "http://www.yahoo.co.jp" 　　With http 　　　　.Open "GET", sURI, False 　　　　.send ' ' ▼HTMLソース　バイナリ取得▼ 　　　　vBinBody = http.ResponseBody　'　★ 　　' ' 文字コードUTF-8としてデコード ----- 　　　　With oAdodbStrm　'　★ 　　　　　　.Type = adTypeBinary 　　　　　　.Open　'　★ 　　　　　　.Write vBinBody　'　★ 　　　　　　Erase vBinBody　'　★ 省略可 　　　　　　.Position = 0　'　★ 　　　　　　.Type = adTypeText　'　★ 　　　　　　.Charset = "UTF-8"　'　★ 　　　　　　sHTML = .ReadText(adReadAll)　'　★ 　　　　　　.Close　'　★ 　　　　End With　'　★ 　　End With　'　★ 　　Debug.Print Left(sHTML, 1000) 　　Set http = Nothing:　　Set oAdodbStrm = Nothing　'　★ End Sub ' ' ===================================
　次の様なやり方もあります。 Sub QNo9037494_f4から右方向に1から28ごとに連続番号を入れたい() Dim FirstCell As Range, LastCell As Range, myRange As Range, c As Range Set FirstCell = Range("F4") Set LastCell = Cells(FirstCell.Row + 1, Columns.Count) _ .End(xlToLeft).Offset(-1) If LastCell.Row < FirstCell.Row Then MsgBox "データがありません。" & _ vbCrLf & "マクロを終了します。", _ vbExclamation, "データ無し" End If For Each c In Range(FirstCell, LastCell) c.Value = 1 + (c.Column - FirstCell.Column) Mod 28 Next c End Sub
JSONなんて初めて聞いたんですが、調べてチャレンジしてみました♪ 以下のサブルーチンで取得できるようですが、いかがでしょうか？ Sub JSON_Parse() Dim objSc As Object Dim strFunction As String Dim strJSON As String Dim objJSON As Object Set objSc = CreateObject("ScriptControl") objSc.Language = "JScript" strFunction = "function jsonParse(s) { return eval('(' + s + ')'); }" objSc.AddCode strFunction strJSON = "{""data"":{""translations"":[{""translatedText"":""これはペンです。""}]}}" Set objJSON = objSc.CodeObject.jsonParse(strJSON) Set objJSON = CallByName(objJSON, "data", VbGet) Set objJSON = CallByName(objJSON, "translations", VbGet) For Each j In objJSON Call MsgBox(CallByName(j, "translatedText", VbGet)) Next End Sub
(1)>(2)Ｂブックは毎月一回だけ、書式の変更マクロを実行します。 つまり目的は AブックのBブックに対する書式変更を行うマクロの実行頻度が月に１度キリで、 所定日（リセット日）を過ぎると再度実行出来るようにしたいという事ですか？ (2)>mydate = Worksheets("集計").Range("D2").Value 「集計」シートとはBブックの（書式設定を対象とする）処理データのシートでしょうか。 (3)>Range("E3").Formula = "1"　’ここで次回起動時マクロ実行しない Bブックのマクロは起動時に実行したいという事でしょうか？ workbookの指定コードが見当たらないため、コードからはＢブックをアクティブにした状態でＡブックに記述した「書式の変更操作」を手動実行しているようですが。 ご提示のコードに関する関連データの仕様と、目的を明確に記述して頂かないと詳細が分からないのですが。 なるべくご提示のコードを変えずに上記(1)により仕様変更したコードを記述しますので参考にしてください。 （不要な処理はコードをコメントアウトしています） また、質問にて「0」「1」でマクロの実行条件フラグを立てられているセルを利用して、 前回の実行日を格納（記録しておく）セルとして利用しています。 ■コードでの処理内容 コード内での処理内容を例題を踏まえて以下の(1)～(4)に記述いたします。 コード内の該当箇所に「▼(1)～▼(4)」でコメント行を記述しています。 （前回実行日「2015/07/24」がセルE3に入力（シリアル値：42209）されているものとします） (1)前回実行日の翌月の1日（2015/8/1）のシリアル値「42217」を変数「reset_day」に格納します (2)今回の実行日「2015/8/24」が(1)のリセット日を(含み)過ぎていれば書式更新マクロを実行 （条件式により真となりますので、更新用マクロを記述してください） (3)実行日をE3セルに上書きします (4)(2)においてリセット日より実行日が前の日付「2015/7/24～2015/7/31」であれば処理 　(2)の条件において、偽となる場合ですが、コード内の冒頭で「Application.ScreenUpdating = False」をしているので「End Sub」で終了せずに、「Application.ScreenUpdating = True」は実行しておきましょう。 前回実行日が7/24であれば、8/1を超えない限り何度実行しても前回実行日となります。 8/1を超えた時点で実行すればリセット日が9/1で更新されるため、9/1を超えない限り同様に実行できなくなります。 以後、繰り返しとなります。 ■VBAコード Sub 書式の変更操作() 　　Application.ScreenUpdating = False 　　Dim n As Long 　　Dim myBtn As Integer 　　Dim myMsg As String, myTitle As String 　　Dim mydate As Date 　　 　　'▼(1) 　　'リセット日格納用変数 　　Dim reset_day As Date 　　'前回実行日の日付を格納 　　reset_day = Range("E3").Value 　　'前回実行日の日付の翌月の1日をリセット日として再格納 　　reset_day = DateAdd("m", 1, DateSerial(Year(reset_day), Month(reset_day), 1)) 　　'▼(2) 　　'リセット日を現在の日時が超えていれば実行 　　If reset_day <= Now() Then 　　　　myMsg = "この" & Format(Range("D2").Value, "m月") & "分 表の書式等を更新します。" 　　　　myTitle = "書式変更の確認" 　　　　myBtn = MsgBox(myMsg, vbOKOnly + vbExclamation, myTitle) 　　　　 　　　　'【ここに書式更新のマクロ実行処理を記述】 　　　　 　　　　'Range("E3").Formula = "1"　　'ここで次回起動時マクロ実行しない 　　　　MsgBox "書式を更新しました。" 　　　　'▼(3) 　　　　'実行日をセルE3に書き出し 　　　　Range("E3").Value = Now() 　　Else 　　　　'▼(4) 　　　　MsgBox "既に変更済みです。", vbOKOnly + vbExclamation 　　　　'『Application.ScreenUpdating = True』は処理するようにしましょう。 　　　　'Exit Sub 　　End If 　　Application.ScreenUpdating = True End Sub
最下のVBAコードでは 「VBAのIE制御入門」http://www.vba-ie.net/ よりIE制御に関するサブルーチンプログラムを引用しています。 IEの読み込み待機を行うことで安定して動作するかと思います。 また駐車場の台数は不要ですか？改行コードによりセル出力時に行がずれてしまっていたため、下記のコードでは住所部分のみ取得しています。 testプロシージャにより、テストプロシージャを10回連続動作するようにしているため 最大行+1のA~C列へ書出すように出力部のコードを書き換えています。 あまり多くてもサーバーに不可をかけるだけなので動作確認程度に10回で行いましたが、問題なく動作しているようです。 ■VBAコード '▼VBAのIE制御入門のサブルーチン引用▼ #If VBA7 Then 　　　　Private Declare Sub Sleep Lib "kernel32" (ByVal ms As LongPtr) #Else 　　　　Private Declare Sub Sleep Lib "kernel32" (ByVal ms As Long) #End If 'http://www.vba-ie.net/ie/navigate2.html#a3 Sub ieView(objIE As Object, _ 　　　　　　　　urlName As String, _ 　　　　　　　　Optional viewFlg As Boolean = True) 'IE(InternetExplorer)のオブジェクトを作成する 　　　　Set objIE = CreateObject("InternetExplorer.Application") 　　　　'IE(InternetExplorer)を表示・非表示 　　　　objIE.Visible = viewFlg 　　　　'指定したURLのページを表示する 　　　　objIE.Navigate urlName 　　　　'IEが完全表示されるまで待機 　　　　Call ieCheck(objIE) End Sub Sub ieCheck(objIE As Object) Dim timeOut As Date 　　　　'完全にページが表示されるまで待機する 　　　　timeOut = Now + TimeSerial(0, 0, 20) 　　　　Do While objIE.Busy = True Or objIE.ReadyState <> 4 　　　　　　　　DoEvents 　　　　　　　　Sleep 1 　　　　　　　　If Now > timeOut Then 　　　　　　　　　　　　objIE.Refresh 　　　　　　　　　　　　timeOut = Now + TimeSerial(0, 0, 20) 　　　　　　　　End If 　　　　Loop 　　　　timeOut = Now + TimeSerial(0, 0, 20) 　　　　Do While objIE.document.ReadyState <> "complete" 　　　　　　　　DoEvents 　　　　　　　　Sleep 1 　　　　　　　　If Now > timeOut Then 　　　　　　　　　　　　objIE.Refresh 　　　　　　　　　　　　timeOut = Now + TimeSerial(0, 0, 20) 　　　　　　　　End If 　　　　Loop End Sub '▲ここまで▲ Sub test() 　　Dim i As Integer 　　　　For i = 1 To 10 　　　　　　　　Call テスト 　　　　Next i End Sub Sub テスト() Dim obj As Object 　　　　Call ieView(obj, "http://map.japanpost.jp/pc/syousai.php?id=300197019000") 　　　　Do While obj.Busy 　　　　Loop 　　　　obj.Visible = True 　　　　For i = 0 To obj.document.All.tags("div").Length - 1 　　　　　　　　If obj.document.All.tags("div")(i).classname = "str_title_hira" Then 　　　　　　　　　　　　s = obj.document.All.tags("div")(i).InnerText 　　　　　　　　　　　　Worksheets("Sheet1").Cells(Cells(Rows.Count, "A").End(xlUp).Row + 1, "A") = s 　　　　　　　　End If 　　　　Next 　　　　For i = 0 To obj.document.All.tags("div").Length - 1 　　　　　　　　If obj.document.All.tags("div")(i).classname = "str_title_kana" Then 　　　　　　　　　　　　s = obj.document.All.tags("div")(i).InnerText 　　　　　　　　　　　　Worksheets("Sheet1").Cells(Cells(Rows.Count, "B").End(xlUp).Row + 1, "B") = s 　　　　　　　　End If 　　　　Next 　　　　For i = 0 To 1 　　　　　　　　If obj.document.All.tags("p")(i).classname = "unit" Then 　　　　　　　　　　　　s = obj.document.All.tags("p")(i).InnerText 　　　　　　　　　　　　Worksheets("Sheet1").Cells(Cells(Rows.Count, "C").End(xlUp).Row + 1, "C") = Replace(s, vbCrLf, " ") 　　　　　　　　End If 　　　　Next 　　　　obj.Quit End Sub
いまいちどのファイルにどのマクロがあるのか理解できませんが MACRO.xlsbをリネームしたのにMACRO.xlsbのsheet1に組み込んだマクロを起動するとか… 呼び出すマクロ「削除」は標準モジュールではないのでしょうか シートのマクロでしたら以下のやり取りを参考にしてください。 http://oshiete.goo.ne.jp/qa/7905931.html また、PERSONAJ.xlsbは開いていますでしょうか、開いていない場合はフルパスでファイル名を記述する必要があります。 それでも動かないと思われる場合、マクロは呼び出されているが削除するコードに不備があるもののエラーではないのでそのまま終わってしまっているとか、それ以前のコードでアラートをオフにしたままにしているとかはありませんか。呼び出されているかどうか呼び出される側でmsgboxで確認してみてください。
もうすぐ70歳を迎える爺ですので、書かれているコードは全く理解不能。そこで、とにもかくにもExcelにコピペして動かしてみました。すると、添付図のような結果をえました。 【修正箇所】 １、オプションで変数宣言を強要にしたこと。 ２、Do-Loop に DoEvents を追加したこと。 ３、For-Next のL、Mを追加。 ３は特に重要な修正です。この場合のLとMはメモリではなくスタックに記憶され高速で参照される可能性があります。ForループのたんびにドキュメントのDIVクラスのテキスト長を参照するやり方よりちょっとだけエレガントかも知れません。教訓として、Option Explicitをモジュールの先頭に必ずが良いと思います。 なお、動作はしましたが内容はチンプンカンプンです。 Option Explicit Sub テスト() 　　Dim I As Integer 　　Dim L As Integer 　　Dim M As Integer 　　Dim S As String 　　Dim obj As Object 　　Dim targetURL As String 　　 　　' ---------------------------------------------- 　　'　ＩＥオブジェクトのセット 　　' ---------------------------------------------- 　　Set obj = CreateObject("InternetExplorer.Application.1") 　　obj.Visible = True 　　 　　' ---------------------------------------------- 　　'　目的のページを開く 　　' ---------------------------------------------- 　　targetURL = "http://map.japanpost.jp/pc/syousai.php?id=300197019000" 　　obj.navigate (targetURL) 　　' ---------------------------------------------- 　　'　読み込み中の待機 　　' ---------------------------------------------- 　　Do While obj.Busy 　　　　DoEvents 　　Loop 　　' ---------------------------------------------- 　　'　[str_title_hira]のInnerTextの取得 　　' ---------------------------------------------- 　　L = obj.Document.All.tags("div").Length - 1 　　For I = 0 To L 　　　　If obj.Document.All.tags("div")(I).classname = "str_title_hira" Then 　　　　　　S = obj.Document.All.tags("div")(I).InnerText 　　　　　　Range("A1") = S 　　　　End If 　　Next L 　　' ---------------------------------------------- 　　'　[unit]のInnerTextの取得 　　' ---------------------------------------------- 　　M = obj.Document.All.tags("p").Length - 1 　　For I = 0 To M 　　　　If obj.Document.All.tags("p")(I).classname = "unit" Then 　　　　　　S = obj.Document.All.tags("p")(I).InnerText 　　　　　　Range("A3") = S 　　　　End If 　　Next M 　　' ---------------------------------------------- 　　'　終了処理 　　' ---------------------------------------------- 　　obj.Quit End Sub
#1です。 不愉快になんかなっていませんよ。気にしないでください。 ただ、私が提示したURLの内容はかなりディープな内容なので、ちょっと無理かなと思っただけです。 クリスタルレポートのメーカーに確認したほうがいいと思います。 ユーザー定義サイズの用紙を使うというのは、そんなに特別なことではないと思いますので、私が提示したようなことをしなくても、何か解決策を提示していただけるのではないでしょうか？ お役にたてず申し訳ないですが。
http://dobon.net/vb/dotnet/system/installedprinters.html
これでweb上のテキストデータは取得できます Sub Macro() With ActiveSheet.QueryTables.Add(Connection:= _ "URL;http://map.japanpost.jp/pc/syousai.php?id=300197019000", Destination:= _ Range("$A$1")) .Name = "syousai.php?id=300197019000" .FieldNames = True .RowNumbers = False .FillAdjacentFormulas = False .PreserveFormatting = True .RefreshOnFileOpen = False .BackgroundQuery = True .RefreshStyle = xlInsertDeleteCells .SavePassword = False .SaveData = True .AdjustColumnWidth = True .RefreshPeriod = 0 .WebSelectionType = xlEntirePage .WebFormatting = xlWebFormattingNone .WebPreFormattedTextToColumns = True .WebConsecutiveDelimitersAsOne = True .WebSingleBlockTextImport = False .WebDisableDateRecognition = False .WebDisableRedirections = False .Refresh BackgroundQuery:=False End With End Sub でも、webとVBAでは世界が違いますので、行指定等はできません 編集については別のコードを書く必要があります ちなみにVBA初心者であれば、「マクロの記録」機能を有効活用することをお奨めします このコードも「マクロの記録」機能を使用して取得したものです
#3です。 ということは、AL4:CU4の各セルにはちゃんと日付が入っているわけだよね？ じゃあ、前回私が提示したようなFor文でいけるんじゃないですか？ Excelはあまり得意でないのだが、ちょっと調べて変えてみた。 Sub 日付選択() For Each objCell In Range("AL4:CU4") If Range("AJ2").Value = objCell.Value Then objCell.Select Exit Sub End If Next Call MsgBox("そんな値ないよ！") End Sub
#2です。 Sub 日付選択() Range("L4:P4").Select Selection.Name = "日付範囲" Range("日付範囲").Find(What:=day(Range("K4")), LookIn:=xlValues).Select End Sub
手元に Access が無いので未確認ですが、このような場合はオブジェクト名を [] で囲む仕様のはずです。 rs.Open "[Q_(クエリ名)]", cn, adOpenStatic, adLockPessimistic
「品目コード」と「品目名」はテキストボックスでしょうか？ 本当にその名前になってますか？ 今一度、プロパティシートでご確認ください。 レコードソースのフィールド名なんじゃないでしょうか？ コントロールの名前を「txt品目コード」「txt品目名」に変えて 再度お試しください。
＞下記のHPに記載のあったWhizhookオブジェクトのまま使用しているのですが、問題ありますでしょうか？ 問題ありありです。 貴方が行なった「勝手な改造」により 「GetFileNameの中でキャンセルされたら、返って来る文字列が、長さ０の文字列になる」 と言う仕様が、仕様通りになっていません。 で、補足説明にあるページのサンプルですが Dim strFilePath As String と変数を宣言して、strFilePathが「長さ０の文字列」になった状態で returnValue = WizHook.GetFileName( _ と呼び出して、呼び出した後、returnValueが何になっているか調べないで GetFileName = strFilePath と、戻り値をセットしています。 キャンセルされたかファイルが選択されたか調べる場合は、本当は、returnValueの値を調べないといけないのですが strFilePath変数を宣言して、strFilePathが「長さ０の文字列」になった状態で、WizHook.GetFileName()を呼び出し、WizHook.GetFileName()がキャンセルされると、strFilePathが「長さ０の文字列」のまま変更されずに返って来る と言う動作をするので strFilePathが「長さ０の文字列」の時は、キャンセルされて帰って来た と判断しているのです。 ところが、あなたは、勝手に改造して Dim strFilePath As String の後に strFilePath = strDefaultPath という処理を入れてしまいました。すると、 WizHook.GetFileName()を呼び出し、WizHook.GetFileName()がキャンセルされると、strFilePathがstrDefaultPathの内容のまま返って来る という動作をするようになりました。 つまり「キャンセルしても、長さが０じゃない文字列が返って来る」のです。 呼び出している方は「長さ０の文字列が返ってくればキャンセルされた」と判断しているので、結局「いくらキャンセルしても、キャンセルされた事にならない」のです。 なので、当方や他の回答者さんが示した修正をしても「いくらキャンセルしても、キャンセルされた事にならない」動作をします。 今の仕様（質問者さんが改造したままの仕様）で、ちゃんとキャンセルされたか判定したい場合は WizHook.Key = 0 ' WizHook 無効 GetFileName = strFilePath の部分を WizHook.Key = 0 ' WizHook 無効 '正常終了なら０が返るので、正常終了か調べる If returnValue = 0 then '正常終了したらファイル名を返す GetFileName = strFilePath Else 'キャンセルされたなら長さ０の文字列を返す GetFileName = "" End If というように改造して下さい。 他人が作ったプログラムを改造する場合は「貴方の改造が、関数の動作仕様に影響を与えない事を、必ず確認」しましょう。 今回は、呼び出される側の「誤動作するように改造された関数が提示された」ので、バグの原因が判明しましたが、もし、提示されなかったなら「正常に動かない原因が判らない」と言う回答しか得られなかった筈です。今回は「非常に運が良かった」と思います。
WizHook.GetFileNameの引数「strFilePath」に表示させたいパスをセットすればOKでは？ なので、 Function GetFileName(OpenOrSaveFlg As Boolean, strFilter As String, _ strTitle As String, strDefaultPath As String) As String みたいにして、 Dim strFilePath As String strFilePath = strDefaultPath とすればいけそうですが・・・ strFileName = GetFileName(False, "MicrosoftExcel ブック (*.xls)|*.xls", "", "C:\Test.xls") みたいにしてコール。
#1です。補足された意味は、シートのコピーを取らずに、ＶＢＡで削除作業を実行してしまった、ということですか。 ＶＢＡで実行した削除は、私の経験では、もとに戻らないと思います。 それ（復活）に限定して、新たな質問を立てて、識者の回答を期待してください。 私も回答に、コピーを取って（テスト）実行と書くべきだったと、昨夜投稿後気づきましたが、漏らしました。 ーー 蛇足ですが、当初質問に対オする別方法。 繰り返しのＶＢＡコードを使わない方法をめざして、 エクセルでは、列方向のフィルターはできないようなので（注）、「行と列を入れ替え（Ｔｒａｎｓｐｏｓｅ）」して、●（行方向に並ぶ）でフィルタをかけて、結果をコピーし、別シート貼り付けし、また、「行と列を入れ替え」すればできました。ＶＢＡコードは略。興味があれば、マクロの記録でもとって修正してください。 ただし、少数データ例でしかやっていないので ・列数の制約　約１６０００件 ・処理速度が心配 ですが。 （注）エクセルも、行と列では、非対称的な点がある例の箇所です。
単に、ファイル名を変えるだけではいけないのでしょうか？ 「お客様の名前」を入力して、「原紙.xlsx」ファイルを 「お客様の名前.xlsx」にかえて、保存するのです。 もちろん、「原紙.xlsx」は、そのまま残っています。 同じフォルダにファイルが出来ますが、 これで良いのでは？ Option Explicit Dim n, w, x, y, z Set w = CreateObject("Scripting.FileSystemObject") Set x = w.GetFolder(".") Set y = CreateObject("Excel.Application") y.Application.DisplayAlerts = False y.Visible = False n = InputBox("Name? ") Set z = y.Workbooks.Open(x & "\原紙.xlsx") z.SaveAs(x & "\" & n & ".xlsx") z.Close y.Quit Set z = Nothing Set y = Nothing Set x = Nothing Set w = Nothing 適当な名前を付けて「～.vbs」保存してください。 その際、「原紙.xlsx」のある同じフォルダに保存して、 あとは、ダブルクリックか、シングルクリック→リターンで 実行すると、名前を聞いてくるので、 新しいお客様の名前を入力します。 すると、「原紙.xlsx」を開いて 「新しいお客様の名前.xlsx」で 同じフォルダに保存します。
こんにちは 早速ですが、VBAの方で、提案をさせていただきたいと思います。 今回は、まずA/B共に、Sheet1の内容であると仮定して。 また、Bと一致する内容の行が、Aには1行しかないことを仮定して 以下のコードを提案させていただきます。 ++++++++++ Option Explicit Sub VBAでの_Bへの数値を入力() 'A.xlsおよびB.xlsは、共にすでに開いてあるものとする。 Dim wkX As Object '探索ループ用 Dim wkA As Workbook, wkB As Workbook 'A/Bワークブックの格納 For Each wkX In Application.Workbooks '各ワークブックの探索 If wkX.Name = "A.xls" Then 'A.xls発見時 Set wkA = wkX ElseIf wkX.Name = "B.xls" Then Set wkB = wkX End If Next '解放 Set wkX = Nothing '★仮に、A/B共にSheet1にデータがあるとする。 Dim shA As Worksheet, shB As Worksheet Set shA = wkA.Worksheets("Sheet1") Set shB = wkB.Worksheets("Sheet1") Dim i As Long For i = 2 To shB.Cells(Rows.Count, 3).End(xlUp).Row 'B.xlsの2行目から下にC列終端までループ Dim k As Long For k = 2 To shA.Cells(Rows.Count, 2).End(xlUp).Row 'A.xlsの2行目から下にB列終端までループ 'B.xlsのA列(1列目)とA.xlsのB列(2列目)、 If Val(shB.Cells((((i - 2) \ 3) * 3) + 2, 1).Value) = _ Val(shA.Cells(k, 2).Value) Then '■↑B.xlsのA列には、3行ごと飛び飛びでデータがあるものとする。 'B.xlsのC列(3列目)とA.xlsのD列(4列目)の行が一致したら If shB.Cells(i, 3).Value = shA.Cells(k, 4).Value Then 'A.xlsのF列(6列目)、H列(8列目)の数値を 'B.xlsのD(4列目),E列(5列目)に数値を入力 shB.Cells(i, 4).Value = shA.Cells(k, 6).Value shB.Cells(i, 5).Value = shA.Cells(k, 8).Value Exit For End If End If DoEvents Next k Next i '解放 Set shA = Nothing Set shB = Nothing Set wkA = Nothing Set wkB = Nothing MsgBox "END" End Sub ++++++++++ 尚、上記のコードは、 取り急ぎ作成したものなので、解放など不十分な点がございます。 また、Excel2013において記述しておりますので、 ほかのバージョンでの動作不良は、ご容赦ください。 以上 ありがとうございました。
・Accessで開いて、レコード操作できる（vbaでやっているのと同じ更新／レコード追加）か、ご確認を。 ・主キーなどのインデックスがなくなったとか・・・ご確認を。 ・データベースが壊れている可能性も・・・・バックアップをとったうえで修復を。
> base64が64文字に対し日本語の文字列は5万文字？あるので大幅に減らせそう 64文字（通り）から5万文字（通り）に増えても，情報量は約2.6倍にしかなりません。 大幅に減らせるなんて事は無いです。 日本語だと文字の幅も増えるので必要スペースを考えるとさらに不利です。 似た文字が増えて誤読する可能性も考えると素直にBase64使ったほうが良いでしょう。 > QRコードのように なら、QRコードを使えば良いと思います。 目的にも合ってそうですし。
まずは、エラーメッセージどおり、 printf("整数2:"); scanf_s("%d , &n2")　←【ココ】 wa = n1 + n2; にセミコロンが無いからでは。 その他、変な所はありますが。 慣れないうちは、素直に１行１ステートメントで書いた方がいいと思う。
---------------------------------------------------- Do While objIE.Busy = True Or objIE.ReadyState <> 4 DoEvents Sleep 100 Loop Do Until objIE.document.ReadyState = "complete" DoEvents Sleep 100 Loop ---------------------------------------------------- と待ってみるとどうか？
Ｎｏ８９９６９１４の質問はＩｎｉtｉａｌｉｚｅイベントだけの問題点で解決したのか？ そうは思わないが、解決したのなら、そちらは締め切っるべきと思う。 ーー ・一旦変数に入れて（Data1など）、TextBox5単価.Text に代入する尾は回りくどい。 ・ActiveRow はありそうな名前であるが（実はシステムにはない）、ＶＢＡシステムで、たとえばＡｃｔｉｖｅＣｅｌｌは存在する名前なので、変数名の命名に注意したほうがよい。 ・繰り返しならＦｏｒＮｅｘｔなどでコード数を少なくしたら。 そのためにはＤａｔａＸとやると邪魔（やりにくく）になる。 ・標準的なＶＢＡの解説書のコントロールの解説箇所を１度読んで勉強したら。ＶＢＡの本はどれくらい読みましたか。 普通のＶＢＡにも慣れて無いのに、いきなりむつかしいこと（フォームやコントロールのこと、イベントのこと、変数のスコープなど）を、やろうとしていることが、コードの記述振りからうかがえる。 ーー 想定シートデータ例 Ｓｈｅｅｔ１のＡ１：Ｃ４に 9999988石井　一郎福島本町 3456111大下　満郡山市南町 3440000田中　宗男仙台市 3233230木村　義男山形市 ユーザーフォーム１にコマンドボタン１つとテキストボックス３つ貼り付け。 ＵｓｅｒＦｏｒｍのコードの表示へ下記貼り付け。 Dim arow Private Sub CommandButton1_Click() arow = arow + 1 Me.TextBox1 = Worksheets(1).Cells(arow, 1) Me.TextBox2 = Worksheets(1).Cells(arow, 2) Me.TextBox3 = Worksheets(1).Cells(arow, 3) End Sub 標準モジュールに Dim arow　’＜－ー最初のモジュールが始まる前の行に置くこと Sub test08() arow = 1 UserForm1.Show End Sub ーー 上記は、もし最初の表示において、シートの第１行目を出すなら Sub test09() arow = 1 With UserForm1 .TextBox1 = Worksheets(1).Cells(arow, 1) .TextBox2 = Worksheets(1).Cells(arow, 2) .TextBox3 = Worksheets(1).Cells(arow, 3) End With UserForm1.Show End Sub test09を実行後,ユーザーフォームが表示され、その上のコマンドボタンをクリックすると 順次、次行のシートのデータが表示されると思う。
ユーザーフォームを表示しただけではユーザフォーム内のプロシージャはコールされません。 ユーザーフォーム内に以下のコードを追加してみて下さい。 「UserForm_Initialize」は、このユーザフォームを開いたときに実行されるプロシージャです。 Private Sub UserForm_Initialize() 　　Call Farst End Sub
・入力される数値は、-128～127の範囲とする。（範囲外の入力は考えない） ・入力された数値が負の場合は、変換元＝256-入力値 ・入力された数値が正の場合は、変換元＝入力値 ・もし必ず２桁必要なら、変換元に256を加える。 ・変換元をHex関数で16進変換する。（変換先に入れる） ・もし２桁が必要なら、変換先の右から２桁をとる。（Right関数）
Windows CE からDBに接続するためには、ODBCドライバが必要ですが、AccessドライバのCE版というのは無いので、無理でしょう。 素直にSQL Serverを使用することを推奨します。
VBとVBAは別物なので、Excelやマクロのカテゴリで聞いた方が良いですよ。
Option Explicit '■ オブジェクトの宣言 Dim objFSO Dim objFile '■ 定数の宣言 Const strFileName = "C:\VBS\TEST.TXT" '■ 定数の宣言 '// ファイル入出力モード(8:追加書き込み) Const ForAppending = 8 Set objFSO = CreateObject("Scripting.FileSystemObject") If objFSO.FileExists(strFileName) Then WScript.Echo "ファイルが見つかりました" '// ファイルのオープン Set objFile = objFSO.OpenTextFile(strFileName, ForAppending) ' ★ ここ　← Else WScript.Echo "ファイルが見つかりませんでした" Set objFile = objFSO.CreateTextFile(strFileName) If IsObject(objFile) Then WScript.Echo "ファイルを作成しました" Else WScript.Echo "ファイルを作成できませんでした" WScript.Quit (1) End If End If ' ' ★　ここではなくて　　↑　↑ objFile.WriteLine "2012/12/21,100,ブレーキパッド,35000"
こんにちは。 > If objFSO.CreateFolder(strFolderName) Then 「戻り値オブジェクト型のメソッド」 なのに、 「オブジェクトそのものを論理式に組み込んでいる」 という構文上の誤りの結果からくる実行時エラーとして、 > Err.Number = 13 です。 > If objFSO.CreateTextFile(strFileName) Then 同様に > Err.Number = 438 です。 つまり、 メソッドの実行に際してのエラー ではなく 論理値が求められる構文にオブジェクト型を渡していることが 原因のエラー、ということです。 ２つの異なるエラーが返る理由は、それぞれのオブジェクト毎に、 「プロパティを省略した場合の既定のプロパティ」が異なるからです。 On Error Resume Next を書くのは、デバッグが済んでから にした方が、この手の混乱はなくなりますので、 一般に進められている工程です。 また、「オブジェクト型を返す」ということについて 強く意識を持って、設計からコーディングするようにしましょう。 ご提示のスクリプトを基に書き換えると下記のような感じでしょうか？ それぞれ、...Existsで存否確認済ませてますから、 エラートラップが必要な状況なのか疑問が残りますけれども、、、。 （コメントブロックした部分は、 　上述の２つのメソッドの戻り値がオブジェクト型であることを 　強調して、確認して貰おうという意図で書き添えたものです。） ' ' ----------------------------------------------------8989589w Option Explicit ' ' ------------------------------------------------------------ Dim objFSO ' Scripting.FileSystemObject 'Dim objFolder ' Scripting.Folder ★fso.CreateFolder の戻り値 'Dim objTextStream ' Scripting.TextStream ★fso.CreateTextFile の戻り値 Const strFolderName = "C:\VBS" Const strFileName = "C:\VBS\test.txt" ' ' ------------------------------------------------------------ On Error Resume Next ' ▼▼▼ Set objFSO = CreateObject("Scripting.FileSystemObject") If Err.Number Then WScript.Echo "FSOオブジェクトを作成できませんでした" ' , Err.Number WScript.Quit 1 End If WScript.Echo "FSOオブジェクトを作成しました" On Error GoTo 0 ' ▲▲▲ ' ' ------------------------------------------------------------ If objFSO.FolderExists(strFolderName) Then WScript.Echo "フォルダが見つかりました" Else WScript.Echo "フォルダが見つかりませんでした" On Error Resume Next ' ▼▼▼ objFSO.CreateFolder strFolderName ' ★ 戻り値オブジェクト型のメソッドです 'Set objFolder = objFSO.CreateFolder(strFolderName) If Err.Number Then WScript.Echo "フォルダを作成できませんでした" ' , Err.Number WScript.Quit 1 End If On Error GoTo 0 ' ▲▲▲ WScript.Echo "フォルダを作成しました" End If ' ' ------------------------------------------------------------ If objFSO.FileExists(strFileName) Then WScript.Echo "ファイルが見つかりました" Else WScript.Echo "ファイルが見つかりませんでした" On Error Resume Next ' ▼▼▼ objFSO.CreateTextFile strFileName ' ★ 戻り値オブジェクト型のメソッドです 'Set objTextStream = objFSO.CreateTextFile(strFileName) If Err.Number Then ' ▲▲▲ WScript.Echo "ファイルを作成できませんでした" ' , Err.Number WScript.Quit 1 End If On Error GoTo 0 WScript.Echo "ファイルを作成しました" End If ' ' ------------------------------------------------------------
質問のコードは、うまく行かないことは、他の回答者の説明があります。 目的（データ抽出とか言う目的でなく、わかりやすく、手早く使用する（条件を整える）うえで、こういう風にして省力化的に、「しくみ」をしたいと、「文章で！！」説明して質問すべきでしょう。自分の（たぶん、そんなにＶＢＡのエキスパートでない質問者の）アイデアの先行・無理が露出した例だと思うが、よくある。そういう質問者は自作のＶＢＡコードを張り付けて、仕組みの目的はあまり説明しない質問者が多い。その仕組みと言うかアイデアこそ、ここで識者に尋ねるべきと思う。 （例）オートシェイプのある列を条件にしようと思い、・・ チェックを入れた列を条件列にするとかか。 一応ＶＢＡを利用するということは、それだけで、省力化になっているわけです。 今回は条件さえも、何とかマウスのクリック指定で何とかしようということか？ こういうユーザーインターフェースの部分までいじくるとなると、ＶＢＡを超えたスキルがいる場合が多いように思う。 ＶＢＡのエクスパートでなければ、他人が使うことまで考慮した仕組みを作るのは、難しいと思う。 エクセルは自分で使う用だと思う。 ーーー 内容は、お気に召さないかもしれないが、やってみた。 シートデータ例　Ｓｈｅｅｔ２のＡ２０：Ｉ３０　（ＷＥＢ例から借用した） 出席番号氏名国語算数理科社会合計順位評価 1001佐藤205148461659不可 1002鈴木566467592465良 1003高橋899297813591優 1004田中717875853094良 1005渡辺2534455415810不可 1006伊藤485642521987可 1007山本928884763402優 1008中村848976843333良 1009小林615965542396可 1010加藤348238491688可 条件入力シートはＳｈｅｅｔ３　Ａ１：Ｉ６　（条件入力シートがデータシートと分離。これはできるようだ。 条件入力シート＜－－第１行 出席番号氏名国語算数理科社会合計順位評価 佐藤 鈴木 中村 伊藤 氏名をほしいだけ、操作者が入力していく。 （１）直接入力以外では、（２）元シートのコピー貼り付け、（３）全員のある氏名列を用意し、そこからＣｔｒｌキーを押しながらＤ＆Ｄ、（４）ＬｉｓｔＢｏｘで選択、などの方法を思いつくが。 ーーー ＶＢＡコード 標準モジュールに Sub Adfilter3() lr2 = Worksheets("Sheet2").Range("B15").End(xlDown).Row '元データ最下行 MsgBox lr2 lr3 = Worksheets("Sheet3").Range("B15").End(xlUp).Row '条件最下行 MsgBox lr3 Worksheets("Sheet2").Range("A20:I30").AdvancedFilter _ Action:=xlFilterCopy, _ CriteriaRange:=Worksheets("Sheet3").Range("B2:I" & lr3), _ CopyToRange:=Worksheets("Sheet4").Range("A1:I50"), _ Unique:=False 'Ｓｈｅｅｔ４に抽出 End Sub ーーー 結果 Ｓｈｅｅｔ４に　Ａ１：Ｉ５ 出席番号氏名国語算数理科社会合計順位評価 1001佐藤205148461659不可 1002鈴木566467592465良 1006伊藤485642521987可 1008中村848976843333良 ーーー ほかに、（氏名はイコール条件なのだが）未検討なのは、数値の大小条件です。 上記条件例で、Ｓｈｅｅｔ３の氏名列は空白とし、国語列のＣ２に>65などと入れる。 Ｓｈｅｅｔ3のＡ１：Ｉ３ 条件入力シート 出席番号氏名国語算数理科社会合計順位評価 >65 と入れてＶＢＡを実行すると（６５点以上） 結果 出席番号氏名国語算数理科社会合計順位評価 1003高橋899297813591優 1004田中717875853094良 1007山本928884763402優 1008中村848976843333良 ーー あと、Ｓｈｅｅｔ４で結果の表示列の選択（操作者が決定できるようにする）があるが、略。 ピヴォットテーブルのようにシート上でＤ＆Ｄを自由にやるスキルがないので上記どまりかな。
ANo.1です。 もし、セルの書式を文字列に設定するところまでマクロでやりたいのなら For retsu = 1 To Worksheets.Count　の、前に↓を入れてみて下さい。 ThisWorkbook.Worksheets(1).Columns("B").NumberFormatLocal = "@" ＃リストの範囲が解らないのでB列全体のセル書式を文字列に設定しています。
Do ~　Loop　と書いただけでは自動で監視されませんが、 別途、タイマーなどが動いているのでしょうか？ このような場合、 ChangeイベントやKeyupイベントでEnterキーを押したなどを検出して、 処理を行うのが一般的かと思います。 http://www.red.oit-net.jp/tatsuya/vb/TextBox_Event.htm
MSDNライブラリに品質レベルを指定するSaveメソッドの説明がありますが、試されましたか？ https://msdn.microsoft.com/ja-jp/library/ytz20d80(v=vs.110).aspx
＃１です。漏れがありましたので、追加回答です。 ＃１のマクロでは、 ブックBの[年齢]列にだけ結果が返る、内容になっていましたが、 ブックBの[氏名]列と[年齢]列の２列に結果が返るように書くべきでしたので、 ＃１のマクロをすべて、下に示すものと差し換えてください。 うっかりしてました。すみません。 ついでに、一応、 > ■ブックAが開いている状況からマクロを実行する前提　だけど、 >　　▲開いていなくても動作するように書きました。 ブックAが開いて居ない場合は、ブックAが開いてから処理する、という意味です。 結果として残したいものが"固定値"ではなく"数式"であるならば、 考える必要もないことですが、、、。 シート上に数式を出力する方法、については、 固定値を出力する目的であったとしても、 現代的な Excel VBA としては、寧ろ一般的な方法で、 演算結果を確定するまでの時間が短い、という特長があり、 同じ様にExcelの関数（数式）を用いるWorksheetFunctionとは、 大きく性格が異なり、パフォーマンスにも違いがあります。 他の有力な方法としては、Excelの関数（数式）を用いずに、 　ＶＢＡでメモリ上で演算した結果を返す方法や 　Excel一般機能の[検索]=.Findメソッドを使う方法など も非常に有力な方法として考えられますが、 シート上で数式を演算させる方法は、 構文的に簡潔ですし、パフォーマンスも十分ですし、 今回は「VLOOKUPで」という指定でしたので、 このような方法を選択しています。 シート上で数式を演算させる方法、の難点、注意点としては、 文字列である"数式"を整形する時にミスし易いこと、が挙げられます。 よくあるのが、 1.　数式内で文字列値を指定する時の二重引用符の書き方。 　　　"=""abc""" 　　　"=IF(A1,1,"""")"　 　　　と書くべきものを誤って 　　　"=ABC" 　　　"=IF(A1,1,"")" 　　　とか、 2.　数式内で外部シートを参照する時の書き方。 　　　='D:\フォルダ\[ブックA.xlsm]Sheet1'!$A$2、 　　　='Sheet1 (2)'!$A$2、 　　　と書くべきものを誤って 　　　=D:\フォルダ\[ブックA.xlsm]Sheet1!$A$2、 　　　=Sheet1 (2)!$A$2、 　　　とか、 今回は二重引用符は関係ありませんし、 シートへの参照方法も数式に使える形の記述を Excel側に問い合わせた結果を用いているので、 この点はミスが無いよう工夫しています。 セル範囲や引数の指定だけは確認の必要がありますけれど。 以下、差し替え、を、お願いします。 ' ' /// ブックB に記載するマクロ　２個 ///　改 Sub Re8984933w() 　　Dim sRefSrc As String ' ' ブックA On Error GoTo errH_　'　ブックA が開いていない場合のエラートラップ 　　' ' 要確認★ブック名 "ブックA.xlsm" ?　拡張子を確認して正確に！★シート名 "Sheet1" ? 　　With Workbooks("ブックA.xlsm").Sheets("Sheet1") On Error GoTo 0　'　エラートラップ解除 　　　　' ' 要確認★先頭列番地(３ヶ所) A ?★[年齢]列までの列数 .Resize(, 3) ? 　　　　sRefSrc = .Range("A2:A" & .Cells(Rows.Count, "A").End(xlUp).Row).Resize(, 3).Address(True, True, xlA1, True) 　　End With ' ' ブックB 　　With ThisWorkbook.Sheets("Sheet1")　'　要確認★ブックB:処理結果を反映させたいシート名 "Sheet1" ? 　　　　' ' 要確認★先頭列番地(３ヶ所) A ?★[年齢]列までの相対列位置 .Offset(, 1) ? 　　　　With .Range("A2:A" & .Cells(Rows.Count, "A").End(xlUp).Row).Offset(, 1).Resize(, 2) 　　　　　　' ' 要確認★ブックB:先頭列番地 A ?★ブックA:[年齢]列までの列数 ,3 ? 　　　　　　' ' 要確認 ブックA:先頭列から見た★[氏名]列の列位置 ,2 ?★[年齢]列の列位置 ,3 ? 　　　　　　.Formula = Array( _ 　　　　　　　　　　　　"=VLOOKUP(A2," & sRefSrc & ",2,0)", _ 　　　　　　　　　　　　"=VLOOKUP(A2," & sRefSrc & ",3,0)" _ 　　　　　　　　　　　　) 　　　　　　' ' 数式の結果を値として残す場合は直下の行を　イキ '　　　　　　.Value = .Value 　　　　End With 　　End With Exit Sub errH_: 　　OpenBookA 　　Resume End Sub Private Sub OpenBookA() 　　' ' 要指定★ブックAのフォルダパス　例示は「このブックのフォルダパス + \」　末尾の \ を忘れずに！ 　　' ' 要確認★ブックAのブック名 "ブックA.xlsm" ?　拡張子を確認して正確に！ 　　Workbooks.Open ThisWorkbook.Path & "\ブックA.xlsm" End Sub ' ' ///
こんにちは。 こちらの理解が至りませんでしたので、 直感的な解釈を基にして仮の設定で例を示してお応えします。 それでも必要なパーツの内の幾つかは提示できているのではないでしょうか。 お応えするスクリプトは、 > VBScriptでファイル名を取得して 　　（スクリプトを記載した.vbs）ファイルの置かれているディレクトリ 　　にあるファイル（自らのファイルを含む）すべて 　　のファイル名を（改行された文字列として）取得して > そのファイル名(英数字)を元に文字を表示させたい。 > またファイル名に使用されている文字が[1]なら[^]、[2]なら[(]、[3]なら[a]というふうに、 > 決められた文字を反映させたい 　　ファイル名に含まれる特定の文字を対応した文字列に置換する というような、ひとつの解釈、に基いた処理内容です。 （暗号or複合化、みたいなものを想定しています） まずは実行結果を確認してみてください。 その上で、 お求めの結果とは異なっているとして、 提示したパーツだけでは応用が難しい、ということでしたら、 　　求める結果とどう違うのか、 　　質問文の説明がどのように誤解されているのか、 ということに注目して、お望みの処理の内容について 補足説明をしてみてください。 ・どの？どこの？（または何を基準に？）ファイル名を取得するのか、 ・どこに？どのような？文字を表示させたい／文字を反映させたい のか、お求めの結果が確認し易いような具体例を添えることが可能でしたら、 より適切な回答に繋げることができるだろうと思っています。 ' ' /// 8984446w /// vbs Option Explicit Dim aryPlain aryPlain = Array("1", "2", "3") Dim aryCipher aryCipher = Array("^", "(", "a") Dim NEWLINE NEWLINE = vbCrLf Call test Sub test() If UBound(aryPlain) <> UBound(aryCipher) Then MsgBox "対照テーブル：件数の不一致",48 Exit Sub End If Dim oWshShell On Error Resume Next Set oWshShell = CreateObject("WScript.Shell") If Err Then Exit Sub On Error GoTo 0 Dim sDir sDir = oWshShell.CurrentDirectory Set oWshShell = Nothing Dim buf Dim oFSO Dim oFile Set oFSO = CreateObject("Scripting.FileSystemObject") For Each oFile In oFSO.GetFolder(sDir).Files buf = buf & NEWLINE & oFile.Name Next Set oFSO = Nothing buf = Mid(buf, Len(NEWLINE) + 1) Dim i For i = LBound(aryPlain) To UBound(aryPlain) If InStr(buf, aryPlain(i)) Then buf = Replace(buf, aryPlain(i), aryCipher(i)) End If Next buf = Mid(buf, 2) WScript.Echo buf End Sub ' ' ///
＃２です。 参考までに、その後に思いついたものを、記します。 出来れば、見出しを選択したいだけのためなら、ボタンをシートに張り付けるのは賛成でないので。 ーー 一番左に目次的なシートを作って配置しておけば、 シート画面の一番下の（シート名タブの左の）◀と▶の、◀を「CTRLキーを押しながらクリックする」と 一番左に移動するようだ。 VBAなどでボタン化する必要はないのでは。 ーー マクロの記録では Sub Macro1() ActiveWindow.ScrollWorkbookTabs Sheets:=-15 End Sub のようになる。マイナスは左移動のようなので、 ActiveWindow.ScrollWorkbookTabs Sheets:=-Worksheets.Countも可能のようだ。 ーー 見出しシートをいつも一番左に持ってくるのは Sub test01() Worksheets("見出し").Move Before:=Worksheets(1) End Sub ブックを開いた最初などに、このステップを入れておくと、見出しシートのTAB位置が、再左の位置になる。 ーー ほかに見出しシートのTABの色を目立つように変えておくと使いやすいかも。
丁寧なのは良いとして、質問文が長く、メモを取って整理しないと内容が理解できなかった。 下記を補足してください。 ーー 明確でない点は ・原データシートは月別（他の月分のデータは混じらない）で別シートになるのか。 ・年間では１２か月分１２シートがあるのか。 ・集計項目（A、B、Cごと）の月別シートは独立して作るのか。 ・年合計はシートに作るのか。 など、はっきり判らなかった。 ーー 月別データ１シートであれば、部門別（A,B、C別）の合計計数は=SUMIF(C17:C29,"Ａ部門",F17:F29)でよいし、 他の月が混じっていても、SUMIFS関数（２００７より増えた）で（月別、部門別）区分して合計できるだろう。 ーー コピー貼り付けなどの作業は必要かもしれないが、普通に関数を利用して、達成できるのでは。 VBAを持ち出すまでもないと思う。 関数、VBAのどちらでもよいといっても、回答者の問題でなく、受け取る側の質問者のVBAの勉強や経験による。 質問者は、試験問題の出題者の先生のような立場ではない。 この程度の課題ならエクセル関数の初歩的景観でできるのでは。 「あくまで質問者がやるのだ」という前提で、できない（行き詰まった）、むつかしい点があれば、そこを重点にして質問を記述し、質問すべきだ。自分でやろうとせず、丸投げ的に回答者を使おうというように見える。 質問者がエクセルVBAの中級にでもならなければ、手作業の多少の面倒さは辛抱せざるを得ないだろう。 ーー ＞２７年１月だけで集計したいです ２月分のデータも混じっているということ？ 月を超えても同一シートにデータを入力しているのか。 SUMIFS関数ではだめか。 ーー VBAでも関数（ワークシート関数という。SUMなど）つかえる。 例データ　 B、C列 A1 A2 B3 C2 A3 B4 A5 11　＜ーーAだけの合計 コード ２行下同列に合計を出す場合 Sub test01() r1 = Sheets("Sheet1").Range("B1000").End(xlUp).Row Sheets("Sheet1").Range("C" & r1 + 2) = Application.WorksheetFunction.SumIf(Range("B1:B" & r1), "A", Range("c1:C" & r1)) End Sub
こんにちは。 ' ' /// Private Sub DateButton_Click() 　　If TypeName(Selection) <> "Range" Then Exit Sub 　　If Selection.Count > 1 Then Exit Sub '　　ActiveCell.Activate 　　Application.SendKeys "^:{ENTER}" End Sub Private Sub UndoButton_Click() '　　ActiveCell.Activate 　　On Error Resume Next 　　Application.Undo End Sub ' ' /// UnDoを前提に考えると、入力方法を.SendKeysにするのが 一番簡単かな、と思います。 「ボタン」には、 フォームコントロールのボタンと ActiveXコントロールのコマンドボタン がありますが、後者の場合は、 　・プロパティを開いて、[TakeFocusOnClick]をfalseに指定しておくか、 　・ActiveCell.Activateのコメントブロックを外してください。 差し当たり、もしうまく動作しないケースが目につくようでしたら、 両方のプロシ'　　ActiveCell.Activate　の次の行に DoEvents: DoEvents を書き加えてください。 尚、 今回の課題事態にも言えることですが、 マクロの実行によってExcel配下のプロパティを変更した場合は、 ExcelはUnDoする候補の記録を破棄します。 （Worksheet_SelectionChangeなど使う場合は処理内容に注意） つまり、一旦マクロを実行してしまえば、 UnDoマクロは機能しなくなりますが、この点は、 ＶＢＡではどうにもできないExcelの仕様によるものです。 考え方を変えれば、すべての処理内容をExcelに頼らず、 ＶＢＡ側で記録しておいてひとつ前の状況を再現させることも 出来なくはないです。 ただ、その場合は細か～い条件のひとつひとつを確認しながら、 細か～く書き上げることになると思いますので、 現在のような情報のやり取りから こちらが導くのは現実的に不可能ですから、自力でお願いします。 結局のところ、.SendKeysをお奨めするのが、 現実的で、簡易な方法、ということになりますが、 .SendKeysが潜在的に抱えている不確かさ、ということも 知っておいてください。 でもまぁ、Excelを使う時には、他のアプリケーションを動かさない、 ということだけでも、看過できる不確かさ、にはなると思いますので。 上記の Private UndoButton_Click() については、ボタンでなくとも、 [Ctrl]+[Z}など、普通にExcel側の操作で [元に戻す]処理をするのと同じです。 以上です。
セルとあるので、Excelマクロかな？違っていたら無視してください。 VBAは標準で正規表現をサポートしていないので、RegExp オブジェクトを作成します。 下記のVBAコードを標準モジュールへ記述のうえ、Sample1を実行してください。 ・A1～空白があるセル（最大A20）までを判定対象とします。 ・正規表現によるマッチングで、一致しない場合は対象セルをセル選択して結果表示。 ・全て一致した場合は「〇件、問題ありません」と表示。 コード的には下記サイトの正規表現によるマッチングコードを書き換えたものになります。 （参考にどうぞ） http://officetanaka.net/excel/vba/tips/tips38.htm ■VBAコード Sub Sample1() 　　Dim RE, r As Range 　　Dim myCell As Range, cnt As Integer 　　Set RE = CreateObject("VBScript.RegExp") 　　With RE 　　　　'正規表現を定義 　　　　.Pattern = "[0-9]{5}\-[0-9]" ''検索パターンを設定 　　　　.IgnoreCase = False　　　　 ''大文字と小文字を区別しない 　　　　.Global = True　　　　　　 ''文字列全体を検索 　　　　For Each r In Range("A1:A20") 　　　　　　If Len(r.Value) = 0 Then Exit For 　　　　　　'正規パターンの一致確認 　　　　　　If .Test(r.Value) Then 　　　　　　　　'正解数をカウント 　　　　　　　　cnt = cnt + 1 　　　　　　Else 　　　　　　　　'誤っているセルを格納 　　　　　　　　If myCell Is Nothing Then 　　　　　　　　　　Set myCell = r 　　　　　　　　Else 　　　　　　　　　　Set myCell = Union(myCell, r) 　　　　　　　　End If 　　　　　　End If 　　　　Next r 　　End With 　　'結果表示 　　If myCell Is Nothing Then 　　　　MsgBox cnt & "件、問題ありません" 　　Else 　　　　myCell.Select 　　　　MsgBox myCell.Count & "件の間違いがあります" 　　End If 　　Set RE = Nothing 　　Set myCell = Nothing End Sub
本件課題は、仕事で使う「ニオイ」がする。他の（他課の）人の作った・使う、データをまたがって使う複数人参加なのではないですか。 エクセルでは、他の人と共同で利用するのは、ＶＢＡでやるのは、相当知識と経験がが要り、この程度の質問の仕方をする人には、習得や慣れに今後長期を要するのではないかな。 他人利用でセキュリティや誤入力、誤操作に対する備えが、必要になり、非常にむつかしくやりにくいと思う。 エクセルは個人使用のソフトなのだと思う。それをエクセルしか知らない人が、何でもエクセルでややろうとする例が多いのではないか。 ーー 利用する仕組みとして、Ｏｆｆｉｃｅ関連に限ってでも、いろいろありそうだが、こういうことは何も質問に書いてない。 （１）抽出作業はどうするか 　　・Ｆｉｌｔｅｒ 　　・Ｑｕｅｒｙ 　　・その他 （２）他ブックへのコピー作業 　　・リンク 　　・Ｑｕｅｒｙ （３）（１）の抽出作業・更新作業のキッカケ 　　　・リンク 　　　・Ｑｕｅｒｙ　Ｒｅｈｒｅｓｈ 　　　・ＶＢＡのイベント ーー 自分だけでやるなら、 （Ａ）のブックを自分の領域にコピペしてきて （Ａ）ブックの作業ＶＢＡ化はやるとしても、結果を（Ｂ）のブックのシートに手動コピペして、（Ｂ）のシートに おいて作業（利用）すればよいと思う。普通はこの程度でしょう。 コピペが面倒とか、社内事情などで、質問のことが出てくるのかもしれないが、質問者のプログラム力がその近く までいってなければ、諦めざるを得ないでしょう。丸投げして、このコーナーにお願いではね。 ーー 私は上記の仕組みのそれぞれを自由に使える力はないが、一応考えてみたので報告する。 仕組みは、Ｆｉｌｔｅｒ－コピーーイベントを使う。 下記の回答の場合、追試をやってみるなら （Ａ）「フィルダ例１」という名のブック （Ｂ　「フィルタ結果受け」という名のブック をそれぞれ作る。 （Ａ）ブックには「Ｓｈｅｅｔ１」というシートを作り、この回答内の下記データをコピーし 質問者のエクセルシートに貼り付けする。 1氏名役職部署年齢移動時期 2山田社員開発45未調整 3田中社員人事424/1から 4鈴木派遣企画30 5高橋役員人事50未調整 6坂野社員企画33 7井上派遣企画29 8木下社員人事50未調整 9坂野社員企画33未調整 10奥村派遣企画29未調整 11田島社員人事50 12大島社員人事51未調整 そして、データー区切り位置以下の操作で、質問者のエクセルシートSheet1の、各行の各列セルに分けられる。 これで私の作ったデータ例が質問者のエクセルシートに再現される （Ａ）ブックには「Ｓｈｅｅｔ２」というシートを作っておく。 　　フィルタ後に結果を張り付けるシートです。 （Ｂ）には最小限で「Ｓｈｅｅｔ１」を作っておく。 ＜準備＞ （Ａ）の「Ｓｈｅｅｔ１」（原データのシート）をＡｃｔｉｖｅにしておく。 　両方のブックを同時に開いておくこと。 ＜コード＞ （Ａ）ブックの標準モジュールに回答の下記コードをコピペする。 Sub test01() Windows("フィルタ例１.xlsm").Activate 'フィルタ例１の１は全角 Worksheets("Sheet1").Activate With ThisWorkbook.Sheets("Sheet1").Range("A1").CurrentRegion .AutoFilter MsgBox "フィルタ解除を確認する" .AutoFilter Field:=4, Criteria1:="人事" .AutoFilter Field:=6, Criteria1:="未調整" lastrow = ActiveSheet.Range("A1000").End(xlUp).Row MsgBox lastrow ActiveSheet.Range("A1:F" & lastrow).Copy Worksheets("Sheet2").Range("A1") 'ActiveSheet.Range("A1:F" & lastrow).Copy Workbooks("C:\Users\惇\Documents\フィルタ結果受").Worksheets("Sheet1").Range("A1") Worksheets("Sheet2").Range("A1:F" & lastrow).Copy Windows("フィルタ結果受.xlsm").Activate Worksheets("Sheet1").Activate 'Sheet2にすればSheet2に張り付く ActiveWindow.ActiveSheet.Paste End With End Sub （Ｂ）ブックの標準モジュールに回答のコードをコピペする。 Sub test01() 'Application.Run "C:\Users\ｘｘｘ\Documents\フィルタ例１!test01" Application.Run "フィルタ例１!test01" End Sub ＜コード修正＞ フォルダ名（ブックの）はテストの場合も質問者の場合に合わせて変えること。 ブック名、シート名も本番では、質問者の場合に合わせて変えること。 ＜実行＞ （Ａ）ブックのを実行してみて、（Ｂ）ブックの「Ｓｈｅｅｔ１］に、抜き出し結果が正しく 移るかテスト。 ＜結果＞ Sheet2に 1氏名役職部署年齢移動時期 5高橋役員人事50未調整 8木下社員人事50未調整 12大島社員人事51未調整 ＜テスト＞ うまく行けば、（Ｂ）ブックの標準モジュールの「Test01()」を実行して、（Ｂ）ブックの 「Ｓｈｅｅｔ１］に、フィルタ結果（抜き出し結果）が, 正しく移るかテスト。 結果は上記と同じく 1氏名役職部署年齢移動時期 5高橋役員人事50未調整 8木下社員人事50未調整 12大島社員人事51未調整 ＜プロジェクトエクスプローラーの状態＞念のため記す VBAProject(フィルタ結果受け.xlsm） Module1 <ーー最終こちらを実行（C） ・・・ VBAProject(フィルタ例１.xlsm） Module1　＜－－中間でテストで、こちらを実行確認 ・・・ （C)は　Auto.Openイベント（開くと実行する）ででも実行するか、ボタンに登録する。 ーー このやり方なら、その都度、本件操作時点の更新後の正しいデータを使うので、質問者側で更新に 気を使う必要はないだろう。
こんにちは。 パスワード付きのpdfはopenできている状態でしょうか？ readしたpdfをセキュリティなしで作成したいのでしたら、 >writer.SetEncryption は不要ではないでしょうか？ #使ったことがないので検討違いでしたらすみません
大丈夫、言ってることはわかるよ。 この場合、検索結果を表示する前から処理しないと取得できない。 例えば検索内容に値をセットしてボタンを押すとか、 直接適切なリクエストを投げて結果を取るとかしないとダメ。
変数「wb1」「wb2」は文字列型として宣言していますので、wb2.Sheets("一覧表")　こんな使い方は出来ません。この様に使うためにはWorkbookオブジェクトにする必要があります。 次に、質問文が正しいとすると、Copy関数の使い方が逆です。 例：Worksheets("Sheet1").Range("A1").Copy Worksheets("Sheet2").Range("B2") Sheet1のセルA1からSheet2のセルB2にコピー また、開いたテキストファイルのシート名を「Sheet1」としていますが、テキストファイルはファイル名がシート名になります。 シート名を指定するよりはSheets(1)の様にして1番目のシートと指定した方が良いと思います。 また、悪いわけではありませんがCopyの様に他でも良く使う名前をプロシージャ名に使うのは混乱の元です(以下の例ではDataCopyに改名しました）。なるべく使わない方が良いです。 Dim wb1 As String Dim wb2 As String Dim wWb1　As Workbook Dim wWb2 As Workbook Sub Opentxt() 　　wb1 = Application.GetOpenFilename("テキストファイル,*.txt") 　　If wb1 <> "False" Then 　　　　Workbooks.OpenText Filename:=wb1, DataType:=xlDelimited, comma:=True 　　　　Set wWb1 = ActiveWorkbook 　　End If End Sub Sub DataCopy() 　　Dim LastRow As Long 　　wb2 = Application.GetOpenFilename("Microsoft Excelブック,*.xls?") 　　If wb2 <> "False" Then 　　　　Workbooks.Open wb2 　　　　Set wWb2 = ActiveWorkbook 　　　　LastRow = wWb2.Sheets("一覧表").Range("A" & Rows.Count).End(xlUp).Row 　　　　wWb1.Sheets(1).Range("B33").Copy wWb2.Sheets("一覧表").Range("A" & LastRow + 1) 　　End If End Sub
ぱっと思いつくのは、基準とする解像度/ウィンドウサイズ？を決めておいて、 ラベル幅40×(解像度/基準とする解像度) で 表示の都度ラベル幅を計算するような感じはどうでしょうか？ ガントチャートみたいなアプリを作りたいということだと思いますので、 参考URLのようなライブラリも使えるようですね。
いや、別にツリー表示するくらいならそんな難しいことじゃないけど、 どこまで理解しているのかわからないから。 VBでGUI自体は作れるの？
背景には等比級数の和の式がある。公式もあるが、あえて先生はＬＯＯＰ（繰り返し処理）の問題に持って行ったものだろう。 そして単純に３＾ｎまでの和でなくて、少しひねって＞500から50000の間に入る数字は、としたものと見える。 ここで５００を超えた時のｎを最終段階まで覚えておかないといけないが、それを仕組むためには、その超えて次の次の段階ではｎを覚えておく変数に代入し（値を崩してしまわ）ないようにしないといけない。この技法の方が、プログラマ的には重要（よく出くわす）のを先生は知っているのかな。 これをスイッチ、（とかサイン、フラグ（３つとも通称））という技法でやってみた。使わない方法はあるのかな。 ５００を超えるまでと、５００００を超える（この段階でプログラムを終了してよい）の２段階（２区分）に分ける方法もあると思う（Ｌｏｏｐが２回出てくる）が、今回は前者でやってみた。 Sub test02() s = 0 '各項までの部分和　初期値として０ n = 1 '累乗の最初１ ovr500 = "N" '部分和が500超えず '--繰り返し部分 Do While s <= 50000 s = s + 3 ^ n MsgBox s If s > 500 Then If ovr500 = "N" Then from = n MsgBox "500超えのn " & n ovr500 = "Y" '超えたというフラグを立てる End If End If ’Range("F" & n) = s n = n + 1 '累乗値を1増やす,その後、繰り返し Loop '-- MsgBox "50000超えのｎ " & (n - 1) 'sが50000を超えるとここへ来るが、終了 '課題の数を計算 MsgBox (n - 1) - from '(10-1)-6 End Sub ーーー 確認のためやエクセルでやるなら エクセルでは Ａ，Ｂ、Ｃ列 133 2912 32739 481120 5243363 67291092 721873279 865619840 91968329523 105904988572 Ａ列は連番数字 Ｂ列の式　Ｂ１セルに　=3^A1　と入れて下方向に式を複写 Ｃ列の式　Ｃ１セルに　=SUM($B$1:B1)　と入れて下方向に式を複写 結果は上記の通り。　 視察で ９－６＋１の４数（個）が該当。
２パターンSPLITすればいいのではないですか？ 例えば、こんな感じ。 （VBで変数の定義を忘れたのでざっくりですが） 変数A = 元の値（kkk4 "バージョン 6" 23） 変数B = 元の値（kkk4 "バージョン 6" 23） 変数A を「"」でスプリットする（「バージョン 6」がとれる） 変数B を「半角スペース」でスプリットする ary(0)・・・kkk4 ary(1)・・・"バージョン ary(2)・・・6" ary(3)・・・23 が取れる。 あとは、変数Aでとれた必要な配列と、 変数BのSPLITでとれた必要な配列の箇所（ary(0), ary(3)）を使用すればいいのではないですか？
FireFoxのタイトルだけでしたら、以下のページのようにプロセス名をチェックしてウィンドウタイトルを取得できると思います。 http://dobon.net/vb/dotnet/process/enumwindows.html FireFoxのURLに関してはDDEを使うと取得できるようです。 http://stackoverflow.com/questions/7814027/how-can-i-get-urls-of-open-pages-from-chrome-and-firefox
>Do...Loopについてお 1づつ加える（自然）数を順次増やしていくという、ロジックにおいての質問でしょう。 ＞1+2+3...=の値はｎが増えるにつれて、「単調増加」していくことはわかりますよね。 Ｓｎはｎまでの自然数の和として s1<s2<s3<.... だから１００を初めて超えたｎのnー１（直前に足した数）が答えになる。直前に足した数を変数に毎度覚えておくか（これは回りくどい）、超えたところで、ｎに対し－１すればよいのでは。 前判定do loopより後判定do Loop・・whileのほうが書きやすい。しかし先生の指定があるなら仕方がないが。 ーー エクセルＶＢＡでの例。 Sub test01() s = 0 n = 0 Do While s < 100 n = n + 1 s = s + n Loop 'loopを脱出した MsgBox "loopを脱出した加数" & n MsgBox "答えは" & n - 1 End Sub ーー 小生なら下記を書いてしまう。 Sub test02() n = 1 s = 0 For n = 1 To 100 s = s + n If s > 100 Then Exit For Next n MsgBox n - 1 End Sub （注）If s > 100 は等しいとすべきか、超えるとすべきかよく設問の趣旨に従ってください。
Linq には接続先によって色々種類がありますが、"Linq to SQL" は以前から死滅する方向になっているっぽいという噂があります。 http://d.hatena.ne.jp/atsushieno/20081103/p1 質問者さんは http://okwave.jp/qa/q8971091/a24942758.html の質問をされた方だと思いますが、使用しているのが .NET Framework 3.5 だとちょっとキナ臭いかもしれません。 なお、Linq の中でも "Linq to Object" は、配列やコレクションの並び替えなどで便利なので、使用されるケースは結構見ますよ。
すみません、WindowsXPの時は問題なかったのですが、 ７ で試すと、96 から変わりませんね。。。。 （Win7 64bit Access2010 32bit で検証） API 版ですがこちらはどうですか？（当方では可） こちらも標準モジュールにコピペです。 Private Const LOGPIXELSX = 88 Private Const LOGPIXELSY = 90 Private Declare Function GetDesktopWindow Lib "user32" () As Long Private Declare Function GetDC Lib "user32" _ (ByVal hWnd As Long) As Long Private Declare Function GetDeviceCaps Lib "gdi32" _ (ByVal hdc As Long, ByVal nIndex As Long) As Long Private Declare Function ReleaseDC Lib "user32" _ (ByVal hWnd As Long, ByVal hdc As Long) As Long Public Function Are2() As Long Dim hWndDesk As Long Dim hDCDesk As Long Dim logPix As Long On Error GoTo Err1: hWndDesk = GetDesktopWindow() hDCDesk = GetDC(hWndDesk) '画面のフォントサイズを取得 Are2 = GetDeviceCaps(hDCDesk, LOGPIXELSX) Call ReleaseDC(hWndDesk, hDCDesk) Exit Function Err1: 'エラーの場合は、-1を返す Are2 = -1 End Function
NorthwindDataContext は、おそらく『SQL Server の Northwind データベース (SQL Server のサンプルデータベース) に接続するような機能を、Visual Studio .NET のウィザード(コード自動生成機能) を使って作ると、自動的に作成されるクラス』です。 接続先が Northwind データベースだから NorthwindDataContext という名前が自動的に付けられただけで、接続先のデータベース名が Pubs なら PubsDataContext、OKWave なら OKWaveDataContext になります。 必須かどうかについては、『質問者さんの作ったプログラムで使用していのであれば、要るのではないですか？』としか言いようがありません。もし、Northwind データベースに接続する機能を作ったつもりがないのであれば、どこかで操作を誤ってサンプルデータベースに接続するゴミコードを作ってしまったのでしょう。
ANDと不等号で範囲を絞るのはどうでしょうか？ DataTable1.select(date1 >= CDate('2015/01/01') AND date1 <= CDate('2015/01/31')) 参考URLには本日分のデータを取得するサンプルが掲載されています。
aからbまでの間で偶数の個数は aが奇数ならINT((b-a+1)/2)個であり aが偶数ならINT((b-a+2)/2)個です。
ご存知と言うか、勉強しましょう。 ブラウザはwebページを開くもので、ブラウザで処理できないものは、ブラウザ上では処理しません。 それだけです。 画像編集ソフトで音楽ファイルを開こうとするのと同じことですね。 ファイルの種類は単純に、拡張子で分けられていますが、そもそもexeが何だかわかれば疑問にならない気がします。 本当に技術者なんですかねぇ
後継ソフトなら次の Visual Studio Express 2013 Desktop になりますね、 Expressは無料で使用できます。 Microsoft Visual Studio Express 2013 Desktop https://www.microsoft.com/ja-jp/download/details.aspx?id=44914 インストール方法などは次のサイトなどが参考になると思います。 http://homepage1.nifty.com/rucio/main/material/VB2013Install.htm 旧式のＶＢのプロジェクトも変換してくれます。 でもそう言う私も、変換してくれても修正や作り直しが必要だったり、新しい開発環境に馴染めず使い難いと思い、結局はWin7にVB6.0を入れ直したのですけどね。
>エクセルを開いたらA１セルの値が５だったら２行目のA１セル値とマッチしたG2 ５の値の列が先頭列へ移動するようにしたい という事は、「A１セルの値とマッチした値が入力されているセルが存在している列が先頭列になる様にする」という処理を行うのは、Excelbookを開いた時のみであり、Excelbookが既に開いた状態となっている時には、特定のシートを開いただけでは何も起こらない様にすると考えれば良いのでしょうか？ 　又、「A１セルの値とマッチした値が入力されているセルが存在している列が先頭列になる様にする」という処理を行うのはExcelbookを開いた時に最初に表示されるシートのみで、他のシートに対してはその様な処理を行わないと考えても宜しいのでしょうか？ 　もしそれで宜しければ以下のVBAを、"標準モジュールではなく"、ブックモジュールに記述されると良いと思います。 　尚、「Microsoft Visual Basic」ウィンドウにおいて「プロジェクト - VBAProject」画面の中にある「Thisbook」と記されている箇所をダブルクリックしてから、「プロジェクト - VBAProject」画面の右隣のVBAの構文の記入欄の左上にある「(General)」と記されている欄をクリックし、現れた選択肢の中にある「Workbook」を選択する事で、VBAを記述するモジュールがブックモジュールに切り替わります。 【参考URL】 　Excel VBA 入門講座 > 第4章　ワークブックの操作 / 5.ワークブックのイベントプロシージャ 　　http://excelvba.pc-users.net/fol4/4_5.html Private Sub Workbook_Open() 'QNo.8962735 セル値が指定行のセル値とマッチしたら先頭列へ移動 Dim myValue, myCell As Variant myValue = Range("A1").Value If myValue = "" Then Exit Sub Set myCell = Range("B2", Cells(2, Columns.Count)).Find(What:=myValue, _ LookIn:=xlValues, Lookat:=xlWhole, MatchByte:=False, MatchCase:=False) If myCell Is Nothing Then Exit Sub ActiveWindow.FreezePanes = False Columns("C").Select ActiveWindow.FreezePanes = True ActiveWindow.SmallScroll ToRight:=myCell.Column - Selection.Column End Sub
「現在の行を受け取る変数とは別に、前の行の内容を保存しておく変数を用意すればいい」というのがわからなかったということですね…。あなたのコードを修正するのならこんな感じでしょう。「preLine」に前の行を保存しておくということです。 ちなみに「Line Inputステートメント」はVBSでは使えないので、もしもVBSで書きたい場合には、FileSystemObjectなどを使って書き換えましょう。それでも、考え方は同じです。 Sub timeout() keyword = "タイムアウト" i = 0 Open "C:150423-all.txt" For Input As #1 Open "C:150423-timeout-vba.txt" For Output As #2 keyword = "*" & keyword & "*" readLine = "" Do Until EOF(1) i = i + 1 preLine = readLine Line Input #1, readLine If readLine Like keyword Then Print #2, CStr(i) + ":" + preLine End If Loop Close End Sub
下記を参考に、質問に、後続の読者のために補足すべきと思う。 ーー 質問の表現が質問者の我流で、データの状況がよく伝わらない。下手な例や、下手な我流のＶＢＡコードを載せるより、文章で表現できるようになるべきだと思う。 そのうえで熟達者の回答コードを読んで、勉強して取り入れる時期でしょう。 ＞VB初心者です。であるとともに、表現の初心者のように思う。 ーー >２つの異なるファイルからの情報に齟齬がないかを ｛齟齬」なんて言う言葉を使うより。「違い」でよいと思うし、セル単位の文字列的に完全一致を同じと解してよいのだろうか。 ーー Ｓｈｅｅｔ１なんて言っているから、エクセルＶＢＡの質問だろう。ＶＢでなくＶＢＡの質問だろう。両者は同じではないと早く悟ったほうがよい。 ーー エクセルのデータとして、シートにデータがどういう状況で入っているかを、説明しないと、比較の話にならない。挙げた例が不適切。 比較とはＡ場所（○○同志のこと。１対１、１対多などある）Ｂ内容（どういう違いまでを同じとするか）を明確にしてが、前提の話だろう。 （１）シートのデータの比較は、対応セル単位しかできないと思ったほうがよい。またセルの文字列の全体を比較するのならば、まだやさしい。しかし一部同志などとなると初心者にはむつかしい。比較する同志が２つのセルのどこにあるか、簡単にＶＢＡで表現できない場合は、初心者にはお手上げだろう。 （２）比較するセルの、あり場所（対応関係）はどう考えたらよいのか。 普通２つのシートにある場合の質問が多いが、この質問では１つのシートの隣り合った行にあるのか（質問のコードからするとそうも見える）。２つのペア関係（行関係）は完全なのか。崩れているケースはないのか。 ここにも初心者が我流のＶＢＡコードを挙げて質問することの、読者の誤解を招く例である。 （３）２つの行のペア関係でＡ列同志、Ｂ列同志、・・で比較すればよいのか。 しかし質問にＦＩＬＥ１、ＦＩＬＥ２なんて表現があるところを見ると、別ブックの（したがって別シート）にデータがあるのか。エクセルではＦＩＬＥはブックというのだ。 ＞マッチングやテストもあるのですが 何のことですか。マッチングのアルゴリズムを知ったうえで言っているのですか。マッチングを行うのはユニークなキーが比較する両者にある場合はやさしいが、それがないか、はっきりしない場合は、ロジックがむつかしくて歯が立たないとおもう。 -- 別ブックの別シート、同一ブックの別シートのデータの扱いを、ＶＢＡやったことがあるのか。質問に上げたコードでは、それがうかがえない。 この辺の簡単な例を勉強することから始めないといけない。
#1です。 小生の誤解で質問内容を変えて解釈しているかもしれないが、１つの参考に。 例え、別の質問であったとしても、今後別の場面で 参考になると思う。 ーー 例データ Ｓｈｅｅｔ１ 調べたい商品の一覧データ。下記では卵とみかん。 担当者価格地域在庫商品名商店名 Bさん埼玉卵佐藤屋 Cさん２５０円神奈川みかん高橋屋 ーー 例データ（ｆｉｌｅｂからコピーをお勧め） 少し勉強が進んだら、ＦＩＬＥＢを直接対象にしたＶＢＡが組めるだろう。 調べるべき資料データ。 Ｓｈｅｅｔ２ 商店名商品名価格地域担当者在庫 山田屋みかん100東京Aさん有り 佐藤屋卵200埼玉Bさん有り 高橋屋牛乳250神奈川Cさん有り 井上商店卵188埼玉Bさん有り 東京商店みかん98埼玉Aさん有り 木村卵195埼玉Bさん有り 今村みかん92静岡Aさん有り ーー コード 標準モジュールに Sub test01() l1 = Worksheets("Sheet1").Range("A65536").End(xlUp).Row MsgBox l1 For i = 2 To l1 c = Worksheets("Sheet1").Cells(i, "D") MsgBox c 'selection.AutoFilter Worksheets("Sheet2").Range("A1:F65536").AutoFilter Field:=2, Criteria1:=c Worksheets("Sheet2").Range("A1").CurrentRegion.Copy Sheets("Sheet3").Cells(Rows.Count, 1).End(xlUp).Offset(1, 0) Next i End Sub ーー 実行結果 Ｓｈｅｅｔ３ 商店名商品名価格地域担当者在庫 佐藤屋卵200埼玉Bさん有り 井上商店卵188埼玉Bさん有り 木村卵195埼玉Bさん有り 商店名商品名価格地域担当者在庫 山田屋みかん100東京Aさん有り 東京商店みかん98埼玉Aさん有り 今村みかん92静岡Aさん有り ーー 私は商品の区切りとして、あるのも良いと思ったが、 見出し「商店名商品名価格地域担当者在庫」が重ねて中間に入っているが、省く方法は http://officetanaka.net/excel/vba/tips/tips155c.htm　に解説がある。 全般にフィルタのＶＢＡについてこのＷＥＢサイトは参考になる。また田中亨さんの、ＷＥＢのＶＢＡの記事は、常々良さを感じています。 ーー 急いでコードを書いて、テストやチェックが不十分かもしれませんが、よろしく。 参考 上記の例データをシートに再現するには、操作の、データー区切り位置以下で処理すると、セルごとにうまく配置されます。
＃３です。補足欄拝見しました。ご苦労様です。 [番号]列は昇順に並んでいる、という前提のようですので、 「最大値」ではなく、 各[種別]毎に「最終行である番号」を基準に、 １加算した新しい付番を返すようにします。 > ... 「100-999-999」だった場合は、 > 「101-000-001」とせずに、エラーを吐くようにしたいです。 この追加要求については、 差し当たり、出力先セルの値が、エラー値 #N/A になるように書きました。 ご確認をお願いします。 ' ' /// Sub Re8958570() Dim Target As Range, c As Range Dim vClass, vRtn 　　' ' 「メインシートのA2」で選択された[種別] 　　' ' ◆要指定◆""で括ったシート名◆要指定◆""で括ったセル参照 　　vClass = Sheets("メインシート").Range("A2").Value 　　With Sheets("シート１")　'　◆要指定◆""で括ったシート名 　　　　' ' [種別]のデータ領域すべてをセル範囲として取得 　　　　' ' ◆要指定◆""で括ったセル参照２ヶ所 = "A2:A" ？、 = "A" ？ 　　　　Set Target = .Range("A2:A" & .Cells(Rows.Count, "A").End(xlUp).Row) 　　End With 　　' ' [種別]のデータ領域に対して、選択された[種別]のうち最下行位置にあるセルを、検索 　　Set c = Target.Find( _ 　　　　　　　　　　What:=vClass, After:=Target(1), _ 　　　　　　　　　　LookIn:=xlValues, LookAt:=xlWhole, _ 　　　　　　　　　　SearchOrder:=xlByRows, SearchDirection:=xlPrevious, _ 　　　　　　　　　　MatchCase:=False, MatchByte:=False) 　　' ' 万が一、選択された[種別]が見つからない場合 　　' ' ◆要指定◆""で括ったメッセージ内容とタイトル 　　If c Is Nothing Then MsgBox "指定の[種別]に該当するデータは見つかりません。", vbExclamation, "Title": Exit Sub 　　' ' 結果（新しい付番）取得 　　' ' ◆要指定◆ 列の位置関係について、[種別]から見た[番号]の相対位置 = 1 ？ 　　vRtn = NextID(c.Offset(, 1).Value) 　　' ' 結果出力 　　' ' ◆要指定◆""で括ったシート名◆要指定◆""で括ったセル参照 　　Sheets("メインシート").Range("B2").Value = vRtn End Sub Function NextID(ByVal v) 　　' ' "-"をトル 　　v = Replace(v, "-", "") 　　' ' 数値化して１加算 　　v = Val(v) + 1 　　' ' 「「100-999-999」だった場合は...エラーを吐くようにしたいです。」 　　If v Mod 1000000 = 0 Then 　　　　NextID = CVErr(xlErrNA)　'　エラー値 #N/A を返す。 　　　　Exit Function 　　End If 　　' ' 「またデータが「100-000-999」だった場合は、数値をリセットし、「100-001-001」としたいです。」 　　If v Mod 1000 = 0 Then v = v + 1 　　NextID = Format$(v, "0-000-000") End Function ' ' ///
× ws.Move(wb.Worksheets[totalSheets]); ○ ws.Move(Missing.Value, wb.Worksheets[totalSheets]); https://msdn.microsoft.com/ja-jp/library/microsoft.office.tools.excel.worksheet.move.aspx https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.worksheet.move%28v=vs.80%29.aspx
下記は捨石の回答です。質問で状況が十分説明されてない（注１）と思うからです。 下記で仮定している状況が、質問例の簡単化のために、質問者がそう書いたので、実際は複雑なら、その旨を後の回答者のために、ぜひ追記してください。 ーー 例データ Ｓｈｅｅｔ１で 第１行は見出しなどとして考慮除外する。 Ａ２：Ｂ１３　Ｃ列は考慮しない。 １ ーーA　ーーは実際は空白セルＡ列。左に寄って表示されるので、入れたもの。実際はないもの。 ーーB ーーC ２ ーーA ーーB ーーC ３ ーーA ーーB ーーC とする。 シート１の「ダブル」クリックイベントに（クリックは、より多く使われると思い、こちらにした） Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Target.Column = 1 Then MsgBox Target.Offset(, 1) MsgBox Int((Target.Row - 1) / 4) + 1 If Target.Offset(, 1) = Int((Target.Row - 1) / 4) + 1 Then r = Target.Row x = (r + 1) & ":" & (r + 3) MsgBox x Rows(x).EntireRow.Hidden = True Else End End If End If End Sub を入れる。 Ａ列第２行目、Ａ列６行目、Ａ列１０行目などを、それぞれダブルクリックすると、３から５、７から９、１１から１３行目までを非表示にします。 ＭｓｇＢｏｘはテスト用なので、本番では省いてください。 （注１）仮定が明確でない。ＡＢＣの３行と小生は仮定しているが、ＡＢＣＤやＡＢの行はないのか。 ーー チェックボックスを使っていないわけは、チェックボックスが置かれていると見えるセル（の行）が、そもそもあいまいと思うから。コントロールは、特定の行に張り付いたものではないと思う（小生の不勉強で間違っておれば、他の回答者の回答を待ちます）。すなわち特定のコントロールから、所属行を割り出せない（エクセルの）仕組みと思うから。 ーー 繰り返しのテストで非表示を解除する必要があるなら Sub test02() Rows.Hidden = False End Sub を、標準モジュールに入れて、実行してください。 ーー ボタンをトリガーにするほうほうはある。その場合は置かれたセル８アクチブセル）に全面的に頼ることになるが、セルのアクチブ場所を気にしないと、おボタンをクリックした後にアクチブセルが間違っていたなどというケースの心配をして、今回はそのコードは略。 ーー MsgBox Int((Target.Row - 1) / 4) + 1 If Target.Offset(, 1) = Int((Target.Row - 1) / 4) + 1 Then はＡの上の行をクリックしたことのチェックを入れている。 また If Target.Column = 1 Then も、ダブルクリックした列のチェックのためです。
Sub hidden() Dim x As Integer x = ActiveCell.Row - 1 Range(Cells(1, 1), Cells(x, 1)).EntireRow.hidden = True End Sub でOKです。 Rows("3:x-1")のように""内で計算はできません。 計算してから、""内には入れるようにしましょう。 あと、VBAを作る上でSelectやSelectionは動作を遅くするだけで無意味です。 上記のように画面上の動作無しに処理ができるので、そのようにした方が良いです。 ご参考まで。
その字の如く、３２ビットのＯＣＸが無い、と言ってます。 マイクロソフトの「デベロッパー」に登録すると、貴社のＩＤが埋め込まれてますが、特殊なＣＤキーが貰え、旧Ｗｉｎｄｏｗｓが使えますので加入も一考だと思います。 ただし、ＣＤキーを流失させると、貴社であることが分かってしまいます。ウイルスなどにご注意ください。 手は３つ １．Ｗｉｎｄｏｗｓ６４対応の開発ツールに、ＯＳとＶＢを切り替える。 ２．デベロッパーネットワークに加入し、特殊なコード（貴社の情報入り）を貰う ３．中古のＸＰマシンを購入する が考えられます。 または、ＶＢを諦めるか。
tokyoと東京などの対応表は内部に持たないといけないというのはいいですよね？ cd /d C:\画像 for %%F in (*.jpeg) do call :sub %%F goto :EOF :sub set F=%1 if not "%F%"=="%F:tokyo=%" copy %F% D:\画像\VMD\01_東京\ 。。。。。。 if not "%F%"=="%F:okinawa=%" copy %F% D:\画像\VMD\47_沖縄\ goto :EOF
Path にスペースがあるから『Program Files』でしょうね。 ShellObj.Run "C:\Program Files\Apache2412\Apache24\bin\httpd -k start", 0, true ↓ ShellObj.Run """C:\Program Files\Apache2412\Apache24\bin\httpd "" -k start", 0, true じゃないかな。 詳しくはこちらの後半から解説がありますので読んでみて。 http://www.atmarkit.co.jp/ait/articles/0709/12/news125.html
こんにちは。 ややベタですが、ＶＢＡ的にはよく使われる基本テクに則した書き方です。 Sub Re8953225() Dim wks2 As Worksheet Dim sClass As String Dim nRow As Long, nCol As Long, i As Long 　　Set wks2 = Sheets("Sheet2") 　　With Sheets("Sheet1") 　　　　nRow = 0 　　　　sClass = "" 　　　　For i = 1 To .Cells(Rows.Count, "A").End(xlUp).Row 　　　　　　If .Cells(i, "B") <> sClass Then 　　　　　　　　sClass = .Cells(i, "B") 　　　　　　　　nRow = nRow + 1 　　　　　　　　wks2.Cells(nRow, 1) = .Cells(i, "B") 　　　　　　　　nCol = 1 　　　　　　End If 　　　　　　nCol = nCol + 1 　　　　　　wks2.Cells(nRow, nCol) = .Cells(i, "A") 　　　　Next i 　　End With End Sub
まず問題点はどこか解ってますでしょうか。 １０進数の値は送信できるけど１６進数だと上手くいかないのであれば、値の変換の問題だと思いますが、そのあたりはどうですか。 質問文では１６進数が数値のように書かれてますが、実際は文字列ですよね。質問文の記述ではビルドできないような気がします。 ※VB.netの事はうろ覚えなので間違ってるかもしれないです。 また、受信はできていますか。受信したデータはの内容は正しいですか。 ポート接続ができたとはどういう状態ですか。通信速度やパリティ等の設定は正しいということで良いですか。送受信ができる状態をが接続ができたという状態だと思いますが、質問文からは状況が判断つかないですね。 もう少し、確認が出来ている事と、出来ていないところを書いたほうが回答しやすいと思います。
同じEXCELのバージョン（OS環境含む）で正常に動くのなら 単純に、オブジェクトの存在の問題でしょう。あなたのPCと相手のPC 『実行時エラー'424'　オブジェクトが必要です。』 が出るのは、Variant 型変数にオブジェクトが代入されていない（Null値）ということなので 原因となるオブジェクト（ファイル）が相手のPCに存在しないか？ 異なるドライブフォルダに保存されてるのでは？ エラーの出るVBAの行を特定すれば、問題のオブジェクトが判るはずですけど。。。
お客の注文書（データ）に郵便番号記入があるー＞あなたの会社の営業支店に結び付けたい、ということか。支店には店番が振ってあるのでしょうね（＊１）。 しかし全国規模の郵便番号が入るのかな（＊２）。全国から注文が入るのかな。 支店は注文に対し何を受け持つのかな（その支店が発送するとかか）、支店のエリアの顧客という統計だけか。 ーー それにＷＥＢで照会できるように、ＷＥＢ上にあなたの会社が、郵便番号ー支店の対応を割り出せる仕組みをつくってくれているのか。まさかそうではないよね。 いまはどうしているの？あなたが郵便番号をＷＥＢで入力ー＞住所町名までを知るー＞メモるー＞あなたが教養と推測で、自社支店名を決めているのか。 ーー 郵便番号は 全国には１０万以上の郵便番号があり、住所番地だけで決まるものではない。たとえば１つの有名ビルなどに割り振っているなど千代田区などにはある。 だから郵便番号と貴社の支店は１対１対応できるかどうか（＊３）わからない。 ーー こういう課題は、システム的に、「＞エクセル初心者」がやる（やれる）ことではなく、金を払ってステム関連会者に相談することだ。無料のコーナーの簡単な質問で済むならシステム業者はいらん、になるでしょう。 現状のままだと日々困るのは、あなたのような担当者であることは同情するが（別件で似たことは昔（コンピュータ発展期）に私も歯がゆい感じを抱いたことは多多あるが、システム部などはなかなか動いてくれない）、質問者は思考の上でも検討不足で（＊1,*2,*3なども書いてないところから断定）力不足と思う。 ーー やや正確さは犠牲にして、アクセスやエクセルで、郵便番号を入力すると、支店ないしは支店候補（複数）を表示するぐらいなら、勉強すれば作れるかも。 その結果をシステムに自動連動入力はまたむつかしいものだ。 　それに私の経験では（１）支店は競争しており、できるだけ自分の担当としたい（２）地図で担当店を決めても地図では分らない事情がある（線路があって、山があってとか、バス便があって他の支店のほうが担当とすべきばあいがある）ときがあって、決めるのがむつかしい（３）郵便番号は住居表示などの変更で、結構テーブルを更新しないと正確にならない、面倒なものだ。 ーー エクセルでどうしてもやりたいなら、１対１、１対多の例を挙げて、総数や割合はいくらぐらいか、など書いて質問すべきだと思う。それにＶＢＡなどのプログラムの必要領域のにおいがする。
2000年ごろならActiveXに関する書籍もいろいろ出ていたのですが．．． http://homepage2.nifty.com/nihon-nouen/programming.htm が参考になるかと もし、VB6.0のヘルプ（MSDN）がインストールされているなら 「Visual Studio 6.0 ドキュメント」→「Visual Basic」→「Visual Basic 6.0 活用ガイド」→「ActiveX/OLEのプログラミングに関するトピック」→「ActiveX コード コンポーネント（OLEサーバー）のプログラミングに関するトピック」→「ActiveX EXE の作成手順」 当たりを見てください。
こんにちは。 ANSIテキストだと仮定して、基本通りの書き方です。 もし、テストしてうまく行かない場合は、 望んだ結果とどう違うかの説明と合わせて、 フォルダ名、テキストボックス名（シート名？）、 文字コード、などを詳しく補足してください。 Sub Re8938350() Const SLF = vbLf　'　改行文字を指定 Dim sFile As String　'　ファイルパス Dim sTemp As String　'　１行ずつ読み込み Dim sBuf As String　'　バッファ Dim nFree As Integer　'　空き番号ファイル番号 Dim flg As Boolean　'　抜出し開始 　　sFile = "test.txt"　'　ファイルパス（必要ならフォルダパスも指定！！） 　　nFree = FreeFile　'　空き番号ファイル番号 　　Open sFile For Input As #nFree　'　.txtを読み込み用に開く 　　　　Do Until EOF(nFree)　'　.txtの終端まで読み込めるようにループを仮設定 　　　　　　Line Input #nFree, sTemp　'　１行ずつ読み込む 　　　　　　If flg Then　'　抜出し開始フラグがTrueなら 　　　　　　　　If sTemp Like "DATA DIVISION." Then Exit Do　'　抜き台終了条件でループを抜ける 　　　　　　　　sBuf = sBuf & SLF & Trim$(sTemp)　'　バッファの終端に改行と１行分のテキストを追加 　　　　　　Else　'　抜出し開始フラグがFalseなら 　　　　　　　　flg = (sTemp Like "FILE-CONTROL.")　'　抜き台開始条件　フラグをTrueに 　　　　　　End If 　　　　Loop 　　Close #nFree 　　sBuf = "" 　　sBuf = Mid$(sBuf, Len(SLF) + 1)　'　先頭の改行を削除 　　If Len(sBuf) Then　'　バッファが空でなければ 　　　　Sheets("Sheet1").TextBox1.Text = sBuf　'　"エクセルファイルのテキストボックスに" ？ 　　' ' ↑テキストボックスの↑オブジェクト名（親オブジェクト）を正しく指定 　　End If End Sub
環境がないので、詳しく言えませんが 直訳でライセンスが無い．．．と読み取れます。 データベースを展開する場合、あの頃はＦＤＤなどでライセンスを入れたマシンしかデータベースが動きませんでした。ＶＢ５と言うよりは、データの入れ物のライセンスに問題があると見えます。
その後考えて、２つ目のユーザーフォームを追加してみます。 コントロールの数やCaptionなどは、質問者の要求に比べて少なく、私の勝手にした例ですが、参考にして得るところがあれば使ってください。 処理推移は １。UserForm1に一度選択入力する。「次へ」でUserForm２を表示。 ２。Userform2にUserform1の選択を引き継ぐ。 ３．UserForm2をみて,「Oｋ」か「やり直し」の選択をする。 ４．「OK」の場合、エクセルシートでの処理条件として使うための、 　　Sheet1のA1,B1に２種類の情報をセットする。 5.　「やり直し」の場合、UserForm1を表示。ただし当初選択の痕跡は消す。 ーーー 前回答に加えて UserForm2を追加（VBEのメニューでは挿入）します。 UserForm2にテキストボックスを２つ設けます。 またコマンドボタンを２つ設けます。 ２つのボタンのCaptionは、それぞれ「OK」と「やり直し」にします。 ーー 「OK」のボタンのクリックに対しては Private Sub CommandButton1_Click() Worksheets("Sheet1").Range("A1") = TextBox1.Text Worksheets("Sheet1").Range("B1") = TextBox2.Text UserForm2.Hide UserForm1.Hide End Sub ーー 「やり直し」ボタンに対しては Private Sub CommandButton2_Click() UserForm2.Hide '-- Dim Ctrl As Control For Each Ctrl In UserForm1.Controls If TypeName(Ctrl) = "OptionButton" Then _ Ctrl.Value = False Next Ctrl End Sub のコードを作成します。 ーーー UserForm1については、前回答とほぼ同じですが、少し変えて 各オプションボタンのプロパティのTagプロパティの行に テキストで設定します。そのテキストは選択された後で、どれを選択したかの点で使いたい文字列を設定します。（Captionでも済むのかもしれません） Private Sub CommandButton1_Click() For Each x In UserForm1.Controls If InStr(x.Caption, "Option") Then If x.GroupName = "g1" Then If x.Value = True Then ' MsgBox x.Caption ' x1 = X.Caption x1 = x.Tag End If End If If x.GroupName = "g2" Then If x.Value = True Then 'MsgBox x.Caption 'MsgBox x 'x2 = X.Caption x2 = x.Tag End If
こんにちは。 全体の呼び出し関係が見えないので、 的確なアドバイスができるか解りませんが、 > If intRtn <> vbOK Then > MsgBox "処理をキャンセルしました。" > End > End If を If intRtn = vbCancel Then MsgBox "処理をキャンセルしました。" Me.Hide Userform1.Show End If のように。 > If intRtn <> vbOK Then > MsgBox "処理をキャンセルしました。" > End > End If を If intRtn = vbCancel Then MsgBox "処理をキャンセルしました。" Me.Hide Userform1.Hide End If のように。 書換えてみたら如何でしょう。 Userform1.Show Userform1が表示中なら本来は不要ですが、 それでも必要になる場合もあります。 先々の話として付け加えておきますが、 End ステートメントはなるべく使わない方がトラブルフリーです。 モードレス表示ならまだしも、ですが、 呼び出し元のプロシージャで待機中の処理が残っていたりすると、 Excelが落ちるような場合もあります。 Userformは、.Showしたら.Hideするようにして、 最後の最後、今日はもう使わないって時にUnLoadするような 運用にするといいでしょう。 とりあえず以上ですが、解決に至らないかも知れませんので、 何かあれば補足してみて下さい。状況が解れば再度お応えします。
Sub test01() l1 = Worksheets("Sheet1").Cells(Rows.Count, "A").End(xlUp).Row MsgBox l1 l2 = Worksheets("Sheet2").Cells(Rows.Count, "A").End(xlUp).Row Worksheets("Sheet1").Range("A2:R" & l1).Copy Sheets("Sheet2").Range("A" & l2 + 1) End Sub
下記のサイトにあります http://dobon.net/vb/dotnet/process/appactivate.html VB.NETは、そのまま使えると思いますし、下の方にWin32APIでの方法がありますのでVB6はそれを参考にすればできると思います。
「About Active Accessibility Support (Windows)」 https://msdn.microsoft.com/en-us/library/ie/gg701963%28v=vs.85%29.aspx このページから察するに(少なくとも)ウィンドウクラス名「Internet Explorer_Server」と 対応してるIAccessibleオブジェクトの子孫要素まで辿らないといけなそうです。 で、IServiceProvider::QueryServiceでIHTMLWindow2を得て、IHTMLDocument2を得ればいいのではと。 (ラッパー関数はIUnknown_QueryService) https://msdn.microsoft.com/en-us/library/windows/desktop/bb759858%28v=vs.85%29.aspx
＃３です。お礼欄拝見しました。 > 最初の式はシート3のＩ8セルから90列　200行　IFERROR(INDEX($G9,MATCH(I$8,$F9,0)),"") > 関数を入れてます。 「Ｉ8セル」は「Ｉ９セル」のことでしょうね（循環参照になる筈ないので）。 　　=IFERROR(INDEX($G9,MATCH(I$8,$F9,0)),"") という数式だけでは、意図が伝わりませんが、 たぶん、 　　=IF($F9=I$8,$G9,"")　 のような数式での処理を意図している■と判断しました。 　Sheet3　 　　Ｆ列[今回]日付 　　Ｉ８から右９０列[過去の数量記録欄]の日付 　が一致した場合だけ 　　一致した列 and 該当行位置に、Ｇ列[数量]を出力 という処理を、ご提示のマクロに追加したい■と。 シートデータ（表）のイメージが判りましたので、 こちらでは、説明された通りのシート構成を作成してテストしました。 解らないのは、 　Sheet3 の見出しが、１行めと８行めの２ヶ所あるのは何故か？■ 　Sheet3 常に９行め以下を処理すればいいのか、それとも、明示できる条件があるのか？■ 疑問は残ったままですが、指示通り、８行めを見出し行、９列めからがデータ という前提で書きました。 もし、違っている場合は、 　　「.... 中見出し行位置　を★★指定」 と書かれた行の数値指定' = 8 'を書き換えてください。 結構手数が要る課題なので、もし、これで不足があっても対応には時間掛かると思っていてください。 因みに、過去の質問を読み込んでも、セルの位置や細かい具体的条件が変わっているようなので 状況の把握には役立ちませんでした。 マクロ（ＶＢＡ）では、曖昧な指示をすることが出来ませんので、 位置情報やシートレイアウトについては、こちらも確実なものを求めるしかありません。 補足を戴く場合は、貴方が実際に目にしているものすべてが、 こちらには見えていないことを意識して、何を伝えれば解決に繋がるかだけを考えて、 十分な情報を用意し、短い手数で解決できるようお互いにつとめましょう。 こちらからは４点の確認事項■を提示していますのでチェックしてください。 現在のマクロを以下のマクロに（一時的に）差し替えて 動作を確かめて下さい。 こちらが想定している通りのシートデザインであれば、 こちらでは動作確認してあります。 そちらでも実際に試してみて下さい。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub Macro1()　'　Re8927109rh Dim tmp Dim rng As Range, rng5SrNum As Range Dim nTopRow As Long, nBtmRow As Long, nPDate1 As Long, nPDateL As Long Dim i As Long, j As Long 　　Set rng5SrNum = Sheets("Sheet5").Range("H:H")　'　Sheet5　Ｈ列[通しＮo]　列（Ｈ？）を★指定 　　With Sheets("Sheet3") '　　　　Set rng = .Range("A:A").Find(What:="月", After:=.Cells(Rows.Count, "A"), _ '　　　　　　　　　　　　LookIn:=xlValues, LookAt:=xlPart, SearchDirection:=xlPrevious) '　　　　If rng Is Nothing Then MsgBox "Ａ列に見出し「月」が見当たりません", vbExclamation: Exit Sub '　　　　nTopRow = rng.Row 　　　　nTopRow = 8　'　Sheet3　中見出し行位置　を★★指定 　　　　nBtmRow = .Cells(Rows.Count, "H").End(xlUp).Row　'　Sheet3　データ最下行位置　列（Ｈ？）を★指定 　　　　nPDate1 = 9　'　Sheet3　[過去の数量記録欄]の先頭列位置　を★指定 　　　　nPDateL = .Cells(nTopRow, "I").End(xlToRight).Column　'　Sheet3　[過去の数量記録欄]の右端列位置　列（Ｉ？）を★指定 　　　　Application.ScreenUpdating = False　'　描画更新を一時停止 　　　　For i = nTopRow + 1 To nBtmRow　'　Sheet3　中見出し行位置　から　データ最下行位置　まで行をループ 　　　　' ' Sheet3　Ｈ列[通しＮo]をループして　Sheet5　Ｈ列[通しＮo]の一致したセルを取得 　　　　　　Set rng = rng5SrNum.Find(What:=.Cells(i, "H"), _ 　　　　　　　　　　　　LookIn:=xlValues, LookAt:=xlWhole, SearchDirection:=xlNext)　'　列（Ｈ？）を★指定 　　　　　　If Not rng Is Nothing Then　'　万が一を考えて　見つかった時だけ以下の処理 　　　　　　　　rng.EntireRow.Resize(, 2).Copy Destination:=.Cells(i, "A")　'　Sheet5からSheet3　A:Bをコピペ　列（Ａ？）を★指定 　　　　　　　　rng.EntireRow.Resize(, 4).Offset(, 3).Copy Destination:=.Cells(i, "D")　'　Sheet5からSheet3　D:Gをコピペ　列（.Offset(, 3)？Ｄ？）を★指定 　　　　　　　　tmp = .Cells(i, "F").Value　'　Sheet3　Ｆ列[今回]日付を変数に格納　列（Ｆ？）を★指定 　　　　　　　　For j = nPDate1 To nPDateL　'　Sheet3　[過去の数量記録欄]の　先頭列位置　から　右端列位置　までループ 　　　　　　　　　　If .Cells(nTopRow, j).Value = tmp Then　'　[今回]日付　と一致する列　を見つけたら 　　　　　　　　　　　　.Cells(i, j) = .Cells(i, "G")　'　Sheet3　[過去の数量記録欄]　該当行　一致した列　にＧ列[数量]を出力　列（Ｇ？）を★指定 　　　　　　　　　　　　Exit For　'　それ以上　[過去の数量記録欄]　を探す必要がないので　ループを抜ける 　　　　　　　　　　End If 　　　　　　　　Next j 　　　　　　' ' 万が一　[今回]日付　が　[過去の数量記録欄]　で見つからない場合　メッセージ 　　　　　　　　If j > nPDateL Then MsgBox "今回日付：" & .Cells(i, "F") & "該当日付欄未設定", vbExclamation　'　列（Ｆ？）を★指定 　　　　　　End If 　　　　Next i 　　End With 　　Application.ScreenUpdating = True　'　コピー処理をループした後に描画エラーを防ぐ為の記述 End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Mytextという変数を設定し、string（文字列）宣言しています。 セルC7が空白で無い場合はmytextにはC7の文字列を格納します。 セルC7が空白の場合はmytextも空白とします。 指定テキストボックスにmytextの値を入力する事にしています。 空白の場合も必ずテキストボックスに入力作業を行います。 if Range("C7").Value <> Empty then　はC7が空白でない場合という意味です。 Sub test() Dim Mytext As String If Range("C7").Value <> Empty Then Mytext = Range("C7").Value Else Mytext = "" End If ActiveSheet.Shapes("Rectangle 27").Select Selection.Characters.Text = Mytext End Sub テキストボックスの書式は手動で最初に設定すればVBAからの指定は不要だと思いますが、設定されたいのでしたら、falseの箇所コードは不要です。 With Selection.Characters(Start:=1, Length:=2).Font .Name = "ＭＳ Ｐゴシック" .FontStyle = "標準" .Size = 11 .Underline = xlUnderlineStyleNone .ColorIndex = xlAutomatic End With 変数の説明は下記を参照下さい。 http://officetanaka.net/excel/vba/variable/index.htm
#1のご回答と同アイデアですが、 ＲｅｇＥｘｐを使うまでもないと思う。 Sub test01() ’MsgBox Range("A100").End(xlUp).Row lrow = Range("A100").End(xlUp).Row For i = 1 To lrow a = Split(Cells(i, 1), "|") MsgBox a(2) Next End Sub ーーー 区切った文字列の３番めを、繰り返しのコードで探索する必要がないところが違い。 簡略化するために単純な例にしているが、例をもう少し詳しく文章で表現すべきだ。 私の回答が、使えないばあいは、すぐ作れる（あり得る）から。
確認しましたが、単にfocusするだけで良さそうです。 ie.document.forms("Login")("S_BRANCH_CD").focus ie.document.forms("Login")("S_BRANCH_CD").value = "店番号" ie.document.forms("Login")("S_ACCNT_NO").focus ie.document.forms("Login")("S_ACCNT_NO").value = "口座番号" ie.document.forms("Login")("PASSWORD").value = "第一暗証" ie.document.forms("Login")("bLogon.y").click
失礼。検索行の末尾の.rowが括弧の中に入ってしまってました。 外に出してください。 .Row)　ではなく　).Row　です。 line3 = Worksheets("Sheet3").Range("H:H").Find(what:=Worksheets("Sheet5").Cells(line5, 8)).Row
総ページ数を出す機能はないので、その部分は毎回修正が必要ですけど。。。 https://support.office.com/ja-jp/article/%e3%81%99%e3%81%b9%e3%81%a6%e3%81%ae%e3%82%b9%e3%83%a9%e3%82%a4%e3%83%89%e3%81%ab%e3%82%b9%e3%83%a9%e3%82%a4%e3%83%89%e7%95%aa%e5%8f%b7%e3%81%a8%e5%90%88%e8%a8%88%e3%82%b9%e3%83%a9%e3%82%a4%e3%83%89%e6%95%b0%e3%82%92%e8%a1%a8%e7%a4%ba%e3%81%99%e3%82%8b-e62b363a-a5c4-413e-b7b7-52c1a4d9dd02?CorrelationId=789aeffe-1973-4a71-87bd-0229b54a545d&ui=ja-JP&rs=ja-JP&ad=JP
#1です。＃１に追加。 （１）エクセルに画像挿入したファイルの名前の後尾に１文字でも追加して、ファイル名を変えて、エクセルに画像挿入したことのしるしにする。ファイルは元のフォルダにあるまま。 次の機会にこのファイル（１文字追加されたファイル名のもの）を読んだら、エクセルに画像挿入処理をしない（読み飛ばす）。 （２）他の方法として、ファイルの日時で判断する。これについて、前に読んだことを残す、ふさわしいファイル属性の項目が無いように予想するが、勉強してみて。。 ーーー 丸投げしていることから、＃１の文章ヒントだけでは何もできないかもしれないので、コード例を挙げてみる。 エクセルシートで１列に下方向に写真を配置していく例。 フォルダ名、ファイル名は当然自分のケースに修正すること。 下部に添えたモジュールTest02()は、テストのとき張り付けた多数の画像を一斉削除したい場合があり、重宝しそうなので、ついでに載せる。 写真は１枚１セルに入れている。セルの大きさは見やすいような大きさに前もって（実行するに先立って）シート上で手動設定しておくものとする。VBAでもできるが課題を増やさぬようにするため略。 Sub test01() Set objfs = CreateObject("scripting.filesystemobject") Set objfolder = objfs.getfolder("C:\Users\ｘｘｘ\Pictures") ActiveSheet.Range("A3").Select For Each objfile In objfolder.Files sBaseName = objfs.GetExtensionName(objfile) If sBaseName = "JPG" Then 'MsgBox sBaseName 'MsgBox objfile.Name w = ActiveCell.Width w = ActiveCell.Height Set myShape = ActiveSheet.Shapes.AddPicture(Filename:=objfile, _ LinkToFile:=False, SaveWithDocument:=True, _ Left:=Selection.Left, Top:=Selection.Top, Width:=w, Height:=h) With myShape .ScaleHeight 1, msoTrue .ScaleWidth 1, msoTrue .LockAspectRatio = msoTrue .Height = ActiveCell.Height - 5 ' 画像高さ = セルの高さ－５ End With ActiveCell.Offset(1, 0).Activate End If Next End Sub ーーー Sub test02() ActiveSheet.DrawingObjects.Delete End Sub みなWEBにある例を多少修正しただけのもの。
＃１,２,４です。＃４補足コメント拝見しました。 > なんだかとても難しそうですね…。 中の上ぐらい？と思います。 > 記述頂いたものをコピペして要指定◆の三か所を、 > (1)Const S = "プロフィールシート" > (2)Set rWork = Columns("V").Resize(.Rows(.Rows.Count).Row) > (3)For Each c In Range("J13:T13")　'　※試しに結合しているセル範囲J13：T13を入力してみました※ > と変えて実行してみました... ご苦労様です。ご確認ありがとうございます。 > ...が、「エラー：1004アプリケーション定義またはオブジェクト定義のエラーです」というメッセージが出ました。 エラーの原因は既に特定され、対策も済みました。 原因は、指定した範囲には、[結合セル]の左上に当たる先頭セルがひとつもなかった為、 本題の処理以外の所でカウンタの数値が不適切になっていたことです。 こちらの想定漏れです。 > ちなみに、行の高さを自動調整したい結合セルは、F9:T9、F13:T13、F21:T21、F22:T22、F23:T23の５か所です。 一気に前が開けて見えて来ました。 　　Range("F9:T9,F13:T13,F21:T21,F22:T22,F23:T23") のような書き方で、一括りに、そしてピンポイントに、セル範囲を指定することが 出来ました。 　●シートイメージが掴めたので、必要以上の処理が不要になったこと、 　●ご指摘のエラーへの対処 　●一部設計について、より簡単で堅実な方法を見つけたので改良（基本設計は同じ） 以上の理由から、＃４のマクロを書き換えましたので、丸々差し替えて 動作を試してください。 動作確認が済んだ所で、ご提示のマクロについて。 こちらでは動作の確認はしていませんが、 今回課題の[結合セル]の行高[自動調整]処理をするタイミングは、 　　Sheets("プロフィールシート").Range("A1").Value = 番号 　　' ■ココ！！■ 　　Sheets("プロフィールシート").PrintOut の間（PrintOutする直前）の行になります。 以下のマクロの名前を適当なものに変えて、 ご提示のマクロから、こちらの（課題の）マクロを呼び出すようにして下さい。 気になるとすれば、改ページが行高の変化の影響を受けないか、 ということぐらいで、今の処、問題なさそうと見込んでいます。 マクロの開発はエラーを重ねて進めることも多いので、 こちらが想定出来ていないことがあれば、またエラーが発生するかもしれません。 もし次にエラーに遭遇したら、 　　On Error GoTo ErrH_　'　エラートラップ の先頭に一時的に ' を付けて（コメントブロックして） 再度実行してみて下さい。 その際、エラーメッセージへの応答で[デバッグ]を選択し、 マクロの記述のどの部分（エラー行が黄色になる）で どんなエラーが発生しているかを確認してみてください。 楽観的にみてはいるのですが、何かあれば、遠慮なく、、、。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub Re8919629_r() Const S_SHT_NAME = "プロフィールシート"　'　要指定◆シート名は正確に◆ Dim rWork As Range　'　作業セル範囲 Dim rArea As Range　'　ループ用　各[結合セル]範囲全体 Dim sngColWid1st As Single　'　処理実行前の作業セル　の列幅 Dim sngColWid As Single　'　各[結合セル]範囲　の実効幅 Dim cnCol As Long　'　処理件数　カウンタ 　　If ActiveSheet.Name <> S_SHT_NAME Then Sheets(S_SHT_NAME).Select　'　処理対象シート　を選択状態に 　　With ActiveSheet.UsedRange　'　処理対象シートの内　使用中の範囲　を捉える 　　　　' ' 要指定◆一時的な作業列としてそれより右すべてが使用可能な列を指定（例ではＶ列）◆ 　　　　' ' ◆但し、作業列は必ず印刷範囲の外であること◆ 　　　　' ' 作業セル範囲を　必要な行数　変数に格納 　　　　Set rWork = Columns("V").Resize(.Rows(.Rows.Count).Row)　' 　　End With 　　sngColWid1st = rWork.ColumnWidth　'　処理実行前の作業セルの列幅　を確保 　　Application.ScreenUpdating = False　'　処理が遅くならないように　描画　停止 　　On Error GoTo ErrH_　'　エラートラップ 　　With Range("F9:T9,F13:T13,F21:T21,F22:T22,F23:T23")　'　要指定◆処理対象[結合セル]範囲　をRange型で指定◆ 　　　　.WrapText = True　'　[折り返して全体を表示する]設定　の徹底 　　　　cnCol = 0 '　カウンタ　初期化 　　　　For Each rArea In .Areas　'　処理対象セル範囲の各[結合セル]範囲　を総当たりでループ 　　　　　　cnCol = cnCol + 1　'　処理する数をカウント 　　　　　　sngColWid = (rArea.Width * 4 / 3 - 5) / 8　'　各[結合セル]範囲の実効幅　を計算で求める 　　　　　　rArea.UnMerge　'　各[結合セル]範囲の[セルの結合]　を一時解除 　　　　　　With rWork.Cells(rArea.Row, cnCol)　'　各[結合セル]範囲と同じ行　未使用の作業列にあるセルを作業セルとして 　　　　　　　　rArea(1).Copy Destination:=.Cells　'　各[結合セル]範囲の先頭セル　をコピーして作業セルに貼付け 　　　　　　　　.Value = rArea(1).Value　'　各[結合セル]範囲の値　を作業セルの値としてトレース 　　　　　　　　.ColumnWidth = sngColWid　'　作業セルの実効幅　を各[結合セル]範囲の実効幅　に合わせる 　　　　　　End With 　　　　　　rArea.Merge　'　各[結合セル]範囲の[セルの結合]　を再設定 　　　　　　rArea.EntireRow.AutoFit　'　各[結合セル]範囲行高　を[自動調整] 　　　　　　rArea.RowHeight = rArea.RowHeight　'　作業セルを基準に[自動調整]された行高　を各[結合セル]範囲で確定する 　　　　Next 　　End With 　　If cnCol > 0 Then 　　　　With rWork.Resize(, cnCol) 　　　　　　.Clear　'　作業セル　をクリア 　　　　　　.ColumnWidth = sngColWid1st　'　列幅　を元に戻す。 　　　　End With 　　　　ActiveSheet.UsedRange　'　印刷範囲を変えない為にUsedRange　を元に戻す。 　　End If ErrH_: 　　If Err Then MsgBox "エラー：" & Err.Number & vbLf & Err.Description　'　エラー時　のメッセージ 　　Application.ScreenUpdating = True　'　描画　再開 End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
こんにちは。 'ボタン'は、シート上に配置したActiveXコントロールのコマンドボタン である、という前提でとりあえずお応えします。 （もしもフォームコントロールやユーザーフォームだった場合は、 　ボタン等のオブジェクト名と現在登録中のマクロの記述を追加提示してください。） 幾つか方法はありそうですが、管理に悩まないで済みそうな方法として。 ◆'リセット'を実行した日付を、どこか失われない所に保管する。 　例では、コマンドボタンのキャプション。 　　オプションとして、.TopLeftCell に記録する方法もあり。 ◆'リセットスイッチを１回押すと、日付が変わらないと再度アクティブ状態にならないようにする。' 　例では、.Enabledプロパティで、ボタンアクションの有効/無効を切り替える。 　　オプションとして、.Visibleプロパティで、表示/非表示を切り替える方法もあり。 但し、'リセット'した後で必ず、ブックを上書き保存する、 という前提になります。 もっとも'リセット'の処理内容がそのボタンが置かれたブックの外に影響しないものであれば、 上書き保存しない場合は、'リセット'処理も取り消される、という結果で、 特に問題ありません。 尚、▲opt1▲opt2と選べるように書き添えていますが、必ずどちらかに統一してください。 ' ' シートモジュール＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Private Sub CommandButton1_Click()　'　■コントロール名を正確に指定■ '　　　■ここに　'リセット'処理の記述■ 　　With CommandButton1　'　■コントロール名を正確に指定■ 　　　　.Caption = CStr(Date)　'　▼opt1/2（要統一＃１） '　　　　.TopLeftCell.Value = Date　'　▲opt2/2 　　　　.BackColor = vbRed　'　色はお好みで 　　　　.Enabled = False　'　.Enabled　または　.Visible（要統一＃２） 　　End With End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ' ' ThisWorkbookモジュール＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Private Sub Workbook_Open() 　　With Sheets("Sheet1").CommandButton1　'　■シート名・コントロール名を正確に指定■ 　　　　If .Caption = CStr(Date) Then Exit Sub　'　▼opt1/2（要統一＃１） '　　　　If .TopLeftCell.Value = Date Then Exit Sub　'　▲opt2/2 　　　　.Caption = "リセット" 　　　　.BackColor = vbYellow　'　色はお好みで 　　　　.Enabled = True　'　.Enabled　または　.Visible（要統一＃２） 　　End With End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 実装前に、テスト用のブックを作成して動作仕様を確認し、 他のシステムとの整合性をシミュレートするようにしてください。 以下にあるテスト支援用マクロ（'リセット'した日付を昨日にします）を 実行して、上書き保存と共にブックを閉じる→再度開く。 ' ' テスト支援用マクロ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub Yesterdy() 　　With Sheets("Sheet1").CommandButton1　'　■シート名・コントロール名を正確に指定■ 　　　　.Caption = CStr(Date - 1)　'　▼opt1/2（要統一＃１） '　　　　.TopLeftCell.Value = Date - 1　'　▲opt2/2 　　End With End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ テストしてみて、不足があれば、補足欄にでも書いてみてくだい。
『2005 から 2010 への移植』とは、具体的に何をしたのでしょう。 開発に使う Visual Studio のバージョンを上げたのでしょうか？ .NET Framework のバージョンも上げたのでしょうか？ 何にせよ、バージョンを変えることによって、コードや設定に修正が 必要になることになっても『何の不思議もありません』。（コードは 良くても、オプションなどの設定に修正が必要になるケースも地味に あります）
Database という名前のプロジェクトがないか確認して ください。もしある場合は、プロジェクトの名前を別の ものにしましょう。 ※プロジェクト名の確認方法 　１）VBAエディタを開く 　２）左側にある「プロジェクト」の一番上がプロジェクト名です 「プロジェクト」が表示されていない時は、「表示」→ 「プロジェクトエクスプローラ」をクリック なお、質問者さんが調べたページは「ユーザ定義型が定義 されていません」というエラーに対する対処方法ですので、 今回のエラーとは内容が全く違います。
＃３-４です。＃４お礼欄拝見しました。 > 系列１３からは濃淡を変えるなどして、色分けするにはどうしたらよいでしょうか？ 濃淡といっても、例えば、 セルの書式等にも使うカラーパレットは同系色５段階になっていますが、 これをチャート上で見分けられるかどうか、というと、 私の仕事環境でも、会議室のプレゼン環境でも、 モニターやスクリーンに全画面チャートを表示した場合で、 同系色２～３段階程度が限界と思います。 思う、のであって、他の環境では違う、他の人は違う、 と言うかも知れないので、非常に相対的です。 これがいい、とか、私の判断は全く介在しない事務的な仕事でしたが、 とりあえず、濃淡織り交ぜて、こちらの環境では見分けられる 適当な配色を２０色で作ってみて、マクロを書き換えました。 あとは、マーカーのスタイル、マーカーのサイズ、等を工夫すれば、 と思います。 ブック固有の（既定の）配色パターンにある色は そもそも濃淡を表現するのが難しい色として選ばれているように思います。 強いて言えば[マーカーの塗りつぶし][透過性]を使うてもありますが、 これで見分けが付くのは原色系でも２段階が限界に思います。 独自の配色にしたのは、そういう理由からです。 組合わせ方は無限にあるでしょうから、方針とか目標とか必要条件とか、 そういうことから絞って考えていった方が決め易いかも知れませんね。 あくまでも一例、です。 Sub Re8916999_RndColors() Const S_ARRAY_HEX = "0000FF A03070 00FF00 0080FF FF0000 70A030 FF00FF 00FFFF FFFF00 000000" & _ 　　　　　　　　　　" 8080FF 80FF80 FF8080 FFAAFF AAFFFF FFFFAA AAAAAA CCCCFF CCFFCC FFCCCC" Dim oSeries As Series Dim arrS() As String Dim arrN() As Long Dim nUbColor As Long Dim i As Long 　　arrS() = Split(S_ARRAY_HEX) 　　nUbColor = UBound(arrS()) 　　ReDim arrN(0 To nUbColor) As Long 　　For i = 0 To nUbColor 　　　　arrN(i) = CLng("&H" & arrS(i)) 　　Next i 　　nUbColor = nUbColor + 1 　　i = 0 　　For Each oSeries In ActiveChart.SeriesCollection 　　　　oSeries.MarkerBackgroundColor = arrN((i \ 2) Mod nUbColor) 　　　　oSeries.MarkerForegroundColor = arrN((i \ 2) Mod nUbColor) 　　　　' ' oSeries.MarkerStyle = xlMarkerStyleSquare 　　　　i = i + 1 　　Next End Sub
こんにちは。お邪魔します。 > 「関数」シートの > 「2つ左のシート」→「1つ左のシート」にして > 関数シート内を文字を置換をすれば良いのかなぁ？ ＶＢＡで対応するということなら、それでいいと思いますが、 間違いがあるといけないので、対話型にしてみました。 ※「関数」シートのシート名をマクロの先頭行で正確に指定してください。 ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ Sub Re8914124() Const SF = "関数" Dim Target As Range Dim sPrev As String Dim sNext As String 　　With Sheets(SF) 　　　　If ActiveSheet.Name <> SF Then .Select 　　　　With .Previous 　　　　　　sNext = "'" & .Name & "'!" 　　　　　　sPrev = "'" & .Previous.Name & "'!" 　　　　End With 　　　　Set Target = .UsedRange.Find(What:=sPrev, LookIn:=xlFormulas, LookAt:=xlPart) 　　　　If Target Is Nothing Then 　　　　　　MsgBox "シート" & SF & "　に設定中の数式について" & vbLf & _ 　　　　　　　　vbTab & "ふたつ左のシートへの参照： " & sPrev & "　を" & vbLf & _ 　　　　　　　　vbTab & "ひとつ左のシートへの参照： " & sNext & "　に" & vbLf & _ 　　　　　　　　"置換するマクロを実行しようとしましたが" & vbLf & _ 　　　　　　　　"シート" & SF & "　には【" & sPrev & "】を参照する数式がありません" _ 　　　　　　　　, vbOKOnly Or vbExclamation, "シート" & SF & "　の月次更新" 　　　　　　Exit Sub 　　　　End If 　　　　If MsgBox("シート" & SF & "　に設定中の数式について" & vbLf & _ 　　　　　　vbTab & "ふたつ左のシートへの参照： " & sPrev & "　を" & vbLf & _ 　　　　　　vbTab & "ひとつ左のシートへの参照： " & sNext & "　に" & vbLf & _ 　　　　　　"置換しますか？", vbOKCancel, "シート" & SF & "　の月次更新") _ 　　　　　　= vbCancel Then 　　　　　　MsgBox "キャンセルされました" _ 　　　　　　　　, vbOKOnly Or vbInformation, "シート" & SF & "　の月次更新" 　　　　　　Exit Sub 　　　　End If 　　　　.UsedRange.Replace What:=sPrev, Replacement:=sNext 　　　　MsgBox "シート" & SF & "　に設定中の数式について" & vbLf & _ 　　　　　　vbTab & "ふたつ左のシートへの参照： " & sPrev & "　を" & vbLf & _ 　　　　　　vbTab & "ひとつ左のシートへの参照： " & sNext & "　に" & vbLf & _ 　　　　　　"置換しました", vbOKOnly Or vbInformation, "シート" & SF & "　の月次更新" 　　End With End Sub ' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ ＶＢＡを使わない方法もいくつかあるにはありますが、 大抵は、現状の関数を活かす方向で考えた方が、 ブックの機能としては有利になる場合が多いだろうと思いますので、 今回のように、数式の置換という手段で良い、と私は考えています。 ＃１様の方法であれば、デメリットは少ないですが、 名前の定義を利用することが、「簡単で」「解り易い」管理方法 になると感じるかどうかは、人それぞれ、と思います。 ご自身が理解できて、メンテにあたる人達のスキルに期待が持てるか、 すべてご自身で管理する、ということでしたら、 名前の定義でもいいと思います。 以上です。
こんにちは。 普通にコピーして貼り付けるだけだったら、こんな感じです。 Sub Re8912718() 　　Worksheets("Sheet1").Shapes("楕円").Copy 　　Worksheets("Sheet2").Range("EE120").PasteSpecial End Sub もし、サイズをアクティブセルに合わせて変更したいという場合は、 　　With Worksheets("Sheet2") 　　　　With .Shapes(.Shapes.Count) 　　　　　　.Height = ActiveCell.Height 　　　　　　.Width = ActiveCell.Width 　　　　End With 　　End With のような記述を上記に続けます。 コピーしたい楕円図形のオブジェクト名は"楕円"で間違いないでしょうか？ もし違っていれば当然エラーになるので気が付くとは思いますが、 もし、そこら辺でお困りの場合は、以下。 Sheet1にある楕円図形の名前をＶＢＥ上のイミディエイトウィンドウに列挙します。 Sub ChkShapeName() Dim o As Shape 　　For Each o In Worksheets("Sheet1").Shapes 　　　　If o.AutoShapeType = msoShapeOval Then 　　　　　　Debug.Print o.Name 　　　　End If 　　Next End Sub 以上です。
RangeオブジェクトにValue（または省略）して参照した場合 値が格納されますが、Textで参照した場合は表示形式で取得することが出来ます。 Sub sumple() 　　Dim i As String 　　i = Range("B1").Text 　　Msgbox i End Sub
こんな感じですか？ ■VBAコード Sub sumple() Dim myRng As Range Dim myStr As String Dim i As Long For Each myRng In Range("A2:A7") 　　myStr = myRng.Value 　　i = 1 　　Do 　　　　i = InStr(i, myStr, Chr(10)) 　　　　If i = 0 Then Exit Do 　　　　Select Case Mid(myStr, i - 1, 1) 　　　　Case "、", "。", ",", "." 　　　　　　myStr = Left(myStr, i - 1) & Right(myStr, Len(myStr) - i) 　　　　Case Else 　　　　　　myStr = Left(myStr, i - 1) & "、" & Right(myStr, Len(myStr) - i) 　　　　　　i = i + 1 　　　　End Select 　　　　myRng.Offset(0, 1).Value = myStr 　　Loop Next myRng End Sub
Cells()は行と列を数値指定ですから、A1セルならcells(1,1)、B2セルならcells(2,2)です。 そして、入力無し（空白）は””（ダブルクォーテーション２つ）でいい。 If Sheet1.Cells(1, 1) = "" Then でsheet1のA1セルに入力が無いならば…という記述となります。
こんにちは。 Ａブック、Userform（表紙）モジュール Private Sub CommandButton11_Click() 　　Me.Hide 　　Workbooks.Open Filename:=ThisWorkbook.Path & "\改善案.xlsm" 　　Sheets(1).Select End Sub Ａブック、標準モジュール Private Sub Show表紙() 　　表紙.Show End Sub Ｂブック（改善案）、Userform（UserForm1）モジュール Private Sub CommandButton2_Click() ' ' ◆↓要指定　Ａブックの名前_"Book1.xlsm!Show表紙"_のようにショートネームで 　　Application.Run "Ａブックの名前.xlsm!Show表紙" 　　Unload Me 　　Application.DisplayAlerts = False 　　ThisWorkbook.Close 　　Application.DisplayAlerts = True End Sub 基本的に、 '別のブック＝別のVBProject'にあるユーザーフォームを 直接呼出し表示させる方法はＶＢＡには用意されていません。 > すると次のエラーが表示され > 「コンパイルエラー　変数が定義されていません」 > 表紙.showの表紙が反転表示されます。 '表紙'というオブジェクト名はＡブックのVBProjectでのみ有効ということです。 最も簡単な代替え策として、 '別のブック＝別のVBProject'にある標準モジュール に書かれたプロシージャをApplication経由で呼出し実行させる方法があります。 ＢブックのCommandButton2_Clickを実行すると、１行めの記述により、 Ａブックの標準モジュールのShow表紙が実行され、 ＡブックのUserform（表紙）を再表示します。 直接の回答としては以上です。 以下、他の部分にある潜在的な問題点を指摘しておきます。 Ｂブック（改善案）のUserform（UserForm1）を呼出し表示させる記述について、 トラブルになり易い例として、、 Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean) 　　Cancel = True 　　UserForm1.Show End Sub のような記述だった場合（且Userformをモーダル表示する場合）は、 　　ThisWorkbook.Close のタイミングでエラーが発生し、Excelが落ちることがあります。 Userformのプロシージャ実行中に、呼び出し元のブックを.Closeする時は、 呼び出し元のプロシージャと呼び出し方に注意を払うようにしてください。 対策として、イベントプロシージャをEnd Subで抜けて（すべての実行を済ませて）から その後でUserformを表示するように書いておく必要があります。 以下、トラブルを回避する方法を、例として挙げておきます。 Ｂブック（改善案）、標準モジュール Private Sub ShowUF() 　　UserForm1.Show End Sub Ｂブック（改善案）、UserForm1の呼び出し例 Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean) 　　Cancel = True 　　Application.OnTime Now, "ShowUF" End Sub 以上です。
ヒントのみですが IsDate関数でセルの値が日付かどうかチェックする。 日付なら、日付の場合の処理をおこなう。 日付でないなら そのセルが空欄かをチェック。空欄の場合の処理。 そのセルが未定かをチェック。未定の場合の処理。
こんにちは。 'あるセルに以下の様な内容''セルの内容''（改行）' という説明からして、 「ひとつのセルに セル内改行を含む文字列 がある」 という理解でいます。 求める結果の方には'（改行）'と書かれていないことから、 切り分けた文字列それぞれを複数のセル（セル範囲）に出力する、 もしくは、単に配列変数に格納できればいい、という理解でいます。 内容的には、 　セルの文字列を 　vbLf（セル内改行と同値）を区切り文字として、 　Split()関数で配列変数に格納し、 　　各要素に対し、 　　一旦、InStr()関数で"-"の桁位置を取得して、 　　５桁手前以降の文字列をLike演算子で評価し、 　　"#####-###-###*"で始まる文字列であれば、 　　先頭の数字の前にvbLfを挿入し、 　処理後の配列変数をvbLfで連結した文字列を 　再度vbLfでSplit()関数に掛け、 　求める配列を作り出します。 方法は他にもありますし、条件によっては簡略化出来そうな部分も多いですが、 比較的解り易い内容にはなっているかと。 Sub Re8909609a() Dim sBuf, arr Dim sTmp As String Dim i As Long Dim nPos As Long 　　sBuf = Cells(1, 1) 　　arr = Split(sBuf, vbLf) 　　For i = 0 To UBound(arr) 　　　　nPos = 1 　　　　sTmp = arr(i) 　　　　Do 　　　　　　nPos = InStr(nPos + 6, sTmp, "-") 　　　　　　If nPos Then 　　　　　　　　If Mid(sTmp, nPos - 5) Like "#####-###-###*" Then 　　　　　　　　　　arr(i) = Left$(sTmp, nPos - 6) & vbLf & Mid(sTmp, nPos - 5) 　　　　　　　　End If 　　　　　　End If 　　　　Loop While nPos 　　Next i 　　sBuf = Join(arr, vbLf) 　　arr = Split(sBuf, vbLf) 　　For i = 0 To UBound(arr) 　　　　Cells(i + 1, 2) = Trim$(arr(i)) 　　Next i End Sub
「appllication」間違っていないか。 範囲はObject変数なので、代入にはSetを使う。 回して合計を求めたければそのようにする。ここでは簡単のためにWorksheetFunctionを使った。すると、なぜこんなコードが必要なのかわからないとなる。 Sub セル範囲の合計() Dim 範囲 As Range, 合計 As Double Set 範囲 = Application.InputBox(prompt:="セル範囲は？", Title:="セル範囲", Type:=8) 合計 = Application.WorksheetFunction.Sum(範囲) MsgBox "合計=" & 合計 Set 範囲 = Nothing End Sub
1. 上記3、4の処理はコマンドボタンのクリックイベント処理として、まとめて 記述すれば 良いのでしょうか? まとめて一つのプロシージャで処理出来ます。 2. 日付データのオブジェクト名を"TextBox1"として、コマンドボタンのクリックイベント処理 など、これらの処理を行うにあたりサンプルなるコードはありませんか? 　 オリジナルの行数は変動します。 「最終行セルのオブジェクト.End(xlup).Row」で最終行の行番号を取得できます。 以下参照。 3. ユーザーフォームを作らずにシート上(shhet1)にテキストボックス、 コマンドボタンを作成できますか? できます。以下参照。 ---------------------------------------------------------------- (1)前提条件： ・シート名は「オリジナルデータ」と「サマリー」（出力先）とします。 ・オリジナルデータは3行目に項目行が1行あり、4行目からデータが入力されているとします。 ・サマリーシートは1行目に項目行（1行）、2行目からコピーしたセルを貼り付けます。 (2)オリジナルデータシートにコントロールを配置する方法： ・エクセルの開発タブ（無ければエクセルオプションから表示設定してくさい）の 　挿入からActiveXから「テキストボックス」と「コマンドボタン」を配置してください。 ・各コントロールを(開発タブのデザインモードをONにして)右クリック＞プロパティを表示し、 　オブジェクト名を「Textbox1」と「CommandButton1」としてください。 ・コマンドボタンの表示名は同じくコマンドボタンのCaptionプロパティで変更できます。 (3)コードの追加 ・(開発タブのデザインモードがONの状態で)コマンドボタンをダブルクリックしてVBE画面を開く。 ・「Private Sub CommandButton1_Click() ～ End Sub」を最下のVBAコードと差し換え。 (4)VBAの実行 ・開発タブのデザインモードをOFFにした状態にする。 ・テキストボックスに「yyyy/m」形式で日付を入力。 ・コマンドボタンをクリックします。 ・結果がダイアログで表示されます。 シートが無い等のエラー処理は行っていませんので必要であれば追加してください。 様式に変更がある場合は適切に修正願います。 ■VBAコード Private Sub CommandButton1_Click() '変数を定義 Dim i As Long Dim maxRow As Long Dim cnt As Long Dim outSheet As Worksheet '出力先のシートをオブジェクト変数へ格納 Set outSheet = Worksheets("サマリー") 'テキストボックスの内容を判定 If (Me.TextBox1.Value = "") Or (Not IsDate(Me.TextBox1.Value)) Then 　　MsgBox "日付が入力されていません" 　　Exit Sub End If '最終行番号を取得 maxRow = Me.Cells(Rows.Count, "A").End(xlUp).Row 'オリジナルデータの最終行番号で分岐処理 If maxRow > 3 Then 　　'出力先を削除してヘッダーをコピー 　　outSheet.Cells.Delete 　　Me.Range("A3:C3").Copy outSheet.Range("A1:C1") Else 　　'4行目以降にデータが入力されていなければメッセージで終了 　　MsgBox "オリジナルデータがありません" 　　Exit Sub End If '4行目から最終行まで繰り返し For i = 4 To maxRow 　　'A列が日付であれば処理 　　If IsDate(Me.Cells(i, "A").Value) Then 　　　　'テキストボックスの年/月とA列が一致した行をコピー 　　　　If Year(Me.Cells(i, "A").Value) = Year(Me.TextBox1.Value) And _ 　　　　Month(Me.Cells(i, "A").Value) = Month(Me.TextBox1.Value) Then 　　　　　　Me.Cells(i, "A").Resize(1, 3).Copy outSheet.Cells(cnt + 2, "A") 　　　　　　cnt = cnt + 1 　　　　End If 　　End If Next i '結果表示 If cnt > 0 Then 　　MsgBox cnt & "件コピーしました" Else 　　MsgBox "一致する日付が有りませんでした" End If End Sub
No.1です。 投稿後気になったので、再び顔を出しました。 VBAで！というご希望なので、もしかして同じ日に「役割」の重複があるのでしょうか？ その場合は関数では難しいので、やはりVBAになってしまうと思います。 Alt＋F11キー　→　メニュー　→　挿入　→　標準モジュール　→　VBE画面のカーソルが点滅しているところに ↓のコードをコピー＆ペースト　→　Excel画面に戻り（VBE画面を閉じて）マクロを実行してみてください。 （Alt＋F8キー　→　マクロ　→　マクロ実行です） Sub Sample1() 'この行から Dim i As Long, j As Long, c As Range, wS As Worksheet Set wS = Worksheets("Sheet1") With Worksheets("Sheet2") .Range("B2:AF15").ClearContents For j = 2 To wS.Cells(1, Columns.Count).End(xlToLeft).Column 'B列～1行目データが入っている最終列まで For i = 2 To 15 '2行目～15行目まで '▼　Sheet1のi行・j列にデータがあれば、Sheet2のA列何行目のデータと一致するか？ If wS.Cells(i, j) <> "" Then Set c = .Range("A:A").Find(what:=wS.Cells(i, j), LookIn:=xlValues, lookat:=xlWhole) '▼　Sheet2の一致した行のj列が空白の場合は、Sheet1のi行・A列データをそのまま表示 'そうでない場合は今あるデータと「半角スペース」と新たにSheet1のi行・A列データを追加表示 With .Cells(c.Row, j) If .Value = "" Then .Value = wS.Cells(i, "A") Else .Value = .Value & " " & wS.Cells(i, "A") End If End With End If Next i Next j .Columns.AutoFit End With End Sub 'この行まで ※　関数でないのでデータ変更があるたびに マクロを実行する必要があります。m(_ _)m
こんにちは サンプルを作成してみました。 Public Class Form1 Const COM_NAME As String = "名前を表示します。" '一行をカンマせ区切った部分の配列 Dim itm() As String '一行をカンマで区切った部分の3番目のリスト Dim ar As New List(Of String) Private Sub f() Handles MyBase.Shown 'ComboBox1に最初に表示される文字 ComboBox1.Text = COM_NAME 'ファイルを読み込んで行を配列に格納 Dim line() As String = IO.File.ReadAllLines("C:\test\test1.txt", System.Text.Encoding.GetEncoding("shift-jis")) 'lineの要素をループ For Each comtxt As String In line '一行をカンマで区切って配列に格納 itm = comtxt.Split(",") '3番目をリストにAddする ar.Add(itm(2)) 'ComboBox1に一番目の配列を表示 ComboBox1.Items.Add(itm(0)) Next End Sub Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click 'カスタムエラー If ComboBox1.Text = COM_NAME Then MsgBox("名前を選択してください。") Return End If 'ComboBox1で選択されたインデックスを取得 Dim num As Integer = ComboBox1.SelectedIndex 'ComboBox1で選択されたアイテムを取得 Dim nam As String = ComboBox1.SelectedItem 'TextBox1に表示 TextBox1.Text = nam & "-" & ar(num) End Sub End Class あの～ ＞山崎 - 10001 は山崎-11111でしょうか？
#2の回答者です。 >うまくいきません。ちなみにオフィースバージョンは２００３です、標準モジュールにコピーして使用しましたが動きません。 うまくいかなかったというのは、全然、処理しなかったのか、それとも、エラーが発生したのか、どちらでしょうか。 >ファンクションもそのまま貼り付けたのが良くなかったのでしょうか？生年月日はF3:F187ではなくE3:E187にして使用しました。よろしくお願いします。 別に、2003でも、問題ない初歩的レベルの内容ですし、そのまま二つセットで、標準モジュールに貼り付けして構いません。データがあったら、その3列右に出力しますから、E列対象なら、H列に「☆」が返ることを意味しています。しかし、#2の中でも、誤動作について、ちょっと触れましたが、問題になるのは、その生年月日自体の中身がシリアル値でなければ、話が全然変わってきます。その場合は、一旦、シリアル値に戻さなくてはなりません。 こちらからでは、見えない部分の注意点を事細かには申すこともできませんので、それだけは、確認してください。また、主要な点に、デバッグのタブの中などの、「ブレークポイント」を設けて、ローカル・ウィンドウで、きちんと値が返っているか、見てもよいかと思います。 なお、#3さんのコードは、数式自体を、どこか空いている計算列に、「☆」を出して、それを、ループで、然るべき所に「☆」を置いても構わないはずです。こちらで試してみましたが、私のコードとの違いはありませんでした。この辺りは、必ず、その場所に式を置かなければならないわけではありませんので、臨機応変に考えてください。私は、基本的にはコードが完成品でしたら、誰のでも構いません。
実際にコーディングをした訳ではないのですが、 前のプログラムが終了して、次のプログラムが直ちに起動されるという前提であれば、 その場合は、クリップボードが使えるでしょう。 前のプログラムで、変数の値をクリップボードへ出力し、それを 次のプログラムで、クリップボードから取り込むことは可能です。 但し、次のプログラムが取り込む前に、クリップボードを他のプログラム若しくは人間が 破壊していないことが、前提です。 もし、上記の方法が、使えない場合は、 一旦外部の資源に保存するしかないでしょう。 外部資源は、 ワークシートのセル、 ユーザーフォームのテキストボックス のほかに ファイル、レジストリなどが考えられます。
こんにちは。 この表を見ていて気がついたことですが、#1さんがご指摘の、 「優先順位を考慮した成績表を別に作った方が良さそうに思えます。」 同感です。あえて、それを、プログラム上で行うとすれば、配列変数(myIndex )の中でしかありません。むろん、Excelなら、ダミーの表を作ってもよいかもしれません。一応、既存のユーザーの表自体を動かしてはいけない、という暗黙のルールには従いましたが…。VBAでは、ややこしくなるようです。 #1さんの回答にように、これは、関数でもできるような気がしますね。私自身は、関数が不得意なので、選択肢はありませんでしたが。 '// Sub OrderAsRequest() 　Dim Rng As Range 　Dim Rng2 As Range 　Dim myIndex As Variant 　Dim i As Long, j As Long, k As Long 　Dim n As Variant 　Dim mySubject As Variant 　Dim max1 As Long, max2 As Long 　Dim subj1 As String, subj2 As String 　 　'出力先用 　Dim ws As Worksheet 　Dim m As Long 　Set ws = Worksheets(2)　'#4さんと同等にしました。 　m = 1 　 　Set Rng = Range("A1:F4") 'テスト成績表 　Set Rng2 = Range("A7:B11") '優先順位 　With Rng 　　Set Rng = .Offset(0, 1).Resize(.Rows.Count, .Columns.Count - 1) 　End With 　ReDim mySubject(Rng2.Rows.Count - 1) 　ReDim myIndex(Rng.Rows.Count - 2, Rng.Columns.Count) 　For i = 1 To Rng2.Rows.Count 　　mySubject(i - 1) = Rng2.Cells(i, 2).Value 　Next i 　 　'Rng2のフォーマットに従い優先順位に並べ替え 　 　For i = 2 To Rng.Rows.Count 　　myIndex(i - 2, 0) = Rng.Cells(i, 1).Offset(, -1).Value '人名　　F 　　For j = LBound(mySubject) To UBound(mySubject) 　　　n = Application.Match(mySubject(j), Rng.Rows(1), 0) 　　　myIndex(i - 2, j + 1) = Rng.Cells(i, n).Value 　　Next j 　Next i 　k = 2 　 　'検索 　For i = LBound(myIndex) To UBound(myIndex) 　　For j = LBound(myIndex, 2) + 1 To UBound(myIndex, 2) 　　　If myIndex(i, j) > max1 Then 　　　　max1 = myIndex(i, j) 　　　　subj1 = mySubject(j - 1) 　　　End If 　　Next j 　　'注意:出力先1 　　With ws 　　　.Cells(m, 1).Value = myIndex(i, 0) 　　　.Cells(m, 2).Value = subj1 　　　.Cells(m, 3).Value = max1 　　End With 　　 　　'二番目を調べる 　　For j = LBound(myIndex, 2) + 1 To UBound(myIndex, 2) 　　　If mySubject(j - 1) <> subj1 Then 　　　　If myIndex(i, j) > max2 Then 　　　　　max2 = myIndex(i, j) 　　　　　subj2 = mySubject(j - 1) 　　　　End If 　　　End If 　　Next j 　　'注意:出力先2 　　With ws 　　　.Cells(m, 4).Value = subj2 　　　.Cells(m, 5).Value = max2 　　End With 　　k = k + 1 　　m = m + 1 　　max1 = 0: max2 = 0: subj1 = "": subj2 = "" 　Next i End Sub '//
こんにちは。 Set objWshShell = WScript.CreateObject("WScript.Shell") を使って、 objWshShell.AppActivate "Microsoft PowerPoint", True で、いかがでしょうか。
＞それでは一般的なコマンドラインソフトの実行結果を変数に代入するにはどうしたら良いでしょうか？ 一般的なコマンドラインソフトの実行結果は、標準出力に出るので、プログラムに間違いは無いと思います。 grepをフルパスにしてみるとか。
コマンドプロンプトを開いて FOR /R H:\ %p in (.) do MD K:%~pp と打ち込んでEnterキー。 間違うと取り返しがつかなくなるので慎重に。 本番の実行前に FOR /R H:\ %p in (.) do ECHO MD K:%~pp とやってみて K:\未完成 K:\完成\製造 K:\完成\営業 と表示されるか確認して、大丈夫そうならECHOを削って FOR /R H:\ %p in (.) do MD K:%~pp にして、本番の実行をしましょう。
こんばんは。 エクセルファイルを開いておけばいいだけだと思うのですが・・・？ セルのデータは、開いていればブック名からきちんと指定してやれば取得できます。 a = Workbooks("book1.xlsx").Worksheets("sheet1").Range("A1").Value の様な感じ。 開くのもマクロで。
回答No.1 です。 色々と仕様が不明ですが、以下の前提で組んでみました。 ・Webページのアクセスには InternetExplorer.Application 　を使用している ・取得したい文字列は BODY 要素内に存在する ・取得したい文字列は、検索文字列 "ABC" から行末(改行) 　までである。 -------------------------------------------------------- ' IE の準備 Dim objIE As Object Set objIE = CreateObject("InternetExplorer.Application") ' Webページのアクセス処理は紙面の都合で省略 ' Webページへのアクセスが完了したら、BODY 要素内のソースを取得する Dim sourceBody As String sourceBody = objIE.Document.body.OuterHtml ' 取得したソースを改行で区切って配列にする Dim lines() As String '　改行コードを LF に揃える sourceBody = Replace(sourceBody, vbCrLf, vbLf) sourceBody = Replace(sourceBody, vbCr, vbLf) '　改行コード LF で区切って配列にする sourceLines = Split(sourceBody, vbLf) ' 検索する文字列(ABC)を含む行を検索 Dim lineNo As Integer Dim position As Integer For lineNo = 0 To UBound(sourceLines) 　' 検索文字列 ABC を探す 　position = InStr(sourceLines(lineNo), "ABC") 　If position > 0 Then 　　' 検索文字列の後ろの文字列を取得して、メッセージボックスに表示 　　MsgBox (Mid$(sourceLines(lineNo), position + Len("ABC"))) 　End If Next
>Dim ObjIE As Object >Dim ZoomRate As Variant >の部分でエラーになってしまったので、 VBScriptでは型宣言は、できないです Dim ObjIE Dim ZoomRate ZoomRate = "70%" '拡大率 Set ObjIE = CreateObject("InternetExplorer.application") ObjIE.Visible = True ObjIE.Navigate "http://www.yahoo.co.jp/" Do While ObjIE.Busy = True WScript.sleep(250) Loop ObjIE.Document.Body.runtimeStyle.Zoom = ZoomRate Set ObjIE = Nothing
回答No.1です。 やっと質問の意味がわかりました。 テンプレートに表示される「テキストファイル」は、画面 (フォーム)ではありません。従って「Windows フォーム」 や「ダイアログ」のように表示させることはできません。 A. テンプレートで画面(フォーム・ダイアログ)扱いのもの 　Windowsフォーム、ダイアログ、エクスプローラフォーム 　MDI親フォーム、情報ボックス 　　…など。他にも名前に「フォーム」と付くものはこちら B. テンプレートで画面(フォーム・ダイアログ)扱いではないもの 　クラス、モジュール、インターフェイス、設定ファイル、 　テキストファイル、アイコンファイル 　　…など。「ファイル」と名前が付くものは全てこちら A. に分類されるものは画面(フォーム)として表示させることが できますが、B. に分類されるものはできません。 テキストファイルの内容を表示させるためには、質問者さんが 調べたとおり 　・Process.Start を使ってメモ帳などに表示 　・テキストを読み込んで、コントロールまたはメッセージ 　　ダイアログに表示 のどちらかしか方法がありません。
「続いて順次」と言うのはどういう意味？ 間をおかずに続けて処理すれば無意味ですよね。 Enterを押す度に次の文字をコピーするのなら、 set /p <NUL="山"|clip set /p ="川"|clip set /a ="谷"|clip 10秒ごとにコピーするなら、 set /p <NUL="山"|clip timeout /t 10 set /p <NUL="川"|clip timeout /t 10 set /a <NUL="谷"|clip
こんにちは。 >i = nyuryokubox()　　 この部分は、いずれにしても、参照できませんね。 おそらく、既存のTextBpxで、ボタンで生成するTextBoxの数でしたら、nyuryokubox.Value や.Text　プロパティだと思います。それは、配列です。 > For i = 1 To i i は、ループのカウンターに使っているのですから、i 自体は、数値型で、To (定数)ですから、別の変数(例：j = nyuryokubox.value として、For i = To j など)にしないと、ループは完成しません。初歩的なミスだと思います。 それから、TextBoxのプロパティ等を調べてみましたが、マクロから、オブジェクト名を変更できなかったようですから、D1.Text は使えませんね。 Controls("D1").Text　等でしかないようです。 登録_Click() Dim obj As Object Dim i As Long 　　With Worksheets("keyplan") 　　　　For Each obj In Me.Controls 　　　　If obj.Name Like "D#" Then 'Dの付いた名前を探す 　　　　　i = i + 1 　　　　 .Cells(30, i + 3).Value = Controls("D" & i).Text 　　　　End If 　　　　Next 　　 End With 　End Sub
ここを参考に http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub05_110_100.html
まずは、VB.NETでの配列の正体を知っておいた方がよいでしょう。 http://msdn.microsoft.com/ja-jp/library/dd314345.aspx 特に > 3-3-3 参照型としての配列変数 から下をよく読んで理解してください。 > Dim Hairetsu() As String は、Stringの配列を覚えることができる変数Hairetsuを用意するだけで、配列の実体は用意されません。 上記URLの「図 3-11 Nothing が代入されるのは、あくまで配列変数 D 自体」が近い状態です。 この図の「配列の実体」が最初から存在しない、というものです。 > Public Sub aaa(ByRef a() As String) > a(0) = "Test" '←正常の場合と、エラーの場合 ※ 念の為、仮引数の名前を変えました。 このsubを aaa(Hairetsu) と呼び出した場合、 Hairetsu() しただけの場合は、a = Nothing となっています。 よって、 a(0) は Nothing(0) ということになり、そんなものは無いのでエラーになります。 ※ エラーメッセージはちゃんと読みましょう。 ※ 質問するなら、ただ「エラーになります」では対処しようがありません。 ※ 正確なエラーメッセージを記載るようにしましょう。 ※ 例えば、そのエラーは ※ 「 NullReferenceException "オブジェクトのインスタンスを指定する必要がある部分に null 値が指定されています" 」 ※ とか表示されていませんでしたか? 対策ですが、いくつもあるので、目的によって選択することになります。 ○ aaa内で Nothingだったら処理を中止するようなコードにする 例) if a is Nothing then exit sub ○呼び出し元で、Hairetuをredimしてからaaaを呼び出す。 ○aaa内でredim する。仮引数aはByRefになっているので、呼び出し元の変数が変更される。 　※ なお、参照型の特性として「a(0) = "Test" 」だけなら、ByVal a でも同じ「配列の実体」にアクセスすることになります。 ○ sub aaaではなく、 function aaa() as String() 等といった配列も返す関数にする ○ List(of T) 等の可変長で配列っぽく使えるクラスを使う
こちら （Access2010 試験ファイル形式は Accdb 。）では問題を再現できませんね。 エラー処理が手抜きですが、 Sub test() Dim hairetu() As Variant Dim i As Integer Dim v As String On Error GoTo errH hairetu = Array("テーブル１", "テーブル２", "テーブルN") 'インポートしたいテーブル名 For i = LBound(hairetu) To UBound(hairetu) DoCmd.TransferDatabase acImport, "Microsoft Access", "D:\tmp\インポート元.accdb", acTable, hairetu(i), hairetu(i), False v = v & hairetu(i) & "_" & CurrentDb.TableDefs(hairetu(i)).Properties("description") & vbNewLine Next MsgBox v Exit Sub errH: if err.number = 3270 then v = v & hairetu(i) & "_" & "説明は設定されていません" & vbNewLine end if Resume Next End Sub ご参考まで。
例外は登録されていないエラー種別なので、厳密には何が起きているか判りません。 ただ、Callで起きる場合の大半は型があっていないことが原因なので、 引数か関数そのもの型を確認してキャストしてみてください
こんにちは。 一応、画像を見て作りましたが、条件が違っていたら、以下のコードは動きません。 A.xlsm 側のファイルの拡張子は任意（画像では読み取れません)ですが、B.xlsmは、マクロ搭載ですから、xlsmの拡張子になります。こちらは、Excel 2010 で開発しましたが、別のブックでは、Findメソッドがまったく検索できないようでしたので、やむを得ず、ワークシート関数のMatchを使いました。 また、A.xlsmの[総括]シートの日付欄は、A:B列連結になっている必要があります。 他には、B.xlsm のシートのそれぞれのCommandButtonは、必ず、A列の[日付セル]よりも行として上に出てはいけません。例えば、[1月1日]は、A3から始まっていますから、少なくとも、CommandButtonは、C3の上辺より下になくてはなりません。その位置で、A列の日付を読取ります。 '//B.xlsm のSheets(1)のマクロコードです。 Private Sub CommandButton1_Click() 　Call ButtonProgs(CommandButton1) End Sub Private Sub CommandButton2_Click() 　Call ButtonProgs(CommandButton2) End Sub Sub ButtonProgs(obj As Object) Dim i As Variant Dim j As Long Dim c As Variant j = obj.TopLeftCell.Row Set c = Cells(j, 1).MergeArea.Cells(1) m = c.Address With Workbooks("A.xlsm").Worksheets("総括")　'ブック名に注意 　i = Application.Match(c, .Columns(1), 0) 　　If IsError(i) = False Then 　　　c.Offset(, 1).Resize(5, 2).Copy .Cells(i + 1, 1)　'コピー　5行の設定になっています。 　　Else 　　　MsgBox Format(c.Value, "mm/dd") & " が見つかりません。", 48 　　End If End With End Sub '//
『毎日指定時刻になったらマクロを動かす』のには Windows のタスクスケジューラを使います。 http://www.siminpc-kitakyushu.com/index.php?QBlog-20141029-1
音を消すには TextBoxのKeyPressイベントにて Private Sub TextBox2_KeyPress(sender as Object, e as KeyPressEventArgs) Handles TExtBox2.KeyPress 　　if e.KeyChar = vbCr then 　　　　e.Handled = True 　　End if End Sub を記述します TextBox2のMultiLineを Falseに設定して見ましょう MultiLineがTrueで質問のコードだと 前回入力した 改行文字(vbCrLf)が TextBox2に残っているために 文字列『3』と文字列『vbCrLf＋3』では 同じでないので『不正解』が表示されているのです
Navigate メソッドで呼び出したページの読み込みが完了する前に 内容を取得しようとしているからです。（Navigate メソッドは ページの取得要求を出したら、ページが実際に取得されるのを待た ずに即処理が返ってくる仕様です） よって『ページが取得されるのを待つ処理』を、きちんと自分で 実装しないとうまく動きません。SHDocVw.InternetExplorer の ReadyState プロパティについて調べてみてください。 ※ なお、VB.NET での IE 利用であれば、SHDocVw ではなく 　 WebBrowser クラスのほうが使いやすいですよ。
Oracle の事は分かりませんが、 クエリ自体は正常に働いている、 ３０件程度の抽出をする場合と６０００件程度の場合とで フィールド数やデータ型が同じなら SpecificationName に３０件程度の時のを流用できませんか？ ご存知かもしれませんが、 インポート定義を確認するには？ http://www.tsware.jp/tips/tips_528.htm エクスポートも同様かと。
こんにちは。 A1セルクリックのみカレンダー表示するには > If Target.Count <> 1 Then Exit Sub > ' A列以外は無視(今回サンプルの例) > If Target.Column <> 1 Then Exit Sub この代わりに、以下を入れればよいのではないでしょうか。 If Target.Address <> "$A$1" Then Exit Sub
こんばんは！ 一例です。 Sheet1のシートモジュールにしてください。 （Changeイベントにしています） Private Sub Worksheet_Change(ByVal Target As Range) Dim c As Range, wS As Worksheet Set wS = Worksheets("Sheet2") If Target.Address = "$A$1" Then Set c = wS.Range("B:B").Find(what:=Target, LookIn:=xlFormulas, lookat:=xlWhole) If Not c Is Nothing Then c.Offset(1, -1).Resize(3, 3).Copy Range("A2") Else MsgBox "該当データなし" End If End If End Sub こんな感じではどうでしょうか？m(_ _)m
まとめファイルに以下のマクロを書いて実行します。 ・店舗ファイル名は　「店舗1.xls～店舗19.xls」としてます（数字は半角)。 ・店舗ファイルとまとめファイルは同一フォルダにある、とします。 機能 各店舗ファイルの中の全シートを参照し、まとめファイルの同一名シートにコピーします。 Sub Macro1() Dim WSname As String Dim i As Long, j As Long For i = 1 To 19 Workbooks.Open Filename:=ThisWorkbook.Path & "\店舗" & i & ".xls" For j = 1 To Worksheets.Count WSname = Worksheets(j).Name 　　　　　　On Error Resume Next Worksheets(WSname).Range(Cells(59, i + 2), Cells(68, i + 2)).Copy Destination:=ThisWorkbook.Worksheet(WSname).Range(Cells(59, i + 2), Cells(68, i + 2)) Next j ActiveWorkbook.Close SaveChanges:=False Next i End Sub
昔のことでうろ覚えですが、xl2003以前でグラフの系列にワークシートを介さないで値を設定する際に、データ数の制約回避のために、どこかで見つけて来て使った事があります。 http://okwave.jp/qa/q6368497.html #4で、 For i = 1 To rs.RecordCount arrayX(i, 1) = rs.Fields(1) arrayY(i, 1) = rs.Fields(2) rs.MoveNext Next i ThisWorkbook.Names.Add Name:="Date", RefersTo:=arrayX ThisWorkbook.Names.Add Name:="Rate", RefersTo:=arrayY てな事をやっています。 時間もないので詳しく見ておりませんが、ご参考まで。
こんにちは。 >このマクロを使用してまとめたシートの数値の部分……（中略)……を変更するとコピー元……の数値も同じように変わるというものを作りたいです。 できそうな気はするのですが、なんとなく釈然としない部分も残ります。 ご自身は、まだ、マクロの実力は初級レベルだと思います。ご自身が後先考えないで作り上げてしまった後で、その先は、こうしたいけれども、どうしたらよいか振れられても、こちらが、最初から作るならともかく、付け足しでは格好が付かないのです。掲示しているマクロは、あまり意味をなしません。 >いろいろと調べましたが手も足も出ませんでした。 手も足も出ないのではなく、そういうのはなかった、ということではありませんか？ イベント(Worksheet_Change)か、元データの各々の範囲を、名前登録しておいて、位置関係を明確にして処理するということは想像つきますが、コピー先のデータから、元データを変更するのは、かなり特異な常識的ではない考え方だなって思います。 それから、 > Sheets(1).Columns("C:D").Delete > Sheets(1).Columns("F:G").Delete > Sheets(1).Columns("G:O").Delete これは、本来は、列を非表示程度にすればよいのですが、削除してしまっていますから、元のデータからの位置関係を壊すことになるだろうな、と感じました。 今のところ、私がみた雑感程度にしかコメントできません。お役に立てなくてすみません。
#1です。 下記をお試し下さい。 Public Declare Function GdipGetImageHorizontalResolution Lib "gdiplus" (ByVal Image As Long, resolution As Single) As Long Public Declare Function GdipGetImageVerticalResolution Lib "gdiplus" (ByVal Image As Long, resolution As Single) As Long こちらは簡単ではなさそうな気がします。当方の良く分かっていないGDI+のGraphicsがからんできそうな気配が... Public Declare Function GdipBitmapSetResolution Lib "gdiplus" (ByVal bitmap As Long, ByVal xdpi As Single, ByVal ydpi As Single) As Long 以上、ご参考まで。
こんにちは。 全体像が書かれていない中で、途中の抜き出しで質問だから、なかなか口を挟みにくいのですが、#1～#3さんの回答とそのご質問者さんの反応をみていて、 「スマートな方法」というリクエストは、私には、抽象的でよく理解できませんが、VBAは、中身を見せることがありませんから、それなりに動けばよいような気がします。コードで、Coolと言わせるなんて、並大抵ではありません。 >wordのマクロだと >"[\(]([0-9]{1,2})[\)]" まあ、それは、正確にはWordのマクロではなく検索コマンドの一部ですが、Excelでは、必要とあれば、正規表現を使いますね。途中まで書いて、読み落としていたのですが、配列に入れるわけですね。 '// Dim buf As String Dim myArray() As String Dim i As Long Dim Matches As Object Dim Match As Object i = -1 buf = "ログソース" With CreateObject("VBScript.RegExp") 　.Pattern = "\shref=""(http:[^""""]+)"　 　'パターンの正しい方法は知らない。以前、最短マッチ法の指摘はされたけれど、VBScriptではやっぱりうまくない。 　.Global = True 　.MultiLine = True 　Set Matches = .Execute(buf) 　For Each Match In Matches 　 i = i + 1 　 ReDim Preserve myArray(i) 　　myArray(i) = Match.SubMatches(0) 　Next Match End With '// でも、一つだけ取り出すつもりなら、狙いを定めた後は、実際、Instr 関数や　Mid 関数の方が楽ではないかな。だから、使い方によっては、Splitで大雑把に切っておいて、そこにHTTPアドレスが一つであるなら、後はループすれば、以下でも有効のはずです。実際、その方が多いかもしれませんね。 i = InStr(1, buf, "href=""http", vbTextCompare) j = InStr(i + i + Len("href="""), buf, """") PickUP = Mid(buf, i + Len("href="""), j - i - Len("href=""")) この通り3行で足りてしまうのです。
1行でも同じです。 「1行」というのは、「改行文字」という特殊な文字を区切りに使っているもので、コンピュータにとっては、他の文字と違いはありません。 「行で探す」というのは「改行文字の数で探す」ことになります。 文字列で探すのと、ほとんど同じことです。 バイト数が置換の前後で同じなら、方法は無いわけではありません (MODE BINARY ACCESS READ WRITE でOPEN→SEEKで書き換える位置へ移動) ですが、プログラムの難易度を考えると、現在の方法より優れている、とは言えません。 もし、Excelでやらなければならない理由が無いのなら、他の方法を使うのが楽です。 例えば、テキストエディタの「grep置換」等と呼ばれる機能を使うとか。 UNIX系OSでは標準の sed コマンドのWindows版を使うとか。
Application.EnableEventsで 制御できないんじゃないかな … わたしなら モジュールレベルの変数として dim toggle, bFlag を定義 ボタンの制御プロシージャを定義 Sub ClickProc(ctl as Object) 　　' フラグが Trueなら そのまま戻る 　　if bFlag then Exit Sub 　　if IsEmpty(toggle) then 　　　　toggle = Array(ToggleButton1, ToggleButton2, ToggleButton3) 　　end if 　　Dim ss as String 　　bFlag = True 　　ss = "処理Z" 　　select case ctl.Name 　　　　case "ToggleButton1" 　　　　　　if ctl.Value then ss = "処理A" 　　　　　　toggle(1).Value = False 　　　　　　toggle(2).Value = False 　　　　case "ToggleButton2" 　　　　　　if ctl.Value then ss = "処理B" 　　　　　　toggle(0).Value = False 　　　　　　toggle(2).Value = False 　　　　case "ToggleButton3" 　　　　　　if ctl.Value then ss = "処理C" 　　　　　　toggle(0).Value = False 　　　　　　toggle(1).Value = False 　　End Select 　　処理 ss 　　' 処理終了のためフラグをFalseに 　　bFlag = False End Sub 各トグルボタンのクリックを Sub ToggleButton1_Click() 　　ClickProc ToggleButton1 End Sub Sub ToggleButton2_Click() 　　ClickProc ToggleButton2 End Sub Sub ToggleButton3_Click() 　　ClickProc ToggleButton3 End Sub といったぐあいで …
.NET以降，DoEvents (System.Windows.Forms.Application.DoEventsメソッド) の使用は推奨されません。 DoEventsはVB6までやVBAのような，マルチスレッドが扱えない言語における代替策でしかなく， 長時間かかる処理 (だいたい50ms：WinRT APIにおける非同期処理の目安) を超えるようであれば，その処理はバックグラウンドスレッドで処理すべきです。 VB 2005以降であれば，BackgroundWorkerコンポーネントをFormに配置し， ・Label2.Visible = False後，配置したBackgroundWorkerのRunWorkerAsyncメソッドを呼び出す ・グラフの点の計算をBackgroundWorkerのDoWorkイベントに記述する。 ※このイベントの中で，Formのコントロールやコンポーネントに触ることができないので注意して下さい。 ・BackgroundWorkerのRunWorkerCompletedイベントで，グラフの描画やLabel2.Visible = Trueを行う。 という方法で処理を行います。 # VB 2012以降で.NET 4.5以降をターゲットとする場合では，Async/Awaitを使う方法が推奨されます。 ref) MSDN: 方法 : バックグラウンドで操作を実行する http://msdn.microsoft.com/ja-jp/library/hybbz6ke.aspx
どちらも一緒で、省略するかしないかの違いかと。 あえて入れる理由としては、変数が配列であることを意識しやすくなるためかと。
Visaul Studio .NET にはそのような機能はありません。 バックアップ目的などでプロジェクトを複製したい場合は エクスプローラでプロジェクトフォルダごとコピーするのが 常套手段です。
質問者さんが求める機能を満たすことはできません。 VBA はプログラム言語としては機能的に弱い言語です。 厳しい機能制限の中、『理想』と『現実』の落としど ころを探って行く必要があります。 (1)(3) ⇒ 後からリストの拡張・縮小をしたい場合は、配列では 　 なくCollection を使用するのが常套です。(2次元配列 　 の場合は、入れ子にするなり工夫が必要になりますが) 　 ReDim を使うか Collection に詰めなおすか、どちら 　 が良いかは、リスト拡張の頻度やデータ量、処理方式 　 によって違うでしょう (2) ⇒ 繰り返しを全く使用せずに実施するのは無理です。 　 セルに貼付可能な形の配列に詰めなおすしかありません。 　 パフォーマンスを気にされている場合は、セルに For で 　 回して一つ一つ値を書き込むよりも、配列間の値の入れ 　 替えして一気に貼り付けたほうが格段に高速ですので、 　 ここらへんが『落としどころ』になるかと思います。 　 いちいち For 文書くのが面倒だという話であれば、自分 　 で汎用関数を作っておけば良いかと。 VBAがどうしても質問者さんの要求に応えられないのであれ ば、VBAを捨てて他の高機能言語からEXCEL を操作すると いう解決策もあるかもしれません。
VotingResponse プロパティについて検索されると 良いかと思われます。 http://msdn.microsoft.com/ja-jp/library/microsoft.office.interop.outlook._mailitem.votingresponse%28v=office.12%29.aspx # サンプルも探してみようかとも思ったのですが、シンプルで # 読みやすそうなところがなかったので(英語苦手)。 # コードの雰囲気的にはおそらく外してないと思いますので、 # そちらで検索しまってみてください。
DataTable の Merge メソッドを使ってはいかがですか？
もしかして、ボタンクリックか何かのイベントの中に e.Graphics.DrawLine(Pens.Red, 50, 60, 100, 150) だけ記述して実行していないでしょうか？ 参考にされたページにも書いてありますが、このコードは Paint イベントに記述しないと動きません。 参考にされたページで、問題のコードの前後に記述されている Private Sub Form1_Paint(sender As Object, e As PaintEventArgs) Handles Me.Paint End Sub もきちんと記述してみてください。
回答No.1 です。 どうやらあと一歩のところまで来たようですね。 ○IEの起動 　⇒ IEが起動して、HPが表示されたのであれば、その記述で 　　 OK です。そもそもの目的である『新規セッションで起動』 　　 になっていたでしょうか？ ○Call GetWindowThreadProcessIdのところでエラー 　⇒ 何が邪魔しているのかと思ったら、Outlookでしたか…。 　　 コードに直してみたので、こちらで試してください。 ------------------------------------------------------------ ' 指定されたウィンドウを作成したスレッドの ID を取得するAPI関数 ' http://msdn.microsoft.com/ja-jp/library/cc364779.aspx Private Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, ByRef ProcessId As Long) As Long Public Sub ろぐいん() ' IE を起動 Dim IEProcessId As Long ' 起動した IE のプロセスID IEProcessId = Shell("C:\Program Files\Internet Explorer\iexplore.exe -noframemerging http://") ' 起動した IE を探す Dim IE As Object Dim ShellObject As Object Set ShellObject = CreateObject("Shell.Application") Do While True 　　' ShellWindows のリストを取得し、その中から起動したIEを探す 　　For Each Explore In ShellObject.Windows() 　　　　' 取得した ShellWindows のリストからIE, Explorer を抽出(Outlookを排除) 　　　　If TypeName(Explore) = "IWebBrowser2" Then 　　　　　　' プロセスIDを取得 　　　　　　Dim CurrentProcessId As Long 　　　　　　Call GetWindowThreadProcessId(Explore.hwnd, CurrentProcessId) 　　　　　　' 起動した IE のプロセスIDと比較 　　　　　　If CurrentProcessId = IEProcessId Then 　　　　　　　　' 見つけた IE のオブジェクトを回収 　　　　　　　　Set IE = Explore 　　　　　　　　' IE が見つかったので、Whileループを抜ける 　　　　　　　　Exit Do 　　　　　　End If 　　　　End If 　　Next 　　 　　' ここに処理が来たときは、IEが見つからなかった 　　' (まだIEが起動中の場合は見つけることができない) 　　' 1秒待ってリトライする 　　Call Application.Wait(Now + TimeValue("00:00:01")) Loop Set ShellObject = Nothing ' ここから先は元のコードが使えます ' 文字入力 IE.document.getElementById("ID").Value = UserID IE.document.getElementById("PASS").Value = UserPass (以下省略) 　
No2です。 書き忘れてましたが以下の部分 Range("A1").Offset(cnt, 0).Value = Obj.GetFolder(f).Name Offsetを利用してますが、何か特別に理由がなければ(以下ご存知かもしれませんが) 処理速度の速い順(といっても、操作を100万回実施して秒単位での差だったりするようですが) A列指定の場合 Cells(cnt, 1).Value←右側の引数は、1はA列、2はB列というように列を数値で表します。変数でもOKです。 Cells(cnt, "A").Value Range("A" & cnt).Value←この書き方は悪評を買ったりしてます。 といった感じでOffsetを利用しなくてもセル指定に変数が使えます。 ただし、最初のcnt = 0はcnt = 1にしておかないとエラーになります。
分は nn で出力できます。 hh:mm:ss は hh:nn:ss と書くことができます。
hour(シリアルデータ)で、時刻が取り出せます。 以下、ベーシックなものですけどお望みの処理が出来るはずです。 　Lastが検出したシート中の最下行 　Lが現在の処理行 Lastから2行目までをfor~nextで回しているだけです。 ～～～ Sub Macro1() Dim L As Integer last = Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row For L = last To 2 Step -1 If Hour(Cells(L, 1)) <= 18 Then If Hour(Cells(L, 1)) >= 9 Then GoTo Label0 End If Rows(L).Delete Label0: Next L End Sub
例えばバブルソートは for j=0 to AMax 　for i=1 to AMax-j 　　if A(i-1)>A(i) then 　　　入れ替え 　　end if 　next next 大体こんな感じですよね。 ここでは、大小比較に「>」を使っています。 ここで 「比較」 という関数を定義したとします。 比較(x,y) : x が yより「大きい」ときは 正の値、「等しい」なら0、 「小さい」なら負の値を返す これを使うと for j=0 to AMax 　for i=1 to AMax-j 　　if 比較(A(i-1),A(i)) > 0 then 　　　入れ替え 　　end if 　next next と書けます。 さて 「大きい」「等しい」「小さい」 と「」付きで書いたのには理由があります。 後ろにくるべきものを「大きい」前にくるべきものを「小さい」と判定するように作れば、実は、実際の数値の大小以外にも使えるのです。 例えば 、x>y のとき 負、x<yのとき正 として作れば 実際には数の小さい方が「大きい」というということになり、その結果、逆順にソートされます。 この比較関数を使った方法は、他のアルゴリズムでも同様です。 > 文字列を五十音順にソートしたい場合 五十音順並べた時の大小関係を返す比較関数を用意しましょう。 いわゆる「辞書順」というのは (1) 1文字目同士比較する。 (2) 違いがあれば、(1)の比較結果が文字列同士の比較結果 (2-1) もし、どちらか一方だけが文字が無い場合は、短い方が「小さい」 (2-2) 両方との文字が無くなったら、「等しい」 (3) 2文字目、3文字目...について(1)から同様に確認 というアルゴリズムになっています。 一応、文字列も 不等号で比較できますし、 StrCompという文字列比較関数もあります。 これらで間に合うようなら、使えばいいでしょう。 それで期待通りにならない場合は、比較関数を自作してみましょう。
mitarashiです。ひょっとしてこういう事がご希望だったのでしょうか？新規作成をやってみました。ご参考まで。 Private Declare Function GdipCreateBitmapFromScan0 Lib "gdiplus.dll" (ByVal nWidth As Long, ByVal Height As Long, ByVal stride As Long, ByVal PixelFormat As Long, scan0 As Any, nBitmap As Long) As Long Sub make8bitIndexedBitmap() Dim GDIsi As GdiplusStartupInput, gToken As Long, pBitmap As Long Dim bmpData As BitmapData Dim lrect As RECT Dim x As Long, y As Long Dim lWidth As Single, lHeight As Single Dim buf(0) As Byte Dim strOutName As String Dim encBMP As UUID Dim paletteSize As Long Dim palette As ColorPalette Dim i As Long Dim strBGR As String Dim myARGB As Long GDIsi.GdiplusVersion = 1& GdiplusStartup gToken, GDIsi lWidth = 200: lHeight = 100 Call GdipCreateBitmapFromScan0(lWidth, lHeight, 0, PixelFormat8bppIndexed, ByVal 0&, pBitmap) lrect.Top = 0: lrect.Left = 0 lrect.Bottom = CLng(lHeight): lrect.Right = CLng(lWidth) If GdipBitmapLockBits(pBitmap, lrect, ImageLockMode.ReadWrite, PixelFormat8bppIndexed, bmpData) <> 0 Then Exit Sub End If For x = 0 To lWidth - 1 For y = 0 To lHeight - 1 buf(0) = y \ 10 MoveMemory ByVal bmpData.scan0 + (y * bmpData.stride) + x, buf(0), 1 Next y Next x Call GdipBitmapUnlockBits(pBitmap, bmpData) 'Palette設定 Call GdipGetImagePaletteSize(pBitmap, paletteSize) Call GdipGetImagePalette(pBitmap, palette, paletteSize) 'Range("A1:P16")のセルの色からPaletteの色を設定する For i = 0 To 255 strBGR = Hex(ActiveSheet.Cells((i \ 16) + 1, (i Mod 16) + 1).Interior.Color) strBGR = Right("000000" & strBGR, 6) myARGB = CLng("&H" & "FF" & Mid(strBGR, 5, 2) & Mid(strBGR, 3, 2) & Mid(strBGR, 1, 2)) palette.Entries(i) = myARGB Next i Call GdipSetImagePalette(pBitmap, palette) 'BMP保存 strOutName = GetDesktopPath & "\make8bitIndexed.bmp" CLSIDFromString StrPtr("{557CF400-1A04-11D3-9A73-0000F81EF32E}"), encBMP Call GdipSaveImageToFile(pBitmap, StrPtr(strOutName), encBMP, ByVal 0&) GdipDisposeImage pBitmap GdiplusShutdown gToken End Sub
http://oshiete.goo.ne.jp/qa/8852322.html (http://okwave.jp/qa/q8852322.html) で回答した者ですが、実はあの#1-2のコードには前半があって、ファイルからセル色に取り込んでいるのです。その部分を投稿しますので改造して下さい。 '(2) ファイルから画像を読み込みbitmapオブジェクトに変換する If GdipCreateBitmapFromFile(ByVal StrPtr(strInName), pSrcBitmap) <> 0 Then Exit Sub End If '(3)　読み込んだ画像のサイズを取得 '画素数は480x360程度でないと、書式が多すぎるというエラーが発生する GdipGetImageWidth pSrcBitmap, lngWidth GdipGetImageHeight pSrcBitmap, lngHeight '(4)　bitmapオブジェクトから1画素ずつ読み込んで、エクセルのセルのColorに設定 'GDI+から取得する色は透明度を含むARGBであるが、セルに設定する場合はBGRに変換する必要がある Application.ScreenUpdating = False For y = 0 To lngHeight - 1 For x = 0 To lngWidth - 1 '画素の色を取り出し、文字列に変換する 'ビットシフトは面倒そうなので、スピードは犠牲にして？文字列に変換して処理 GdipBitmapGetPixel pSrcBitmap, x, y, myARGB strARGB = Hex(myARGB&) With ActiveSheet Range(.Cells(1, 1), .Cells(1, lngWidth)).ColumnWidth = 1.63 'ARGB->BGRに変換してセル色に変換 .Cells(y + 1, x + 1).Interior.color = RGB(CInt("&H" & Mid(strARGB, 3, 2)), CInt("&H" & Mid(strARGB, 5, 2)), CInt("&H" & Mid(strARGB, 7, 2))) End With Next x Next y Application.ScreenUpdating = True >これらの変数はLongとして定義されていて、 >型が配列ではないのですが >どのようにして扱えば良いのでしょうか？ ここでのimage、pDstBitmapは「ハンドル」と言われるものです。画像ファイルが読み込まれ、ビットマップオブジェクトが生成された時に、Windowsによってつけられた管理番号といった感じでしょうか。 ついでに、先のQAのARGBのオーバーフローについてですが、下記をご参照下さい。 http://support.microsoft.com/kb/189323/en-us 機械翻訳したページもありますが、よけいに分かり難いような... http://support.microsoft.com/kb/189323
>12月10日（水）の更新後、Excel2013ではActiveXコントロールのコマンドボタンが使用できなくなったと思いますが < これは当方は対処済みなので、ほぼ普通に使えているつもりです。 セルに入力できるということは UserForm1.Show vbModeless になっているわけですね。 doeventsを入れてみたらどうでしょう。 それともまだ対処していない状態での話なのですか。 　 セキュリティ面のことで使用できなくされたらしいのですが 私の場合は C:\Users\○○\AppData\Local\Temp　の中を削除したら普通に使えるようになりました。 セキュリティ面は・・・・・・気になりますが使えないのも困るので・・・。
回答No.1 です。 ○effect 引数, AllowedEffects というのはどのように 　して使うのでしょうか？ ここから先は私もサンプル組んで検証しないことには 何とも言えません。しかし、私としてもこれ以上は時間を 割きにくいので、これで私はギブアップにさせてください。 なお、回答No.3さんのアドバイスも問題解決案としては 魅力的なアイディアですよ。
こんにちは 質問者さまと同じ環境で同じ不具合が発生しましたが 以下のQAの内容で解決しました。 http://oshiete.goo.ne.jp/qa/8854280.html
#1-3です。 型変換をVBAに頼り過ぎだと存じます。 真面目にやるべきでしょう。 簡単な例で試してみました。ご参考まで。 Sub test() Dim myR As Byte, myG As Byte, myB As Byte Dim myRGB As Long myR = 255 myG = 255 myB = 255 myRGB = myR & myG & myB Debug.Print Hex(myRGB) '->F36E2D7　白にならない End Sub Sub test2() Dim myR As Byte, myG As Byte, myB As Byte Dim myRGB As Long myR = 255 myG = 255 myB = 255 myRGB = CLng("&H" & Hex(myR) & Hex(myG) & Hex(myB)) Debug.Print Hex(myRGB) '-> FFFFFF End Sub Sub test3() Dim myR As Long, myG As Long, myB As Long 'Byte型だとmyR * &H10000のところでオーバーフロー Dim myRGB As Long myR = 255 myG = 255 myB = 255 myRGB = myR * &H10000 + myG * &H100 + myB Debug.Print Hex(myRGB) '->FFFFFF End Sub
こんな感じでしょうか Sub ボタン1_Click() On Error GoTo Er With ThisWorkbook.Sheets("シート１") '元のブックの出荷データを使うので　Withで指定しておく Workbooks.Open Filename:=ThisWorkbook.Path & "\顧客データひとり分.xls" 'このファイルと同じフォルダーにある顧客データひとり分のファイルを開く Sheets("シート１").Select '準備しておいたシートに移動 GYOU = .Range("A" & Rows.Count).End(xlUp).Row + 1 'このブックの最後の行を取得 .Range("A" & GYOU & ":C" & GYOU + 4).Value = Range("A2:C6").Value '注文書のデータを入れる ActiveWorkbook.Close '顧客データひとり分のファイルを閉じる End With Kill ThisWorkbook.Path & "\顧客データひとり分.xls" '顧客データひとり分のファイルを削除 Exit Sub Er: MsgBox "ファイルが存在しないか、その他のエラーが発生しました。" End Sub コピーするセルは4A2~C6としています。
＃１です。再度。 > 「Rst.FindFirst "名称コード" & " = " & "' 101 "'」という記述 そもそもこの記述は何かを参考になさってるのでしょうか。 このサイトへの転記ミスかお尋ねした部分が補足では確定してない。 転記ミスでは無いなら参考にした「何か」そのものの誤記ではありませんか？ Rst.FindFirst に続く右側（引数）ですが 必要としている条件を記述する部分です。 質問文からは「名称コードが値[101]に等しいもの」と読めます。 （101の前後に半角スペースがあるのが気になりますが） 新たな疑問ですが、「名称コード」のデータ型は何ですか？ 値そのものをクォーテーションで囲もうとしているからには 文字型（＝テキスト型）で合ってますか？ 「いや、数値型でした」だったら 条件のために値101をクォーテーションで囲む必要はなく、 ＶＢＡのコード記述のためにダブルクォーテーションで囲むだけなので Rst.FindFirst "名称コード" & " = " & "101” になります。 「はい、文字型です」なら、「クォーテーションで囲むこと」は 必要ですが、囲む文字のルールがあります。 クォーテーションとして使えるのは 「’」シングルクォーテーション（アポストロフィ）か 「”」ダブルクォーテーション のどちらか。 （他は割愛） シングル・ダブル何れの場合も「値の両端を同じもので囲む」ので 引数は「名称コード = ’101’」か「名称コード = "101”」の どちらかになります。 ところが質問で「入力できない」とおっしゃってる >「Rst.FindFirst "名称コード" & " = " & "' 101 "'」 では、両端を囲おうとしているのは「”（Shift＋2）’（Shift＋7） で囲む」ですから もし記述できたとしても実行時にはエラーになります。 動作確認をしてみて下さい。 シングルでなら >「Rst.FindFirst "名称コード" & " = " & "' 101 "'」 を Rst.FindFirst "名称コード" & " = " & "'101'” へ変更し実行。 「ダブルクォーテーションで囲いたい亅にこだわるなら 101の両端を”（Shift＋7）×３で囲って Rst.FindFirst "名称コード" & " = " & ”””101””” と変更し実行してみて下さい。 「文字列中に”を記述するには”を２回続ける」という ＶＢＡのルールがあります。 最後の&に続く９文字は 1～1 文字列記述の始まりの” 2～3 文字列中に”を表すための”” 4～6 値101 7～8 文字列中に”を表すための”” 9～9 文字列記述の終りの” で。 最後にもう一度 成し遂げたいことは 「”’101”’」（Shift+2、Shift+7、101、Shift+2、Shift+7）にこだわること なのか ＶＢＡを実行できるようにすること のどちらなのでしょうか？
XOR を使うとか。
あと、どこかに 　'印刷範囲をA1～BV30にする 　ActiveSheet.PageSetup.PrintArea = "$A$1:$BV$30" の行を挿入して、印刷範囲を固定して下さい。 With xlPageSetup と End With で挟まれた中のどこかに '拡大縮小を100％にする .Zoom = 100 を挿入して、拡大率を100％に固定してみましょう。 すくなくとも .Zoom = 100 で ＞印刷できる帳票のサイズが小さくなってしまいました。 は防げる筈です。
オートシェイプ描画時に自身を削除する（Wクリックでは無くクリックになってしまいますが）マクロを仕込む方法があります。リンク先の#3ですが、コードが（おそらく実行時間も）短いのがメリットです。 http://okwave.jp/qa/q5496600.html １．ダブルクリックでセル内に楕円を描く（ご質問には合わせておらず、以前回答したままです、OnActionのところにご注目下さい。） これはシートモジュールに記述 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) With Target .Parent.Shapes.AddShape(msoShapeOval, .Left, .Top, .Width, .Height).Select End With With Selection .ShapeRange.Fill.Visible = msoFalse .OnAction = "eraseShape" End With End Sub ２．消すときはダブルクリックではなく、クリックになってしまいますが、こちらは標準モジュールに記述してください。（Module1など） Sub eraseShape() ActiveSheet.Shapes(Application.Caller).Delete End Sub こちらは少々やりとりが長いですが、一般的なシート内の全図形をスキャンして、セル位置が合致したら削除する方法を含んでいます。（我田引水） http://okwave.jp/qa/q8241405.html
No1です。すみません、間違えました。 Cells(RowNum,4)の前にピリオド「.」を入れ忘れました。 下記、訂正済です。 Dim MyVariant As Variant MyVariant = Application.VLookup(.Cells(RowNum,1), Worksheets("在庫シート").Range("B:J"), 9, False) 　　　　If IsError(MyVariant) Then 　　　　　　.Cells(RowNum,4).value="" 　　　　Else 　　　　　　.Cells(RowNum,4).value=MyVariant 　　　　　　'Worksheets("在庫シート").Cells.Find(What=.Cells(RowNum,1)).EntireRow.Delete　'この行は(5)の削除 End if
＞追加情報:レポートのロードに失敗しました。 とあるので、レポートファイルのパスを間違っている可能性が高い。
こんにちは！ Excelだとして・・・ No.1さんと同じ疑問を持ちつつやってみました。 ↓の画像のようにA列1行目から文字列データがあり、B1セルに結果を表示させるとします。 ↓のコードでマクロを試してみてください。 Sub Sample1() Dim i As Long, k As Long, lastRow As Long, cnt As Long Dim str As String, buf As String Application.ScreenUpdating = False lastRow = Cells(Rows.Count, "A").End(xlUp).Row Range(Cells(1, "A"), Cells(lastRow, "A")).Copy Range("D1") Range(Cells(1, "E"), Cells(lastRow, "E")).Formula = "=LEN(D1)" Range("D1").CurrentRegion.Sort key1:=Range("E1"), order1:=xlDescending, Header:=xlNo For k = 1 To Len(Range("D1")) cnt = 1 For i = 2 To lastRow str = Mid(Range("D1"), k, 1) If InStr(Cells(i, "D"), str) > 0 Then cnt = cnt + 1 End If Next i If cnt = lastRow And InStr(buf, str) = 0 Then buf = buf & str End If Next k Range("B1") = buf Range("D:E").Clear Application.ScreenUpdating = True End Sub こんな感じではどうでしょうか？m(_ _)m
例の様にA列の文字が連続しているならこんな感じで可能です。 ただし、サンプルですのでエラー処理等は入れていません。 なお、名前定義に予約語は使えませんので「C」はNGです。エラーになります。 Sub Sample() 　　nRow1 = 1 　　nRow2 = 1 　　Do While Cells(nRow2, 1) <> "" 　　　　If Cells(nRow2, 1) <> Cells(nRow2 + 1, 1) Then 　　　　　　ActiveWorkbook.Names.Add Name:=Cells(nRow2, 1).Value, RefersToR1C1:="=R" & nRow1 & "C2:R" & nRow2 & "C2" 　　　　　　nRow1 = nRow2 + 1 　　　　End If 　　　　nRow2 = nRow2 + 1 　　Loop End Sub
ユーザフォームから変数(Txtbx1, Txtbx2)への代入を知らないので、そこは自前でお願いします。 A列に並んでるものとします。 sub Macro1() Dim LastRow As Long Dim Txtbx1 As Long, Txtbx2 As Long, Flag As Long Dim myRange As Range Dim i As Long, j As Long Flag=0 LastRow=Cells(Rows.Count "A").End(xlUp).Row For i=Txtbx1 to Txtbx2 For j=1 to LastRow if Cells(j,"A").Value=i then If Flag=0 then set myRange=Cells(j,"A") Flag=1 Else set myRange=Union(myRange, Cells(j, "A")) End if End if Next j Next i myRange.Select End sub
こんばんは！ すでに回答は出ていますので、余計なお世話かもしれませんが・・・ VBAで処理する場合、気を付けなければならないコトがあります。 同じ表を月が変わっても使用する場合、月が変われば「2」の列が変わってきますよね？ 関数の場合は自動で「2」だけの列を判断してくれますが、VBAでは実データとなっているために 「前月」に表示されている「公」はそのまま残ってしまいます。 すなわち月が変われば一旦「公」を消去する必要があります。 ループさせるときに、「2」以外であれば空白に！という条件を付けくわえてやります。 ループの方法はNo.1さんが回答されていますので、 3行目を一旦数式で表示させそれを実データにする方法です。 Sub Sample1() Dim lastCol As Long lastCol = Cells(1, Columns.Count).End(xlToLeft).Column With Range(Cells(3, "A"), Cells(3, lastCol)) .Formula = "=IF(OR(A2="""",A2<>2),"""",""公"")" .Value = .Value End With End Sub こんな感じでも大丈夫だと思います。m(_ _)m
ご参考 https://gist.github.com/kumatti1/4028479
>Openの方は余裕がありましたら、標準モジュールの方で処理をするように改善したいと思います。 >SheetChangeの方で何かお気づきの点がございましたらお教えいただければ幸いです。 #1です。Workbook_SheetChangeの中で、沢山のプロシージャを呼んで、（たぶん）複雑な処理をして、訳の分からないエラーに悩まされている様なので、イベントプロシージャをさっさと抜けて、別プロシージャで処理してみては如何という提案です。ご参考まで。
http://www.h3.dion.ne.jp/~sakatsu/index.htm がとっても^100 参考になるかと思います。 法令そのものの解説もありますし、考え方も載せてくれています。 週末にでもじっくり読んでみてください。 コードは上記リンク中の「祝日判定ロジック」を読まれることをお勧めします。 VBA、C# ・・・色々と有志の方々が参加されています。 春分の日・秋分の日についてですが 以前（質問者さんは生まれていないかも）に天文学的に微妙な場合がありまして 国の決定した祝日とカレンダー屋さんのが異なることがありました (^_^;) カレンダー屋さんは早い物は秋口から刷りはじめます。 結果、当社で配るカレンダーには修正シールが付いてきて みんなでペタペタ貼っていた記憶があります。 それ以来？、前年の２月に官報で発表されることになりました。
Excel2010でのお話ですが2013でも通用する部分があるかと。 VBAでVBAのコードを変更するのは 目的が異なれ一時期猛威を振るったマクロウィルスと やっていることは同じです。 セキュリティセンターの「マクロの設定」から VBA プロジェクト オブジェクト モデルへのアクセスを信頼する にチェックを入れる必要がありますが セキュリティレベルは下がります。 VBAでパブリック変数を設定し、変更が必要になった時には 手作業で修正する。 他のコードではこのパブリック変数を参照する。 パブリック変数の代わりに適当なシートに書き込んでおいて これを参照。 CustomDocumentProperties に設定する。 http://officetanaka.net/excel/vba/tips/tips122.htm なども考えられては？
１番目の文字列を含めて色付きアンダーラインを設定してから実行すれば １文字目のものについて取得できます。 コードを書くときは適当に書いてもだめですから、 ピリオド（.）を打ってそのなかから適切なものを選択すれば下記のようにいくつかのことがわかります。 MsgBox .Font.UnderlineColor.SchemeColor MsgBox .Font.UnderlineColor.RGB MsgBox .Font.UnderlineStyle 前回のレスの通り、すべての文字について調べないといけないので面倒です。 当方はやる気がしないのでご自分で、さらにfor each を使って面倒な判定を設定して取得してください。
Call test だとだめですか？
こんにちは ＞下記のようにしてもカーソルが点滅しません。その解決方法を教えてください。 との事でございますが。 早速ですが、 以下の２点の方法を、提案させて頂きます。 +++++++++++++++++ Public Class Form1 '"指定されたウィンドウをキーボードフォーカスを持つウィンドウにする。"API 'http://nienie.com/~masapico/api_SetFocus.html のページより引用 Declare Function SetFocus Lib "user32" (ByVal hWnd As IntPtr) As Integer Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load '■この方法では失敗する。 'TextBox1.Focus() ''■方法１。TabIndexを最初にする。 'TextBox1.TabIndex = 0 '■方法２。API関数を使用する。 Call SetFocus(TextBox1.Handle) End Sub End Class +++++++++++++++++ 尚、私は、VB2008の環境にて動作確認を行っています。 なので、 他の環境や、私の勘違いで、ご希望の動作が得られなければ、 申し訳ございません。 また、コード中のコメントに示させて頂いたURLのサイト様の情報を引用しておりますので、 あわせてご覧いただけると幸いでございます。 以上 ありがとうございました。
出来ます。 全てのバーコードリーダーがそうなのかは知りませんが、当方が使ったことが有るの物はバーコードを読み込むとその値をアクティブセルに入力し、アクティブセルが直ぐ下のセルに移動しました。 つまり、キーボードから値を入力しEnterを押したのと同じ動き。 ＃最近のUSB接続の物なら恐らく同様だと思います。 これで図書IDリストを作れば、蔵書リストとの付き合せもCountif関数程度で事足りるでしょう。 丁度こんな感じです↓ https://www.technical.jp/barcode/handbook2/chapter-2-1.html
>オートシェイプ内のテキストの行間をVBAで指定することはできるのでしょか？ > （マクロを登録してもなにも記述されていないので、困っています。） Excel2013では記録されました。 Selection.ShapeRange.TextFrame2.TextRange.ParagraphFormat.SpaceWithin = 1.5
こちらでは動きましたが Win7(32bit) Excel2013 Application.Run "'C:\Users\○△◇\Documents\Book1.xlsm'!Test"
スクリプトを32bit版ファイラーから試すと問題ありませんでした。 が、Explorer （64bitで動作）から試すと同じエラーになりました。 Explorer 64bit で動作 ↓ Wscript も64bitが呼ばれる ↓ ADODB の64bit版は存在しないのでエラー発生の流れかと思います。 （Win7 64bit & Office 2010 64bit でもほんの少しだけ確認） なので、 http://d.hatena.ne.jp/KenKens/20140312/1394641831 の中ほどにあるように32bit版で起動しなおすようにすれば解決するものと思われます。
格子をBitmapに描画して PictureBoxのBackgroundImageに設定して グラフのビットマップを Imageプロパティに設定すれば 希望通りになると思いますよ
ShellWindowsで列挙してGetForegroundWindowが返すハンドルと一致するかで判別するとか。 Dim o As New SHDocVw.ShellWindows Dim ie As InternetExplorer For Each ie In o If ie.Hwnd = GetForegroundWindow Then '何か処理 Exit For End If Next お望みのハンドルからIEオブジェクトを得るには、 >GetForegroundWindow がIEFrameなら、その子孫ウィンドウのInternet Explorer_Serverに対して WM_HTML_GETOBJECTメッセージを送信すればHTMLDocument2オブジェクトが得られるので parentWindowプロパティが返すIHTMLWindow2オブジェクトを IUnknown_QueryService APIの第一引数に指定して、 第二、第三引数はIID_IWebBrowser2を指定すれば第四引数でIEオブジェクトが得られます。
SendKeysは「現在アクティブなウィンドウにしか送れない」ので「アドレス入力バーにフォーカスを移す」と言う処理が必要です。 まず、Adobe Acrobatが起動されている状態で、Adobe Acrobatのプロセスにフォーカスを当てます。 AppActivate("Adobe Acrobat Pro") フォーカスが当たるまで時間がかかる場合があるので、ここで少しSleepしましょう。 次に、SendKeysで「Alt+F」「Alt+A」をセンドします。 SendKeys "%(FA)" ダイアログが出るまで時間がかかる場合があるので、ここで少しSleepしましょう。 スリープ後で「名前を付けて保存」のダイアログが出ている筈なので「Alt+N」をセンドして「ファイル名」にフォーカスを当てます。 SendKeys "%N" 次に（少しスリープを入れてから）、保存先のパス名とENTERをセンドします。 SendKeys "C:\User\Save_Folder\{Enter}" こうすると、アドレスバーが「C:\User\Save_Folder\」に変わります（アドレスバーに直接に保存先を入力する必要はありません） 次に「FileName.pdf」とENTERをセンドすれば、その名前で保存されます。 SendKeys "FileName.pdf{Enter}" 「名前を付けて保存」ダイアログが出た時の初期の「ファイル名」テキストボックスにあった名前で保存したい場合は、ファイル名にフォーカスが移った状態で「Ctrl＋C」をセンドして、アドレスバーを変更したあと「Ctrl+V」をセンドすれば、ダイアログが出た時の初期のファイル名に戻せます。
End Sub の前に Label1(1).ZOrder 0 を入れてみてください
プロジェクトの読込でエラーが出ているのですから、その後なにをやっても無駄です。まともなexeが作成されるわけがありません。 ＞気にせず、OKを押し、コードの内容を変更したあと（※変更しなくても）、 プロジェクトの上書き保存をしたあと 気にしましょうよ。エラーを内包した状態でまともなexeが作成できるはずがありません。そのプロジェクトを上書き保存してしまうとエラーを許容したプロジェクトとなってしまいますのでそのプロジェクトファイルはただのゴミファイル群となり再利用も出来なくなります。 オリジナルのプロジェクトファイルを持ってきて、それが正常に開くことが最低の条件です。プログラムの修正や変更はその後の話です。 ＞GPIB、I/O、ActiveXコンポーネントの環境下 このプロジェクトを開くための環境がそのPCに整ってません。 GPIB、I/Oに関連するDLL/OCXファイルが必要ですActiveXコンポーネントはファイル以外にもレジストリへの登録が必要です。 つまり、ターゲットマシンと同じ実行環境をプログラムを変更しようとしているPCにも整えることが必要です。 具体的にはGPIB、I/Oのドライバのインストール、独自のActiveXコンポーネントがあるならそれらのレジストリへの登録。 なお、エラー無視して上書きしてしまったプロジェクトはもう使えませんので注意してください。
参考に With CreateObject("Scripting.FileSystemObject") 　　MsgBox .GetParentFolderName("C:\xxxx\yyyy.txt") End With
VBA IDEにはショートカットキーのカスタマイズ機能はなさそうですね。 すでにある機能でExcelやWordの[Ctrl]Y相当の機能を呼び出すには、[Alt]E R と言うキーストロークでやるしかないのでは？
「VB Form1_DragDrop」で検索してみてください。 下記などが参考になると思います。 http://blog.livedoor.jp/akf0/archives/51252181.html
推測による所などもあり明確な回答ではありませんが、一部について回答します。 便宜上、質問項目を上から順に番号付けて記載します。 (1)および(2)について。 Visual Studio Express 2013 には3種類のバージョンがありますが、(1)のリンク先に示される Web Developer に相当するのは「Express 2013 for Web」というバージョンです。 このバージョンを利用しているでしょうか？ # 当方はfor Webをインストールしていないので、それを使えばできるのかどうかははっきりとはわかりませんが。。 (3)について。 VBS (VBScript) を利用するのであればexeにはできません。 VBSはその名の通りスクリプトとして実行する目的のものですので、そもそもexeなどのバイナリを作らずに実行したい場合に使うものです。 exeにしたいのならば、たとえばVB.NETなどを利用を検討する必要があります。 (そして個人的には、VB.NETを使うぐらいならC#をおすすめしますが。VB.NETと基本的にプログラムの作り方は同じで、書きやすさが断然上だと思うので。あくまで個人的主観による。) (4)について。 リンク先にも書かれていますが、その手順は製品版のVisual Studioを利用する場合のものかと思います。 製品版のVisual StudioはExpressのように種類が分かれていないため、C++のプロジェクトを流用してスクリプトデバッガを起動することなどが出来るのだと思います。 ちなみに、当方の手元では「Visual Studio Express 2013 for Windows Desktop」がインストールしてあるのですが、これにはスクリプトデバッガは含まれていないようです。 # コマンドラインから「wscript //x script.vbs」のようにしてもVS2013が選択肢に出てこないので、たぶん。 そのため、「for Windows Desktop」バージョンでメイクファイルプロジェクトを利用しても同じことをするのは不可能そうです。
プロジェクト→参照設定と進んでください。 このなかに『参照不可』の項目がありませんか。 この問題は、 測定器そのものではなく、 測定器の動作に必要なドライバあるいはライブラリが質問者様のPCに存在しないために発生します。 実際に動作しているPCと同じライブラリをインストールすれば解決します。 GP-IBにて通信ということはおそらく、 USB→GP-IBか、PCI→GP-IBの変換器を使用していると思われます。 これらはそのメーカーのHPより入手できると思われます。
#1,2です。KenKen_SP様には失礼して、改造部分のコードを提示させていただきます。Win7Home(64) xl2010(32) で試しています。 出典：http://okwave.jp/qa/q5124395.html ' // Bitmapオブジェクトからファイルへ書き出し Public Function SaveImageToFile( _ ByVal hBmp As OLE_HANDLE, _ ByVal sFilename As String, _ Optional ByVal sFormat As String = "JPG", _ Optional ByVal nQuarity As Long = 60 _ ) As Boolean '@ sFormat : BMP, JPG, GIF, TIF, PNG '@ nQuality: 0-100(0:高圧縮低画質, 100:低圧縮高画質, Jpg のみ有効) Dim sEncoderStr As String Dim nStatus As Long Select Case UCase$(sFormat) Case "JPG": sEncoderStr = ENCODER_JPG Case "GIF": sEncoderStr = ENCODER_GIF Case "TIF": sEncoderStr = ENCODER_TIF Case "PNG": sEncoderStr = ENCODER_PNG Case Else: sEncoderStr = ENCODER_BMP End Select Dim uEncoderParams As EncoderParameters ' Jpeg のクオリティー設定 If UCase$(sFormat) = "JPG" Then nQuarity = Abs(nQuarity) If nQuarity > 100 Then nQuarity = 100 uEncoderParams.count = 1 With uEncoderParams.Parameter(0) .GUID = pvToCLSID(QUALITY_PARAMS) .TypeAPI = 4 ' Type Long .Value = VarPtr(nQuarity) .NumberOfValues = 1 End With End If ' 保存処理 If UCase$(sFormat) = "JPG" Then nStatus = GdipSaveImageToFile(hBmp, _ StrPtr(sFilename), _ pvToCLSID(sEncoderStr), _ VarPtr(uEncoderParams)) Else nStatus = GdipSaveImageToFile(hBmp, _ StrPtr(sFilename), _ pvToCLSID(sEncoderStr), _ ByVal 0&) End If SaveImageToFile = CBool(nStatus = 0) Call GdipDisposeImage(hBmp) End Function ' // サンプル Sub Sample() Dim hBmp As OLE_HANDLE Dim file1 As String file1 = GetDesktopPath & "\Hydrangeas.bmp" ' GDI+ を初期化する If GDIplus_Initialize() = False Then MsgBox "GDI+ を初期化できません", vbCritical Exit Sub End If '変換元ファイル読込 If GdipCreateBitmapFromFile(ByVal StrPtr(file1), hBmp) <> 0 Then Gdiplus_Shutdown Exit Sub End If ' 保存(JPEG でクオリティー30の場合） If SaveImageToFile(hBmp, GetDesktopPath & "\sample.jpg", "jpg", 30) = False Then MsgBox "保存に失敗", vbCritical Else MsgBox "保存に成功", vbInformation End If ' GDI+ を終了させる（必ず呼び出すこと） Call Gdiplus_Shutdown End Sub 'テスト用 Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
時刻は24時間を1とする値じゃなかったかな？ 現状のまま、ZISA の値を0．25にして実行したらどうなります？ 6時間ズレの結果になるなら間違いない
アプリ側で 取得するためのインターフェースが用意されていないのであれば無理かも … VB6とかでWordを対象としてやるなら dim obj as Variant set obj = GetObject(,"word.application") if not obj is nothing then 　　MsgBox obj.Documents(1).FullName end if といった具合で … obj が Word Documentsが Word側で用意したプロパティ FullNameが文書へのパス
No.1・3です。 ＞シート３のH列が朝在庫数で、 ＞I列が販売数、ここにcountifが入っていて、シート１のAE列の名称を数えています。 ＞J列が現在残っている在庫です。 ＞K列に販売終了時間を入れたいです というコトは前回のコードはSheet3のシートモジュールにしなければなりませんが、 そのようになっているのでしょうか？ その上でそのような状態になるのであれば、別の方法を考えなければなりませんね。 前回のコードは再計算されるたびにマクロが走ってしまいます。 それが原因かもしれません。 別マクロで前回のコードを記載してみてはどうでしょう？ もちろん「再計算」されるたびにマクロが実行されるのではなく、コマンドボタン等でご自身でマクロを実行させます。 もう一つ気になるのがCOUNTIF関数の「検索条件」がコマンドボタンをクリックするたびに変わるのでしょうか？ もしそうであれば、一旦K列データを消去する必要があるように思うのですが・・・ お手元のSheetの動きがこちらでは判断できませんので、 とりあえずはこの程度で・・・m(_ _)m
こちらで Wendy02 さんが二つ挙げられています。 http://okwave.jp/qa/q2008661.html あとは、Workbook_open か Auto_open で指定するとかでは？ 検証してはいませんが、SendKeys だと タイミング的に微妙かも知れません。
以下の Sample1()とSample2()を作成してテスト。両者は、かなり似た動きをしました。が、異なっている点もあります。ただ、20ミリ秒では瞬間過ぎて・・・・。せめて1000ミリ秒（=1秒）前後を指定した方がいいです。 Sample1()…Pause中もExcelは動作する。 Sample2()…Sleep中はExcelも停止する。 Excel のシートを切り替えるだけであれば Sample2()のやり方でOK。でも、次の切り替えまでの待機中に別のSub()を動かしたいのであればSample1()のやり方。Sample2()ではテストしていませんが、解説を読めばそのようです。 Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) Sub Sample1() 　　Dim I As Integer 　　For I = 1 To 8 　　　　Sheets("Sheet" & I).Select 　　　　Pause 1 　　Next I 　　Sheets("目次").Select End Sub Sub Sample2() 　　Dim I As Integer 　　 　　For I = 1 To 8 　　　　Sheets("Sheet" & I).Select 　　　　Sleep 1000 　　Next I 　　Sheets("目次").Select End Sub 【標準モジュール】 Public Sub Pause(ByVal PauseTime As Single) 　　Dim Finish As Single 　　 　　Finish = Timer + PauseTime 　　Do 　　　　DoEvents 　　Loop Until Timer > Finish End Sub
iかjがゼロになってませんか？ デバックモードでカーソル当てると値を確認出来ます。
ここに有るんとちゃう？ http://book.mynavi.jp/support/bookmook/vbapro/accessvba/ の「ファイルをダウンロード」から vba_access.zip
> 「実行時エラー1004　アプリケーション定義またはオブジェクト定義のエラーです」 > というエラーが出てきました。 コードの中のsheet1を正しい名前に変更しましたでしょうか。 コードを表示した画面の左側のペインで表示されているツリー上で Sheet1(シート) となっているシートの場合、コードでは With Sheets("シート")にしてください。通常の画面の下のタブに表示されているシート名になります。 > 現在A1には見出しが入っているので、A1を除いて並び替えは可能でしょうか？ Sub example3() Dim BRow As Long With Sheets("シート") .Activate BRow = .Range("A" & Rows.Count).End(xlUp).Row - 1 .Range("A2:BI" & BRow).Sort Key1:=.Range("A2"), order1:=xlAscending .Range("XX2").Formula = "=A2 & (IF(COUNTIF(OFFSET($A$2,0,0,ROW(A1),1),A2)-1=0,"""", -(COUNTIF(OFFSET($A$2,0,0,ROW(A1),1),A2)-1)))" .Range("XX2").Copy .Range("XX2").Resize(BRow, 1).PasteSpecial Paste:=xlPasteFormulas .Range("A2:A" & BRow).Value = .Range("XX2:XX" & BRow).Value .Range("XX2").Resize(BRow, 1).ClearContents .Range("A1").Select End With End Sub
こんばんは！ Bブックが開いているかどうかによってコードが変わってきますが・・・ とりあえず開いていなくても対応できるようにしてみました。 Aブックの標準モジュールに↓のコードをコピー＆ペーストしてマクロを実行してみてください。 尚、Aブックの aシート　のA1セルからデータはあるという前提です。 Sub Sample1() Dim i As Long, k As Integer, myPath As String, fN As String Dim wS As Worksheet, myFlg As Boolean myPath = "保存場所\" fN = "B.xlsx" Set wS = ThisWorkbook.Worksheets("a") For k = 1 To Workbooks.Count If Workbooks(k).Name = fN Then myFlg = True Exit For End If Next k If myFlg = False Then Workbooks.Open myPath & fN End If For i = 1 To wS.Cells(Rows.Count, "A").End(xlUp).Row Workbooks(fN).Worksheets("b").Cells(i, "B") = Left(wS.Cells(i, "A"), 6) If wS.Cells(i, "A") = "" Then Exit For Next i End Sub ※　コード内の「保存場所」の部分は、Bブックのプロパティの「場所」から確認して フルパスを入力してください。 こんなんではどうでしょうか？m(_ _)m
こんばんは！ 一例です。 標準モジュールに↓のコードをコピー＆ペーストしてみてください。 Sub Sample1() Worksheets("Sheet1").Range("A1:C3").Copy Workbooks.Open "ファイルの保存場所\集計.xlsx" ActiveWorkbook.Worksheets("Sheet1").Cells(Rows.Count, "A").End(xlUp).Offset(1).Select Selection.PasteSpecial Paste:=xlPasteValues Application.CutCopyMode = False End Sub ※　コード内の「ファイルの保存場所」の部分は 「集計」ブックのプロパティから確認してフルパスを入力してください。 ※　「集計」ブックが開いていないという前提のコードですので、開いている場合はエラーになります。 「集計」ブックが開いている場合 ＞Workbooks.Open "ファイルの保存場所\集計.xlsx" の1行を ＞Workbooks("集計.xlsx").Activate に変更してください。 ※　「集計」ブックのA列最終行以降にコピー＆ペーストするようにしていますので コピー元のA2～A3セルには空白セルはないとします。 （空白セルがあると行がずれてしまいます）m(_ _)m
元の値が０なので取得できないと勘違いしたのでしょう。 下記のように自分で指定してみればわかります。 Sub test() 　Dim wkbWorksheets As Worksheet 　Dim wksShapes As Shape For Each wkbWorksheets In ActiveWorkbook.Worksheets For Each wksShapes In wkbWorksheets.Shapes With wksShapes.TextFrame2.TextRange.Characters .Font.Spacing = 5 .Font.Kerning = 10 MsgBox .Font.Kerning MsgBox .Font.Spacing End With Next wksShapes Next wkbWorksheets End Sub
こんな感じ Sub ボタン1_Click() For i = 1 To 50 If Range("A" & i).Value = "" Then Range("B" & i).Value = "" Range("C" & i).Value = "" Range("D" & i).Value = "" Range("E" & i).Value = "" Else Range("B" & i).Value = "い" Range("C" & i).Value = "う" Range("D" & i).Value = "え" Range("E" & i).Value = "お" End If Next End Sub
こちらはいかがでしょうか。 http://tanlab.blog.fc2.com/blog-entry-31.html 試してみたところ、ファイル名は、変数に変えてもOKでした。 Dim file1 As String, file2 As String file1 = "C:\Users\Public\Pictures\Sample Pictures\Hydrangeas.jpg" file2 = getDeskTopPath & "\test.tif" （注）getDeskTopPathはデスクトップのパスを取得する自作（というかWebから切り貼りした）関数 GdipCreateBitmapFromFileは、BMP,JPEG,PNG,TIFF等に対応しています。 With encParam.Parameter(0) 　　　　.Value = VarPtr(4) ' 画像圧縮:LZW=2, CCITT3=3, CCITT4=4, Rle=5, None=6 End With 圧縮方法については詳しくは無いですがVarPtr(2)のLZW等にするとカラーになりました。 なお、JPEGからLZW圧縮TIFFに変換したら巨大ファイルになりました。当たり前かも。
見落としていました。 　　　　　　　　.DownBars.Format.Fill.ForeColor.RGB = RGB(128, 0, 0) ' 陰線の塗り潰し色　赤系 > 陰線の塗り潰しを黒以外で指定する方法は、 見つけいたのを忘れていました。 > 陰陽線（枠を除く）の幅を指定する方法は、 間接的には出来るみたいですが、直接の方法はやっぱり解りません。 それでは、ここら辺で、、、。
失礼しました。 以下のコードは「文字か、数字かで判断する場合」で置き換えたものになります。 補足の問題点を修正いたしましたのでご確認お願いします。 結果の問題点 １．7行目の文字を削除してしまった。 　→　削除処理判定flagが正常に行われていなかったため修正しました。 ２．9行目から最終行の間の削除処理が行われていない。 　→　"["から8文字シフトした後、行末までの文字数が10文字無い場合に 　　　次の行を跨ぎ処理をしていましたので修正しました。 　→　末尾まで10文字確保できない場合『[8:31:25 | 8:31:2』などはスキップされます。 気になること・・・ 補足にてご提示の元の文面には以下の統一性がありません。 「を編集しました」と「編集しました」や「]」の有無など行によって結果が異なります。 現在の処理は"["を検索した位置より8文字右へシフトしたところから10文字を抜出し 抜き出した文字が特定文字「数値, ,:,/」であれば削除、それ以外ではればそのまま。 8文字シフトした位置から末尾までで10文字取得できなければ次の"["を検索・・・ としております。 ■VBAコード Sub sample() '変数を宣言 Dim lmoji As String, lVal As String, cVal As String Dim aa As String, pp As String, a As String, p As String Dim flag As Boolean Dim i As Integer 　　'検索文字を指定 　　lmoji = "[" 　　'カーソルを先頭へ 　　Selection.HomeKey Unit:=wdStory 　　Application.ScreenUpdating = False 　　'メイン処理 　　Do 　　　　'検索条件を設定 　　　　With Selection.Find 　　　　　　.Forward = True 　　　　　　.ClearFormatting 　　　　　　.MatchWholeWord = True 　　　　　　.MatchCase = False 　　　　　　.Wrap = wdFindContinue 　　　　　　'lmojiを検索 　　　　　　If .Execute(FindText:=lmoji, Forward:=True, Format:=True) = True Then 　　　　　　　　'行、頁位置を取得 　　　　　　　　aa = Selection.Information(wdFirstCharacterLineNumber) 　　　　　　　　pp = Selection.Information(wdActiveEndPageNumber) 　　　　　　　　'末尾までの対象文字を10文字分取得可能か判定 　　　　　　　　Selection.EndKey Unit:=wdLine, Extend:=wdExtend 　　　　　　　　If Len(Selection) - 9 < 10 Then 　　　　　　　　　　flag = False 　　　　　　　　Else 　　　　　　　　　　'文字列の取得 　　　　　　　　　　Selection.MoveLeft Unit:=wdCharacter, Count:=1 　　　　　　　　　　Selection.MoveRight Unit:=wdCharacter, Count:=8 　　　　　　　　　　Selection.MoveRight Unit:=wdCharacter, Count:=10, Extend:=wdExtend 　　　　　　　　　　lVal = Selection 　　　　　　　　　　flag = True 　　　　　　　　End If 　　　　　　End If 　　　　　　'開始位置ならループ終了 　　　　　　If a = aa And p = pp Then Exit Do 　　　　　　'末尾まで10文字確保できない場合は処理をスキップ 　　　　　　If flag Then 　　　　　　　　'文字を取得して判定 　　　　　　　　For i = 1 To Len(lVal) 　　　　　　　　　　cVal = Mid(lVal, i, 1) 　　　　　　　　　　If IsNumeric(cVal) Then 　　　　　　　　　　　　'数値の場合 　　　　　　　　　　　　flag = True 　　　　　　　　　　Else 　　　　　　　　　　　　'文字の場合 　　　　　　　　　　　　If cVal = ":" Or cVal = "|" Or cVal = " " Then 　　　　　　　　　　　　　　flag = True 　　　　　　　　　　　　Else 　　　　　　　　　　　　　　flag = False 　　　　　　　　　　　　End If 　　　　　　　　　　End If 　　　　　　　　　　If flag = False Then Exit For 　　　　　　　　Next i 　　　　　　　　'対象文字の削除 　　　　　　　　If flag Then 　　　　　　　　　　Selection.Delete Unit:=wdCharacter 　　　　　　　　　　flag = False 　　　　　　　　End If 　　　　　　End If 　　　　　　'初期位置を記録 　　　　　　If a = "" Then a = aa: p = pp 　　　　　　'検索位置をシフト 　　　　　　.Parent.Move Count:=1 　　　　End With 　　　　DoEvents 　　Loop 　　Application.ScreenUpdating = True 　　Selection.Find.ClearFormatting End Sub
ADO: INSERT文 SELECT文 DELETE文 UPDATE文 ADOX: CREATE DATABASE文 CREATE TEBLE文 CREAtE INDEX文 DAOを継いだのがADO。ADOXは、その名が示すとおりADOの拡張版。いうなれば、INSERT文んどのレコード操作にではADOを使い、テーブルの定義・最低後・定義情報の参照にはADOXを利用します。通常の登録、変更、削除、参照という操作においてはADOのみで十分です。 ＞サーバーにACCESSのDBを置き・・・ ということは、 サーバー：バックエンド クライアント：フロントエンド と、小規模なクライアント・サーバー・システムを目指されているのでしょうか？ 経験では、350MZのワークステーション、OSはWindowsNTにバックエンドを置き、10台のWindwos98という構成でも快適に動きました。UNIXシステムを引き継いだものですが、全く、問題はありませんでした。 ＞２～３人程度で使用する超小規模システムで利用したい。 サーバーのOSが通常のWindowsでなければ、全く問題ないと思います。頑張って開発されてください。
こんにちは。 前提。 行高、列幅が統一されているとして、 ' ' まず、６行４列のセル範囲の　 ' ' 　幅　xSize ' ' 　高さ　ySize ' ' を採っておく。 　　With Range("A2:D7") 　　　　xSize = .Width 　　　　ySize = .Height 　　End With ' ' 次に、 ' ' チャートオブジェクトを配置する位置を ' ' チャートオブジェクトの.Left、.Top、を ' ' セルの.Left、.Top、に合わせるようにする。 　　For i = 1 To 4 　　　　For j = 1 To 4 　　　　　　LA = LA + 1 　　　　　　With ActiveSheet.ChartObjects.Add( _ 　　　　　　　　　　Left:=Cells((j - 1) * 4 + 1).Left, _ 　　　　　　　　　　Top:=Cells((i - 1) * 12 + 2, 1).Top, _ 　　　　　　　　　　Width:=xSize, _ 　　　　　　　　　　Height:=ySize) 　　　　　　　　.Name = "GF" & LA 　　　　　　　　With .Chart 　　　　　　　　　　.ChartType = xlLine 　　　　　　　　　　.SetSourceData Source:=GFDT(LA), PlotBy:=xlColumns 　　　　　　　　End With 　　　　　　End With 　　　　Next j 　　Next i 以上のようなやり方が現状に対する直接的な対策になります。 チャートオブジェクトを配置する法則性の説明が詳しくないので、 こちらで推理した仮の想定として、 水平位置は、 　Ａ列、Ｅ列、Ｉ列、Ｍ列、 　のように、４列ステップ、 垂直位置は、、 　行２、行１４、行２６、行３９、 　のように、２行目を先頭に、１２行ステップ という設定で組んでいます。 いずれにしても、セル範囲に合わせてチャートオブジェクトを配置する ことは簡単に動作確認できるので、 後は、列、行、のステップ数と先頭位置を、狙いに合わせて修正してください。 　　 * 4 + 1 の意味は、４列ステップ、先頭は１列め、 　　 * 12 + 2 の意味は、１２行ステップ、先頭は２行め、 という要領です。 配列変数 GFDT については、こちらでは中身が解りませんが、 正しく、セル範囲への参照がなされているものとします。 尚、こちらで追加した変数xSize, ySize について、 変数宣言をする場合にはSingle型を指定してください。 "行高、列幅が統一されている" という前提も、こちらの推測でしかありませんが、もし違っている場合でも ニーズさえ詳らかならば対策は難しくはないので、 包括的に補足して貰えれば、再度レスします。 以上です。 追伸。 たぶん、結果を確認しながら作業をやり直したりすることになるでしょうから、 簡単に 今回のマクロで作成したチャートオブジェクトを 削除するマクロを添えておきますね。 Sub DeleteCharts() Dim o As ChartObject 　　For Each o In ActiveSheet.ChartObjects 　　　　If o.Name Like "GF*" Then o.Delete 　　Next End Sub
フォルダを変化させるには > デスクトップ＞zenkoku＞kanagawa＞kanagawa01＞kanagawa01A これの「どこが」「どのセルに」対応して「変化するか」考えてください。 デスクトップ＞zenkoku＞[列D]＞[列E]＞[列F]でしょ？ これを組み込めばよい。 20社まとめる件は、あらかじめワークシートをソートしておけば良い。 ※でも「20社にまとめる」は[列D]都道府県も考慮する必要があるのかな？ ※これ以上の後出しは知りませんよ Sub HTMLファイル出力改() 　' http://oshiete.goo.ne.jp/qa/8787726.htmlの質問本文から改造 　' ※PC引っ張り出してキーボード入力しましたが、EXCELが無いので無試験 　Dim myPath As String 　Dim i As Long 　Dim strPath as string　　'HTML出力ファイルのパス 　dim nFile as long　　　'ファイルハンドル 　dim nCount as long　　　'20社判定 　’環境変数からデスクトップフォルダへのパスを定義する 　myPath = Environ("USERPROFILE") & "\Desktop\Zenkoku\" 　’20社単位で処理できるよう、ソートする 　Range("A:F").Sort Key1:=Range("E2"), Key2:=Range("F2"), _ 　　　Header:=xlYes, MatchCase:=False, Orientation:=xlTopToBottom 　nCount = 0 　 　For i = 2 To Range("F1").End(xlDown).Row 　　' ブレーク判定１：前行と現在行を比較する 　　' 　処理が必要なのは「初回」または「20社単位名が変わる」 　　' 　※初回は見出し行≠データ１行目であること 　　' 20社の場合 　　If Range("E" & i - 1).Text <> Range("E" & i ).Text Then 　　' 1社の場合 ''''If Range("E" & i - 1).Text & "|" & Range("F" & i - 1).Text <> Range("E" & i ) & "|" & Range("F" & i ).Text Then 　　　 　　　'ファイルハンドルの空きを取得 　　　nFile = freefile() 　　　'-出力パスの作成--ここから--------------------------------- 　　　’20社の場合 　　　strPath = myPath & Range("E" & i).Text & "\" & Range("F" & i).Text 　　　’ 1社の場合 　''''strPath = myPath & Range("E" & i).Text & "\" & Range("F" & i).Text "\" & Range("G" & i).Text 　　　'-出力パスの作成--ここまで--------------------------------- 　　　' 出力ファイルを開く 　　　Open strPath & "\index.html" For Output As #nFile 　　　'-20社共通部分1出力--ここから--------------------------------- 　　　Print #nFile, "<!DOCTYPE html>" & vbNewLine _ 　　　　　& "<html lang=""en"">" & vbNewLine _ 　　　　　& "<body>" & vbNewLine _ 　　　　　& "<div class=""span3"" id=""sidebar"">" & vbNewLine 　　　'-20社共通部分1出力--ここまで--------------------------------- 　　　nCount = 0 　　End If 　　'-20社個別部分出力--ここから--------------------------------- 　　Print #nFile, vbNewLine _ 　　　　& "<div class=""widget"">" & vbNewLine _ 　　　　& "<h4 class=""widgetTitle"">" & Range("A" & i) & "</h4>" & vbNewLine _ 　　　　& "<ul><li>" & Range("B" & i) & "</li>" & vbNewLine _ 　　　　& "<li>" & Range("F" & i) & "</li></ul></div>" & vbNewLine 　　'-20社個別部分出力--ここまで--------------------------------- 　　’20社単位の出力件数をインクリメント 　　nCount = nCount + 1 　　' ブレーク判定２：現在行と次行を比較する 　　' 　処理が必要なのは「次行は20社単位名が変わる」または「先ほどの出力が20社目」 　　' 　※データ最終行の次行は空白等であること 　　' 20社の場合 　　If Range("E" & i).Text <> Range("E" & i - 1).Text or nCount = 20 Then 　　’ 1社の場合 ''''If Range("E" & i).Text & "|" & Range("F" & i).Text <> Range("E" & i + 1) & "|" & Range("F" & i + 1).Text Then 　　　'-20社共通部分2出力--ここから--------------------------------- 　　　Print #nFile, "</div>" & vbNewLine & "</body>" & vbNewLine & "</html>" 　　　' 出力ファイルを閉じる 　　　Close #nFile 　　　nCount = 0 　　　'-20社共通部分2出力--ここまで--------------------------------- 　　End If 　Next i End Sub
PictureBoxで透過処理を行うのであれば BackColorプロパティを Color.TransParentに変更します 次に 設定する画像を Bitmapオブジェクトで構築して MakeTransparentメソッドで 何色を透明にしたいか設定します 次に 透過画像の背景になるコントロールの ControlsコレクションにAddします PictureBoxの Locationを適切な位置に変更すれば 希望の動作になるかと … ' 透過画像を用意 Dim bmp as new Bitmap("透過画像のパス") ' 透過色を設定 bmp.MakeTransparent(bmp.GetPixel(0,0)) ' コントロールの背景色を透過に設定 PictureBox2.BackColor = TransParent ' 透過画像を設定 PictureBox2.Image = bmp ' ここまでが初期設定 ' 背景になるPictureBoxに 前景のコントロールを追加 if PictureBox1.Controls.Contains(PictureBox2) = false then 　　PictureBox1.Controls.add(PictureBox2) End if ' 前景の描画位置を設定 PictureBox2.Location = new Point( PictureBox1.Width / 2, PictureBox1.Height / 2) といった具合です
ChooseColor APIで表示されるダイアログを、モーダル→モードレスに変更したいという意味なら、 ChooseColorにそういう選択肢は無さそうなので無理だと思います。外していたらすみません。 http://wisdom.sakura.ne.jp/system/winapi/common/common1.html 作成したカスタムカラーを保存するバージョンを回答した事があります。ご参考まで。 http://okwave.jp/qa/q8449398.html
'XMLで重複カットして、XPATHをフォルダーパスに変換したらどうかという思いつきでやってみたコードです。話の種にどうぞ。 'Microsoft XML V3.0に参照設定（もっと新しいのもありますが、大抵の環境にあるバージョン） Dim oXMLDom As DOMDocument30 Dim fso As Object Public Sub myMakeFolders() Dim I As Long, j As Long, k As Long Dim myXPath As String Dim targetRange As Range Dim buf As Variant Dim root As IXMLDOMElement Set oXMLDom = New DOMDocument30 Set fso = CreateObject("Scripting.FileSystemObject") '初期設定 settingDOM oXMLDom 'ワークシートからリスト取得 Variant配列に収納 With ThisWorkbook.Sheets("Sheet1") Set targetRange = .Range(.Range("D2"), .Range("D" & .Rows.Count).End(xlUp)).Resize(, 3) End With buf = targetRange.Value Set root = oXMLDom.createElement("root") oXMLDom.appendChild root For I = 1 To UBound(buf, 2) Call addElement(root, I, buf) Next I Set fso = Nothing Set oXMLDom = Nothing End Sub Private Sub addElement(root As IXMLDOMElement, level As Long, buf As Variant) Dim I As Long, j As Long Dim parentElement As IXMLDOMElement Dim newElement As IXMLDOMElement Dim myXPath As String Dim retNode As IXMLDOMNodeList Dim folderPath As String Dim myParentPath As String '親フォルダーのパスを指定、デスクトップに置くとします myParentPath = getDeskTopPath & "\zenkoku" If Not fso.FolderExists(myParentPath) Then fso.CreateFolder myParentPath For I = 1 To UBound(buf, 1) myXPath = "/" & root.nodeName For j = 1 To level - 1 If level > 1 Then myXPath = myXPath & "/" & buf(I, j) Next j Set parentElement = root.SelectSingleNode(myXPath) Set retNode = root.SelectNodes(myXPath & "/" & buf(I, level)) If retNode.Length = 0 Then Set newElement = oXMLDom.createElement(buf(I, level)) parentElement.appendChild newElement folderPath = Replace(myXPath & "/" & buf(I, level), "/root", myParentPath) folderPath = Replace(folderPath, "/", "\") If Not fso.FolderExists(folderPath) Then fso.CreateFolder folderPath End If Next I End Sub 'MSXMLDOMの設定 Private Sub settingDOM(ByRef dom As DOMDocument30) With dom .async = False .validateOnParse = False .resolveExternals = False .preserveWhiteSpace = True .setProperty "SelectionLanguage", "XPath" End With End Sub Function getDeskTopPath() As String Dim WSH As Object Set WSH = CreateObject("Wscript.Shell") getDeskTopPath = WSH.SpecialFolders("Desktop") Set WSH = Nothing End Function
　すみません。もう一か所書き換えていたのにうっかりコピーし忘れていました。 With wksShapes.TextFrame2.TextRange.Characters MsgBox .Font.UnderlineStyle Excel　２００７でも確認しました。
問題ありません。 ご自分でテストしてみればすぐにわかる話だと思うのですが、Windows 8.1 搭載のタブレットはこれから導入するってことですかね。
　いつまでも回答がつかないのはなぜだと思いますか？ マクロの記録で必要なことはわかるので あとはそれを少し編集するだけでできることだからです。 　
エクセルの定数ではなく MsoTextUnderlineType 列挙体が近いようです。（日本語のヘルプが見つからなかった） Name／Value／Description msoNoUnderline／0／Specifies no underline. msoUnderlineDashHeavyLine／8／Specifies a dash underline. msoUnderlineDashLine／7／Specifies a dash line underline. msoUnderlineDashLongHeavyLine／10／Specifies a long heavy line underline. msoUnderlineDashLongLine／9／Specifies a dashed long line underline. msoUnderlineDotDashHeavyLine／12／Specifies a dot dash heavy line underline. msoUnderlineDotDashLine／11／Specifies a dot dash line underline. msoUnderlineDotDotDashHeavyLine／14／Specifies a dot dot dash heavy line underline. msoUnderlineDotDotDashLine／13／Specifies a dot dot dash line underline. msoUnderlineDottedHeavyLine／6／Specifies a dotted heavy line underline. msoUnderlineDottedLine／5／Specifies a dotted line underline. msoUnderlineDoubleLine／3／Specifies a double line underline. msoUnderlineHeavyLine／4／Specifies a heavy line underline. msoUnderlineMixed／-2／Specifies a mixed of underline types. msoUnderlineSingleLine／2／Specifies a single line underline. msoUnderlineWavyDoubleLine／17／Specifies a wavy double line underline. msoUnderlineWavyHeavyLine／16／Specifies a wavy heavy line underline. msoUnderlineWavyLine／15／Specifies a wavy line underline. msoUnderlineWords／1／Specifies underlining words.
Windows フォームアプリケーションを前提とします。 プロジェクトを右クリック→プロパティ→参照→インポートされた名前空間 に System.Windows.Formsのチェックが外れてるならいれる。 Microsoft.Office.Interopのチェックが入ってるなら外す。 Microsoft.Office.Interop.Excelのチェックが入ってるなら外す。 コードは Imports Microsoft.Office.Interop です。 > Dim oXls As Excel.Application：Excel.Applicationにエラー ここで指定したいApplicationクラスは、Microsoft.Office.Interop.Excel.Applicationクラスだし、 > Label14.Location = New Point(350, 100) ここは、System.Drawing.Pointクラスです。 名前空間の設定や記述周りが悪くて Applicationクラスを、System.Windows.Forms.Applicationクラス、 Pointクラスを、Microsoft.Office.Interop.Excel.Pointクラスと 認識されているなどとしか思えません。 もしでしたら、名前空間について理解を深めたら良いかと思います。
厳密には、VB内でR1C1方式のセル指定というのはありません。 VB内でR1C1に似た方式でセルを指定したい場合は、Cellsプロパティを使います。 exCel.Cells(1,1).Value = "Hello World" と書くと exCel.Range("A1").Value = "Hello World" と同様になります。 ちなみにCells(行番号, 列番号)です。 VB内では、Rangeによるセル指定より、基本的にCellsプロパティを使うことの方が多いです。 Rangeはあくまで範囲を指定するものですから、Range(Cells(1,1), Cells(1,4))のように使います。 Cellsプロパティを使ってセルを指定する最大のメリットは、行番号や列番号を変数を使って増減させることで、繰り返し処理に使えることです。 例えば For i = 1 to 10 exCel.Cells(1,i).Value = "Hello World" Next とすれば、A列～J列まで繰り返し処理することができます。 ご参考まで。
(1)Alt+F11でVBEを開き、挿入→標準モジュール (2)作成された標準モジュールへ以下のVBAコードを貼付 (3)コード内の以下の箇所を該当のシート名に合わせて修正 　　　'対象のシートを設定 　　　Set mySt(0) = Worksheets("Sheet1")　←元データのシート 　　　Set mySt(1) = Worksheets("Sheet2")　←表示先のシート (4)Alt+F11でVBEを閉じ、Alt+F8で「sample」マクロを実行 ※補足 処理中で使用している区切り文字列について 元データのA列（ID）に「;」「,」を含む場合は正常に動作しません。 含む可能性がある場合は、コード内の以下の箇所をそれぞれ元データで使用していない 文字列に変更してください。（key(0)とkey(1)は別の文字列としてください） 　　　key(0) = ";": key(1) = "," ■VBAコード Sub sample() '変数を宣言 Dim mySt(1) As Worksheet, key(1) As String Dim bsData() As Variant, myData() As Variant Dim i As Long, j As Long, cnt As Long Dim names() As String, buf As Variant Dim tar As Range, flag As Boolean '対象のシートを設定 Set mySt(0) = Worksheets("Sheet1") Set mySt(1) = Worksheets("Sheet2") '区切り文字（必要であれば変更） key(0) = ";": key(1) = "," '配列にデータを格納 With mySt(0) 　　bsData = .Range(.Cells(1, "A"), .Cells(Rows.Count, "C").End(xlUp)) End With '重複しない名前の配列を作成 For i = 1 To UBound(bsData, 1) 　　flag = True 　　If Sgn(names) <> 0 Then 　　　　For j = 0 To UBound(names, 2) 　　　　　　If names(0, j) = bsData(i, 1) Then 　　　　　　　　flag = False 　　　　　　　　Exit For 　　　　　　End If 　　　　Next j 　　End If 　　If flag Then 　　　　If Sgn(names) = 0 Then 　　　　　　ReDim names(1, 1) 　　　　Else 　　　　　　ReDim Preserve names(1, UBound(names, 2) + 1) 　　　　End If 　　　　names(0, UBound(names, 2)) = bsData(i, 1) 　　End If Next i '名前配列へ同名のデータを集約 For i = 1 To UBound(names, 2) 　　For j = 1 To UBound(bsData, 1) 　　　　If bsData(j, 1) = names(0, i) Then 　　　　　　names(1, i) = names(1, i) & bsData(j, 2) & key(1) & bsData(j, 3) & key(0) 　　　　End If 　　Next j Next i 'シートへ書き出し Application.ScreenUpdating = False With mySt(1) 　　.Cells.ClearContents 　　For i = 1 To UBound(names, 2) 　　　　buf = Split(names(1, i), key(0)) 　　　　For j = 0 To UBound(buf) - 1 　　　　　　If j Mod 3 = 0 Then 　　　　　　　　cnt = cnt + 1 　　　　　　　　Set tar = .Cells(cnt, "A") 　　　　　　　　tar = names(0, i) 　　　　　　End If 　　　　　　tar.Offset(0, (j Mod 3) * 2 + 1) = Left(buf(j), InStr(1, buf(j), key(1)) - 1) 　　　　　　tar.Offset(0, (j Mod 3) * 2 + 2) = Right(buf(j), Len(buf(j)) - InStr(1, buf(j), key(1))) 　　　　Next j 　　Next i End With Application.ScreenUpdating = True '終了 MsgBox "終了" End Sub
'ADOのレコードセットを使用 Sub testMain() 　　Dim myCon As New ADODB.Connection 　　Dim FileName As String 　　Dim rs1 As New ADODB.Recordset 　　Dim rs2 As New ADODB.Recordset 　　Dim rs3 As New ADODB.Recordset 　　Dim conStr As String 　　Dim strSQL1 As String 　　Dim strSQL2 As String 　　Dim strSQL3 As String 　　Dim dic1 As Object 　　Dim dic2 As Object 　　Dim buf1 As Variant 　　Dim buf2 As Variant 　　Dim i As Long 　　Dim j As Long 　　Dim fso As Object 　　Dim strPath As String 　　Set dic1 = CreateObject("Scripting.Dictionary") 　　Set dic2 = CreateObject("Scripting.Dictionary") 　　strSQL1 = "SELECT 大分類 FROM [Sheet1$] GROUP BY 大分類" 　　strSQL2 = "SELECT * FROM [Sheet1$]" 　　strSQL3 = "SELECT * FROM [Sheet1$]" 　　'カレントフォルダのパス 　　strPath = ThisWorkbook.Path 　　'接続先のExcelファイル(質問の場合は現在のファイル) 　　FileName = ThisWorkbook.FullName 　　conStr = "Provider=Microsoft.Jet.OLEDB.4.0;" & _ 　　　　　　　"Extended Properties=Excel 8.0;" & _ 　　　　　　　"Data Source=" & FileName 　　'接続 　　myCon.Open conStr 　　'レコードセットを開く 　　rs1.Open strSQL1, myCon, adOpenStatic, adLockReadOnly 　　rs2.Open strSQL2, myCon, adOpenStatic, adLockReadOnly 　　rs3.Open strSQL2, myCon, adOpenStatic, adLockReadOnly 　　If rs1.RecordCount > 0 Then 　　　　rs1.MoveFirst 　　　　Do Until rs1.EOF 　　　　　　If Not IsNull(rs1!大分類) Then 　　　　　　　　'フォルダ作成 　　　　　　　　Call cmdMkDir(rs1!大分類) 　　　　　　　　'中分類の取得 　　　　　　　　If rs2.RecordCount > 0 Then 　　　　　　　　　　rs2.MoveFirst 　　　　　　　　　　Do Until rs2.EOF 　　　　　　　　　　　　'大分類と同じ分類の中分類を検索 　　　　　　　　　　　　If rs2!大分類 = rs1!大分類 Then 　　　　　　　　　　　　　　If Not IsNull(rs2!中分類) Then 　　　　　　　　　　　　　　　　buf1 = rs2!中分類 　　　　　　　　　　　　　　　　If Not dic1.exists(buf1) Then 　　　　　　　　　　　　　　　　　　'検索済みの中分類をDictionaryに格納 　　　　　　　　　　　　　　　　　　dic1.Add buf1, buf1 　　　　　　　　　　　　　　　　　　'中分類ファイルの作成 　　　　　　　　　　　　　　　　　　Call cmdMakeChuFile(strPath & "\" & rs1!大分類, buf1) 　　　　　　　　　　　　　　　　　　'小分類の取得 　　　　　　　　　　　　　　　　　　rs3.MoveFirst 　　　　　　　　　　　　　　　　　　Do Until rs3.EOF 　　　　　　　　　　　　　　　　　　'大分類および中分類が同じ小分離の検索 　　　　　　　　　　　　　　　　　　If rs2!大分類 = rs3!大分類 And buf1 = rs3!中分類 Then 　　　　　　　　　　　　　　　　　　　　If Not IsNull(rs3!小分類) Then 　　　　　　　　　　　　　　　　　　　　　　buf2 = rs3!小分類 　　　　　　　　　　　　　　　　　　　　　　If Not dic2.exists(buf2) Then 　　　　　　　　　　　　　　　　　　　　　　　　'検索済みの小分類をDictionaryに格納 　　　　　　　　　　　　　　　　　　　　　　　　dic2.Add buf2, buf2 　　　　　　　　　　　　　　　　　　　　　　　　'小分類ファイルの作成 　　　　　　　　　　　　　　　　　　　　　　　　Call cmdMakeShoFile(strPath & "\" & rs1!大分類, buf2) 　　　　　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　　　　　'変数とDictionaryの初期化 　　　　　　　　　　　　　　　　　　buf2 = "" 　　　　　　　　　　　　　　　　　　dic2.RemoveAll 　　　　　　　　　　　　　　　　　'次のレコードに移動 　　　　　　　　　　　　　　　　　rs3.MoveNext 　　　　　　　　　　　　　　　　　Loop 　　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　　End If 　　　　　　　　　　　　　End If 　　　　　　　　　　'次のレコードに移動 　　　　　　　　　　rs2.MoveNext 　　　　　　　　　　Loop 　　　　　　　　End If 　　　　　　　　'変数とDictionaryの初期化 　　　　　　　　buf1 = "" 　　　　　　　　dic1.RemoveAll 　　　　　　End If 　　　　　　'次のレコードに移動 　　　　　　rs1.MoveNext 　　　　Loop 　　End If 　　'後始末 (オブジェクトの破棄が主) 　　rs1.Close: Set rs1 = Nothing 　　rs2.Close: Set rs2 = Nothing 　　rs3.Close: Set rs3 = Nothing 　　myCon.Close: Set myCon = Nothing 　　Set dic1 = Nothing 　　Set dic2 = Nothing End Sub Sub cmdMkDir(ByVal strDir As String) 　　Dim obj As Object 　　Dim strPath As String 　　Dim strFolder As String 　　Set obj = CreateObject("Scripting.FileSystemObject") 　　strPath = ThisWorkbook.Path 　　strFolder = obj.BuildPath(strPath, strDir) 　　obj.CreateFolder strFolder 　　Set obj = Nothing End Sub Sub cmdMakeChuFile(ByVal strPath As String, ByVal strFileName As String) 　　Dim strFile As String 　　strFile = strPath & "\" & strFileName & ".html" 　　Open strFile For Output As #1 　　Print #1, "<html>" 　　Print #1, "中分類ファイル" & "-------" & strPath & "-------" & strFileName 　　Print #1, "</html>" 　　Close #1 End Sub Sub cmdMakeShoFile(ByVal strPath As String, ByVal strFileName As String) 　　Dim strFile As String 　　strFile = strPath & "\" & strFileName & ".html" 　　Open strFile For Output As #1 　　Print #1, "<html>" 　　Print #1, "小分類ファイル" & "-------" & strPath & "-------" & strFileName 　　Print #1, "</html>" 　　Close #1 End Sub
＞クエリの式で実装したいのです。 添付図を参照されたし！
VB2008でExcelのVBプロパティを使うには、「Microsoft Excel Object Library」の参照が必要になります。 VB2008でその設定が抜けているので、COMExceptionが発生するだけです。 ライブラリの参照方法については、参考URLを参照してみてください。 ご参考まで。
Dir(フルパスファイル名） ファイルの存在を調べ、あればファイル名（パス無し）を返します。 Sub W() Dim ファイル名 As String, fpFilename As String Dim 列番号 As Long 列番号 = 4 Do While Cells(2, 列番号).Value <> "" ファイル名 = Cells(2, 列番号).Value fpFilename="D:\学校\データ\" & ファイル名 & ".xlsx" If Dir(fpFilename)<>""　then Workbooks.Open fpFilename Range("A2:A1000").Copy Application.DisplayAlerts = False ActiveWorkbook.Close ThisWorkbook.Activate ActiveSheet.Paste Cells(5, 列番号) end if 列番号 = 列番号 + 1 Loop End Sub 質問とは関係ありませんが、ちょっと便利な使い方があります。詳細はググって下さい。
変数[ファイル名]がstring型のため、activateが使用できない状態です。 Workbooks(ファイル名).activate でactiveにできると思います。 また、別の方法ですが、追加した箇所を削除し(元に戻し)、代わりに、下記の一文を入れてみてください。 Application.DisplayAlerts = False これで「クリップボードに～」は表示されなくなります。
これでは？ Sub 連続シート作成() 　　For Each 対象セル In Selection 　　　　Sheets("マスタ").Copy After:=ActiveSheet 　　　　ActiveSheet.Name = 対象セル.Value 　　Next 対象セル End Sub
>項目軸を確実に設定したいのですが、どうすればよいでしょうか。 どんなデータで、どの部分を確実になのかわかりませんが・・・・。 1行・１列は項目名として、データは変数で行範囲を指定し、 12～40列の指定列を対象とする場合、以下のコードで設定出来ます。 また、グラフを選択していない状態でも動作するように、 名前で対象のグラフを選択してから値を変更するようにしています。 コード内でグラフの名前は「グラフ 1」としています。 （異なる場合はコード内の該当位置を修正してください） >項目軸を「Wb3Sh6.Range(Cells(範囲1, 12), Cells(範囲2 - 1, 12)), 」 >のみとしたいのに コード内のArray(1, 12, ・・・)で対象の列番号をカンマ区切りで指定してください。 　For Each myCol In Array(1, 12) で1列目（項目列）と12列目（データ列）を対象範囲として設定します。 ■VBAコード Sub sample() Dim RngData As Object, Wb3Sh6 As Worksheet Dim 範囲1 As Long, 範囲2 As Long Dim myCol As Variant '定数を設定 Set Wb3Sh6 = ActiveSheet 範囲1 = 1: 範囲2 = 11 '項目範囲を設定 With Wb3Sh6 For Each myCol In Array(1, 12, 18, 33, 34, 39, 40) 　　If RngData Is Nothing Then 　　　　Set RngData = .Range(.Cells(範囲1, myCol), .Cells(範囲2 - 1, myCol)) 　　Else 　　　　Set RngData = Union(RngData, .Range(.Cells(範囲1, myCol), .Cells(範囲2 - 1, myCol))) 　　End If Next myCol End With '項目を反映 ActiveSheet.Shapes("グラフ 1").Select ActiveChart.SetSourceData Source:=RngData, PlotBy:=xlColumns End Sub
シートやセルに対する操作のように直接扱いませんが・・・ フォームのあるブックに値を受け取りフォームに値をセットするプロシージャを用意し、 別のブックからそのプロシージャへ書き込む値を渡す方法です。 以下の設定を【Book1】【Book2】でして頂き、 【Book1】の「Sample1」を実行してください。 【Book1】 (1)以下のコードを標準モジュールへ記述 　　Sub Sample1() 　　　　Dim msg As String 　　　　msg = "入力する文字列" 　　　　'変数msgを引数としてBook2のSample2を実行 　　　　Application.Run "Book2!Sample2", msg 　　End Sub 【Book2】 (1)UserForm1を作成してTextBox1コントロールを配置 (2)以下のコードを標準モジュールへ記述 　　Sub sample2(msg As String) 　　　　Load UserForm1 　　　　'受け取った引数をTextBox1にセット 　　　　UserForm1.TextBox1.Value = msg 　　　　UserForm1.Show 　　End Sub
１回目のループ終了時の「列番号＝列番号＋１」結果は「D」になりますか？おそらくならないと思います。エラー発生時にデバッグを押した後、列番号のところにカーソルを合わせると値表示がされるので、確認出来ます。 これが原因ならば、以下のように対策すればOKです。 Sub W() Dim ファイル名 As String Dim 列番号 As Long 列番号 = 3 Do While Cells(5,列番号).Value <> "" ファイル名 = Cells(5,列番号).Value Workbooks.Open "D:\学校\データ\" & ファイル名 & ".xlsx" Range("A2:A5").Copy ActiveWorkbook.Close ThisWorkbook.Activate ActiveSheet.Paste Cells(6,列番号) 列番号 = 列番号 + 1 Loop End Sub 要は列番号をアルファベットでなく整数に変更し、セル表現をRangeからCellsに変更します。
No.1さんに加えて Workbooks.Open "D:\日本\データ\ファイル名.xlsx" ↓↓↓↓ Workbooks.Open "D:\日本\データ\" & ファイル名 & ".xlsx"
参考に Sub Test() 　　Dim c As Range, Bunnrui As String 　　Dim i As Long, j As Long 　　For Each c In Range("C2", Cells(Rows.Count, "C").End(xlUp)) 　　　　If c.Value <> Bunnrui Then 　　　　　　Bunnrui = c.Value 　　　　　　i = 1: j = 1 　　　　ElseIf i >= 20 Then 　　　　　　i = 1: j = j + 1 　　　　Else 　　　　　　i = i + 1 　　　　End If 　　　　c.Offset(, 1).Value = c.Value & Format(j, "00") 　　　　c.Offset(, 2).Value = c.Value & Chr(64 + i) 　　Next End Sub
ExcelのVBAだったら簡単にできますが、普通のVBからだと手間が余分に必要です。以下がズバリの操作を行っているサンプルです。 http://homepage2.nifty.com/nonnon/SoftSample/VB.NET/SampleExcelOpe.html また、上記サンプルでセルの位置を指定するのに使われているRangeオブジェクトは、以下のExcel VBAの解説をあたってください。RangeとCellsの組み合わせで指定されたセルを操作するので、ここを理解しないと先に進めないはずです。 http://www.asahi-net.or.jp/~ef2o-inue/vba_k/sub04_070_10.html
【訂正】[住所X_控え]は不要！ 添付図通りに[住所1_控え]、[住所2_控え]を用意し、もって比較し[住所不一致]を更新するコードを書いてみました。そして、実際に試した場合、一旦、別のレコードに移動した場合に[住所1_控え]、[住所2_控え]を再現する必要があることに気付きました。そうしないと、新たな[住所1]、[住所2]との正しい比較が出来ないからです。 Private Sub Form_Current() 　　If Me.NewRecord Then 　　　　Me.住所1_控え = "" 　　　　Me.住所2_控え = "" 　　Else 　　　　Me.住所1_控え = ZipConv(Me.郵便番号, zcKen) 　　　　Me.住所2_控え = ZipConv(Me.郵便番号, zcCty1) & ZipConv(Me.郵便番号, zcCty2) 　　End If End Sub そこで、某サイトのZipConv()を利用して[住所1_控え]、[住所2_控え]を再現。でも、そんなことをする位ならば・・・ Public Sub 住所不一致_Update() 　　Dim isNotAgree As Boolean 　　 　　If Len(Me.郵便番号 & "") Then 　　　　isNotAgree = CBool(Me.住所1 <> ZipConv(Me.郵便番号, zcKen)) 　　　　isNotAgree = isNotAgree + CBool(Me.住所2 <> ZipConv(Me.郵便番号, zcCty1) & ZipConv(Me.郵便番号, zcCty2)) 　　　　Me.住所不一致 = isNotAgree 　　End If End Sub と、ZipConv()をもって比較すれば済む話。そういうことで、コメントアウトしている行は不要。つまり、[住所1_控え]、[住所2_控え]は不要。そういうことになるようです。 Option Compare Database Option Explicit Private Sub Form_Current() 　　'If Me.NewRecord Then 　　'　　Me.住所1_控え = "" 　　'　　Me.住所2_控え = "" 　　'Else 　　'　　Me.住所1_控え = ZipConv(Me.郵便番号, zcKen) 　　'　　Me.住所2_控え = ZipConv(Me.郵便番号, zcCty1) & ZipConv(Me.郵便番号, zcCty2) 　　'End If End Sub Private Sub 住所1_AfterUpdate() 　　住所不一致_Update End Sub Private Sub 住所2_AfterUpdate() 　　住所不一致_Update End Sub Private Sub 郵便番号_AfterUpdate() 　　Me.住所不一致 = False End Sub Public Sub 住所不一致_Update() 　　'Me.住所不一致 = CBool((Me.住所1 <> Me.住所1_控え) + (Me.住所2 <> Me.住所2_控え)) 　　 　　Dim isNotAgree As Boolean 　　 　　If Len(Me.郵便番号 & "") Then 　　　　isNotAgree = CBool(Me.住所1 <> ZipConv(Me.郵便番号, zcKen)) 　　　　isNotAgree = isNotAgree + CBool(Me.住所2 <> ZipConv(Me.郵便番号, zcCty1) & ZipConv(Me.郵便番号, zcCty2)) 　　　　Me.住所不一致 = isNotAgree 　　End If End Sub さてさて、問題は、[住所1]と[住所2]とを変更すべき事態の発生頻度です。事実上はゼロではないでしょうか？いずれにしろ、私の当初アイデアには致命的な問題点があったので撤回します。
現在のコードだと列Ｇの値で1社ずつの別ファイルで出力される。 これを20社で１ファイルとしたい。 で合ってます？ > If Range("G" & i).Text <> Range("G" & i - 1).Text Then と > If Range("G" & i).Text <> Range("G" & i + 1).Text Then の行で会社が変ったことを判断しています。 なのでここに手を加える。 ここでカウンタを数え、20以内ならファイルオープン・クローズ操作しない。 20の倍数（カウンタ Mod20 =0)ならファイルオープン・クローズする。 ファイル名は”tokyo” & trim（カウンタを20で割った商（整数）＋1） クローズ時にはカウンタをリセットする。 Forループ終了時にカウンタの20の剰余を判断し、0でなければクローズ操作する。 （不要なのは会社数が20の倍数の時にループ内でクローズしてる場合）
こんばんは！ http://oshiete.goo.ne.jp/qa/8786862.html の方は目を通されたのでしょうか？ 全く同じコトなのですが・・・ どうしてもVBAでの方法というコトなので、一例です。 Sub Sample2() Dim lastRow As Long, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row With Range(.Cells(2, "G"), .Cells(lastRow, "G")) .Formula = "=IF(COUNTIF(Sheet2!A:A,F2),VLOOKUP(F2,Sheet2!A:B,2,FALSE),"""")" .Value = .Value End With End With End Sub ※　今回もわざわざVBAでやるメリットはないと感じます。m(_ _)m
こんばんは！ わざわざVBAでやるメリットはないように思えますが・・・ Excel2003　というコトなので Sheet1のB2セルに =IF(COUNTIF(Sheet2!A:A,A2),VLOOKUP(A2,Sheet2!A:B,2,0),"") という数式を入れB2セルのフィルハンドルでダブルクリック！ これで完了だと思います。 どうしてもVBAでやりたい場合、一例です。 ワークシート関数をそのまま使用するのが一番簡単だと思います。 Sub Sample1() Dim lastRow As Long, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") lastRow = .Cells(Rows.Count, "A").End(xlUp).Row With Range(.Cells(2, "B"), .Cells(lastRow, "B")) .Formula = "=IF(COUNTIF(Sheet2!A:A,A2),VLOOKUP(A2,Sheet2!A:B,2,False),"""")" .Value = .Value End With End With End Sub 別の方法としては、いかにもVBAらしくやると Sub Sample2() Dim i As Long, c As Range, wS As Worksheet Set wS = Worksheets("Sheet2") With Worksheets("Sheet1") For i = 2 To .Cells(Rows.Count, "A").End(xlUp).Row Set c = wS.Range("A:A").Find(what:=.Cells(i, "A"), LookIn:=xlValues, lookat:=xlWhole) If Not c Is Nothing Then Cells(i, "B") = wS.Cells(c.Row, "B") End If Next i End With End Sub こんな感じでしょうか。 ※　Sample2はループさせていますので、データ量が多い場合は Sample1の方が速いと思います。m(_ _)m
Sub 県名の列作成() Dim i As Long For i = 2 To Cells(Rows.Count, "B").End(xlUp).Row Range("D" & i).Value = Left(Range("B" & i), 3) Next i End Sub ではどうでしょうか。 Cells(Rows.Count, "B").End(xlUp).Rowで B列の入力されている最終行までにしています。 途中に空白があっても最後まで実行されます。
ランダムデータで試してみましたが一瞬でしたねぇ。 余計な処理が行われていたりしませんか？ステップ実行で確認してみてください。 ■自動計算のON・OFFを追加するとか。 'OFF Application.Calculation = xlCalculationManual 'ON Application.Calculation = xlCalculationAutomatic ■オートフィルタでやってみるとか。 Sub Macro1() Dim LastRow As Long, mySt(1) As Worksheet 'シート設定 Set mySt(0) = Worksheets("全体") Set mySt(1) = Worksheets("Sheet2") With mySt(0) 　　LastRow = .Cells(Rows.Count, 1).End(xlUp).Row 　　.Rows(1).Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove 　　With .Range(.Rows(1), .Rows(LastRow)) 　　　　.AutoFilter Field:=5, Criteria1:="=12345", Operator:=xlAnd 　　　　With .SpecialCells(xlCellTypeVisible) 　　　　　　.Copy mySt(1).Rows(1) 　　　　　　.ClearContents 　　　　End With 　　End With 　　.Rows(1).Delete End With mySt(1).Rows(1).Delete End Sub ■その他高速化テク http://officetanaka.net/Excel/vba/speed/index.htm
訂正です。 上側のコードですが、Addressが抜けておりました。 申し訳ありません。 またMeは不要です。Meはユーザーフォーム等で自身のフォームなどを対象にする場合に用います。 現在のワークシートを対象にするのであれば、Activesheet.Rangeとしてください。 Cells(cnt, n - 3) = WorksheetFunction.Sum( _ 　　Range( _ 　　　　"cr" & cnt & ":" & _ 　　　　Range("cr" & cnt).Offset(Range("CR6") * -1, 1).Address _ 　　) _ ) またn及びcntの値は正しいですか？cntが3以下または nが3以下ですと、エクセルの取り扱えるセル範囲外となりますのでエラーとなります。 以下のテストコードで動作致します。 （合計対象範囲はCR1：CS4となり、結果はCQ4セルに出力されます） Sub sample1() Dim cnt As Long, n As Long cnt = 4 n = 98 Cells(cnt, n - 3) = WorksheetFunction.Sum( _ 　　Range( _ 　　　　"cr" & cnt & ":" & _ 　　　　Range("cr" & cnt).Offset(Range("CR6") * -1, 1).Address _ 　　) _ ) End Sub Sub sample2() Dim cnt As Long, n As Long cnt = 4 n = 98 Cells(cnt, n - 3) = WorksheetFunction.Sum( _ 　　Range( _ 　　　　Cells(cnt, "cr"), _ 　　　　Range("cr" & cnt).Offset(Range("CR6") * -1, 1) _ 　　) _ ) End Sub
excelとのことですので、VBAですね。 単純に複数のコントロールを変数を用いて指定し、プロパティを設定するだけなら、Controlsコレクションを使用します。 http://www.moug.net/tech/exvba/0140013.html ですが、 今回ご提示の質問のように、チェンジイベントをまとめて記述するには以下のような方法があります。 http://okwave.jp/qa/q8747288.html
こんばんは！ 細かい配置まで検証する気力がありませんが・・・ ＞Grp1~10をB7に、yamada10xをC7に抽出するように変更 ＞Grp1~10をJ7に、yamada4xをK7に抽出するように変更 と ＞Sheet1のyamada10xとyamada4xのセルBの位置をセルCに移動させたい場合なのですが の件に関しては、↓の画像のような配置と解釈しています。 尚、 ＞空けておいた３行に罫線が設定してしまい、繰り上がってきます。 ＞これは wS2.Cells(k, (i - 2) * 8 + 2).Resize(, 2).Delete shift:=xlUp ＞重複しているセルの削除が関係しているのですか？？？ はい！その通りです。 文章だけでは、お手元にある表の細かいレイアウトは全く判りませんので （もちろん質問にもそんなコトは書いてないので）そこまでの対処はしていません。 とりあえず今判っている問題点だけを考慮しもう一度コードにしてみました。 （削除したセルは追加して下側のセルのレイアウトに影響を与えないようにしています） Sub Sample4() Dim i As Long, j As Long, k As Long, lastRow As Long, lastCol As Long Dim wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False If wS2.Range("A1") = "" Then wS2.Range("A1") = "ダミー" End If lastRow = wS2.UsedRange.Rows.Count '▼7行目が項目行？なので7行目で最終列取得 lastCol = wS2.Cells(7, Columns.Count).End(xlToLeft).Column If lastRow > 6 Then For j = 2 To lastCol Step 8 Range(wS2.Cells(7, j), wS2.Cells(lastRow, j + 1)).ClearContents Next j End If '★←追加 With Worksheets("Sheet1") '▼Sheet1の項目行は5行目？ If .Range("A5") = "" Then .Range("A5") = "ダミー" End If '▼C列で最終行取得 lastRow = .Cells(Rows.Count, "C").End(xlUp).Row '▼C列でフィルタ（重複なしでSheet3のA1セルに貼り付け） Range(.Cells(5, "C"), .Cells(lastRow, "C")).AdvancedFilter Action:=xlFilterCopy, copytorange:=wS3.Range("A1"), unique:=True '▼Sheet3の2行目～最終行まで For i = 2 To wS3.Cells(Rows.Count, "A").End(xlUp).Row '▼Sheet2の7行目に項目表示 wS2.Cells(7, (i - 2) * 8 + 2) = .Range("AA5") '▼「○○の合計数」という表示形式ではなく、データそのまま wS2.Cells(7, (i - 2) * 8 + 3) = wS3.Cells(i, "A") '▼Sheet1の5行目のC列でオートフィルタ（Sheet3のi行A列でフィルタを掛ける） .Rows(5).AutoFilter field:=3, Criteria1:=wS3.Cells(i, "A") '▼AA列の表示されているデータをSheet2の8行目、(i-2)*8+2　列に貼り付け Range(.Cells(6, "AA"), .Cells(lastRow, "AA")).SpecialCells(xlCellTypeVisible).Copy wS2.Cells(8, (i - 2) * 8 + 2) wS3.Range("C:C").Clear For k = wS2.Cells(Rows.Count, (i - 2) * 8 + 2).End(xlUp).Row To 8 Step -1 wS2.Cells(k, (i - 2) * 8 + 3) = WorksheetFunction.CountIfs(.Range("AA:AA"), wS2.Cells(k, (i - 2) * 8 + 2), .Range("C:C"), _ wS2.Cells(7, (i - 2) * 8 + 3)) If WorksheetFunction.CountIf(wS2.Columns((i - 2) * 8 + 2), wS2.Cells(k, (i - 2) * 8 + 2)) > 1 Or _ wS2.Cells(k, (i - 2) * 8 + 3) = 0 Then wS2.Cells(k, (i - 2) * 8 + 2).Resize(, 2).Delete shift:=xlUp '▼削除したセルの1行下を挿入 wS2.Cells(k + 1, (i - 2) * 8 + 2).Resize(, 2).Insert shift:=xlDown End If Next k Next i wS2.Columns.AutoFit wS2.Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole .Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole wS3.Cells.Clear .AutoFilterMode = False End With '▼Sheet2のB7セルと連続しているセルに格子の罫線 wS2.Range("B7").CurrentRegion.Borders.LineStyle = xlContinuous Application.ScreenUpdating = True End Sub ※　今までのコードで行・列合わせは理解の方法は理解できたと思いますので、 後はご自身で頑張ってみてください。m(_ _)m
こちらで解決するかも（charset の指定）？ 文字化けするのは、YAHOO.BBの携帯だけで発生するのか 特定のWEBページのテキストでだけ発生するのか オブジェクトの値ではなくて手打ちのテキストでも発生するか なども確認する必要があるかも？です。 当方テスト環境は作れないので、ここまで。 メモしとこ CDO.Messageによるメール送信 http://serialty.blog117.fc2.com/blog-entry-10.html
特殊ディレクトリの取得方法は以下ページのようにしてください。 http://dobon.net/vb/dotnet/file/getfolderpath.html
> たとえば、「現在の状態をコードとして表示する」なんてことでもいいんですが・・ > 現在のフォームの状態、どこかにないんですかねぇ。 それはコンパイラされたアセンブリの実行中の動作結果であって、開発上のソースにはどこにもありません。 > ご紹介いただいてる「変換.zip」というのはどういうものなんですか？ Excelでの変換方法です。 単純に説明しづらいので、アップローダを利用してあげてます。
DOUGLAS_ です。 > 早速試してみたのですがエラー表示が出て先に進めませんでした。 　ここで躓かれているようでしたら、ちょっと後が心配ですが。。。 myPath = Environ("USERPROFILE") & "\Desktop\Hoge\" の行で、作成された htmlファイル の保存場所を指定しています。 　上の例ではデスクトップに「Hoge」というフォルダを予め作成しておかなければ、「パスが見つかりません。」となるのは当然です。 　ですから、「Environ("USERPROFILE") & "\Desktop\Hoge\"」の部分を、oshiete100goo さんが、実際に htmlファイル を保存したいと思っていらっしゃるフォルダのフルパスに書き換えてください。 　ただし、一番最後に「\」を付けてくださいね。 例） myPath = "C:\Users\user\Documents\Hoge\" myPath = "D:\oshiete100goo\html\"
No.1です。 結局、行・列合わせだけの問題だと思います。 質問ではSheet1のB列は2種類だけですが、何種類あっても対応できるようにしてみました。 Sheet2の他の列に数式などが入っていてはいけませんので、 D:E列・I：J列・N:O列・・・と5列おきに操作しています。 Sub Sample3() Dim i As Long, j As Long, k As Long, lastRow As Long, lastCol As Long Dim wS2 As Worksheet, wS3 As Worksheet Set wS2 = Worksheets("Sheet2") Set wS3 = Worksheets("Sheet3") Application.ScreenUpdating = False If wS2.Range("A1") = "" Then wS2.Range("A1") = "ダミー" End If lastRow = wS2.UsedRange.Rows.Count lastCol = wS2.Cells(10, Columns.Count).End(xlToLeft).Column If lastRow > 9 Then For j = 4 To lastCol Step 5 Range(wS2.Cells(10, j), wS2.Cells(lastRow, j + 1)).ClearContents Next j End If With Worksheets("Sheet1") If .Range("A4") = "" Then .Range("A4") = "ダミー" End If lastRow = .Cells(Rows.Count, "B").End(xlUp).Row Range(.Cells(4, "B"), .Cells(lastRow, "B")).AdvancedFilter Action:=xlFilterCopy, copytorange:=wS3.Range("A1"), unique:=True '★ For i = 2 To wS3.Cells(Rows.Count, "A").End(xlUp).Row wS2.Cells(10, (i - 2) * 5 + 4) = .Range("F4") wS2.Cells(10, (i - 2) * 5 + 5) = wS3.Cells(i, "A") wS2.Cells(10, (i - 2) * 5 + 5).NumberFormatLocal = "@の合計数" .Range("A4").AutoFilter field:=2, Criteria1:=wS3.Cells(i, "A") Range(.Cells(5, "F"), .Cells(lastRow, "F")).SpecialCells(xlCellTypeVisible).Copy wS2.Cells(11, (i - 2) * 5 + 4) For k = wS2.Cells(Rows.Count, (i - 2) * 5 + 4).End(xlUp).Row To 11 Step -1 wS2.Cells(k, (i - 2) * 5 + 5) = WorksheetFunction.CountIfs(.Range("F:F"), wS2.Cells(k, (i - 2) * 5 + 4), .Range("B:B"), _ wS2.Cells(10, (i - 2) * 5 + 5)) If WorksheetFunction.CountIf(wS2.Columns((i - 2) * 5 + 4), wS2.Cells(k, (i - 2) * 5 + 4)) > 1 Then wS2.Cells(k, (i - 2) * 5 + 4).Resize(, 2).Delete shift:=xlUp End If Next k Next i wS2.Columns.AutoFit wS2.Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole .Cells.Replace what:="ダミー", replacement:="", lookat:=xlWhole wS3.Cells.Clear .AutoFilterMode = False End With Application.ScreenUpdating = True End Sub 今度はどうでしょうか？m(_ _)m
こんにちは。 > 何か解決策はありますでしょうか？ "範囲内のセル全てに処理が適応され"るように書き直せばいいです。 具体的な説明が何もないので、 汎用的なサンプルと、仮の処理例でお応えします。 要は 　Targetの中で処理が必要なセルを篩に掛けることと、 　Targetの中で処理が必要なセルすべてを総当たりで処理することと、 　それぞれのセルについて条件分岐をすることと、 　条件分岐に副ってセルの色を変えること、 の４つのポイントを考えればいいです。 以下の記述の応用としては、 ★で示した部分で「処理対象範囲」を指定することと、 「条件分岐と処理の一例」として、こちらが勝手に書いている部分を そちらのやりたいように書換えること、だけで済むように書いています。 以下の記述を新しいシートのシートモジュ－ルにコピペしたら、 「テスト壱」「テスト弐」を実行して動作を確認してみてください。 ' ' /// Private Sub Worksheet_Change(ByVal Target As Range) Const 処理対象範囲 = "A1:B100"　'　←★運用に合わせて★←要指定★ ' ' 関係ないセルの値変更なら処理を中止して Exit Sub 　　If Intersect(Target, Range(処理対象範囲)) Is Nothing Then Exit Sub ' ' 値変更されたセルの内、処理対象範囲に含まれるセルだけを、総当たりで処理 Dim c As Range 　　For Each c In Intersect(Target, Range(処理対象範囲)) 　　　　' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 　　　　' ' 以下、各セル c に対する、条件分岐と処理の一例 　　　　If c.Value = "" Or Not IsNumeric(c.Value) Then 　　　　　　c.Interior.ColorIndex = xlColorIndexNone 　　　　Else 　　　　　　Select Case c.Value Mod 5 　　　　　　Case 0: c.Interior.Color = vbRed Or &HAAAAAA 　　　　　　Case 1: c.Interior.Color = vbBlue Or &HAAAAAA 　　　　　　Case 2: c.Interior.Color = vbMagenta Or &HAAAAAA 　　　　　　Case 3: c.Interior.Color = vbGreen Or &HAAAAAA 　　　　　　Case 4: c.Interior.Color = vbYellow Or &HAAAAAA 　　　　　　End Select 　　　　End If 　　　　' ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 　　Next End Sub Sub テスト壱()　'　数値オンリー 　　Cells.Clear 　　Cells(1, 1) = 1 　　Cells(2, 1) = 2 　　MsgBox "オートフィルします" 　　Range("A1:A2").AutoFill Destination:=Range("A1:A30") End Sub Sub テスト弐()　'　数値と文字列 　　Cells.Clear 　　Cells(1, 1) = 1 　　Cells(2, 1) = "履歴-1" 　　MsgBox "オートフィルします" 　　Range("A1:A2").AutoFill Destination:=Range("A1:A30") End Sub
＃３-５,７、ｃｊです。＃７お礼欄へのレスです。 > 動作確認の準備ですが１，２迄で出来きました > ３、のコピー＆ペーストする場所ですが、コード表示画面にてユーザーフォームを表示し、そのユーザーフォーム内の部分をダブルクリックして、表示された画面にコードをコピー＆ペーストすればよいのでしょうか？、ペーストしたコードの初めの１０行ほどが赤字になっています、何処かおかしいでしょうか 大丈夫です。ご指摘の状況は異常ではありません。 "そのユーザーフォーム内の部分をダブルクリック"すると、 Private Sub UserForm_Click() End Sub が表示されますよね？その画面（コードペイン）の記述をすべて消してから、 ＃７のコードを貼り付けます。 "ペーストしたコードの初めの１０行ほどが赤字になっています" おかしくないですから安心してください。 #Ifから#End Ifまで、これは条件付きコンパイルというもので、 Excelのバージョン環境によって、どこかしら構文エラーで赤い字にはなりますが、 VBAはそれらの記述を読み飛ばしますから、動作には影響ないです。 そもそもは、様々なバージョンに自動的に対応させる為の記述です。 気にせずに動作確認して貰っても問題ない筈です。 もし気になるようでしたら、赤い字で書かれている行を 削除しちゃっても構いませんので。 赤い字を削除した場合は、その前後の #If VBA7 Then #Else #End If の３か所についても、消しちゃって構いません。 取り急ぎの返答でした。
サラッと検索したら出てきました。 もちろん使ったことがないのでご自分で試してみてください。 .NET diff class http://d.hatena.ne.jp/siokoshou/20070315
VBAによる対応となります。 対象のシートタブを右クリックしてコードの表示を選び、 最下のVBAコードを貼り付けてください。 セルに値が入力されるとグラフの参照範囲が変わります。 ■コードの修正 以下のコードでは、対象のグラフ名が「グラフ 11」であり、 変更するセル範囲がB列1行目から最終行までとしています。 (1)対象のグラフ名を変更する場合 　　If .ChartObjects(i).Name = "グラフ 11" Then 　　「グラフ 11」の部分を修正してください。 (2)再設定するセル範囲を変更する場合 　　Range(Cells(1, "B"), Cells(Rows.Count, "B").End(xlUp)) 　　→Cells(1, "B")が開始セルになります。 　　　　Cells(行番号, "列記号")の様式で記述 　　→Cells(Rows.Count, "B").End(xlUp)が終了セルになります。 　　　　Cells(Rows.Count, "列記号").End(xlUp)の様式で記述 ■VBAコード Private Sub Worksheet_Change(ByVal Target As Range) With ActiveSheet For i = 1 To .ChartObjects.Count 　　'変更対象のグラフ名を設定 　　If .ChartObjects(i).Name = "グラフ 11" Then 　　　　'グラフの参照範囲をB1:B最終行に変更 　　　　.ChartObjects(i).Chart.SetSourceData Source:= _ 　　　　　　Range(Cells(1, "B"), Cells(Rows.Count, "B").End(xlUp)) 　　　　Exit For 　　End If Next i End With End Sub
No.1です。 ＞cu6 から　ｄｖ83までが選択されてしまいます。 ＞ＣＵ49からＤＶ49までの行およびＣＵ50からＤＶ50までは空白のセルになってますので 83行目まで選択されるというコトはCU83セルに何らかのデータが入っているというコトになります。 ＞End(xlUp).Row を使っていますので、下の行から上に向かって検索しデータがあった場合にその行が最終行として 変数　lastRow　としていますので、その行まで選択されてしまいます。 49・50行目が空白で、51行目以降にデータがある場合48行目までを選択したい！というコトなのでしょうか？ その場合は ＞lastRow = .Range("CU6").End(xlDown).Row に変更してみてください。 そうすればCU6～DV48行目までが選択されます。 ※　余談ですが、Resize　を使うと選択範囲が広い場合行合わせが大変だと思います。 最終列が判っている場合、個人的には Sub Sample1() Dim lastRow As Long With Worksheets("計算") .Activate lastRow = .Range("CU6").End(xlDown).Row Range(.Cells(6, "CU"), .Cells(lastRow, "DV")).Select End With End Sub のようなコードの方が簡単だと思います。 ※　さらに・・・ CU6～DV6セルに項目なり何らかのデータがすべて入っている場合は >Range(.Cells(6, "CU"), .Cells(lastRow, "DV")).Select の行を ＞.Range("CU6").CurrentRegion.Select にしても同様の結果が得られると思います。m(_ _)m
レジストリへの書き込み、読み込み、削除を行う http://dobon.net/vb/dotnet/system/registrykey.html
まずは、ＶＢ（ビジュアルベーシック）て何？ これについて説明しておきますね。 http://oshiete.goo.ne.jp/qa/1431672.html http://oshiete.goo.ne.jp/qa/1252366.html を参考にしてください。 実は、目的に応じてＶＢはいくつもあるのです。 ただ文法が同じと云うだけで使い方など全く違います。 まずは、小手初めに、ご自身のパソコンで使ってみてください。 もし、Ｏｆｆｉｃｅ製品がインストールされているのであれば エクセルＶＢＡが手っ取り早いでしょう。 Ｏｆｆｉｃｅモインストールされていなければ ＶＢＡで勉強しても良いでしょう。 エクセルＶＢＡで良ければ http://www.eurus.dti.ne.jp/yoneyama/Excel/vba/index.html のサイトでもよく見て勉強してみてください。 有料の講習会であれば、アビバなど多数あります。 無料となると、ネット上で独学するか 親しい友人でＶＢに詳しい人に教えていただく事になると思います。 実は、私も独学で学んだ一人です。 頑張ってみてください。
COUNTIFS関数だけで済む話なんじゃないかと。 http://www.becoolusers.com/excel/countifs.html =COUNTIFS(A2:A50,"yamada10x",B2:B50,"Grp1") これでyamada10xのGrp1の件数合計が出てきますが？
＞どのような動作をするのか試したいので、その方法を教えていただいてもよろしいですか？ １．システムの「復元ポイントの作成」で、適当な復元ポイントを作成する。 ２．インストールしないと正常動作しない、何かのアプリケーションを適当にインストールする。 ３．「システムの復元」で、１．の手順で作成しておいた「復元ポイント」に戻す。 ４．システムが復元されたら、２．の手順でインストールしたアプリケーションがインストールされたままの状態かどうか「プログラムの追加と削除」で確かめてみる。 ５．インストールした筈の場所にあるアプリケーションを起動してみる（インストールされてない状態なので正常動作しない筈） ６．アンインストール処理をしていなくても、アンインストールされたのと同じ状態になっている事を思い知る。
＞そのため、タスクマネージャーの”プロセスの終了”でもそのアプリが終了しないようにしたいのですがそれは可能でしょうか？ 不可能。 だけど「終了させようとすると、自分自身をもう一つ起動させてから終了する」って言うアプリは書ける。 書けるけど、それやると「Windowsがシャットダウンできなくなる」ので、やらない方が良い。
こんにちは。 mac互換といわれると、最近の事情はまったく知らないのですが、 とりあえず３例挙げてみます。 ところで、投稿用に便宜的に書き換えた？のでしょうけれど、 > STAR_TIME = Cells(0, STAR_CL)　　　'出勤時間の行です Cells の rowindex に 0 を指定するのは （相対参照で書く場合以外は）失敗しますから、 便宜的に、変数 i に置き換えて提示します。 IF ... ElseIf ... Else ... End If で書いていると後から見ても条件分岐が解り難そうですから、 一般的な、Select Case ... Case ... End Select で書いてみます。 勤務時間と比較する時間値は、色々な書き方がありますが、 やはり読み易さ重視で、TimeValue()関数で書きます。 出力値は、"0:45"のように文字列の直値でもＯＫなので、 これも読み易いものを選びます。 時刻を出力するのにDate型を出力する場合は必ず 書式の表示形式を設定しておかなければなりませんから、 時刻値の出力は文字列値の方が却ってバリアントです。 ご提示された（抜粋された）記述を読む限りは、 With フレーズ を使う必然性が低いので、 こちらでは、新規の変数として、休憩時間を指す myRecess に一旦格納してから、この変数値をセル出力するように （他の記述での変数の扱い方に合わせるように）書いています。 とりあえず、普通な感じで。 ' ' /// Dim myRecess As Variant Dim i As Long ' ... 　　STAR_TIME = Cells(i, STAR_CL)　'　出勤時間 　　LAST_TIME = Cells(i, LAST_CL)　'　退勤時間 　　myTime = LAST_TIME - STAR_TIME　'　休憩時間 　　Select Case myTime 　　Case Is >= TimeValue("8:00")　'　８ 時間以上で休憩時間は1時間 　　　　myRecess = "1:00" 　　Case Is >= TimeValue("6:00")　'　６ 時間以上8時間未満で休憩時間45分 　　　　myRecess = "0:45" 　　Case Is >= TimeValue("4:00")　'　４ 時間以上6時間未満で休憩時間30分 　　　　myRecess = "0:30" 　　Case Else　'　４ 時間未満で休憩時間０分 　　　　myRecess = "0:00" ' 　　End Select 　　Cells(i, RECESS_CL) = myRecess ' ... ' ' /// ここに書かれていない他の記述での条件さえ合えば、 Hour(myTime) 時刻値の"時"だけを比較する方法もあります。 別段コメントを付加しなくても意味が呑み込み易いという意味で ビギナー向き、の書き方です。 ' ' /// Dim myRecess As Variant Dim i As Long ' ... 　　STAR_TIME = Cells(i, STAR_CL)　'　出勤時間 　　LAST_TIME = Cells(i, LAST_CL)　'　退勤時間 　　myTime = LAST_TIME - STAR_TIME　'　休憩時間 　　Select Case Hour(myTime) 　　Case Is >= 8　'　８ 時間以上で休憩時間は1時間 　　　　myRecess = "1:00" 　　Case 6 To 8　'　６ 時間以上8時間未満で休憩時間45分 　　　　myRecess = "0:45" 　　Case 4 To 6　'　４ 時間以上6時間未満で休憩時間30分 　　　　myRecess = "0:30" 　　Case Else　'　４ 時間未満で休憩時間０分 　　　　myRecess = "0:00" ' 　　End Select 　　Cells(i, RECESS_CL) = myRecess ' ... ' ' /// また、Switch()を知っている人なら、以下のようなシンプルな書き方 の方が解り易く馴染み易い、という場合もあるでしょうから、 一応挙げておきますが、 実質４行という短い記述にはなるものの、慣れていない人には扱い難いですね。 ' ' /// Dim i As Long ' ... 　　STAR_TIME = Cells(i, STAR_CL)　'　出勤時間 　　LAST_TIME = Cells(i, LAST_CL)　'　退勤時間 　　myTime = LAST_TIME - STAR_TIME　'　休憩時間 　　Cells(i, RECESS_CL) = Switch(myTime >= TimeValue("8:00"), "1:00", _ 　　　　　　　　　　　　　　　　　　myTime >= TimeValue("6:00"), "0:45", _ 　　　　　　　　　　　　　　　　　　myTime >= TimeValue("4:00"), "0:30", _ 　　　　　　　　　　　　　　　　　　myTime >= 0, "0:00") ' ... ' ' /// > このあと勤務時間の集計も行なう為、時間の計算方法なども教えて頂けると助かります。 教室ではないのでスキルアップ講座的に授けることは、時間的・空間的に無理です。 逆に教室で教わるにしても、実例に則して学ぶのが易しく効率的ですから、 解らなかったことを都度都度、訊ねるようにした方が、 身に付くと思いますし、未然に混乱を避ける意味もあるかと思います。 とりあえず、以上です。
> (2)Range("A1:C5,E1:G5") ⇒　？？？ Union(Range(Cells(1, 1), Cells(5, 3)), Range(Cells(1, 5), Cells(5, 7))) でいかがでしょう。
一例ですが Sub kigoumade() Range("DK30").Activate Do Until ActiveCell.Value = "※※" Range("BR" & ActiveCell.Row & ":EE" & ActiveCell.Row).UnMerge Range("BR" & ActiveCell.Row & ":EE" & ActiveCell.Row).Clear ActiveCell.Offset(1).Activate Loop End Sub では如何でしょうか。
> お恥ずかしい話ですが，記述は，ネットのものを参考にしたものでありあまり理解できていません。 ファイルの最後まで7個ずつデータを読み込んでおるわけですが、データが15個だった場合、最後に1個しかデータがないのに7個読もうとしてエラーになります。 > もし，可能でしたら具体的な記述をご教示いただけないかと思います。 CSVファイルの中身がどうなっているのかわからないので以下の変更で正しく動くかどうかは不明ですが 2番目に回答した http://www.moug.net/tech/exvba/0060086.html を参考にして Line Input を利用した例です。 Dim X(1 To 7) As Variant ' 読み込んだレコード内容 ' (1) ↓変更 Dim X As Variant ' 読み込んだレコード内容 ' (1) 追加 Dim buf As String コードのこの部分を レコードを読み込む(このサンプルは7項目のCSV) Input #intFF, X(1), X(2), X(3), X(4), X(5), X(6), X(7) ' (2) ' 行を加算しA～G列にレコード内容を表示(先頭は2行目) GYO = GYO + 1 Range(Cells(GYO, 1), Cells(GYO, 7)).Value = X ' 配列渡し ' (3) Loop 以下に変更します。 ' レコードを読み込む Line Input #intFF, buf X = Split(buf, ",") ' 行を加算しA～G列にレコード内容を表示(先頭は2行目) GYO = GYO + 1 Range(Cells(GYO, 1), Cells(GYO, UBound(X) + 1)).Value = X ' 配列渡し ' (3) Loop ActiveSheet.UsedRange.Value = ActiveSheet.UsedRange.Value
＞その稼働しない動作はデバイスの状態変更(有効から無効)にする動作です。 デバイスに停止命令を送っているAPI関数から、どういう戻り値が返って来るか表示してみましょう。 「デバイスに対するアクセス権なし」とか「デバイスに対するファンクション番号エラー」とか、色々なエラーが返されている可能性があります。 それ以前に、API関数が正常終了したかエラー終了したかくらいは調べましょう。 あと、もしかしたら「無効化しても、勝手にすぐに有効化しちゃってる」と言う可能性も捨て切れませんし、そもそも「無効化できないデバイス」なのかも。
http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.php?topic=14093&forum=7 もしこのような状況で、プロシージャ名が全角であることが起因し、プロシージャ名の 変更が行えないなら、別プロシージャを作成してラップすればいいと思います。 また、こちらのように、プロシージャ名にパラメータまで設定しているなら外してください。 http://otn.oracle.co.jp/forum/message.jspa?messageID=28015837&#28015837
CSVのデータは960行640列あるんですよね？ 以下の解釈ですと、 それを1行目は項目行として614401行（960×640+1行）×3列（A～C列）に出力します。 残念ながら、ご提示のコードでは目的を果たしておりません。 CSVのデータをbufに読み込んだ後、tmpに1行ずつ格納してから 格納した1行分のデータをsplitで列に分解する必要があります。 標準モジュールに以下のコードを貼り付けて コード内の「CSVのファイルパス」を適切に変更してください。 出力先のシートを選択してから、マクロ「並び替え」を実行してください。 （614401×3=1843203セルのデータを書出すため、時間がかかります） 最下のマクロ「並べ替え2」は1行分のデータを丸ごと配列変数に格納して、 1行分のデータ（1920セル）を出力時にセル範囲へ配列を書出しますので処理速度が向上しています。 このように毎回セルへデータを書出さず、配列で処理を行った後 出力をまとめてすることで処理速度を上げることが出来ますので試行錯誤してみてください。 参考：『VBA高速化テクニック』 http://officetanaka.net/Excel/vba/speed/index.htm ■VBAコード Sub 並べ替え() Dim i As Long, j As Long, m As Long Dim buf As String, tmp As Variant '出力先の行番号初期値 i = 1 '1行目（項目）を出力 Range("A1:C1") = Array("X", "Y", "Z") Exit Sub 'CSVをテキストデータとして読込 Open "CSVのファイルパス" For Input As #1 '画面の更新停止 Application.ScreenUpdating = False 'データ終末まで繰り返し Do Until EOF(1) 　　'CSVから1行読込 　　Line Input #1, buf 　　'読み込んだ行分のデータを「,」カンマで列に分割 　　tmp = Split(buf, ",") 　　'CSVの行番号をカウントアップ 　　i = i + 1 　　'列の数だけ繰り返し 　　For j = 0 To UBound(tmp) 　　　　'出力行をカウントアップ 　　　　m = m + 1 　　　　'データを出力 　　　　Cells(m, 1) = i 　　　　Cells(m, 2) = j + 1 　　　　Cells(m, 3) = tmp(j) 　　Next j 　　'進行度合いを表示 　　If i Mod 5 = 0 Then Application.StatusBar = i & "行分を出力中": DoEvents Loop Close #1 '画面を更新 Application.ScreenUpdating = True End Sub ■VBAコード（速度向上版） Sub 並べ替え2() Dim i As Long, j As Long, m As Long Dim buf As String, tmp As Variant Dim myData() As String '1行目（項目）を出力 Range("A1:C1") = Array("X", "Y", "Z") 'CSVをテキストデータとして読込 Open "CSVのファイルパス" For Input As #1 '画面の更新停止 Application.ScreenUpdating = False 'データ終末まで繰り返し Do Until EOF(1) 　　'CSVから1行読込 　　Line Input #1, buf 　　'読み込んだ行分のデータを「,」カンマで列に分割 　　tmp = Split(buf, ",") 　　'CSVの行番号をカウントアップ 　　i = i + 1 　　Erase myData 　　ReDim myData(UBound(tmp), 2) 　　'列の数だけ繰り返し 　　For j = 0 To UBound(tmp) 　　　　'出力行をカウントアップ 　　　　m = m + 1 　　　　'データを配列に格納 　　　　myData(j, 0) = i 　　　　myData(j, 1) = j + 1 　　　　myData(j, 2) = tmp(j) 　　Next j 　　'格納したデータを最終行に追加出力 　　With Cells(Rows.Count, "A").End(xlUp) 　　　　Range(.Offset(1, 0), .Offset(UBound(tmp) + 1, 2)) = myData 　　End With 　　'進行度合いを表示 　　If i Mod 5 = 0 Then Application.StatusBar = i & "行分を出力中": DoEvents Loop Close #1 '画面を更新 Application.ScreenUpdating = True End Sub
もともとB列に旧商品名があってそれをC列に代入してB列の旧商品を新商品に変換するという動作でしたら たとえば Range("C" & i).Value=Range("B" & i).Value と必要な分だけループか検索かで代入しておいて あとは B列の商品名をreplaceで書き換えたらいかがでしょう。 > また、VBAについて初心者向けにわかりやすく解説しているサイト エクセル vbaで検索したら色々出てきますのでご自身にあったページを参考にしてみてください。 たとえば http://www.eurus.dti.ne.jp/~yoneyama/Excel/vba/ とか http://officetanaka.net/ とか http://www.happy2-island.com/excelsmile/ などいかがでしょう。 基本的に「エクセル vba やりたいこと(たとえばファイルを開くとか)」で検索すると解説しているページが結果として出てきますので、その中で分かりやすいページを見つけるのもいいかと思います。
http://www.atmarkit.co.jp/fdotnet/dotnettips/1055ilspy/ilspy.html http://build.sharpdevelop.net/BuildArtefacts/#ILSpyMaster デバッグビルドのexeなら、コメントも戻ると思います。
この↓コードの意味を理解せずに適当に使っているように思えます。 Day(DateSerial(Year(Date), Month(Date), 31)) このコードは本日（2014/9/25）に動かした場合、2014/9/31の日を求めています。 ただ、9月は30日まで有りませんから、求められるのは2014/10/1の日、つまり1になります。 セルBW28の数値をそのまま使いたいなら以下の様なコードで良いでしょう。 Sub sersusentaku() 　　If (Range("BW28") >= 28) And (Range("BW28") <= 31) Then 　　　　Range("B30").Resize(Range("BW28"), 66).Select 　　End If End Sub
タイミングの問題じゃないかな？ デバッグしながらステップ実行していると、プログラムは「非常にゆっくりと動作」します。 どこかの処理で「ある命令を実行してから、次の命令を受け付け可能になるまで、待ち合わせが必要」だった場合、ステップ実行していれば「充分な待ち合わせ時間が確保される」ので正常に動作します。 しかし、上記のような状況で、アプリモードで「一気に待ち合わせ時間なしで実行してしまう」と、必要な待ち合わせ時間が確保されず、どこかの命令がエラーになってしまいます。 たぶん「デバイスに対して命令を発行したあと、その結果を受け取ってない」とか「受け取った結果によって待ち合わせしないといけないのを待ってない」とか、そういう「タイミングの問題」だろうと思います。
> 税率も表示させたいのですがどうすればいいでしょうか。 書き出し部分を変更します。 税率は、配列argの４列目、つまりarg(x,4）に格納しています。 ただし、大小比較のために無税は０（ゼロ）値として格納していますので、「無税」表示とするなら書き出しの時に戻す必要があります。 ～～～ 　　While　arg(aln,　1)　>　0 　　　　Cells(30　+　aln,　1)　=　arg(aln,　1) 　　　　Cells(30　+　aln,　2)　=　arg(aln,　3) 　　　　If　（arg(aln,　4)＝0）　then　　　　　　　'//ここから税率の書き出し 　　　　　Cells(30　+　aln,　3)　=　"無税"　　　'　値が0％の時に無税に変換する。 　　　　Else 　　　　　Cells(30　+　aln,　3)　=　arg(aln,　4)　　'　税率数値を書き出す。 　　　　End If　　　　　　　　　　　　　　　　　　　　'ここまで//　　 　　　　Cells(30　+　aln,　4)　=　arg(aln,　5) 　　　　Cells(30　+　aln,　5)　=　arg(aln,　6) 　　　　aln　=　aln　+　1 　　Wend ～～～ なお、 　Cells(30　+　aln,　□) の□部分は、回答4の通り、結合セルの先頭列にあわせて変更ください。　
> なので、終わった工事の行を選択し、1クリックで塗りつぶすボタンを作りたいのです。 選択した範囲 = Selection 選択した範囲の行 = Selection.EntireRow 選択した範囲の行 の A:N = Range("A:N (" & Selection.EntireRow.Address(0, 0) & ")") Sub Re8762667od() Dim c As Range 　　If TypeName(Selection) <> "Range" Then Exit Sub 　　For Each c In Range("A:N (" & Selection.EntireRow.Address(0, 0) & ")") 　　　　If c.MergeArea(1).Interior.ColorIndex = xlColorIndexNone Then 　　　　　　c.MergeArea.Interior.Color = 16777164 　　　　End If 　　Next End Sub > なので、終わった工事の行を選択し、1クリックで塗りつぶすボタンを作りたいのです。 > この黄色のセルだけ塗りつぶさず、他のセルを塗りつぶしたいのです。 黄色 = 65535 = vbYellow Sub Re8762667od2() Dim c As Range 　　If TypeName(Selection) <> "Range" Then Exit Sub 　　For Each c In Range("A:N (" & Selection.EntireRow.Address(0, 0) & ")") 　　　　If c.MergeArea(1).Interior.Color <> vbYellow Then 　　　　　　c.MergeArea.Interior.Color = 16777164 　　　　End If 　　Next End Sub
ここは [技術者向] コンピューター > プログラミング > Visual Basic というカテゴリなので，それに沿って回答します。 System.IO.File.StreamWriterのコンストラクタの第一引数にファイル名を指定できるので， そこに"○○.sql"と指定するだけでよいです。 ref) http://msdn.microsoft.com/ja-jp/library/fysy0a4b(v=vs.110).aspx このコンストラクタ自体はBCLに存在するようなので， CLIの実装がCLR (.NET Framework)でなく，例えばmonoであっても存在します。 ref) http://docs.go-mono.com/?link=C%3aSystem.IO.StreamWriter.StreamWriter(System.String)
フォームアプリケーションをサービスに登録することはできません。 ログインしていない状態でも動作させたいなら、タスクスケジューラーに『スタートアップ時』で登録すればいいかもしれません。 http://ameblo.jp/parallel-line/entry-11071840143.html ログインした際にということならば、ログインユーザーのスタートアップにショートカットを入れておけば済むでしょう。 Windows7の場合、対象フォルダは以下です。(すべてのプログラム→スタートアップに、ショートカットをドラッグしてもいいですが) C:\Users\ユーザー名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
こんばんは！ 横からお邪魔します。 ＞D2-H2,D5-H5,D8-H8などのもともとA-CのとなりにあったセルデータをれぞれのセルA-Dに500人分動かすのが最終目標ですが、 ＞一括で3行飛びで移動させるための・・・ 結局2・5・8・・・行目のA～C列データを削除してその行の残りのデータを左詰めにすれば良いのでしょうか？ そうであれば↓のコードを試してみてください。 Sub Sample1() Dim i As Long Application.ScreenUpdating = False For i = 2 To 501 Step 3 Cells(i, "A").Resize(, 3).Delete shift:=xlToLeft Next i Application.ScreenUpdating = True End Sub こんな感じをご希望だったのでしょうかね？m(_ _)m
すでに曲が取り込まれていて どれかの曲が選択または再生または一時停止しているときに userformを閉じると何番目かを取得（表示）します。 　（リスト中の曲名を再生中の曲名で検索しています。） 　（エラー処理してありません） Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer) Dim i As Long, nm As String, lstct As Long, lstnum As Long lstct = Me.WindowsMediaPlayer1.currentPlaylist.Count nm = Me.WindowsMediaPlayer1.currentMedia.Name For i = 0 To lstct - 1 If nm = Me.WindowsMediaPlayer1.currentPlaylist.Item(i).Name Then lstnum = i End If Next MsgBox lstnum + 1 & "番目" End Sub
こんにちは。 > セルに色がついています 条件付き書式での、背景色の塗りつぶし、のことですね。 Excelのバージョンが2010以降であれば、 かなり簡単に出来ます。 Sub Re8753545() Dim c As Range 　　For Each c In Range("A2:G6") 　　　　If c.DisplayFormat.Interior.ColorIndex <> xlColorIndexNone Then 　　　　　　c.Value = Empty 　　　　End If 　　Next End Sub 但し、見た目に色が付いていないようでも、実は白く塗り潰している、 なんて場合も、"色のついたセル"と看做すよりありませんから、注意が必要です。 もし、Excelのバージョンが上記に該当しない場合は、 各バージョンごとにそれぞれ対応が異なりますし、非常に複雑になります。 なので、少し考え方を変えた方が汎用的にうまくいくと思います。 例示が具体的・現実的なものであれば、 １列め（A1:G1）をループして、セルの値が"土"または"日"ならば、 そのセルのひとつ下から、５行分の範囲の値をクリアする、 という方法でも、同じ結果が得られます。 Sub Re8753545c() Dim c As Range 　　For Each c In Range("A1:G1") 　　　　If c.Value Like "*[土日]*" Then 　　　　　　c.Offset(1).Resize(5).ClearContents 　　　　End If 　　Next End Sub 他にも方法はありますが、 このように、直接的に条件判別する方がＶＢＡとしては正当なアプローチですし、 上に書いたような但し書きも無用になります。
バッチで、 @echo off (for /f "tokens=1,2 delims=," %%A in (input.txt) do call :sub %%A %%B)>out.txt goto :EOF :sub for /f "tokens=1,2 delims=-" %%C in ("%~1") do set C=%%C&set D=%%D echo %D:~0,1%,%C%,%D:~1,1%,%~2 goto :EOF
紹介したスレに進展があった様です。 Navigateメソッドの前後にVisibleプロパティを挟むそうです。
環境変数の名前を調べて一致した場合に値を取り出します。 Sub Sample() 　　Dim myFol As String 　　Dim environmentString As String 　　Dim i As Long 　　Dim hit As Integer 　　i = 1 　　Do 　　　　environmentString = Environ(i) 　　　　hit = InStr(1, UCase(environmentString), "=") 　　　　If Left(UCase(environmentString), hit - 1) = "HOME" Then 　　　　　　myFol = Mid(environmentString, hit, Len(environmentString)) 　　　　　　Exit Do 　　　　End If 　　　　i = i + 1 　　Loop Until Environ(i) = "" 　　Shell "C:\Windows\Explorer.exe " & myFol, vbNormalFocus End Sub
＃２-３、ｃｊです。＃２お礼欄拝見しました。 > アドオンで、設定セル（5個ほど）にネット経由でデータの変更が有るたびに送り込まれます。 お返事頂いてありがとうございます。 そういうことなら、理解できます。 ただ、それはそれで、"普通"ではない"特殊"な条件な訳ですから、 "セル式の計算"という簡単な説明で済まされるものではないですし、 当初の質問文から、明示しておいた方が、より有用な回答が得られ易かったのだと思います。 まぁ、なんとなくDDE絡みの話かも？とか想像できなくもなかったのですが。 とりあえず、 Worksheet_Calculate と Application_AfterCalculate との違いは ヘルプで確認してみてください。 これが役に立つかどうか、こちらでは未確認ですが、 ＃２-３で、役に立つことがもしあるとすれば、_AfterCalculate とリンクを張ったページぐらい だと思います。 テスト環境を整えて、きちんとレスしようと思ったのですが、 株価RSSは私の環境（Excel2010x64）で使えるものがない（あるにはあるけど他の理由でNG） ので、断念しました。 １、２年前にRSSに同期をとるVBAサンプルコードが紹介された書籍が出ていたように思いますが、書名が思い出せません。 たぶん、情報をお持ちの方は多数いらっしゃる筈ですから、 要件を整理して、質問建て直した方が、解決が近づくかも知れませんね。 RSSの具体名をタイトルにも掲げるとかして、重要度の高い情報（条件）が 目立つように質問すれば、いいことあるかも、です。 OnTime メソッドについての現状説明については、正直、よく解りませんでした。 あらためて考えてみましたが、 OnTime メソッドって、 １．予定した時刻に指定のプロシージャを実行する。 ２．待機中のキューを先に実行させる。（＃２での説明主旨） ３．非同期処理との連携で時刻が過ぎたら処理をキャンセルする という使い方がメインなんだと思います。 この内、関連ありそうなのは２.３．ですが、 非同期・同期を問わず、外部オブジェクトを扱う際には、決定的な解決策になる場合も多いので、 この際、色々試してみるのも、無駄になることはないと思います。 ただ、RSSの処理の完了のタイミングをとったり、ワークシートの再計算終了のタイミングをとったり、 ということには、やはり役には立たないかな、とは思います。 あらためて、返信ありがとうございました。 解決に届くことを、そして、ご健闘をお祈りいたします。
http://oshiete.goo.ne.jp/qa/8750372.html 例えば、30ファイルあっても10ファイルしか読み込まれない事があり、 エラーメッセージもない、何事もなく終了するが10ファイルしか処理されていない、 常に発生する訳ではなく、マシンが変われば同じデータでもOKだったり、 データが少し変わればOKだったりする。 なので、昨日までOKだったのに、今日データが変わった為、急にダメになったりする。 もし、10ファイル目で発生した場合、何度実行しても必ず、10ファイル目までしか処理されない。 そのファイルがおかしいかと思い、その前後の2～3ファイルを削除しても、 やっぱり、10ファイル目（さっきとは違うファイル）までしか処理されない、 という恐ろしいバグがExcel VBAにありますが、それじゃないですかね？ While文などのループの中に、ワークブックのオープンがあると、 何度目かでオープンが実行されず、エラーなしでスルンと終わります。 回避方法は、Open 文の前に　DoEvets　の１行を書く事。 だいたいこれで直りますが、これで直らなかったマクロもあったので、 Open 文の後ろにも　DoEvets　の１行を書いて、前後を　DoEvets　ではさむと直りました。 安全（？）の為、前後をはさんでおいた方が良いと思います。 こんな感じ： DoEvents Workbooks.Open aaa DoEvents かなり前（１年くらい？）にハマりググりまくったところ、ほとんど情報はなかったですが、 １人だけ、自分の質問に「直った」と自己回答している方がいて、Open文の前にDoEvetsをつけたら直ったそうです。 半信半疑で真似たら私も直りました。 何故、これで直るのかはわかりませんが、DoEvetsを外すと見事に再現し、DoEvetsではさむとピタッと直ります。 ググりまくった際、とても情報が少なく、こんなに顕著に再現するのに、 何故、情報が少ないのかは不思議に思いました。
＃１です > While(Not rs.EOF) > 　　rsTo.AddNew > 　　rsTo!SBN = rs!SBN > 　　・・・ > 　　rsTo.Update > 　　rs.MoveNext > Wend ここのところの rsTo は、AddNew / Update しかしていないので DAO / ADO 区別ありません。 Dim rsTo As DAO.Recordset と記述して、メニューの「デバッグ」→「コンパイル」してみて エラーにならなければ、DAO が使えます。（以下雰囲気） Set rs = adoCON.Execute(sqlstr) CurrentDb.Execute "DELETE FROM SAMPLE_T;" Set rsTo = CurrentDb.OpenRecordset("SAMPLE_T") While (Not rs.EOF) 　　rsTo.AddNew 　　rsTo!SBN = rs!SBN 　　・・・ 　　rsTo.Update 　　rs.MoveNext Wend rs.Close rsTo.Close また、 Dim rsTo As New ADODB.Recordset でコンパイルエラーでなければ ADO が使えます（以下雰囲気） Set rs = adoCON.Execute(sqlstr) CurrentProject.Connection.Execute "DELETE FROM SAMPLE_T;" rsTo.Open "SAMPLE_T", CurrentProject.Connection, adOpenForwardOnly, adLockOptimistic While (Not rs.EOF) 　　rsTo.AddNew 　　rsTo!SBN = rs!SBN 　　・・・ 　　rsTo.Update 　　rs.MoveNext Wend rs.Close rsTo.Close ※ コンパイルエラーでも、使いたいのであれば、参照設定で追加すれば良いと思います ※ 参照設定しなくても、質問者さんの様に（チョッと修正） Dim cn As Object Dim rsTO As Object Set cn = CurrentProject.Connection Set rsTO = CreateObject("ADODB.Recordset") rsTO.Open "SAMPLE_T", cn, adOpenForwardOnly, adLockOptimistic　' ★ Object 宣言しておいて、CreateObject("ADODB.Recordset") することでも同じなのですが adOpenForwardOnly　とか　adLockOptimistic　の様な定数部分の記述で苦労すると思います。 Dim rsTO As ADODB.Recordset としておけば、 Set rsTO = CreateObject("ADODB.Recordset") ↓部分は、 Set rsTO = New ADODB.Recordset で良いですし、 Dim rsTO As New ADODB.Recordset としておけば、Set rsTO =　・・・　自体不要です
データベースがutf8で、クエリーがvbaから投げるからunicodeになっているせいかな？ まずはこれを自分で試してから質問したら良いと思います。
社内で出来る人が居ないなら、この機会に勉強してはどうですか？私もプログラマではなく、仕事上の必要から勉強した片手間VBAです。1年位ですよ。 ただし、手広くやり過ぎるとマクロ係みたいになって本業から外されるリスクがあるのでご注意を。
日付から曜日を取得する(WEEKDAY) http://www.officepro.jp/excelfunc/date/index9.html を使って計算します。A1に元の金額があるとしたら Range("J" & NewDataRow)..Formula = "=IF(WEEKDAY($E1,1)=4,A1*0.9,A1)"
まず，MySqlConnectionStringBuilderはMySqlConnectionで利用するためのConnectionStringを， 各種プロパティを設定することで作っていくためのクラスです。 そして，PropertyGridは，対話的にインスタンスのプロパティを設定していくことができるコントロールです。 今回のものは，これらを組み合わせて，ConnectionStringを対話的に作成するためのものになります。 Server, User Id, Passwordなどを入力して，対象サーバーに接続できる文字列を作って， 間違いの無いConnectionStringを作れるかどうか確認してみるのが目的です。 ただ，何度も書いていますが，CLI，つまりはmysqlコマンドから接続できていますか。 先にも書きましたが，エラーメッセージが出る状況は， サーバーが存在しなかったり，ファイアウォールで接続を拒否された時のものです。 MySqlConnectionで接続する前に，mysqlコマンドで接続できることを確認した方がよいですよ。
それなら、こういう手があります。 まず、個人レコードに「処理済みフラグ」列を確保します。 次に、年1回処理の初めに「処理済みフラグ」にフラグが立って いれば、処理をスキップするコードを入れ、スキップせずに処理 に入った場合の最後に「処理済み」フラグを立てます。 最後に「年1回処理の走った翌日以降のいつか」に「処理済み フラグを外す処理」を入れます。 こうすれば、年1回処理は「その日1回だけ」しか走りません。 日付で処理を走らせるプログラミング能力があるなら、この程度 の処理は簡単ですよね。要は起動回数に関係なく参照できる シート上に、フラグを作ってしまうことで何とかするわけです。 ちなみにこの「フラグ」、工夫次第で「その処理専用のエリア」に 確保することも（例えば個人コードとセットで持たせるとか）可能 だと思いますよ。
こんにちは。 ご提示のサンプルですが、当方のVBA7x64環境でも （実行の度に無条件で必ず）Excelの異常終了を再現できました。 この問題の解決については、私の力量を越えていますので、 情報提供、という形でお応えします。 『APPS PRO > VBA Tips > How Can I Locate a Specific Child Window Handle?』 http://www.appspro.com/Tips/VBA%20Tips.htm こちらのページの一番下の[EnumChildWindows]をクリックすると x32|x64両方対応のサンプルコードが入手できます。 そのままこちらで試してみた処、 （このサンプルは、ThisWorkbook.Windows(1)のハンドル'だけ'を取得するものなので） エラーにはなりませんでした。 コールバック関数側で、条件分岐を書き換えてみたり、 無条件でWindowClassやWindowTitleを取得するよう試みたりして、 約30（重複を含む）の子ウィンドウのウィンドウハンドルが取得出来る所までは確認しましたが、 すべてを取得出来ていないか、うまく終了させることが出来ていないか、どちらかで、 完全な動作を確認するには至りませんでした。 デバッグのヒントにはなりそうな気はしますので、サンプル試してみては如何でしょう。 もしうまく行く方法があるとすれば、 WindowClassとWindowTitleでの条件分岐を整理して、 適切に列挙を終了させることになるような気がしています。 例えばThisWorkbook.Windows(1)のWindowClassとWindowTitleが確認できたら、 （そこから数えてx番目の子ウィンドウで、、、x = 0 かも？） コールバック関数の戻りを0にして列挙を終了する、、、、みたいな？ 或いは、特定の子ウィンドウに限定できるなら、同様にうまく扱えるようにも思えます。 実践的には、同じハンドルが重複して戻る場合があることを考慮して、 ハンドル列挙の受け皿としてCollectionオブジェクト等を用いることになるかと思いますが、 もしかしたら、この戻り値の重複についてもチェックしてみた方がいいのかも？？知れません。 参考になるか解りませんが、以上です。
> エラーの内容： 公開メンバー 'btn' は型 'HTMLFormElementClass' に見つかりませんでした btnというClassは標準では持っていないと思いますが、ご自分で作られたのでしょうか。 そうだとしますと、目的のサイトの方でbtnというIDが変更されたのではないでしょうか。
こんにちは。 > ブックを開くコマンド > × Workbooks("filename.xls").open > ○ Workbooks.open filename:="filename.xls" > 何故下なのですか？ > ワークブックコレクションの中から特定のブックを指定し開くなら、 > 上の構文にした方がワークシートコレクション等と構文表現を統一出来ます。 > 現にブックを閉じるコマンドは > Workbooks("filename.xls").close > です。何故ブックを開くコマンドだけ別表現なのですか？ <以上、改行は筆者。> まず、ヘルプの引用ですが、 その前に、Parentを省略せずに書くと、 Excel.Application.Workbooks.Open Filename:="filename.xls" だという点を確認しておいてください。 ｜Application.Workbooks プロパティ ｜開かれているすべてのブックを表す Workbooks コレクションを返します。値の取得のみ可能です。 <以上、VBAのヘルプより。> 一般論として、コレクションというのは、実体を持ったオブジェクトの集合体です。 "filename.xls"はWorkbookの設計図を収めたファイルとしてのみ存在している訳ですから、 開いてこそ実体を持ったWorkbook オブジェクトとなり得ます。 つまりブックとして開くまではWorkbooks コレクションに加えることは出来ません。 また、 開いていないブック＝Workbooks コレクションに存在しないブック を、Workbooks("filename.xls"). ...のように参照しようとしても当然実行時エラーになります。 Worksheets("sheetname"). ...のように存在しないワークシートを参照しようとしても同様です。 > 上の構文にした方がワークシートコレクション等と構文表現を統一出来ます。< 再掲 違いは、ブックを開いた時に連動して配下のシートは実体を持つ、ということです。 Worksheets には.Open メソッドはあり得ませんし、.Close メソッドもないですよね。 解り難い説明になってしまっていたらすみません。 結構な長文を用意したのですが、クドクなったので要約を上げました。 以上です。
動作確認が出来ない状況ですみません。とりあえず書きました。 Sub Macro1() Dim i As Long Dim myPath As String, Flnm As String ReDim Flnmfp(0) As String Dim WS1 As worksheet Set WS1=ThisWorkbook.sheets("sheet1") myPath="望みのフォルダパスを入力" Call fpFileName(myPath, Flnmfp ) 'フォルダ内のファイル名取得 If Ubound(Flnmfp)=0 Then 'フォルダにファイルが無ければ終了 Exit Sub End if For i =1 to Ubound(Flnmfp) Workbooks.open filename := Flnmfp(i) Flnm=Dir(Flnmfp(i)) With Workbooks(Flnm).sheets("sheet1") WS1.Cells(2, i).value=.Range("G5").value WS1.Cells(3, i).value=.Range("G6").value WS1.Cells(4, i).value=.Range("K7").value WS1.Cells(5, i).value=CStr(.Range("G9").value) & CStr(.Range("N9").value) & CStr(.Range("P9").value) '同じ要領で望みのセルを記入する WS1.Cells(8, i).value=Flnm End with Workbooks(Flnm).close Savechanges:=False Next i End Sub Sub fpFileName(ByVal myPath As String, ByRef Flnmfp() As String) 'サブフォルダも含め全部のxlsファイル名をフルパスで取得する 　　Dim cnt As Long, buf As String, f As Object 　　buf = Dir(myPath & "\*.xls") 　　Do While buf <> "" 　　　　cnt = Ubound(Flnmfp) + 1 ReDim Presearve Flnmfp(cnt) 　　　　Flnmfp(cnt)= myPath & "\" & buf 　　　　buf = Dir() 　　Loop 　　With CreateObject("Scripting.FileSystemObject") 　　　　For Each f In .GetFolder(myPath).SubFolders 　　　　　　Call fpFileName(f.Path, Flnmfp) 　　　　Next f 　　End With End Sub
> EXCEPT_NAME = " 一覧 　種別　 基本" & Worksheets(Sheets.Count - 4).name & Worksheets(Sheets.Count - 5).name 「一覧」の前２ケなら-4と-5じゃなくて Worksheets(Sheets.Count - 3).name & Worksheets(Sheets.Count -4).name じゃないでしょうか。
BASICとVisual Basic では同じではありません。 BASICをベースとした言語のひとつが Visual Basic ととらえて頂けばいいかと思います。 Visual Basicで使用できる関数など、WordやExcelのVBAでは制限がいろいろあります。 Visual Basicを覚えたいのであれば、VS Expression 2013 for Desktopは必要になると思います。 目的が、VBAなのであれば、VBAに特化された本で勉強なさるのがいいように思います。 また、インターネットにも多くのQ&Aじょうほうがあります。 頑張ってください。
こんにちは。 ご提示のExcel数式は、そちらの望み通りに書けているものとして、 =IF(DATEDIF(E3,TODAY(),"Y")>80,"大型中止","OK") この数式を行のみ相対参照で列は絶対参照でしていしたい、ということだとすると、 VBAでは、 NewDataRow = Cells(Rows.Count, "J").End(xlUp).Row + 1 Range("J" & NewDataRow).FormulaR1C1Local = "=IF(DATEDIF(RC5,TODAY(),""Y"")>80,""大型中止"",""OK"")" のように設定します。
=INDIRECT("データ2!A"&COUNTA(データ2!A:A)) でいかが？
はい。その方法でできます。
こんにちは ＞Windows Updateの状況を取得したい との事でございますが、 http://technet.microsoft.com/ja-jp/scriptcenter/ff595215.aspx ↑こちらのWebページにございます。 「コンピュータの更新を確認する」という項目の情報は、いかがでしょうか? こちらのページにあるコードを、 私のExcel2003のVBAにそのままコピーして、動作いたしました。 他にも、 http://www.vbforums.com/showthread.php?615352-VB-NET-Windows-Updates http://blogs.technet.com/b/junichia/archive/2007/09/01/sce-wsus-2.aspx ↑こういったページも、参考になるかもしれませんので、 紹介させていただきます。 以上 ありがとうございました。
DebugモードとReleaseモードがあり、作られる実行ファイルに 違いがあります。また、モードに応じた実行ファイルしか 作成されません。 そして、このモードは[ソリューション構成] のダイアログなどで切り替える必要があります。 http://msdn.microsoft.com/ja-jp/library/wx0123s5.aspx
ソリューションのディレクトリ名は手作業で変更する必要があります。 というか， ・ソリューション名とソリューションのディレクトリ名 ・プロジェクト名とプロジェクトのディレクトリ名 には全く関連がありません。 ただし，プロジェクトのディレクトリ名を変更したい場合は， 一度プロジェクトをソリューションから外した上でディレクトリ名を変更し， 再度ソリューションに追加する必要があります。
補足です 表示　→　ツールバー　→　テキストエディター にチェックがはいってない場合はでてませんので チェックがはいってない場合はいれてください
・VS2012_WDX_JPN.iso 　一旦これをダウンロードすれば、あとはインターネットにつながっていない状態でもインストールできる。 　ただし、ダウンロードしたファイルを使ってインストールDVDを焼くか仮想ドライブにマウントしないといけない。 　また、インストールに必要になる可能性のあるデータがすべて含まれているためデータ量が多く、ダウンロードに時間がかかる。 ・wdexpress_full.exe 　インストールの設定とその実行だけをするプログラムで、インストールに必要なファイルはその都度ダウンロードしてくる。 　本当にインストールに必要なファイルだけをダウンロードするので上記よりデータ量が少なくなり、インストール時のダウンロード時間も短くなる。 　ただし、当然インストール時とコンポーネント修正時にインターネットにつながっている必要がある。 というわけで、ダウンロードに膨大な時間をかける無駄をとるか、インストール時やコンポーネント修正時にインターネットにつながなくてはならない制約をとるか、どちらかを選んでください。
変数をパブリック宣言しておいて 名前ではなく変数そのものを渡してあげれば。 Public AryVal() GET_FILE = wscript.scriptfullname '"sample.txt" SET objFs = CreateObject("Scripting.FileSystemObject") ' 動的配列セット Call Array_Set(AryVal,GET_FILE) ・・・以下は冒頭の質問と同じなので省略しました。
なんども追加ですいません。 coppertrucさんのコードを以下のようにすれば氏名と元のフリガナをリストシートのB列とC列に入力できます。 頭が固くて単純なことがひらめかなくて申し訳ないです。 Sub Example2() Dim h As Range Dim r As Long On Error Resume Next For Each h In Range("B2:K41").SpecialCells(xlCellTypeConstants) r = r + 1 Worksheets("リスト").Cells(r + 1, "B") = h Worksheets("リスト").Cells(r + 1, "c") = WorksheetFunction.Phonetic(h) Next End Sub
以下のようにIFで商品Cの場合とそれ以外を分岐してやればいけると思います。 If ActiveCell.Value=商品名Ｃ Then With Worksheets("sheet3") 各セルへデータのコピーのコード .Printout End With else With Worksheets("sheet2") .Range("A6").value=ActiveCell.Offset(0,0).Value .Range("D6").value=ActiveCell.Offset(0,1).Value .Range("G9").value=ActiveCell.Offset(0,2).Value .Range("J9").value=ActiveCell.Offset(0,3).Value .Printout End With End If
補足で何を質問されているのか読み取れなかったのですが。。。 実行ファイルと同じ場所にtaro.sdfを配置するように インストーラに登録すればいいのでは？ ただし、現段階で実行ファイルの場所が >c:\programFiles\taro\setup\ でない場合は、問題が２つ発生している可能性があります。 エラーメッセージに出てくるということは、どこかにそのパス が書いてあり、プログラムが使っているということですので。
質問文に書かれたとおり解釈しますと、 >Me.CheckBox1がNothingの状態 これはオフにする対象のチェックボックスがメモリ上に用意されていません。 エラーメッセージもその場合に出るものです。 なので、チェックボックスをオフにはできません。 もともとMe.CheckBox1というのは只の変数名です。コードを選択して 右クリックメニューから「定義へ移動(G)」を利用すると該当コードに 飛びます。この変数にInitializeComponent()という自動生成される 関数内でメモリ上に確保したCheckBoxクラスのインスタンス(実体)の 先頭アドレスを入れ、プログラムで使えるようにしています。 >Me.CheckBox1がNothingの状態 これは上記チェックボックスをプログラムで使えるようにする手順が できていない状態ですので、そもそも命令ができません。 デザイン画面で作成したものであれば、それ以降の何かの変更でコードが 欠損している可能性があるのでそれを直す必要がありますし、どこかから コピペして自前のコードに不備があるのであれば、上記ルールに従った コードを追加する必要があります。
こんなかんじでしょうか？ Sheet1など対象のシートを選択（複数選択可能）してから、 マクロ「印刷シート作成」を実行してください。 ダイアログが表示されますので「年/月/日 時:分」（「年/」は省略可） を入力してOKを押してください。 「印刷」シートが先頭に作成されます。 コード内の「設定」の箇所を変更することで、 ある程度フォーマットの変更に対応出来ます。 ■VBAコード Sub 印刷シート作成() Dim dt1 As Variant, dt2 As Variant, myCol() As Variant Dim i As Long, j As Integer, k As Integer Dim key() As Variant, flag As Integer Dim osn As String, mySelSht As String Dim tsht As Variant, cpcnt As Integer '///////////////設定////////////////////////////// key = Array("▲", "●") '除外記号を設定 myCol() = Array("B", "E") '登録日,住所の列記号を設定 osn = "印刷" '印刷シート名を設定 '///////////////////////////////////////////////// cpcnt = 2 '印刷シートの全削除 Application.ScreenUpdating = False Application.DisplayAlerts = False For k = Sheets.Count To 1 Step -1 　　If Sheets(k).Name = osn Then 　　　　Sheets(k).Delete 　　　　Exit For 　　End If Next k Application.DisplayAlerts = True '日付の入力 dt1 = InputBox("抽出範囲の日付を入力してください", "日付入力", "0/0 00:00") If dt1 = "" Then Exit Sub dt1 = DateSerial(Year(dt1), Month(dt1), Day(dt1)) + TimeSerial(Hour(dt1), Minute(dt1), 0) '選択中の対象シートを取得 For k = 1 To ActiveWindow.SelectedSheets.Count 　　mySelSht = mySelSht & ActiveWindow.SelectedSheets(k).Name & vbCrLf Next k tsht = Split(mySelSht, vbCrLf) '印刷シートを作成 Sheets(tsht(0)).Copy Before:=Sheets(1) With ActiveSheet 　　.Range(.Rows(2), .Rows(.Cells(Rows.Count, myCol(0)).End(xlUp).Row)).Delete 　　.Name = osn End With '各シートのコピー処理 For k = 0 To UBound(tsht) - 1 　　With Sheets(tsht(k)) 　　　　For i = 2 To .Cells(Rows.Count, myCol(0)).End(xlUp).Row 　　　　　　flag = 1 　　　　　　dt2 = .Cells(i, myCol(0)).Value 　　　　　　dt2 = DateSerial(Year(dt2), Month(dt2), Day(dt2)) + TimeSerial(Hour(dt2), Minute(dt2), 0) 　　　　　　For j = 0 To UBound(key) 　　　　　　　　If InStr(1, .Cells(i, myCol(1)), key(j)) > 0 Then 　　　　　　　　　　flag = 0 　　　　　　　　　　Exit For 　　　　　　　　End If 　　　　　　Next j 　　　　　　If dt1 >= dt2 And flag = 1 Then 　　　　　　　　.Rows(i).Copy Sheets(osn).Rows(cpcnt) 　　　　　　　　cpcnt = cpcnt + 1 　　　　　　End If 　　　　Next i 　　End With Next k Application.ScreenUpdating = True End Sub
ActiveWorkbookというのは「現在アクティブになっているワークブック」のことですから その時々によってアクティブなブックが選択されることになります。 そういう意味では相対的な指定ですね。 割り込みなんかが入ったり、開いたファイルがアクティブにならなかったりすると厄介ですね。 私ならこんな感じに。 ThisWorkbook.Sheets("Sheet3").Range(Cells(6, 3), Cells(lrow, 3)).Copy Workbooks(Dir(temp)).Sheets(1).Cells(6, 3) Dir(パス文字列) でファイル名のみを取得し、Workbooksの引数にすることで 既に開いているファイルのWorkbooksオブジェクトを取得します。
こんな感じでしょうかね。 秒の四捨五入は意図をくみ取れなかったので考えていません。 そちらで何とかしてください。 他の部分（日付をまたがる場合、再生時間を取得できないファイルの場合）は 多分、大丈夫かな？と。Windows7で簡単なテストは行いました。 Dim objParam Set objParam = WScript.Arguments 'D&Dでの読み込みを可能にする Dim objFS Set objFS = WScript.CreateObject("Scripting.FileSystemObject") ' 引数の全ファイルについてファイル名を変更する Dim objFile Dim dtRecordStart Dim i Dim newName For i = 0 To objParam.Count - 1 If objFs.FileExists(objParam(i)) Then Set objFile = objFS.getFile(objParam(i)) dtRecordStart = GetDuration(objParam(i)) 'ExtendedProperty用 'dtRecordStart = GetDuration2(objParam(i)) 'GetDetailsOf用 If dtRecordStart <> 0 Then dtRecordStart = objFile.DateLastModified - (dtRecordStart / 3600 / 24) newName = Right("0" & CStr(Hour(dtRecordStart)), 2) & Right("0" & CStr(Minute(dtRecordStart)), 2) objFile.Name = objFS.getBaseName(objFile) & "-" & newName & "." & objFS.getExtensionName(objFile) End If Set objFile = Nothing End If Next Set objFS = Nothing Set objParam = Nothing Function GetDuration(filePath) '再生時間の秒数を求めます Const FMTID_AudioSummaryInformation = "{64440490-4C8B-11D1-8B70-080036B11A03}" Dim objShell, objFolder, objItem Dim tmpStr tmpStr = Left(filePath, InStrRev(filePath, "\", -1, vbTextCompare)) '親フォルダを求めて Set objShell = CreateObject("Shell.Application") Set objFolder = objShell.Namespace(tmpStr) tmpStr = Mid(filePath, InStrRev(filePath, "\", -1, vbTextCompare) + 1) '拡張子を含めたファイル名のみを求めて For Each objItem In objFolder.Items If StrComp(objItem.Name, tmpStr, vbTextCompare) = 0 Then 'アイテムの名前とファイル名が同じなら GetDuration = CDbl(objItem.ExtendedProperty("Duration")) GetDuration = Int(GetDuration / 1000 / 1000 / 10) Exit For End If Next 'オブジェクトの解放未処理 End Function Function GetDuration2(filePath) Dim objShell Dim objFS, objFolder, objFile Dim tmpStr Set objShell = CreateObject("Shell.Application") Set objFS = CreateObject("Scripting.FileSystemObject") Set objFile = objFS.getFile(filePath) Set objFolder = objShell.Namespace(objFile.ParentFolder.Path) tmpStr = objFolder.GetDetailsOf(objFolder.ParseName(objFile.Name), 27) 'WindowsXPなら、27 → 21 If tmpStr = "" Then GetDuration2 = 0 Else GetDuration2 = CDbl(CDate(tmpStr) * 3600 * 24) '文字列型の時間を日付時刻型にしてから秒数を求めています End If 'オブジェクトの解放未処理 End Function
NIC address .net c# でGoogleっただけですが http://nanoappli.com/blog/archives/4025 などでは？
プログラムがその音声ファイルをどうしているかによる。 例えば、音声ファイルがプロジェクトの中にあり、プログラムからはプログラムのパス＋hogehoge.wavとかで参照しているのであれば、EXEと同じ場所に音声ファイルがあればいいのだからビルドした時にEXEと同じ場所に自動的に置くようにすればいい。 それの仕方はソリューションエクスプローラーでそのファイルを選ぶ→プロパティで「出力ディレクトリーにコピー」を「常にコピーする」にする。発行は分からん。 埋め込んでプログラムからは自分でリソースのロードとかするので使えるのであれば埋め込めばいい。 それの仕方はソリューションエクスプローラーでそのファイルを選ぶ→プロパティで「ビルドアクション」を「埋め込まれたリソース」にする。 ～～～～～ 正常動作しなかったというのが「プログラムが落ちる」という事であれば、そういう外部ファイルは何かの拍子に無くなる事もあるのでそのファイルが読み込めなくても音を出さずに前に進むようにして置くのが良いのかも知れない。
No2の添付画像、右側のトリム漏れてました、 見えにくいので貼り直します。 変わらなかったら諦め・・・・
>If Target = Range("C6") Then このコードですと、Target（変更されたセルの値）がセルC6の値と同じであれば処理をするという事になります。 >C6の内容に応じて、セルに式を設定する 以下のようにTarget.Address（変更されたセルのアドレス）が「C6」であるかを判定する必要があります。 　　If Target.Address = "$C$6" Then 　　　　　　　　　　又は 　　If Target.Address(False, False) = "C6" Then >Range("I11").Formula～Range("J14").Formula = "=C8" 「=C7」や「=C8」を絶対参照とし、セル範囲「Range("I11:I14")」を挿入先として指定することで以下のように出来ます。 　　Range("I11:I14").Formula = "=$C$7" 　　Range("J11:J14").Formula = "=$C$8" >Range("I11").Formula = ""～Range("J14").Formula = "" 数式を消すのであれば""を代入するのではなく、ClearContents（値の削除）で良いかと。 >Worksheet_Chang >セルに式を設定する Worksheet_Changイベントはユーザーが変更（入力やコピー）した場合に発生しますが、 VBAコード内で値を変更した場合にも発生します。 ですので、セルの値をVBAコードで変更する前にイベントを一時的に停止する処理 と、最後にイベントを再開する処理を追加してください。 　　Application.EnableEvents = False　'イベント停止 　　　　　　　～　セル変更処理　～ 　　Application.EnableEvents = True　'イベント再開 >If 条件式 Then 真の場合の処理 Else 偽の場合の処理 End If 上記If文において、偽の場合の処理が無い場合は「Else 偽の場合の処理」を省略できます 以上をふまえると以下のようになります。 ■VBAコード Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address(False, False) = "C6" Then 　　Application.EnableEvents = False 　　If Range("C6").Value = "する" Then 　　　　Range("I11:I14").Formula = "=$C$7" 　　　　Range("J11:J14").Formula = "=$C$8" 　　Else 　　　　Range("I11:J14").ClearContents 　　End If 　　Application.EnableEvents = True End If End Sub
シート名はそれぞれ「Sheet1」「Sheet2」とします。 以下の式は両シートともA1から提示の様式でデータが入っているとして、 Sheet1の「D1」から下へSheet2のC列のデータを持ってきます。 Sheet1のD1セルに以下の数式を入力して下へオートフィルしてください。 =OFFSET(Sheet2!$A$1,MATCH(TIME(TEXT(B1,"HH"),0,0),Sheet2!B:B,0)-1,2)
VBAは「URLDownloadToFile」のことを知らないから定義する必要があります。 以下のコードを先頭に付け加えてください。 Private Declare Function URLDownloadToFile Lib "urlmon" Alias _ "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal _ szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long あとURLの指定方法、間違えていますよ GetImageFile "http://toyota.jp/sp/image/e_bn/FCV_20140625.jpg", "FCV_20140625.jpg" としてください。 おそらくマイドキュメントに保存されるかと。
ShowDialog メソッドの使い方が違ってない？ バージョン情報ToolStripMenuItem というコントロールが配置されているフォーム (仮に MainForm) があって、そこから AboutBox1 フォームを呼び出すんだよね。 [対象のフォーム インスタンス].ShowDialog([オーナー]) という書き方になります。 つまり Dim aboutForm As New AboutBox1 aboutForm.ShowDialog(Me) と書きます。 ただし VB の場合はインスタンス作成を暗黙的に行う人もいるので AboutBox1.ShowDialog(Me) とだけ書く人もいます。
＞１．ダイアログをアクティブにし、正常に処理を実行させるにはどのように記述すれば良いですか？ objShell.AppActivate(objExec.ProcessID) とのことですが、VBScriptのAppActivateで引数にウィンドウタイトル名でなくプロセスIDがとれることは確認されてますか？手元のヘルプファイルにはウィンドウタイトルしか書いてないです。 ＞２．このVBSファイルをユーザーがログオフされている状態で実行することは可能ですか？ さすがにそれは無理です。 あと、AppActivateの戻り値を確認してないですが、AppActivateが失敗した場合にSendKeysすると他のウィンドウに送られちゃいます。
1. 「範囲はSheet1のAA3からAAの最終行まで」というのだから、nは最終行(Rows.Count)になるようにする。 2. 「RnC27」これが違っている。下記のようにする。 3. 名前の定義だけなら、選択する必要がないし、選択しない方がいい。 4. R1C1形式とA1形式が混在していいるので、統一したほうがいいかなとも思うが。 Sub test() '対象の名前を定義する Dim n As Long n = Rows.Count ActiveWorkbook.Names.Add Name:="対象", RefersTo:="=Sheet1!R3C27:R" & n & "C27" End Sub
続けてお邪魔します。 （1）について・・・ 前回のコードは7行目の項目が最終列まで空白セルなしに入っているという前提のコードでしたので 途中に空白セルがあると連続しているセルまでしか表示されないと思います。 （2）の ＞Ａ、Ｂ、Ｅ以外に職種が増えてしまった場合は ＞どうしたらいいでしょうか・・・ 「一覧」Sheetにデータ追加があり、「職種名」のSheetがない場合は新たにSheetを追加して 同じ操作をするようにしてみました。 前回のコードは削除して↓のコードを標準モジュールにコピー＆ペーストしてマクロを実行してみてください。 尚、「一覧」Sheetはシート見出しの一番左側に配置してあるとします。 Sub Sample2() Dim i As Long, k As Long Dim lastRow As Long, lastCol As Long, endRow As Long, endCol As Long Dim str As String, wS As Worksheet, myFlg As Boolean Application.ScreenUpdating = False With Worksheets("一覧") .Activate lastRow = .Cells(Rows.Count, "B").End(xlUp).Row lastCol = .UsedRange.Columns.Count endCol = lastCol + 1 Range(.Cells(7, "B"), .Cells(lastRow, "B")).AdvancedFilter Action:=xlFilterCopy, _ copytorange:=.Cells(1, endCol), unique:=True For i = 2 To Cells(Rows.Count, endCol).End(xlUp).Row str = .Cells(i, endCol) For k = 2 To Worksheets.Count If Worksheets(k).Name = str Then myFlg = True Exit For End If Next k If myFlg = False Then Worksheets.Add after:=Worksheets(Worksheets.Count) Worksheets(Worksheets.Count).Name = str End If Set wS = Worksheets(str) wS.Cells.Clear .Rows(7).AutoFilter field:=2, Criteria1:=str If .Cells(Rows.Count, "B").End(xlUp).Row > 7 Then Range(.Cells(7, "A"), .Cells(lastRow, lastCol)).SpecialCells(xlCellTypeVisible).Copy wS.Range("A1") endRow = wS.Cells(Rows.Count, "B").End(xlUp).Row Range(wS.Cells(1, "A"), wS.Cells(endRow, lastCol)).Sort key1:=wS.Range("D1"), order1:=xlAscending, Header:=xlYes wS.Columns.AutoFit End If myFlg = False Next i .AutoFilterMode = False .Columns(endCol).Delete End With Application.ScreenUpdating = True End Sub こんなんではどうでしょうか？m(_ _)m
エクセル的だなと思いつつ、無理矢理やってみましたが、こんな事で良いのでしょうか？自分ならオートメーションでExcelを操作して入れてやろうといった方向に走ったと思います。 Sub test() Dim mySQL As String mySQL = "SELECT Table1.[フィールド1], Table1.[フィールド2], Table1.[フィールド3], Null AS [作成日 exportDate] FROM Table1;" mySQL = Replace(mySQL, "exportDate", Format(Date, "yyyy/mm/dd")) Application.CurrentDb.CreateQueryDef "Q_test", mySQL DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "Q_test", GetDesktopPath & "\qtest.xlsx" Application.CurrentDb.QueryDefs.Delete "Q_test" End Sub Private Function GetDesktopPath() As String Dim wScriptHost As Object, strInitDir As String Set wScriptHost = CreateObject("Wscript.Shell") GetDesktopPath = wScriptHost.SpecialFolders("Desktop") Set wScriptHost = Nothing End Function
余談ですが・・・・ >VBSで、凝ったHTMLを出力する！ という事ですので、もう少し（見た目的に）凝ってみます。 CSSファイルを以下のようにすると添付画像のようになります。 あくまで一例ですので、CSSでいろいろ触ってみてください。 VBSコードは回答No7のものを使用しています ■main.css a.menu { padding: 0 100px 0 10px; border: 1px solid #8080ff; text-decoration: none; background-color: #ccccff; } a.menu:hover { background-color: #ccffff; border-color: blue; } h1 { font-size: 1.25em; } li { line-height: 2em; list-style-type: none; } p.note { font-size: 80%; line-height: 1.3; } li.dir { list-style-type: none; color:#F0F; margin: 15px 0 0 0; padding: 0 15px 15px 10px; border-style: solid; border-width: 1px; border-color: #aaa #333 #333 #aaa; -webkit-border-radius: 7px; -moz-border-radius: 7px; border-radius: 7px; font-size: 14px; line-height: 10px; text-decoration: none; text-shadow: 1px 1px 1px #FFF; background-color:#DDD; }
System.Console.Beep http://www.atmarkit.co.jp/fdotnet/dotnettips/440systemsounds/systemsounds.html
Split関数を使って文字列を分解する。
2007 にも「重複の削除」はありますよ。 VBA で記述してみると以下の様な感じです。 Public Sub Samp1() 　　Cells.RemoveDuplicates Array(2) End Sub 上記では行全部消えますけど、他の列に影響しない指定もできるようです。 以下は B, C 列を対象にして、Array 部分にはその対象の何番目を指定する様です。 Public Sub Samp2() 　　Columns("B:C").RemoveDuplicates Array(1) End Sub ただ、質問者さんがやりたそうな事は、 ・重複したら前の方を消す・・・ みたいで、上記「重複の削除」では、前の方を残すものの様です。 残したいものを前にするようなソートしてからなら、一番速そうです。 前の方を消す場合は、後ろの方から重複を確認して、重複するものだったら消す。 以下の様に考えます。 重複のチェックには Dictionary のキーを利用します。 無条件でキーを登録し、 重複した場合、前後の Count 値は変化しない事を利用し、 消す対象のセルを覚えておいて、 重複のチェックが終わったら、覚えていた重複していたものに対して一気に行削除 ３０万件で１５秒くらい（環境によって大幅変動あると思います） Public Sub Samp3() 　　Dim dic As Object 　　Dim rng As Range 　　Dim iRow As Long, i As Long 　　Application.ScreenUpdating = False 　　Set dic = CreateObject("Scripting.Dictionary") 　　iRow = Cells(Rows.Count, 2).End(xlUp).Row 　　Set rng = Cells(iRow + 1, 2) 　　While (iRow > 0) 　　　　i = dic.Count 　　　　dic(Cells(iRow, 2).Value) = Null 　　　　If (i = dic.Count) Then 　　　　　　Set rng = Union(rng, Cells(iRow, 2)) 　　　　End If 　　　　iRow = iRow - 1 　　Wend 　　rng.EntireRow.Delete 　　Set rng = Nothing 　　Set dic = Nothing 　　Application.ScreenUpdating = True End Sub ※ ループの中では Union だけ使いたかったので、 消えても良い最終行＋１のセルをダミー登録してからループに突入 ※ Union で覚えて一気に削除していましたが、覚える事はしないで 　　　　If (i = dic.Count) Then 　　　　　　Rows(iRow).Delete 　　　　End If と、１行毎に削除しても結果は同じになりますが・・・ 気長に処理が終わるのを待ってください・・・　それだけ遅くなります 【余談】 > 上記処理にどのような処理を加えればスムーズに処理されるでしょうか。 提示あったVBA記述を見て、危ない所を何箇所か・・・・ ★ ループ条件を考えてみる Public Sub test1() 　　Dim i As Long, j As Long 　　j = 3 　　For i = 1 To j 　　　　Debug.Print i, j 　　　　If (i = 1) Then j = j - 1 　　Next End Sub 上記のような記述がみられますが、出力された i, j はどうなっていたでしょうか？ For 文が解釈された時点で、ループ回数は決まってしまうので、 途中でループ条件を変更しても無意味 途中でループ条件を変えて動きたいのであれば、While 等で毎回判別する様に Public Sub test1k() 　　Dim i As Long, j As Long 　　j = 3 　　i = 1 　　While (i <= j) 　　　　Debug.Print i, j 　　　　If (i = 1) Then j = j - 1 　　　　i = i + 1 　　Wend End Sub ★ 行を削除した時をキッチリとイメージする 1行目：Ａ 2行目：Ｂ 3行目：Ａ 4行目：Ａ だった時、i=1, j=3 で、1行目を削除するみたいですが 1行目：Ｂ 2行目：Ａ 3行目：Ａ になって、また i=1, j=3 で、さらに1行目を削除しようとしていませんか？ 少なくとも１行目を削除した時には、j の For 文は抜ける？？？ また、i = i - 1　も必要？？？ For 文で指定した変数（i とか j）は、いじらない方が良いと思います。 いじるのなら For 文はやめて、While 等に書き換えるとか・・・ > マクロ側で対象ファイルを読み込むなどして 元は CSV ファイルとかでしょうか？ これについては、状況がわからないと・・・
こんにちは。 以下の２つのイベントの内のどちらかひとつ、を使います。 Private Sub TextBox1_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) 　　If KeyCode = vbKeyF1 Then 　　　　MsgBox "F1キー" 　　End If End Sub ' Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer) 　　If KeyCode = vbKeyF1 Then 　　　　MsgBox "F1キー" 　　End If End Sub 参考に。 ＶＢＥ画面から、F2キー、で、オブジェクトブラウザを開き、 KeyCodeを検索すれば、MSForms.ReturnIntegerの一覧が見られます。 （MSFormsのコントロールを使った後でないと表示されませんが） 以上です。
Private Sub Command1_MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single) 　　Command1.Drag End Sub Private Sub Command2_DragDrop(Source As Control, X As Single, Y As Single) 　　Dim strTmp As String 　　strTmp = Command2.Caption 　　Command2.Caption = Source.Caption 　　Source.Caption = strTmp End Sub
＞何か問題とかありそうでしょうか？ ＞（また、思い通りの操作ができそうでしょうか…） 問題無さそうですが、実際に試してないので判りません。 ＞レジストリということもあり、何も考えずに実行してしまうのは少し怖いです。 仮想PCを構築して、仮想PCの中で実行しましょう。 仮想PCは「割り当ててあるHDDイメージファイル」をバックアップしてあれば、いつでも、バックアップしてあった状態に戻せます。 仮想PCは、例えレジストリが破壊さえたとしても、HDDイメージファイルをバックアップで上書きして元に戻せば、すぐに復活します。
リンクなど貼ってもらえたら有難いです。 とりあえず、そのまま引用させてもらうと Sub Macro1() Dim rng As Range Dim ptr As Integer Const tStr As String = "ABC" 'ここに色を変える文字列を書く 　For Each rng In ActiveSheet.Cells.SpecialCells(xlCellTypeConstants, 23) 　　ptr = InStr(rng.Value, tStr) 　　If ptr > 0 Then 　　　rng.Characters(Start:=ptr, Length:=Len(tStr)).Font.ColorIndex = 3 　　End If 　Next rng End Sub ですよね？？ Instr　というのは、中に文字列が含まれているかどうかを検索するものです。 この場合だと、含まれていたら、1回だけ実行するようなプログラムになっています。 そのセルに何度も含まれている場合は、ptrの部分も含め 繰り返す必要があります。 Sub Macro1() Dim rng As Range Dim ptr As Integer Dim StartRange As Long Const tStr As String = "ABBA" 'ここに色を変える文字列を書く For Each rng In ActiveSheet.Cells.SpecialCells(xlCellTypeConstants, 23) StartRange = 1 Do ptr = InStr(StartRange, rng.Value, tStr)'StartRangeの位置から、検索文字があるかどうか判別。 StartRange = ptr'検索後、StartRangeを更新する If ptr > 0 Then rng.Characters(Start:=StartRange, Length:=Len(tStr)).Font.ColorIndex = 3 StartRange = StartRange + Len(tStr) End If Loop Until ptr <= 0 Next rng End Sub んー、こんな感じでしょうか？（上手くいくかは不安ですが） StartRangeというのは、セル内の検索位置になります。
以下の要件で作ってみました。（当方、Excel2010です） ・入力順の制御をするセルの個数は制限しない。 ・制御するセル番地をプログラム内に入れない。 ・制御するセルを登録しやすくする。 ・結合セルも可とする。 ・基本的な移動順は上から下、左から右とする。（戻るときに必要） ・セルを移動するキー 　　Enterキー、４つの方向キー、Tabキー、Shife+Tabキー 　　セルを移動させたキーよりも移動後のセルで制御する 　　方向キーの右、下はEnterキー、Tabキーと同じ 　　方向キーの左、上はShift+Tabキー ・シートの保護・非保護には依存しないようにする。 ・入力順の制御のオンオフを可能にする。 ●最初に入力順の制御を行うシートで、開発タブ＞挿入＞フォームコントロールでチェックボックスを1つシート上に配置し、右クリック＞コントトールの書式設定＞コントロールタブ＞リンクするセルを「$H$1」にして、チェックボックスはオフにしてください。マクロが「$H$1」になっているからです。後で修正してください。 入力用のマクロが動き出すと修正ができなくなるので、このチェックボックスのオン・オフでマクロを制御します。 ●下記のマクロをシートのコードウィンドウに貼り付け、最初の行の「AdrJump」の右に動かすセルを「,」で区切って順に記入します。結合セルの場合はその左上のセル番地になります。数の制限はありませんがほどほどに。この登録データで環状リストを作ります。 ●最初の時点は、編集した後、チェックボックスをオンにしてマクロを実行するとエラーが起きる可能性があります。VBE画面でマクロを中断し、「setEnableEvents」を実行してください。以降、エラーは起きないはずです。 ●今のマクロは添付図での入力用の設定になっています。 シートのコードウィンドウに貼り付けます。 '□□□　入力セルを順に書く　□□□ Const AdrJump As String = "C2,C4,C5,F5,D7,D8,D10" Dim Jmp1() As String　　'飛び先のセル（今） Dim Jmp2() As String　　'飛び先のセル（前） Dim DownUp As Integer '戻るか進むか（1:戻る、2:進む） Private Sub Worksheet_SelectionChange(ByVal Target As Range) 　　If Range("H1") = False Then Exit Sub 　　Application.EnableEvents = False 　　Jmp1 = Split(getAdr(Target), ",") 　　If Jmp1(0) = "" Then 　　　　'前に進むか戻るかを判定 　　　　DownUp = 1 - (Range(Jmp2(0)).Row < Target.Row Or _ 　　　　　　　　　　 Range(Jmp2(0)).Column < Target.Column) 　　　　 　　　　Jmp1 = Split(getAdr(Range(Jmp2(DownUp))), ",") 　　　　Range(Jmp2(DownUp)).Select: Jmp2 = Jmp1 　　Else 　　　　Jmp1 = Split(getAdr(Range(Jmp1(0))), ","): Jmp2 = Jmp1 　　End If 　　Application.EnableEvents = True End Sub '選択セル(結合セルも可)によってどこに移動するか候補を決める Function getAdr(Tgt As Range) As String 　　Dim wk() As String, i As Integer 　　 　　wk = Split("," & AdrJump & ",", ",") 　　wk(0) = wk(UBound(wk) - 1) '環状リスト（最初） 　　wk(UBound(wk)) = wk(1)　　 '環状リスト（最後） 　　 　　getAdr = ",," 　　For i = 1 To UBound(wk) - 1 　　　　If Tgt.Range("A1").Address(0, 0) = wk(i) Then 　　　　　　getAdr = wk(i) & "," & wk(i - 1) & "," & wk(i + 1) 　　　　　　Exit For 　　　　End If 　　Next End Function '最初、編集時エラーが発生したらこのプロシージャを実行する Sub setEnableEvents() 　　Erase Jmp1 　　Erase Jmp2 　　Application.EnableEvents = True End Sub
> =COUNTIF(A1:J1,"a")となるのでしょうか。 その場合、abcは個数に入りませんがそういう仕様ですか? > 行は10行くらで、 > 列は10列くらいなので、J1としました。 1行目にはaで2行目にはbで3行目以降は不明ですが、それともすべての行でaとbの個数を合算した結果をそれぞれK列L列にに出すのでしょうか。どちらにしても、回答されたコードをご自身で解析してご自身の仕様に合うように改良する必要がありますが、不明な部分が多いので、とりあえず それぞれの行でaの個数はK列にbの個数はL列に表示するということとして3種類の例を示します。 Sub Example1() 'a及びbの文字総数を求める Dim c As Range Dim i As Integer, j As Integer Dim samplestr(2) As String Range("K:L").ClearContents samplestr(0) = "a" samplestr(1) = "b" For i = 1 To 10 For Each c In Range(Cells(i, "A"), Cells(i, "J")) Cells(i, "K").Value = Cells(i, "K").Value + (Len(c.Value) - Len(Replace(c.Value, samplestr(0), ""))) / Len(samplestr(0)) Cells(i, "L").Value = Cells(i, "L").Value + (Len(c.Value) - Len(Replace(c.Value, samplestr(1), ""))) / Len(samplestr(1)) Next Next End Sub Sub Example2() '文字列にa及びbを含む文字列の個数を求める Dim c As Range Dim i As Integer, j As Integer Dim samplestr(2) As String Range("K:L").ClearContents samplestr(0) = "a" samplestr(1) = "b" For i = 1 To 10 For Each c In Range(Cells(i, "A"), Cells(i, "J")) If InStr(1, c.Value, samplestr(0)) > 0 Then Cells(i, "K").Value = Cells(i, "K").Value + 1 End If If InStr(1, c.Value, samplestr(1)) > 0 Then Cells(i, "L").Value = Cells(i, "L").Value + 1 End If Next Next End Sub Sub Example3() 'COUNTIFと同じ結果 Dim c As Range Dim i As Integer, j As Integer Dim samplestr(2) As String Range("K:L").ClearContents samplestr(0) = "a" samplestr(1) = "b" For i = 1 To 10 For Each c In Range(Cells(i, "A"), Cells(i, "J")) If c.Value = samplestr(0) Then Cells(i, "K").Value = Cells(i, "K").Value + 1 End If If c.Value = samplestr(1) Then Cells(i, "L").Value = Cells(i, "L").Value + 1 End If Next Next End Sub
こんな感じでいかがです。 Sub XXX() Dim A, B Dim AA, BB, CC, DD Dim AAA, BBB, CCC, DDD AA = "C:\MyFile.txt" BB = "D:\YourFile.txt" Set AAA = CreateObject("Scripting.FileSystemObject") Set BBB = AAA.GetFile(AA) Set CCC = AAA.GetFile(BB) A = BBB.DateLastModified B = CCC.DateLastModified If B > A Then Kill AA CC = Left(AA, InStrRev(AA, "\")) DD = Right(BB, Len(BB) - InStrRev(BB, "\")) AAA.MoveFile BB, CC Set DDD = AAA.GetFile(CC & DD) DDD.Name = Right(AA, Len(AA) - InStrRev(AA, "\")) End If End Sub InStrRevの意味は、AA,BB の値に"\"が増えた場合の措置です。 また、AA,BB の値がどこに記述されているかによって、 AA=Sheets("ZZZ").Range("C2").Value BB=Sheets("AAA").Range("D3").Value のような記述OK
下記のコードでよろしいかと。 Docmd.TransferText acImportDelim, , "テーブル名", Me.テキスト45.Value
失敗している方のテキストファイルの改行コードが、Windows形式の改行コードになっているか確認しましょう。 OSの違いによる改行コードの違いについて http://www.rsch.tuis.ac.jp/~mizutani/online/with-pc/textline.html 他の形式（LFのみ、CRのみ）の場合、VBAのReadLineは「CR+LFが現れるまでを１行として扱う」ので、１度で全部を読み込んでしまいます。 Visual Basic Editorなどで見ていると違いに気付けませんが、Windowsのメモ帳で見ると、CR+LF以外の改行では改行されずに表示されるので、メモ帳で開いて確認してみましょう。
基本VB知りません（なのでエラーチェックなども一切行っていません） Windowsフォームアプリケーションだとして Formに Button1　 Button2　 TextBox1　Label1 を配置した状態にして 1. Button1クリックイベントに 　　　Label1.Text = Math.Sqrt(Val(TextBox1.Text)).ToString() 2. Button1クリックイベントに 　　　Label1.Text = "" で動くのは確認(VisualStudio 2010 Proにて)
「いつ，どんなときにそうなる(ファイルはどんどん重くなる)のか？」 この条件を探すのに少々手間取りましたが， その VBS ファイルが存在するフォルダ内に 元から HTML ファイル(実際は拡張子 .html のファイル)が存在したときに そうなるようですよ。 当たり前と言えば当たり前ですが， VBS ファイルが存在するフォルダ内に 最初から拡張子 .html のファイルがあった場合， 「そのHTMLファイルを開いてはタグを付け加えて同じ名前で保存する。」 この作業を延々と繰り返すわけですから 巨大ファイルができてしまいます。 (できるというよりも，作ろうとして強制終了させない限り PC が重くなる。) 結局，制限のかけ方が間違っているのだと思います。 現時点では If file.name <> WScript.ScriptName Then という制限を付けて VBS ファイル(つまり自分自身)以外のであれば どんなファイルにでもタグを付けて行って HTML として保存させようとしています。 そうではなくて 同じ部分を If Right(file.name,4) = ".txt" Then のように変更して 拡張子 .txt のファイルに対してのみ プログラムを実行させるとか， せめて If file.name <> WScript.ScriptName And Right(file.name,5) <> ".html" Then のように変更して 自分自身以外と，拡張子 .html 以外のファイルに対して プログラムを実行させるとかに変更する必要があると思います。 そうしないと メモリ や CPU どころか ドライブの全容量食いつくし現象が起きて ハード自体も危ないことになるかもしれませんよ。
★☆★☆★☆今回のコードについて☆★☆★☆★ 今回のコードで以下の点を変更・追加しました。 (1)データブックを選ぶフォームにてシートの選択機能を追加 (2)最終行の取得方法をセル"D3"より下へ終端として取得 (3)変更が容易になるようにセル指定をCellsからRangeへ変更 ★☆★☆★☆ユーザーフォーム・コードの修正☆★☆★☆★ ユーザーフォームを添付画像のように作り変えます。 (1)No1で作成したユーザーフォームの下側にツールボックスより 　「リストボックス」を追加してください (2)「ユーザーフォーム内」のコードを以下のコードと全て置き換えてください。 　（プロジェクトウィンドの『UserForm1』を右クリック→コードの表示） '＿＿＿＿＿＿＿以下VBAコード＿＿＿＿＿＿＿＿ '■シート名一覧をリストボックスに表示 Private Sub ComboBox1_Change() Dim i As Integer Dim tar_book As Workbook Dim bpath As String Dim book_name As String Me.ListBox1.Clear With Me.ComboBox1 If .ListIndex > 0 Then Set tar_book = Workbooks(.List(.ListIndex)) Me.ListBox1.AddItem "[アクティブなシート]" For i = 1 To tar_book.Sheets.Count Me.ListBox1.AddItem tar_book.Sheets(i).Name Next i Me.ListBox1.ListIndex = 0 exit_flag = exit_flag + 1 Else bpath = Application.GetOpenFilename("ファイル *.*,*.*") If bpath = "False" Then exit_flag = exit_flag + 32 Exit Sub Else Workbooks.Open bpath Call set_booklist ListIndex = .ListCount - 1 exit_flag = exit_flag + 8 End If End If End With End Sub '■フォームを非表示 Private Sub CommandButton1_Click() Me.Hide exit_flag = exit_flag + 16 End Sub '＿＿＿＿＿＿＿以上VBAコード＿＿＿＿＿＿＿＿ ★☆★☆★☆VBAコードの差替え☆★☆★☆★ (1)標準モジュールのコードを全て以下のコードで置き換えてください。 (2)コード内の「'出力先のシートを設定」の部分をNo1同様に修正。 　（データブック及びシートの設定はフォームで指定するので、 　　ここでの設定は廃止しました） '＿＿＿＿＿＿＿以下VBAコード＿＿＿＿＿＿＿＿ Option Explicit '処理判定フラグ Public exit_flag As Integer '■メイン Sub action() '型宣言 Dim LAST As Long Dim i As Long Dim tar_obj(1) As Object Dim cnt As Long 'フォームの表示・判定（実処理はFunction getbookで処理しています） Set tar_obj(0) = getbook If tar_obj(0) Is Nothing Then MsgBox "正常に処理が出来ませんでした。" & vbCrLf & "exit_flag = " & exit_flag GoTo exend End If '出力先のシートを設定 Set tar_obj(1) = Workbooks("TEST.xls").Sheets("test") '表示先(セルA1を左上とする出力先の塊)をクリア tar_obj(1).Range("A1").CurrentRegion.ClearContents 'メイン処理 With tar_obj(0) '最大行数取得(セルB3から下へ終端セルの行番号) LAST = .Range("D3").End(xlDown).Row 'データの数だけループ処理(3行目～LAST行目) For i = 3 To LAST 'E列（数値1）が0以外なら実行 If .Range("C" & i) <> 0 Then 'E列（数式1）が数式でないなら実行 If .Range("C" & i).HasFormula = False Then '表示先の行数をカウントアップ cnt = cnt + 1 'A列へB列（名前）の値を表示 tar_obj(1).Range("A" & cnt).Value = getword(.Range("B" & i).Value) 'B列へC列（数値1）の値を表示 tar_obj(1).Range("B" & cnt).Value = getword(.Range("C" & i).Value) End If End If Next i End With '終了処理・初期化 exend: exit_flag = 0 UserForm1.Hide Unload UserForm1 End Sub '■カッコ「()」内の文字を取得 Function getword(word As String) As String Dim st As Integer Dim ed As Integer On Error GoTo era '変数wordから「(」の位置をstに、「)」の位置をedに代入 st = InStr(1, word, "(") ed = InStr(st, word, ")") '変数wordから「()」内の文字をトリムして返す getword = Mid(word, st + 1, ed - st - 1) Exit Function era: 'カッコ「()」が見つからなかった場合、元の値を返す getword = word End Function '■データのブックを指定 Function getbook() As Object Dim i As Integer Dim bpath As String 'ユーザーフォームを読込 Load UserForm1 'ユーザーフォームのコンボボックスに対する処理 With UserForm1.ComboBox1 Call set_booklist 'ユーザーフォームの表示 UserForm1.Show 'フォーム処理が正常に行われなければ中断 If exit_flag < 2 Then Set getbook = Nothing: Exit Function '選択されているコンボボックスのブックをセット Set getbook = Workbooks(.List(.ListIndex)) End With 'ユーザオーフォームのリストボックスに対する処理 With UserForm1.ListBox1 'リストボックスの1項目目が選択されているかで分岐 If .ListIndex = 0 Then 'アクティブシートをセットしメイン処理へ返す Set getbook = getbook.ActiveSheet exit_flag = exit_flag + 4 Else '選択シートをセットしメイン処理へ返す Set getbook = getbook.Sheets(.List(.ListIndex)) exit_flag = exit_flag + 2 End If End With End Function '■ブックの一覧をコンボボックスへセット Sub set_booklist() Dim myData() As String Dim i As Integer 'ワークブック格納用の配列を用意 ReDim myData(Workbooks.Count) 'ユーザーフォームのコンボボックスに対する処理 With UserForm1.ComboBox1 myData(i) = "[ファイルを指定する]" '開いているブック名の一覧を配列へ格納 For i = 1 To Workbooks.Count myData(i) = Workbooks(i).Name Next i 'コンボボックスにブック名一覧をセット .List = myData End With End Sub '＿＿＿＿＿＿＿以上VBAコード＿＿＿＿＿＿＿＿ ★☆★☆★☆使い方☆★☆★☆★ 基本的にNo1と同じです。 フォームでコンボボックスが変更されるたびにシート名一覧がリストボックスに表示されます。 リストボックスより対象のシート名を選択して「OK」をクリックしてください。 処理結果がコード内で指定した出力先に表示されます。
こんにちは。 EXCELに関するご質問として、お応えします。 直接的な答えとしては、 =SUMIF(INDIRECT("損益!M"&Q25&":M"&Q26),">0",INDIRECT("損益!M"&Q25&":M"&Q26)) または一般的に、 =SUMIF(INDIRECT("損益!M"&Q25&":M"&Q26),">0") というような結果をお求めなのかと思います。 SUMIF()関数の引数については、 第一引数と第三引数が同一のセル範囲を参照する場合、 第三引数を省略するのが通常です。 仮に、第三引数を指定する必要がある場合は、そちらも[セル範囲]を指定する必要がありますから、 [セル参照を表す文字列]を指定するのは誤りということになります。 INDIRECT()関数の引数には、ひとつ、セル参照を表す文字列を指定します。 構文上、INDIRECT()の括弧の中に、カンマで区切った複数の引数を指定するのは誤りです。 別シート上の（単一ではない）セル参照を表す方法の基本例ですが、 　損益!A2:A11 のように、 　「シート名」！「起点セル」：「終点セル」 という書式で書いた方が、演算上のロスも無く、エラーを起こす機会も減ります。 　損益!A2:損益!A11 のように書いても多くの場合で同じ結果を返すので、絶対にダメ、とまでは言いませんが。 ご質問冒頭の数式については、 =SUM(INDIRECT("損益!M"&P25&":M"&P26))です。 この書き方の場合、P25,P26が両方とも未入力だった場合に =SUM(損益!M:M)の計算結果を返します。 例えば、 =SUM(INDIRECT("損益!M"&P25&":損益!M"&P26))のような指定をしてしまうと、 =SUM(損益!M:損益!M)という数式は成立しませんから、必然的に#REF!を返すことになります。 以上、ご参考まで。
TextBox1とLabel1はForm1上の好きな位置に配置してください。 Public Class Form1 Private Sub TextBox1_TextChanged(sender As Object, e As EventArgs) Handles TextBox1.TextChanged If IsNumeric(TextBox1.Text) Then Label1.Text = Math.Sqrt(TextBox1.Text) Else Label1.Text = "" End If End Sub End Class
http://dobon.net/vb/dotnet/process/getprocesses.html
変数aはstring型がいい。 mid関数の引数のLen(a)はおかしい、ここはiとすべきでは 変数bはどこかで初期化した方がいい。 b += 2 ^ (i - 1)　この式はおかしい、LSBからビットを 判定しているのに、iがMSBからになっている。 1と0以外の文字が来た場合の処理を入れたほうがいい。 全体的にプログラムを見なおしたほうがいい。
ちょっと確認していませんが > .Radio_btn1.Checked = True　　’ここへくるとbuttonのeventが発生, イベントは節制しますが、実際に対応するルーチンが実行されるのは、このSubを抜けた後だったように思います。 デバッガでステップ実行したらどうなってますか?
>しかし、新名にも空白が入っている場合に、 >どういうクォーテーションを入れたら良いのか、 >あれこれ試しましたが、うまく行きませんでした。 >重ねてのお尋ねで恐縮ですが、ご教授ください。 なにをどうあれこれ試したのでしょうか？ パソコンをはじめて触る方なのでしょうか。 そうだとしても、それくらいは自分で考えられるようになったほうがいいと思うのですが。 「ren "c:\users\me\desktop\data\旧名.txt" "新名.txt"」 こういう内容の文字列にすればいいわけです。ということはコードは cmd = "ren ""c:\users\me\desktop\data\" & 旧名 & """ """ & 新名 & """" でしょ。
文字列オブジェクトを作成しようとしましたが、システムのメモリを使い果たしているために作成できません。動的に割り当てられる配列が大きくなりすぎたか、多数のオブジェクトがインスタンス化されたことが考えられます。 このエラーを解決するには ・Erase ステートメントを使用して、動的配列記憶領域を再割り当てします。 ・ReDim ステートメントを使用して、記憶領域を再割り当てします。 ・開いているアプリケーション、ドキュメント、ソース ファイルなどのうち、不要なものを閉じます。 文字列領域が不足しています。 http://msdn.microsoft.com/ja-jp/library/cc410219.aspx
となると・・・。以下推測にすぎませんが ファイル出力のソフトが別のユーザーで実行されている。 Excelが立ち上がっていたらすべて閉じる。 Excel出力を行って閉じずにタスクマネージャを開き プロセスタブのExcel.exeのユーザー名が あなたのアカウント名か確認してみてください。 ファイル出力が『管理者として実行』されている。 ExcelでAlt + F11 → Ctrl + G でイミディエイトウィンドウで shell "cmd /k" としてEnter コマンドプロンプトが立ち上がります。 タイトル部分が、管理者:c:\windows\・・・となっていたら 『管理者として実行』されています。 どちらにも当てはまらない場合と 前者の場合はどうしようもないです。。。 後者の場合は、あなたがローカルPCのAdministratorsグループに 属していればナントカなるかも（出来なさそうな）しれませんが -2147417848 のエラーの再現が出来ないのがネックです。 何かにVBSの処理がブロックされているのは間違いないとは思いますけど。。。
ACCESSというアプリケーションは、 フロントエンド部分 バックエンド部分（Het OLEDBデータベースエンジン） データベースファイル（MDB） の3つから出来ています。 VS（Visual Studio）を使う場合、Jet OLEDBはVisual Studioに含まれていますので、ACCESSは特に不要です。MDBファイルさえあれば良いです。 MDBファイルは、ACCESSで使用されているもので、データが入っていてもかまいません。またVS側から挿入・編集・削除することももちろん可能です。 SQL文は、VSがJetOLEDBを通してMDBを読みだす際に使用しますが、VSには複数のDAO（データベース・アクセス・オブジェクト）があって、その中の最も低水準のアクセス手段がSQLの直書きです。 新しいものになるほど、ウィザードだけでほとんどSQLの記述を必要としないようになります。 （その場合でも、細かいDB操作などのためにSQLによるアクセスは可能になってます） Jet OLEDBは、現在、VisualStudioが使用できるデータベースの中で最も低レベルのものであり、DAOの中にはすでにJet OLEDBをサポートしていないものも多いです。 VSからJet OLEDBを使うには、古い順に SQLCommand（VS2003） DataAdapter（VS2003） TableAdapter（VS2005） 3つの方法があり、これ以上新しい LINQ for SQL（VS2008 SP） Entity Framework（VS2008 SP） ではJet OLEDBはサポート外です。 これから学習されるのであれば、古臭いSQLCommandなど使用せず、最低でもTableAdapterによる利用です。 ネット上にあるリソースはほとんどSQLCommandを使ったケーースなので、この書籍が一押しです。 http://www.amazon.co.jp/Microsoft-Visual-Studio-2005%E3%81%AB%E3%82%88%E3%82%8BWeb%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E6%A7%8B%E7%AF%89%E6%8A%80%E6%B3%95-%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%BD%E3%83%95%E3%83%88%E3%82%B3%E3%83%B3%E3%82%B5%E3%83%AB%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%86%E3%82%AF%E3%83%8B%E3%82%AB%E3%83%AB%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/dp/4891005157/ref=cm_cr_pr_product_top
FORTRANのOPEN命令の引数の意味が判らないのであれば、先ずそのFORTRANの取説あるいは文法書を見ないことには始まらない。 昔使っていたFORTRAN（VAX FORTRAN）には「form='BINARY'」や「convert='BIG_ENDIAN'」といったオプションはなかったので、 正確には判らないが、私の経験から ◎FORTRAN側 (1) FORTRANでのREAL変数は、4バイト実数です。（8バイト、又は16バイトの可能性もある） (2) ファイルを'BINARY'指定でOPENしているので、ファイルに書き込まれているデータはバイナリ形式（メモリ内部形式）と推測できる。 (3) ファイルを'BIG_ENDIAN'指定でOPENしているので、ファイルに書き込まれているバイナリデータはビッグエンディアン形式と推測できる。 ※　これは非常に厄介な状態です。なぜならWindows系の言語ではリトルエンディアンが普通なので、バイトの順番を入れ替えて読まないといけない。 ◎Windows側 (1) バイナリファイルなのでエンコードは関係ない。（エンコードはテキストファイルの時のみ使う） (2) ファイルから１変数分の4バイトをByte配列に読込む。（FORTRANのREALのサイズにより8または16の可能性あり） (3) 読みこんだ4バイトの順番を入れ替える。 (4) 4バイトのByte配列を実数に変換する。 (5) ２～４をデータの個数分繰り返す。 ※　ただし、FORTRANのREALのデータ形式と、VB.NETのSingleのデータ形式が同じとは限らないので正しく変換できないかもしれない。 ※　また、ファイルサイスが572バイトだと、読み込もうとしているデータとサイズが合わないのも気になる。 サンプル（ファイル名等は合わせてください） 　　Dim fs As New FileStream("c:\test.bin", FileMode.Open, FileAccess.Read) 　　Dim buf(3) As Byte ' データ格納用配列（REALが8バイトならbuf(7)にする） 　　Dim fWork As Single ' 実数データ（REALが8バイトならDoubleにする） 　　Dim readSize As Integer ' Readメソッドで読み込んだバイト数 　　Dim i As Integer 　　For i = 0 To 16 　　　　readSize = fs.Read(buf, 0, buf.Length) 　　　　Array.Reverse(buf) 　　　　fWork = BitConverter.ToSingle(buf, 0) 　　　　Console.WriteLine(fWork.ToString()) 　　Next i 　　fs.Close()
> Const Chr1 As String = "GN " 「GN」の後にスペースが入っているのが原因でしょう。 ただ、ここを直すだけでは「N=12jikl 」と言う文字列を取り出すことになりますのでMid関数の開始位置を調整してください。
以下のVBAコード内の「\\ネットワークフォルダパス\」を変更してからご利用ください。 ■VBAコード Option Explicit Sub csv保存() '変数宣言 Dim filePath As String Dim i As Long, j As Long Dim fileNo As Integer Dim dpath As String Dim gyou As String '*****初期値設定 'ネットワークパスを指定（最後は「\」） dpath = "\\ネットワークフォルダパス\" 'ダイアログ表示 filePath = Application.GetSaveAsFilename( _ InitialFileName:=dpath & "売上表" _ , FileFilter:="CSVファイル(*.csv),*.csv") If filePath = "False" Then Exit Sub '*****出力処理 fileNo = FreeFile 'ファイル開く Open filePath For Output As #fileNo '最終行までループ For i = 1 To Selection.Rows.Count gyou = "" For j = 1 To Selection.Columns.Count If j > 1 Then gyou = gyou & "," gyou = gyou & Selection.Cells(i, j).Value Next j Print #fileNo, gyou Next i 'ファイル閉じる Close #fileNo End Sub ■フォルダを毎回指定する場合 >1.csvの保存フォルダを指定したい の指定方法で定数でなくユーザーにフォルダを毎回選択させる場合は 「初期値設定」の中の「dpath = "\\ネットワークフォルダパス\"」 の箇所を以下のように変更してください。 With Application.FileDialog(msoFileDialogFolderPicker) If .Show = True Then dpath = .SelectedItems(1) & "\" End If End With
VB6 での経験しかありませんが・・・ 右側の表示内容の分だけ（コンテナとしての）Frame を用意しておいてその上に選択されたノードに必要な各種オブジェクトを配置、 TreeView のノードを選択するたびに一旦全 Frame を Visible = False とした後、必要な Frame を Visible = True とした事はあります。
私が書いたコードですね。 MyMonth = Val(StrConv(Left(Cells(i, "A").Offset(-1, 0).Value, 1), vbNarrow)) Cells(i, "A").Value = Month(DateAdd("m", 1, Year(Date) & "/" & MyMonth & "/" & "1")) & "月合計" この部分です 最初の行は元のA列i行にある ○月合計 という文字列からLeft関数で最初の一文字を取得しています。そして、月の文字が全角だったのでStrConvで半角にしてValで数値にして、変数MyMonthに代入しています。 次の行で、DateAdd関数を使って Year(Date) & "/" & MyMonth & "/" & "1　(= 2014/○/1　になります) の同年翌月の1日を求めてその結果から Month関数を使って月だけを求めています。 DateAddを利用するのは単純に月だけを数値として加算していくと12月の次に13月をなってしまうのを防ぎたかったためで、もっといい方法があったかもしれませんが、とりあえずその方法を思いついたので採用しました。 じつは、このコードには問題があって月が10月になると正常に加算されなくなります。それは必ず最初の一文字しか取得していないためです。 Left(Cells(i, "A").Offset(-1, 0).Value, 1) を Mid(Cells(i, "A").Offset(-1, 0).Value, 1, InStr(Cells(i, "A").Offset(-1, 0).Value, "月") - 1) に変更してください。
> コピー元は、4月の見込,4月の実績の行でペースト先は黄色に塗った個所のようにしたいです そのあたりはなんとなくわかるのですが、セル番地がコードと画像と違うようなのでこちらでは参考コードで指定のしようがないので選択したものをコピーすることにしたということです。 またコピー先が画面では4行下だけどコードだと9行下になっているのでこれも何が正解かわからないし、複数回繰り返すと書かれていて具体的に何回かわからないので、とりあえず2回下方向にコピーするものを参考に作ってみましたということです。 > コンパイルエラー:= ] > となってしました。 Sub 書式のコピー() 同じ名前のものがあるのだと思います。適宜名前を変更してください。 エラーが出た場合、エラーメッセージを全て記載しないのは質問者さんがよくすることですが、全て記載しないとエラー内容が回答者側に適切に伝わりませんので、メッセージは全て記載するようにしてくだい。 とりあえず A1に ６月合計 A2に ６月実績 として B列以降は適当にデータを入れて データを入れた範囲の1行目と2行目を選択して実行してみてください。 なお、データの無いセルを選択し実行すると型が一致しませんというエラーがでますし、選択範囲が適切かどうかは判断していません。
質問の意味をとらえきれていないかと思いますが参考にしてください。 まず、表題の「ExcelでVBAを利用してオートシェイプ情報取得」と最初にある「Excelのオートシェイプをテキストデータに変化するVBAを作成したいです」が異なることを言っているように思えます。『情報取得』と『変化』です。「テキストデータに変化する」がどんな意味なのか分からないからかもしれません。テキストデータに「円」と書かれていたら「図形の円」にする？ ＞このようなオートシェイプの情報をうまく拾う方法、テキストデータと紐づける方法はありませんでしょうか これは、 　１．オートシェイプの情報をうまく拾う方法 　２．テキストデータと紐づける方法 の２つでしょうか 「１．オートシェイプの情報をうまく拾う方法」については参考にモジュールを作ってみました。 「２．テキストデータと紐づける方法」については、 　オートシェイプの情報がどのようなものか分からないですが、オートシェイプのテキストをセルを参照する形式にしてみてはどうでしょうか。添付図の場合、「楕円」のテキストは「=A11」で「明日は」になります。オートシェイプのテキストの算式を使った登録は「セル参照」のみで、複雑な計算式は登録できないのでこのようにしています。複雑な内容を登録したい場合はセル側で整形したりしています。 登録内容を変えたいときはセルの内容を変更します。 ＞Excelのオートシェイプをテキストデータに変化するVBAを作成したいです。ただし対象となるオートシェイプは複数のオートシェイプがグループ化されたグループオブジェクトになっています 　「テキストデータに変化する」がどんな意味なのか分かりませんが、「オートシェイプの情報をうまく拾う方法」として、グループ化された複数のオートシェイプから左から順にテキストを取り出して1行目に表示してみました。VBAでテキストを拾ってくる例です。オートシェイプの位置を変えれば再度マクロを実行すれば出力が変わります。 ＞具体的な操作としては複数のオートシェイプオブジェクトを横に並べたイメージダイアグラムを作成し、それらにそって対応するテキストを配置していきたいというものです 　この説明から、先にグループ化された複数のオートシェイプ（テキスト入力済み）があり、そのテキストを順に表示するのかなと考えた次第です。 「シートのコードウィンドウ」 グループ化されたオートシェイプを選択して実行します。 添付図にはコマンドボタンがありますが、ボタンから実行する場合は、コマンドボタンの「TakeFocuusOnClick」プロパティを「False」にしてください。 Sub オートシェイプのテキスト出力() 　　Dim shp As Shape 'オートシェイプ 　　Dim i As Integer, j As Integer 'カウンタ 　　Dim n As Integer　　'オートシェイプの個数 　　Dim potLeft() As Single 'オートシェイプの左位置 　　Dim Sort() As Integer　　'オートシェイプの左位置の順 　　On Error GoTo ErrorTrp 　　 　　With Selection.ShapeRange 　　　　If .Type = msoGroup Then 'グループ化されていたら 　　　　　　n = .GroupItems.Count 　　　　　　ReDim potLeft(n), Sort(n) 　　　　　　 　　　　　　For i = 1 To n 　　　　　　　　potLeft(i) = .GroupItems(i).Left 　　　　　　　　Sort(i) = 1 　　　　　　　　For j = 1 To i - 1 '左位置を取り込んでソート 　　　　　　　　　　If potLeft(j) >= potLeft(i) Then 　　　　　　　　　　　　Sort(j) = Sort(j) + 1 　　　　　　　　　　Else 　　　　　　　　　　　　Sort(i) = Sort(i) + 1 　　　　　　　　　　End If 　　　　　　　　Next 　　　　　　Next 　　　　End If 　　 　　　　For i = 1 To n 　　　　　　For j = 1 To n　　'ソート順に出力する 　　　　　　　　If Sort(j) = i Then 　　　　　　　　　　Exit For 　　　　　　　　End If 　　　　　　Next 　　　　　　'1行目に順に出力 　　　　　　Cells(1, i) = .GroupItems(j).DrawingObject.Characters.Text 　　　　Next 　　End With 　　Exit Sub ErrorTrp: End Sub
親Excelというより、データベースですですが、ExcelやAccessですと 開く→閉じる だけでも処理が重いので、CSVファイルにしたら如何ですか？ テキストファイルだから速いし、Excelでも開けますからね。 '1ミリ秒間スリープするAPI Declare Sub Sleep Lib "kernel32" (ByVal ミリ秒 As Long) 'CSVファイルのパス ★実態に合わせて変えて下さいね Const パス As String = "\\共通サーバ\集計\蓄積.csv" 'ボタンクリック時のイベント処理 Sub 記録(ByVal 行 As Long) Dim A列 As String Dim B列 As String Dim C列 As String '予め編集する A列 = Cells(行, 1) B列 = Cells(行, 2) C列 = Format(Now, "yyyy/mm/dd hh:nn:ss") 'エラーハンドリングを開始する On Error Resume Next 'ファイルが開けるまで繰り返す Do 　　'ファイルを開く(他の書き込みは許さず、参照は許可する) 　　Open パス For Append Lock Write As #1 　　'成功したらループを抜ける 　　If Err.Number = vbNormal Then Exit Do 　　'エラーをリセットする 　　Err.Clear 　　'1ミリ秒待つ 　　Sleep 1 Loop 'エラーハンドリングを終了する On Error GoTo 0 'ファイルに出力する Print #1, A列; vbTab; B列; vbTab; C列 'ファイルを閉じる Close #1 End Sub 仕組みはファイルを開いて書き込むだけですが、万一、書き込みが 同時に起きると、僅かでも遅い方が負けてファイルを開けません。 そこで、エラーで停止しないようハンドリングし、開けるまで 繰り返しリトライします。この間、CPUストレスを軽減するため、 Sleepを入れます。 ファイルを開いてから、書き込み→閉じるまで、数ミリ秒ですので、 書き込みがカブっても人間が感じる程のフリーズ状態にはなりません。
そんなところにエラー処理ルーチン書いたら毎回通ってしまいますね。 On Error GoTo ErrHandler Do Until objTS.AtEndOfStream Loop '必要ならここで On Error GoTo 0 ’Loop 終了後の処理・・・・ Exit Sub または Exit Function ErrHandler: 　　MsgBox "エラーが発生しました。Excelを強制終了します。", vbOKOnly + vbCritical, "終了" 　　Application.Quit 　　Windows("ファイル名").Close True 　Loop こうすればエラー処理はエラーが発生したときしか通らなくなります。
loopにはいる前に一行読んで（捨てて）しまえばよいだけです。 csvtitle = objts.readline Do Until objTS.AtEndOfStream ※この中で・・・ Loop のように。
先ず 「FTPサーバーからファイルをダウンロードする」 http://dobon.net/vb/dotnet/internet/ftpwebrequest.html#downloadfile のサンプルプログラムを、ダウンロードするファイルのURIとダウンロードしたファイルの保存先を引数として受け取るFunctionに修正しておきます。 「FTPサーバーのディレクトリのファイル一覧を取得する」 で取得したファイルリストから、１つずつの取得したいファイルの ダウンロードするファイルのURIとダウンロードしたファイルの保存先 を作成する。 ダウンロードするファイルのURIとダウンロードしたファイルの保存先 を引数として、上記で作成したFunctionを呼びだす。 必要なファイルの数だけ、上記の関数呼び出しを繰り返す。 ※FTPサーバが返すファイル一覧の書式は様々なので、接続しているFTPサーバに合わせてファイル名の切り出しを行う必要が有ります。
こんばんは！ それぞれのテキストボックスのプロパティ　→　Tabindex　を確認してみてください。 何も指定がない場合は ユーザーフォームを立ち上げた段階でTabindexが「0」のテクストボックスが　SetFocus　されます。 後はEnterを押すたびに　1　→　2　→　3　・・・と順に入力可能な状態になるはずです。m(_ _)m
Val(Right(Date, 2)) で日にち部分だけを数値として取り出せますのであとは15と比較してその後の処理をしてください。
本来は 　If number Is Nothing Then の部分でエラーになるのですが(Variant型変数であるnumberの内部処理形式がStringのため)、 　On Error Resume Next が書かれているためにエラーが無視され、 結果的に条件分岐が正常に行われていないようです。 個人番号が1文字も入力されていなかったら関数を抜ける、という動作がしたいのでしょうか？ InputBoxに何も入力しなかった場合はNothingではなく空文字列が返ってくるので、 　If number = "" Then と書いてくださいな。
> 今度はRangeクラスのselectメソッドが失敗しました > と言われてしまいました、、、 「Range Select 失敗」といったキーワードで検索してみるとすぐ出てくる情報ですが、 セルを選択状態にするには、そのセルを含むシートがアクティブになっている必要があります。 With wskyu 　.Activate 'シートをアクティブにする 　.Range("P7:AQ7, ……").Select 　(略) End With
私は、デフォルト設定から変更する場合は、主にコードで設定しています。 ただ、デザイナで変更しても、InitializeComponent 内に自動でコードが 書かれます。そういった意味では、プロパティウインドウで設定しても 自分でコードを書かないだけで、コードで設定しているとも言えます。 ところが、この自動で書かれているコードには独自のルールがあるようで、 プロパティのデフォルト値と同じであると省略されたり、コードに書かれる コントロールの順も不定な部分があります。また、開発環境の解像度などの 影響を受けて、プロパティ値が自動調整される事があります。 そういった諸々の事情から、企業で開発するプロジェクトでの保守性や、 別プロジェクトへの再利用性に劣ります。 自前のコードで書いてあると、そこが自動で変更される事は無い(実行時に 調整される事はあっても)ので、意図して値を変更した事が明確に履歴管理 でき、また、そのコードで1回十分にテストしておけば、そのまま安心して 他プロジェクトに流用できます。また、複数プロジェクトで、どのプロパティ を流用して、どのプロパティは流用しなかったか(つまり、どの機能を実装し、 どの機能は実装しなかったか)といった差分比較も簡単になります。 少し特殊な事例としては、画面上に規則正しくコントロールが並んでいる時に その位置や初期値を関数で設定した事があります。一度設定するだけなら デザイナ上で設定しても手間は変わらないか、むしろ関数化するほうが時間が 掛かるかもしれませんが、何度も調整したり、変更が予想される場合は 少しの変更で調整できて便利でした。 以上のような経験から、 デザイナ上で調整するのは、位置と、タブ順・コントロール名くらいで、 他のプロパティは基本的には自前のコードで設定するようになりました。
該当フォルダの参照権を持つアカウントの ユーザとパスワードが分かっていれば可能です。 特定の利用者にしか権限を与えないフォルダに システム情報を記録して、一般ユーザから保護 するという仕組みはよく見られる手法です。 LogonUserで権限ユーザのトーケンを取得し、 ImpersonateLoggedOnUseで偽装します。偽装中は フォルダを参照できます。 その後、RevertToSelfで偽装を終わり、処理後、 CloseHandleでトーケンを閉じます。 以下、サンプルです。 Const LOGON32_LOGON_INTERACTIVE As Long = 2 Const LOGON32_PROVIDER_DEFAULT As Long = 0 Declare Function LogonUser Lib "Advapi32" Alias "LogonUserA" _ 　　　　(ByVal ユーザ As String, _ 　　　　 ByVal ドメイン As String, _ 　　　　 ByVal パスワード As String, _ 　　　　 ByVal タイプ As Long, _ 　　　　 ByVal プロバイダ As Long, _ 　　　　 ByRef トーケン As Long) As Long Declare Function ImpersonateLoggedOnUser Lib "Advapi32" _ 　　　　(ByVal トーケン As Long) As Long Declare Function RevertToSelf Lib "Advapi32" () As Long Declare Function CloseHandle Lib "kernel32" _ 　　　　(ByVal ハンドル As Long) As Long Sub サンプル() Dim トーケン As Long Dim 処理結果 As Long '★トーケン取得 処理結果 = LogonUser("uuuu", ".", "pppp" _ 　　　　　　　　　, LOGON32_LOGON_INTERACTIVE _ 　　　　　　　　　, LOGON32_PROVIDER_DEFAULT _ 　　　　　　　　　, トーケン) If 処理結果 = 0 Then 　　　　MsgBox "ログオンできない" 　　　　Exit Sub End If '★偽装開始 ImpersonateLoggedOnUser トーケン '== '= ここで該当フォルダの処理を行う '== '★偽装終了 RevertToSelf '★トーケン解放 CloseHandle トーケン End Sub ※上記はローカルアカウントのuuuu/ppppの例です。 但し、フォルダ毎に権限者が誰か調べたりする 必要があります。尚、権限が設定されていないと、 Administratorでも何も出来ません。 これも調べる方法、破る方法はあるんですが、さすがに セキュリティに関することなので、一般公開できません。 ここまでするよりはエラーハンドリングで逃げたほうが マシかも知れませんね。
コントロールパネルの「地域と言語」で日付の形式は一緒ですか？
Private Sub Worksheet_Change(ByVal Target As Range) Dim FoundCell As Range If Not Application.Intersect(Target, Worksheets("Sheet2").Range("B1")) Is Nothing Then '範囲に含まれて無くない＝含まれてたら！ If Worksheets("Sheet2").Range("B1") <> "" Then Set FoundCell = Worksheets("Sheet1").Columns("A").Find(what:=Worksheets("Sheet2").Range("B1"), lookat:=xlWhole) If FoundCell Is Nothing Then MsgBox "個人番号が見つかりませんでした。" Else Worksheets("Sheet1").Select FoundCell.Activate FoundCell.Select ' "見つかったセルを選択" Dim ActiveRow As Long ActiveRow = ActiveCell.Row Worksheets("Sheet2").Range("B2") = Worksheets("Sheet1").Range("B" & ActiveRow) '通信費 Worksheets("Sheet2").Range("B3") = Worksheets("Sheet1").Range("C" & ActiveRow) '所属コード Worksheets("Sheet2").Range("B4") = Worksheets("Sheet1").Range("D" & ActiveRow) '会社コード Worksheets("Sheet2").Range("B5") = Worksheets("Sheet1").Range("E" & ActiveRow) '基本給 End If End If End If End Sub すごく遠回りした気もしますが、こんな感じでしょうか？（たぶんバグあります。） 一番簡単なのは、関数を使うことだと思いますよ。 B2に =INDEX(Sheet1!$A$1:$E$6,MATCH($B$1,Sheet1!$A$1:$A$6,0),MATCH(A2,Sheet1!$A$1:$E$1,0)) と入力して下にコピーしていけば出来ると思います。
> 具体的には複数選択したフォルダ（年月の名前が付いたフォルダ）が複数個あり （中略） > フォルダは年月の名前が付くフォルダなので１年分だと１２フォルダ、２年分だと２４フォルダになり名前も変わります（２０１４０３、２０１４０４、２０１４０５、・・・・） んーと、それだけ規則的にフォルダ名とファイル名がつけられているならば、複数フォルダの選択じゃなく > 年月の名前が付くフォルダ があるフォルダの選択（だけしか行わない）ボタンと処理年月区間の入力、それに処理実行ボタンを持つUIを作った方が楽なんじゃないかなと思いますが。 それなら、 For Z = LBound(処理年月区間) To UBound(処理年月区間) 　　　　対象フォルダ名 = 選択したフォルダ \ z の年月を文字列変換したもの 　　　　対象fileｓ = 対象フォルダ内のファイルの配列 　　　　　For Y = LBound(対象fileｓ) To UBound(対象fileｓ) 　　　　　　　　　　ファイルを開いてデータ収集 　　　　 Next Next というイメージでできると思いますが。
はい 「ADO.NET パフォーマンスの向上」 http://msdn.microsoft.com/ja-jp/library/ff647768.aspx#scalenetchapt12_topic15 「1 つの処理について Fill または Update を使う場合は接続を明示的に開かない。」 と書いてあります。
こんにちは！ ＞ある文字列を探し、その値がある行番号を知りたい ご質問の内容だとHLOOKUP関数等は適当ではないと思います HLOOKUP関数は指定した範囲で1行目データを検索値として、その列の何行目を返すか？という関数になります。 すなわち「何行目」はご自身で決める必要があります。 知りたいのは何行目にあるか？ですよね？ 色々やり方はあると思いますが、 ↓の画像のようなレイアウトだとG2セルに =SUMPRODUCT((A1:E6=G1)*ROW(A1:A6)) という数式を入れています。 画像で「つ」は範囲指定内の4行目にありますので、「4」という結果が返っています。 （データ範囲内に重複はない！という条件です） ※　的外れならごめんなさいね。m(_ _)m
質問の意図がよく分からないのですが、この条件なら算式で直接計算できます。 　セルD2: =MAX(CEILING(F2-(B2-C2),A2),0) モジュールを書くとcalcCyumon1のようになりますが、わざわざ分かりにくくしたようです。ユーザー定義関数にするのも何か間が抜けた感じです。（関数で計算できるので） シートのコードウィンドウに貼り付けています。 '// 直接計算 Sub calcCyumon1() 　　Dim rw As Long '行カウンタ 　　 　　rw = 1 　　With Range("A1") 　　　　While .Offset(rw, 0) <> "" 　　　　　　.Offset(rw, 3) = Application.Max(Application.Ceiling( _ 　　　　　　　　 .Offset(rw, 5) - (.Offset(rw, 1) - .Offset(rw, 2)), _ 　　　　　　　　 .Offset(rw, 0)), 0) 　　　　　　rw = rw + 1 　　　　Wend 　　End With End Sub 発注単位を条件を満たすまで追加するなら下のようになります。 マクロは実行する必要があるわけで、作り方によっては1件の再計算のために全件計算することになることもあります。この事例の場合は関数が便利に思えます。VBAの勉強のための事例ならまた別の話ですね。 '// 発注単位を追加 Sub calcCyumon2() 　　Dim rw As Long　　　　 '行カウンタ 　　Dim Zaiko As Double　　 '在庫 　　Dim Cyumon As Double　　'注文数 　　 　　rw = 1 　　With Range("A1") 　　　　While .Offset(rw, 0) <> "" 　　　　　　Cyumon = 0 　　　　　　Zaiko = .Offset(rw, 1) - .Offset(rw, 2) 　　　　　　While Zaiko < .Offset(rw, 5) '安全在庫未満 　　　　　　　　Cyumon = Cyumon + .Offset(rw, 0) 　　　　　　　　Zaiko = Zaiko + .Offset(rw, 0) 　　　　　　Wend 　　　　　　.Offset(rw, 3) = Cyumon 　　　　　　 　　　　　　rw = rw + 1 　　　　Wend 　　End With End Sub
「次のステートメントの設定」
1つの変数の宣言と初期化を1行で済ませたいのなら、 　Dim a As String : a = "○○" 　Dim b As String : b = "○○" 　Dim c As String : c = "○○" 　(以下略) と書くと多少はすっきりします。 そうではなく、「変数が多すぎて大変……」という話であれば、 1つのメソッドにいろいろと詰め込みすぎなのかもしれません。 設計を見直し、処理を複数のメソッドに小分けするといいでしょう。
Range(Cells(3, 1), Cells(GYO1, 18)).Copy　から察するところ シート１はA列からR列までデータがあるのですね？ Range(Cells(3, 1), Cells(GYO1, 18)).Copy ↑はシート１のA列の3行目からR列の最終行までコピーなので 最終行だけの一行コピーではなくボックスコピーになります。 貴殿のスクリプトをなるべくそのまま修正すると Sub copy_last_line2() Dim GYO1 , GYO2 As Long 'シート１の最終行 GYO1 = Sheets("Sheet1").Cells(Rows.Count, 1).End(xlUp).Row 'シート2の最終行の一行下 GYO2 = Sheets("Sheet2").Cells(Rows.Count, 1).End(xlUp).Row + 1 'シート1を選択 Sheets("Sheet1").Select 　　'シート１のA3からR列の最終行までコピー？このままだとボックスコピーになります。 　　'Range(Cells(3, 1), Cells(GYO1, 18)).Copy 'シート1のA列最終行からR列最終行を一行だけコピー Range(Cells(GYO1, 1), Cells(GYO1, 18)).Copy 'シート２を選択 Sheets("Sheet2").Select 　　'シート２のA列の最終行のセルを選択したい？ 　　'Range("A" & GYO2).Select 'シート2のA列の最終行のセルを選択 Cells(GYO2, 1).Select 'コピーした行をペースト ActiveSheet.Paste Application.CutCopyMode = False End Sub となりますが、いかがでしょうか？
> できればfile2を適当な名前で作った時にも値を持ってこられるようにしたいのですが、、、 もし、エクセルのファイルをfile1とfile2の2個しか開いていないのでしたら For i = 1 To Workbooks.Count If ThisWorkbook.Name <> Workbooks(i).Name Then file2 = Workbooks(i).Name End If Next i とすることで、どのようなファイル名でも対応できます。 複数開いている場合には、何をもってfile2だと判断できるのかによって対応が違ってきます。 たとえば、ファイル名に一定のワードを必ず入れてもらうようにするのでしたら、同じような感じで For i = 1 To Workbooks.Count If Workbooks(i).Name Like "*一定のワード*" Then file2 = Workbooks(i).Name End If Next i で対応できます。 もし、フォルダの中で一番新しいファイルと決まっているのでしたら i = 1 ChDir ThisWorkbook.Path f = Dir("*.*") file2 = f Do While f <> "" buf = f If FileDateTime(file2) < FileDateTime(buf) Then file2 = buf End If i = i + 1 f = Dir() Loop などのような手段があります。 > 参照という言い方が悪かったかもしれません(・・;) > 新たに作るfile2にはfile1で必要な値がいくらかあり、 > それを持ってきたいのです Range("A1") = Workbooks(file2).Sheets("Sheet1").Range("A1") みたいな感じでfile2の内容をfile1に持ってこれます。同一ファイルのセルの値をセルに代入するのと同じでWorkbooks(file2)でファイル名を追加するだけです。
C:\REAL\SYSFILE"を編集して"C:\REAL\SYSFILE_NEW"を作成（コード省略） SYSFILE_NEWを読み込んで最終行の番号を取得（コード省略） 　　　　　　↑ この部分に問題があるのでは？ どうやってるのかわからないんですが、例えばファイルを閉じてないためCopyFileでファイルが取得できないとか、そういったことはないでしょうか。
＞順番にやっていくとVlookupがうまくいっていないようです、、、 H = Application.WorksheetFunction.VLookup(a, .Range("B9:J13"), 3) は「aの中身の値が、B9～B13の中にあったら、あった行のD列の中身を取り出す」です。 取り出す場所はD列ではないのではないですか？H列から取り出さないといけない筈ですが？ 3つ目の引数の「３」は「左から数えて３番目から取り出す」を意味します。 ２つ目の引数で、セル範囲をB～Jの範囲で指定していますから、３つ目の引数は ０以下⇒実行時エラー（引数が範囲外） １⇒B列から取り出す ２⇒C列から取り出す ３⇒D列から取り出す ４⇒E列から取り出す ５⇒F列から取り出す ６⇒G列から取り出す ７⇒H列から取り出す ８⇒I列から取り出す ９⇒J列から取り出す 10以上⇒実行時エラー（引数が範囲外） となります。 検索対象の列がB列、取り出す場所がH列であれば、この式は H = Application.WorksheetFunction.VLookup(a, .Range("B9:H13"), 7) でなければいけません。 検索する範囲は「B9:J13」ではなく「B9:H13」で良い筈です。 取り出すのがH列ですから、取り出し位置は３ではなく７です。 たぶん、該当行のD列には「空白セル」がある筈です。なので、変数Hには「空（Null）」が入る筈です。 エラーも起きないし、何も入らなくて当たり前です。 ＞On Error GoTo 0 ＞これはどうなるのでしょうか？？ これの意味は「エラーがあったらエラーで止まれ」です。 どこかで「On Error Resume Next」と書いてあると、エラーが出てもエラーで止まらずに次のステートメントを実行してしまうので「エラーがあったらエラーで止まれ」って意味で入れます。 一応、On Error Resume Nextは、プロシージャが終了したら（Subが終了したり、Exit Subしたら）解除されますが、同じプロシージャ内のどこかでOn Error Resume Nextしてる可能性があるので、念のために入れてもらいました。
質問文ではどちらもセルB2になっていますが、B1とB2だと勝手に判断しました。 「A×30%+15000」のAの箇所をセルB2に入っている25000と言う値に変えて演算と言う意味で良いですか? こんな感じでどうでしょう。 Sub test() 　　sFormula = Range("B1").Value 　　nB2 = Range("B2").Value 　　sFormula = Replace(sFormula, "A", nB2)'「A」→セルB2の値 　　sFormula = Replace(sFormula, "×", "*")　'「×」→「*」に変換 　　MsgBox Evaluate(sFormula) End Sub
表を作り直してVlookupで十分です。 VBAでやるなら↓ MsgBox Application.WorksheetFunction.VLookup(225000, Range("A:B"), 2)
失礼しました。 2行目が開始行であるところを、1行目からと見間違え、 ご質問者の文章と画像が1行ズレていると勘違いしておりました。 ですが、C5、C6に1が入っていないように見えますが。 【関数で処理】 A2セルに「=IF(COUNTA(D$2:D2)=0,"",COUNTA(D$2:D2))」を入力して C6までオートフィル（コピー）してください。 【VBAで処理】 (1)エクセル関数を使用するなら Sub test1() Dim cnt As Long, i As Long, j As Long For i = 1 To 3 For j = 2 To 6 Cells(j, i).ClearContents cnt = WorksheetFunction.CountA(Range(Cells(1, i + 3), Cells(j, i + 3))) If cnt > 0 Then Cells(j, i) = cnt Next j Next i End Sub (2)数えるなら Sub test2() Dim cnt As Long, i As Long, j As Long, l As Long For i = 1 To 3 For j = 2 To 6 Cells(j, i).ClearContents For l = 1 To j If Cells(l, i + 3) <> "" Then Cells(j, i) = Cells(j, i) + 1 End If Next l Next j Next i End Sub
