例示されている商品テーブルの場合、商品コードが一意な値と言う事なのでシリアル型のカラムは不要でしょう。 一般的にシーケンスを使ったシリアル値は、1つのレコードを容易に特定する一意な情報が無い場合に使用します。 集合としてデータを抽出する場合はいいですが、1つのレコードを特定する一意な情報が無いと特定のレコードを更新したり削除したりと言った操作が煩雑になってしまいます。 例えば、顧客からの注文情報を扱う場合、注文データテーブルには注文1件毎の注文番号や顧客情報、注文日等の情報を記録し、注文明細テーブルに注文データテーブルのキーと商品コード、注文数、販売単価等を記録すると思います。 注文データテーブルでは注文番号をシリアル型にすると、人が採番する事なく自動的にユニーク値を割り当てられて重複した値を割り当てると言ったミスを無くせますし、注文明細テーブルだと明細一件毎にレコードを特定するキーが作れて、明細の内容を修正したい時などはDB操作がしやすくなり、誤ったデータ修正が発生しなくなります。
VBのほうに原因がありそうです。 SQL接続のタイムアウトの初期設定が15秒なのでSqlConnection.ConnectionStringのプロパティを変更して接続すると設定の延長、あるいは制限無効にできます。 このプロパティは読み取り専用になるので接続前にConnectionStringにて設定してください。 https://msdn.microsoft.com/ja-jp/library/system.data.sqlclient.sqlconnection.connectionstring(v=vs.80).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-1
mst_exam_result は tbl_result_interview を継承して作成されたテーブルではないでしょうか？ もしそうであれば、Update文で指定するテーブル名の前にONLYを指定することで、指定されたテーブルのみで一致する行が更新されると思います。 (試行される場合、念のため、動作をご確認のうえでの実施をお願いいたします。)
環境変数 PGUSER ではないでしょうか。 https://www.postgresql.jp/document/9.1/html/libpq-envars.html
できません。必ずストアドファンクションを作る必要があります。 以下の方法で、そのセッションだけで使用できる一時ファンクション (一時テーブルのファンクション版) が作れますので、これを使えば似たようなことはできます。面倒ですが、仕様です。代替手段があるだけマシと考えたほうが良いかと。 CREATE FUNCTION pg_temp.test(arg integer) RETURNS integer AS $$ BEGIN RETURN arg +1; END; $$ LANGUAGE 'plpgsql'; SELECT pg_temp.test(1); DROP FUNCTION pg_temp.test(integer); なお、Npgsql はライブラリ内部にコネクションプールを持つという特殊な仕様なので、利用される場合はご注意ください。デフォルトではコネクションを Close しても DB との接続は切断されません。
where句で論理積(AND)を取るようにすれば良いと思います。 論理積については以下URLを参考に頂ければと思います。 http://itpro.nikkeibp.co.jp/members/ITPro/ITBASIC/20020731/1/ ＞(1)１番左を１番目の質問として、１番目の回答に１がついている人数（上記の場合は１人） where (data & '1000000000')::int <> 0 ＞(2)３番目の質問に１がついているuser（上記の場合はBとE） where (data & '0010000000')::int <> 0
PostgreSQLではOracleと異なりDDLで自動コミットされないので、基本的にはBEGINとCOMMIT(またはROLLBACK)で囲むのが基本です。 今回のWARNINGは、すでにトランザクションが終了しているのにCOMMIT/ROLLBACKを発行したために発生しています。アプリケーションのコードパスでBEGINとCOMMIT/ROLLBACKが1:1対応になっていない箇所(ROLLBACKしているのにCOMMITもしている、など)があるのではないでしょうか？ また、今回のケースではテーブルが存在しないことが通常ケースとしてあり得るということのようなので、DROP TABLE IF EXISTS <table name>;というDDLを使うのが良いと思います。 ちなみに、PostgreSQLではトランザクション開始後にエラーが発生してもトランザクションは終了せずabort状態に遷移します。この状態では、COMMIT/ROLLBACK以外の全てのSQLがエラーになります。COMMIT/ROLLBACKを実行すると、どちらでもトランザクションはROLLBACKされて終了します。 https://www.postgresql.jp/document/9.3/html/tutorial-transactions.html
Microsoft Accessのクエリとかであれば SELECT seiseki.bangou, seiseki.tensu, seiseki.instime FROM seiseki INNER JOIN [SELECT seiseki.bangou, Max(seiseki.tensu) AS maxtensu FROM seiseki GROUP BY seiseki.bangou]. AS AQ ON (seiseki.bangou = AQ.bangou) AND (seiseki.tensu = AQ.maxtensu); で出来ます。 他のSQLでも、上記の応用で行けると思います。
こんな感じでいけるんじゃないかな。結果セットの列名はcol_id、col_time、col_titleになる。 select * from ( select A_id as col_id, A_time as col_time, A_title as col_title from table_A union all select B_id as col_id, B_time as col_time, B_title as col_title from table_B ) order by col_time desc limit 10 offset 0
PostGlSをさわったことがありませんが。 > ST_GeomFromText('POLYGON(( POLYGONのカッコが２重になってますが、1重にしたらどうなります？ 参考URLも見て下さい
＞　文字列を格納するフィールド型は可変長文字列型にした方がいいのか、固定長文字列型にした方がいいのかです。 varchar 型も可変長文字列なので varchar と text を比べても意味はありません。 固定長と可変長を比べるなら char と varchar を比べなければ行けません。 CPUの性能が良くなり、メモリの搭載量が増え、HDDの読込速度が上がった今となっては、char 型の優位性はあまりないと考えていいでしょう。 データの取扱量が多い環境では、char より varchar の方が資源の有効利用という意味ではメリットが多いかもしれません。 text 型はRDBMSによっては検索時の性能や制限に差があるので、必要最小限にするべきだと思います。 よほど大きな文字列が入る予定が無ければ、varchar(2000) といった感じで varchar 型で大きく取った方が使い勝手がいい場合があります。
> いろいろネットを調べてみると、PostgreSQLで日本語の検索をやるにはpg_trgmやpg_bigmを > インストールしないとダメなようなことが書いてあるのですが、私がやったことは誤っているのでしょうか？ 日本語の検索をするのにpg_trgmやpg_bigmのインストールが必須ということはありません。 これらは、PostgreSQL上で全文検索機能を提供するツールです。 これらを使うことで、spring3333さんが書いている中間一致検索のSQLに対しても、 インデックスを使って高速な検索が可能です。(これは、日本語、英語関係ありません。) 中間一致検索が多い場合は、こういったツールの導入も考えた方がいいかもしれませんね。 蛇足かもしれませんが、各検索方法にどういったインデックスが効くのかは以下のページを参考にされるとよいかと思います。 ●Let's PostgreSQL ～テキスト検索の方法とインデックス http://lets.postgresql.jp/documents/technical/text-processing/3/
postgreSQLのLPAD関数は引数の型が 文字列,数値,不定　となっています。 seq_noが数値なので、文字型でなければ いけないLPADの第1引数に指定すれば、 当然ですが、掲題のようなエラーになります。 関数の意味としては前ゼロを付けて、 shiyo_ketaの示す長さでseq_noを表現 したいのではないかと思います。 lpad()の代わりに、以下の方法を使って 見てください。 to_char(seq_no,repeat('0',shiyo_keta))
INNER JOINに書き換えたのが以下。 q1クエリ SELECT date, Sum(num) AS num, date1, date2 FROM (SELECT Table1.date, Table1.num,Table1.date-1 as date1,Table1.date-2 as date2 FROM Table1 union SELECT Table1.date-1, 0 as num,Table1.date-2 as date1,Table1.date-3 as date2 FROM Table1 union SELECT Table1.date-2, 0 as num,Table1.date-3 as date1,Table1.date-4 as date2 FROM Table1) GROUP BY date, date1, date2; 結果クエリ SELECT q1.date, q1.num+q1_1.num+q1_2.num AS sum_num FROM (q1 INNER JOIN q1 AS q1_1 ON q1.date1 = q1_1.date) INNER JOIN q1 AS q1_2 ON q1_1.date1 = q1_2.date WHERE q1.num<>0;
　……belong_cat_3='10086', belong_cat_4='' ,goods_id='1000402' or …… の部分って 　……belong_cat_3='10086', belong_cat_4='' where goods_id='1000402' or …… だったりしませんか？
month でグループ化しないと、opencoursesテーブルに有る分の行数が出力されますね。 グループ化すると、CASE式を入れ子にする必要が出てきますが。 SELECT month AS 開講日 ,CASE WHEN SUM(CASE WHEN course_name = '経理講義' THEN 1 ELSE 0 END) > 0 THEN '○' ELSE '×' END AS 経理講義 ,CASE WHEN SUM(CASE WHEN course_name = '財務講義' THEN 1 ELSE 0 END) > 0 THEN '○' ELSE '×' END AS 財務講義 ,CASE WHEN SUM(CASE WHEN course_name = '簿記講義' THEN 1 ELSE 0 END) > 0 THEN '○' ELSE '×' END AS 簿記講義 ,CASE WHEN SUM(CASE WHEN course_name = '税理講義' THEN 1 ELSE 0 END) > 0 THEN '○' ELSE '×' END AS 税理講義 FROM OpenCourses AS OC INNER JOIN CourseMaster AS CM ON OC.course_id = CM.course_id GROUP BY month ORDER BY 1 ;
http://www.postgresql.jp/document/9.3/html/sql-select.html 名前 as 別名 の as は省略可能です。(こういう記法では、 []でかこった部分は省略可能を意味します) つまり yamato_order_info as yo と同じです。 IN については http://www.postgresql.jp/document/9.3/html/queries-table-expressions.html#QUERIES-WHERE http://www.postgresql.jp/document/9.3/html/functions-subquery.html#FUNCTIONS-SUBQUERY-IN
要件がおかしくない？ 例示データならＤよりＥが先と思います。 あと、テーブル名、列名も決めておいてね。TABLE、IDとNAMEとします。 Select NAME From ( Select NAME，Max（ID) as MAX_ID From TABLE Group by NAME ) Order by MAX_ID DESC ;
>時系列が抜けている 抜けている年度の値はどうするのでしょう？ 例： 1993 56 1994 55 1995 ?(抜け) 1996 ?(抜け) 1997 53 1997は２年連続減少？ ２年連続減少とは限りませんが。 （抜けが0だと考えると、２年連続減少ではない。データのある年度でいうと２年連続減少である。） というのを気にしないで、単にあるレコードのみで判定するのなら、 前々のレコードを調べたいなら、 (select max(year) from sales2 s3 where s1.year > s3.year)) で求めたmax(year)より小さいmax(year)を求めれば出てくるわけですから、 select year,sale from sales2 s1 where sale >=(select sale from sales2 s2 where s2.year = (select max(year) from sales2 s3 where s1.year > s3.year)) or sale >=(select sale from sales2 s2 where s2.year = (select max(year) from sales2 s3 where (select max(year) from sales2 s4 where s1.year > s4.year) > s3.year) ) order by year ; で求まります。 (未検証ですが。)
文字コードがおかしいんじゃないでしょうか。 DreamWeaverじゃなくて、例えばサクラエディタで開いてみたらどうでしょう。そして元のファイルはEUC-JPになっているでしょうからそれをUTF-8で保存します。そしてFileZillaのところからやり直してみるといいでしょう。 とにかく、pg_dumpで出力されたファイルの中身をEUC-JPからUTF-8に変換してからpsqlで取り込むと良さそうかと存じます。
select s.year, s.sale from sales s join sales s1 on s1.year = s.year -1 　　　　　　　　join sales s2 on s2.year = s.year - 2 where s1.sale > s2.sale and s.sale > s1.sale order by year で、行けそうな気がしますけど。 　書いてないことで推定した条件は、 　　yearフィールドには重複が無いこと。又は、適切な条件で一意化が出来ること。（この場合は、条件の付加が必要です。） 　　yearが初出又は、２年目の登場の場合には、２年前との比較のしようがありませんので、このような年度は表示しません。 　 　やっていることは単純です。内部結合を使って 　year, sale, year(-1), sale1(-1), year(-2), sale(-2) 　という構造の結合テーブルを構成し、単純に二年前と前年、前年と今年の比較をしているだけです。
"Base Directory"そのものにも空白があります。 そのため、 (略)DO IF "%%A %%B"=="Base Directory"(略) と指定しないと見つからないようです。 "Program Files"の空白の処理が面倒な気がします。 "ProgramFiles"とかにインストールされていると空白の数が違ってきますので。 コマンドプロンプトで REG QUERY "HKEY_LOCAL_MACHINE\SOFTWARE\PostgreSQL\Installations\postgresql-9.0" /v "Base Directory" を実行して結果を見るとわかりやすいです。
> これの何がいけないのでしょうか？ ---------------------------------------- 1【TAB】aaa 2【TAB】bbb 3【TAB】ccc \. ---------------------------------------- の部分がCOPYコマンド向けのデータそのものであり、psqlの入力として正しくない為、エラーとなっています。 リストアの際には下記の様なコマンドを実行するかと思います。 　psql リストア先のDB < pg_dumpで出力したファイル これは、pg_dump で出力した内容をpsqlが標準入力から受け取って実行する事になりますが、 　copy tb1 (item1, item2) FROM stdin; の行を受け取って実行すると標準入力からのデータをCOPYコマンドの入力として受取る状態になります。したがって、その後に続く行はCOPYコマンド自体の入力として扱われ、SQL文としては処理されません。\.に到達するとCOPYコマンドはデータが終了したと判断し、標準入力の受け取りを止め、それまでのデータをテーブルに挿入して終了します。 \.の次の行からは、再びpsqlが標準入力の内容を直接処理する事になります。 http://www.postgresql.jp/document/9.3/html/sql-copy.html
select * from hoge order by id limit 10 offset 45 これで、45行目から10行分返します。普通は select * from hoge order by id limit 10 offset 0 select * from hoge order by id limit 10 offset 10 select * from hoge order by id limit 10 offset 20 select * from hoge order by id limit 10 offset 30 と言う風にlimitずつoffsetをずらして取得する事でしょう。
No.1です。 追加です ＞#psql --version でバージョンが出力されるなら、 which psql と入力してみてください。psglのある場所が表示されます。 その周辺をみて削除してみてください。 先にも書きましたように使い始めたところでしたら、初期化を強くお勧めします。
PostgreSQLでは空文字列とNULLは区別されます。空文字列が入った項目は「IS NULL」では抽出されません。
LINUXのnkfコマンドを使って、pg_dumpしたファイルをS-JISに変換出来ます。 （例） nkf -s 入力ファイル名 > 出力ファイル名 それ以前の問題として、pg_dumpしたファイルを英訳なんて無茶苦茶ですね。 psqlのcopyコマンドでテーブル毎にCSVファイル出力可能です。 これをnkfコマンドでS-JISに変換し、PCにftpする方が現実的でしょう。
> Npgsqlではフェッチは使えないのでしょうか？ できますよ。 http://msdn.microsoft.com/ja-jp/library/9kcbe65k(v=vs.110).aspx 別にNpgsqlに限った話ではなく、こういうライブラリはよっぽど独自 実装してない限り、大抵DbCommand、DbDataReaderを使うのと一緒です。 継承元クラスを直接利用するならば、 Dim con As NpgsqlConnection ' コネクションがある前提 Dim command As NpgsqlCommand = con.CreateCommand() Dim r As NpgsqlDataReader = command.ExecuteReader() Do While r.Read() 　Console.WriteLine(r.GetString(0)) Loop r.Close() command.Dispose() こんな感じに。 DB操作がわからないなら、System.Data.Common内のクラスを見るなり、 それぞれのメソッドを見るなり、他サイトでクラスやメソッド単位で調べるなり すれば解決すると思います。 Npgsqlのクラスのほとんどは、このクラスを継承して実装が行われています。 http://msdn.microsoft.com/ja-jp/library/System.Data.Common(v=vs.110).aspx Npgsqlのクラス名を知りたければ、CHMファイルがあります。 http://pgfoundry.org/frs/?group_id=1000140
使ったことは無いのですが、phpPgAdmin 自体が php で動くスクリプトだと思います。 php とついているように。 実際ウエブサーバに置いたりして活用するようですし、ウェブサーバも必要ですね。 私のサイトにスキャンを仕掛けてくる人が定期的に存在しますし。
ストアドファンクションを作ってください。 8.1でもsplit_part関数は使用できるようですから、 これで数値部分を取り出して加算していけばいいかと思います。 まあ、カンマの数が例えば最大で10個とか決まっている場合は、 split_part関数を利用して力技でSELECTだけで完結させることもできそうですね。
http://pgfoundry.org/frs/?group_id=1000140
失礼しました。 COUNT(*)だと表2にレコードが存在しない場合も表1の1件を返してしまうので COUNT(*)　→　COUNT(表2.id_no) に変えてみて下さい。
ひょっとしてカタカナの部分は元々半角文字で、 質問を投稿する際に全角になってしまっているのでしょうか？ そうであれば濁点も半濁点も１文字ですので、 LIKE１回で絞り込むことはできないような気がします。 チルダをつかって正規表現でマッチさせるのではだめでしょうか？ column_1 ~ 'カルヒ([^゛゜].*)?$'
であれば、やはりcommitされていないか、どこかでrollbackされているということぐらいしか思い当たりません・・・ executeBatchではなく、executeUpdateで1件だけInsertした場合はちゃんと登録されるのですよね？
select * from ( select * from [DB名] where [ユーザID]='1111' order by [更新日] desc limit 3) where [パスワード] = 'test' って感じでしょうか。 手元にテスト環境が無いので未検証です。
私も大した差は無いと思います。 ただし、回線速度の遅いネットワーク越しにDBへ接続している場合などは、転送量が増える分、クライアント側でのターンアラウンドタイムにはそれなりの差は出てくるでしょう。 PostgreSQLでSQLのパフォーマンスを測りたい場合、下記の様に EXPLAIN (ANALYZE, BUFFERS) を付けてSQLを実行すれば、実行時間やバッファのヒット数などが分かります。 (DBMS内部での処理の分だけです。ネットワークの転送時間やクライアント側での処理時間などは含まれません。) EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM test; EXPLAIN (ANALYZE, BUFFERS) SELECT key FROM test;
こんにちは。 カラム | 型 | 修飾語 -------------+-----------------------------+---------- updatetime | time with time zone | not null value | integer | updatetime2 | timestamp with time zone | updatetime3 | timestamp without time zone | 上記のカラム構成で select * from mast where updatetime3 = '2013-07-26 12:07:13' を実行すればその該当レコードが取れてます。 何か他に条件入ったりしてないですよね。
> nameの入力が5件あるので、５回同じような検索をする、ということです。 なるほど、意味がわかりました。 それなら5つのnameを一度に検索すれば済みますね。 （発行すべきクエリは＃４の回答がそのままその通りでしょう） そのかわり、ロジックが面倒になると思います。 感覚的に、 　１．SQLを発行してResultSetを取得 　２．SQLの結果を専用クラスかなんかに突っ込んで、それをHashMapなどsnameをキーにして格納 　３．探す時に、２．ので作った変数に対して、HashMap.get(sname)で求める こんな感じになる気がしますが、どうなんでしょう？ ロジック内で余計なループをする必要が出てくるなら、 検索スピードが速くなっても、レスポンスタイムも速いとは限りませんよね。 クエリを投げるよりロジックで頑張る方が遅いっていうのも往々にありますし。 AppサーバとDBサーバが分かれていて、絶対的な制約として、極力ネットワーク通信をしない、 Appサーバの処理性能に任せるというコンセプトならSQL一発ってのが正解かも しれませんが。 こんな些細な部分に、それをやるほどの意義があるのかと言うと甚だ疑問です。 仮にその検索がいちいち遅いとすると、そもそもプログラムではなくDBの問題のような。
tarコマンドで.tar.gzにした、ということは、 tarでアーカイブ(複数のファイルを一つの書庫に入れる。無圧縮ZIPみたいなもの)した後、gzipで圧縮した状態になっています。 pg_restore -U postgres -d (データベース名） < ****.tar.gz では、その圧縮されたままの入力になるので、不正となります。 gunzip -C ****.tar.gz | pg_restore -d (データベース名） これでも、 gzipの展開はされていますが、tar形式のアーカイブになっています。 元のダンプファイルではありません。 pg_restoreで使うためには、アーカイブの中にあるファイルを取り出す必要があります。 GNUtarの場合、 -Oオプションで標準出力に出力、というのがあるので tar -O zxvf ****.tar.gz | pg_restore -d (データベース名） でできるかと思います(実験はしていません) 本来のtar等、標準出力オプションが無い場合は、 tar.gzから元のダンプファイルをファイルに展開→そのファイルをpg_restore となります。 そもそも、tar+gzipでアーカイブして圧縮するのが間違いです。 単にgzipで圧縮すればいいでしょう。そうしていれば gunzip -c ****.gz | pg_restore -d (データベース名） で使えたはずです
おそらくSQL文の間違えになると思います。 update "store_table" set "tenpo_post1" = '123', "tenpo_post2" = '4321', "tenpo_add" = '東京都１－１－１' where "kaiin_no" = '123456'; 上記のように１つ１つ値を設定するような形が、 複数項目をUPDATEする場合の記述になります！
#1です。 > default_transaction_read_onlyをoffで設定してみたのですが、動作は変わりませんでした。 postgresql.conf ファイルに設定を追加したという事でしょうか？ 何も設定していなければ、default_transaction_read_only は off になるはずです。 また、ある場所で off に設定しても、それより優先順位の高い場所で on に設定していれば on になります。 http://www.postgresql.jp/document/9.2/html/config-setting.html ですので、先の回答の意図は、 default_transaction_read_only を on に設定している箇所がどこかにないか確認して、もし有ったら除去した方が良いですよ、ということでした。 もちろん、問題のトランザクションが明示的に READ ONLY にされていてもダメですので、念の為にそれも確認した方が良いかも知れません。 確認の手順としては↓の様になるでしょうか。 1. そのトランザクションの開始時に READ ONLY が指定されていないか確認し、されていたらそれを除去する。 2. そのトランザクション中に SET TRANSACTION で READ ONLY が設定されていないか確認し、されていたらそれを除去する。 3. その接続中に SET コマンドで default_transaction_read_only が on に設定されていないか確認し、されていたらそれを除去する。 4. 下記の全ての箇所について、パラメータ default_transaction_read_only が設定されていないか確認し、されていたらそれを除去する。 　a. postgresql.conf ファイル 　b. 環境変数 PGOPTIONS 　c. 起動時のコマンドラインオプション (コマンド postgres または postmaster) 5. それでもダメなら、そのトランザクションの開始時に READ WRITE を指定してみる。 　例) BEGIN READ WRITE;
>yumでインストールできるような事を書いているのもありましたが、 >yum list 上にpgadmin3は見当たりません。 epelのリポジトリにあるみたいですが。 epelのリポジトリを追加する方法は…まぁ、難しくないですから検索して調べてみて下さいな。 # epelだけで依存関係がクリアできるかどうかは…試していないので不明ですが。 # CentOS5.xでやっている例だとrpmfusionのリポジトリも追加しているところもありますし。
レプリケーションの状態を確認するためには、 マスタのDBに接続し、 SELECT * FROM pg_stat_replication; のSQLを実行すると、マスタのレプリケーション状態の確認ができます。 その際、stateがstreamingをとっていれば、正常にレプリケーションができていると考えられます。 また、PostgreSQLのデフォルトのログ位置は、 /var/log/postgresql になるようですので、 マスタ、スレーブ両DBのログを確認いただくと、 エラー内容が分かるかと思います。 http://www.postgresql.org/docs/9.1/static/runtime-config-logging.html おそらく上記のどこかでエラーが確認できるかと思いますので、 エラーログにしたがって対処するのがよいかと思います。
http://www.itmedia.co.jp/enterprise/0307/18/epn20_10.html 上記に更新SQLのサンプルが掲載されています。 答えを直接誰かに教えてもらうより、サンプルを見て自分でSQLを組み立てられるようにした方が力がつきますよ。
selectの文法には無いと思います。プログラムを作ってテーブル情報からSELECT文を組み立てて実行する方法を取れば可能です。テーブル一覧はpg_classで列名はpg_attributeに有ります。
> 通常のエディタで開くことはもちろん、手作業で行うことは気が遠くなってしまいます。 そういうことでしたら、思いつくのは下記の様な方法でしょうか。 a. pg_dumpall ではなく pg_dump を使ってダンプする 　元のDBに接続でき、現在の状態のリストアでよいならば、この方法が簡単でしょう。 　例) pg_dump -h localhost -p 5432 -U user_hoge -t table_hoge db_hoge > dump.txt; http://www.postgresql.jp/document/9.2/html/app-pgdump.html b. スクリプト言語を使って対象のテーブルの箇所を抽出する 　perl や ruby などを使えば、対象部分を抽出するプログラムが割りと簡単に作れるかと思います。 c. サイズの大きいファイルも扱えるエディタを使って抽出する 　例えば、 vim などではサイズが大きくてもさほど不自由なく編集はできたと思います。 　検索機能で該当箇所への移動・選択を行い、新旧の2ファイルを開いてコピーすれば良いかと。
エラーメッセージを見ると、org.apache.commons.dbcp.BasicDataSourceFactory がロード出来なくてエラーになっているようです。 ドキュメントの設定例に factory 属性は書かれていないようですですので、 factory 属性を取り去って試してみては？ http://tomcat.apache.org/tomcat-7.0-doc/jndi-datasource-examples-howto.html もしくは、factory 属性の値を↓にしてみては？ org.apache.tomcat.dbcp.dbcp.BasicDataSourceFactory
ロケール(lc_ctype)の設定とロケールライブラリの実装に依存します。 日本語のロケールであればロケールライブラリの実装に依存しますが、少なくとも手元のLinux環境ではupper関数で全角アルファベットの小文字を大文字に変換できます。 現在のロケールは以下のSQLで確認できます。 =# SHOW lc_ctype; lc_ctype ---------- C (1 行) Cというのはロケールなしの状態です。これが日本語のロケール(ja_JP.文字コード)になっていれば全角アルファベットでも変換できます。 PostgreSQL 8.4以降であればデータベースごとにロケールを指定できます。以下のSQLで日本語のロケールを指定してデータベースを作成できます。 =# CREATE DATABASE test TEMPLATE template0 LC_CTYPE 'ja_JP.UTF8'; CREATE DATABASE 日本語のロケールのデータベースに接続し、upper関数を実行すると全角アルファベットでも大文字に変換できます。 =# \c test You are now connected to database "test". =# SELECT upper('ａ'); upper ------- Ａ (1 row)
.pgpassで出来ると思います。詳しくはこちらを参照してください。 http://www.postgresql.jp/document/9.2/html/libpq-pgpass.html バックアップのトリガがクライアントというのが理解に苦しむのですが、サーバでcron動かしちゃダメなんでしょうか？ しかもバックアップファイルがローカルに出来ちゃいますよね。 ビックデータになった場合、下手するとパンクしそうですが大丈夫なんでしょうか…。
PostgreSQL が Windows に直接インストールできるように なったのは、バージョン 8 からです。 バージョン 7 以前は、『 Cygwin (シグウィン) という UNIX ライクな環境を Windows にインストールし、その Cygwin 上で PostgreSQL を動かす』 という、手の込んだことが 必要です。 具体的な方法は以下の参考URLを見てください。
行末には必ず区切り文字が存在するのでしょうか？ 案1A： 　　1.　COPY先テーブルの最後に 1列ダミー列を追加し、 　　　　COPY実行。 　　2.　COPY実行後に追加したダミー列を削除。 案1B： 　COPY先テーブルにダミー列を入れるのが嫌なら、 　　1.　COPY専用のテーブル (テーブルの最後にダミー列を 　　　　入れたもの) を別に作って、そこにCOPY実行。 　　2.　COPY専用テーブルからCOPY先テーブルに 　　　　INSERT ～ SELECT ～ でデータを移動。 　　3.　COPY専用テーブルを DROP。 案2： 　問題のファイルがテキストであるならば、テキストエディタの 　正規表現置換を使って行末の | を空白に置換。 　検索文字　|$　置き換え文字 (空白) で行けるはず。 　テキストエディタは何でもよいですが、サクラエディタ等が 　使えます。 　http://sakura-editor.sourceforge.net/download.html 自分なら、データ量にもよりますが、案1B を使いそうな気が します。(COPYファイル数が多かったりすると案2は面倒なので)
PL/pgSQL であれば、INSERT/UPDATE 操作によって更新された新しい行の値を NEW.～～～ という形式で参照できます。 http://www.postgresql.jp/document/9.2/html/plpgsql-trigger.html パーティショニングの際の INSERT に対するトリガーの設定も参考になるかと思います。 http://www.postgresql.jp/document/9.2/html/ddl-partitioning.html#DDL-PARTITIONING-IMPLEMENTATION
DELETEの書き方は下記の方法ですので間違えないで下さい。 DELETE FROM [ ONLY ] table [ WHERE condition ]
最新のバージョン9.2であっても、PL/pgSQL では SELECT INTO は使用できません。(下記ページの注釈参照) http://www.postgresql.jp/document/9.2/html/sql-selectinto.html したがって、SELECT INTO の様なことを行う場合は CREATE TABLE AS に書き直してやる必要が有ります。 また、PL/pgSQL 内で動的にSQLを生成して実行する場合は EXECUTE を使う必要性が有るようです。 http://www.postgresql.jp/document/9.2/html/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN 例) BEGIN EXECUTE 'CREATE TABLE ret_val AS SELECT * FROM ' || t_name::regclass || ' OFFSET ' || ofs_num || ' LIMIT ' || lmt_num; END;
列に対して primary key や unique を指定すれば，システム側で決めたindex名で自動的にindexが作られます。ご指摘のような機能はすでにあるわけです。 http://d.hatena.ne.jp/sternheller/20090717/1247853538 > なぜindex名をこちらが名前を指定するようになっている？ 索引がオブジェクトだからでしょう。 > 表も索引もそれぞれ別物として実装しているのですよね。 > 索引を削除せずに，索引を表から切り離すこともできるし， > 索引を再び表に紐付けることもできる。 > だから，索引はオブジェクトと呼ばれるのが適切なわけです。 http://okwave.jp/qa/q6879675.html の私の回答ANo.5 表に大量の行を挿入する際，索引が付いたままだと処理が遅くなるので，いったん索引を外し → 行を挿入し → 再び索引を付け直す（挿入後の全行に対してまとめて索引を更新し直す）という処理をおこないます。あと，列名というのは決めたが最後 変えられないものではなく，後から変更も可能な名前です。 これらの例を通じてみても，索引というのは指定したある列名にいつも紐付けられている存在ではないですね。 index名が無指定の場合，create index が既定のindex名を与えてくれるような言語仕様にするならするでもいいのですけれど， ANo.1にもあるように，であるなら， table名が無指定の場合，create table も既定のtable名を与えてくれる方が，言語仕様として統一が取れていると思います。
こんにちは！ すでにSiegrune様よりいい回答が出ておりますので ご質問の回答だけさせていただきますね。 > とても初歩的なご質問で恐縮なのですが、LPADでNoを+1して埋める件ですが > ぱっと思いついたのがMAXで最後の数字を取得することだったのですが > LPADの方がスマートだということでしょうか？ SELECT MAXだとSELECT文が2つ入る形になってしまい 見辛いかな？…と思って上記関数を使用しました。 （そうせねば実現不可とか、速度的にということであればやりますが…） 特にスマートとかではありませんが、 この程度のSQLであればそこまで性能を求めなくても 見やすさ優先でいいかな？…という安直な考えです。 深い意図はございませんので(^^; > それから、WHEREで他から取得するのと、分かっている内容なので > 普通にVALUEで書いてしまうのとはどちらの方が良いのでしょうか？ 今回の場合であればどちらでもいいと思います。 NOだけでPKになる構造のようですし。 これが更新者ごとにNOをインクリメントしていくとか 名前ごとに…となった場合、いちいちNOを探すのは面倒ですよね？ そんな時WHEREから取得するようにしておけば 事前にSELECTをかけなくて済むから楽なワケですよ。 要するに、ある程度汎用性があるように書いてみたというところです。 > 範囲を付けないと永遠に追加されていくのではないかと思われます 1回の実行で1行しか入らないと思ってましたが…。 あ、NOが範囲外になる可能性のことですか？ それなら間違いないです(汗) 汎用的になってる分、範囲の設定は必要でしょうね。 （if NO < 30 thenみたいな設定もあれば適当にコピペでも問題なさそうです） プログラム全般そうですが、実現方法は本当に色々ですよね。 色んな引き出しが作れるようにガンバっていきましょう！
SELECT * FROM スキーマA.テーブルA a, スキーマB.テーブルB b WHERE a.カラム1 = b.カラム1 AND (a.カラム2 <> b.カラム2 OR a.カラム3 <> b.カラム3 OR a.カラム4 <> b.カラム4) こんな感じでいかがでしょうか。
こういうことでしょうか。 select A.uriage from A inner join B on (A.data like '%' || b.data || '%') where A.month = 1 and b.day = 5;
SELECT * FROM M_SHOHIN WHERE code = ANY( SELECT code FROM M_SHOHIN WHERE class_code = '01' );
WAL アーカイブを有効にして、ベースバックアップを取得、archive_command でベースバックアップ後の WAL を自動バックアップすればよいようです。archive_command で scp を使ったり、コピー先を NAS にしたりすれば別サーバにバックアップデータを退避できます。 バックアップは復旧できてなんぼのものですから、取得したバックアップデータからきちんと復旧できることも確認してください。
SQLは論理的に考えないとできません。 先ずIDは一意だと仮定します。 品番毎に順位を付けるとすると、以下の 理論になります。 (1)品番が同じである。 (2)あるレコードから見て、自分より金額が大きいか、 　金額が等しく日付が小さいレコード数を数える。 (3)上記で数えた数値が0なら自分が1位、1なら2位 　2なら3位である。 ということで、順位を見つけるクエリがこちら SELECT A.品番,A.ID,MAX(A.金額) 金額Z FROM 参照テーブル A LEFT JOIN 参照テーブル B ON A.品番=B.品番 AND (A.金額<B.金額 OR (A.金額=B.金額 AND A.日付>B.日付)) GROUP BY A.品番,A.ID ORDER BY A.品番,COUNT(B.ID) 1位のレコードなら以下の条件にすればよい。 HAVING COUNT(B.ID)=0 よって、COUNT(B.ID)が0、1、2のものを抽出する クエリを品番で結合して並べればよいのです。 SELECT A.品番,A.ID,A.金額Z,B.ID,B.金額Z,C.ID,C.金額Z FROM ((SELECT A.品番,A.ID,MAX(A.金額) 金額Z FROM 参照テーブル A LEFT JOIN 参照テーブル B ON A.品番=B.品番 AND (A.金額<B.金額 OR (A.金額=B.金額 AND A.日付>B.日付)) GROUP BY A.品番,A.ID HAVING COUNT(B.ID)=0) A LEFT JOIN (SELECT A.品番,A.ID,MAX(A.金額) 金額Z FROM 参照テーブル A LEFT JOIN 参照テーブル B ON A.品番=B.品番 AND (A.金額<B.金額 OR (A.金額=B.金額 AND A.日付>B.日付)) GROUP BY A.品番,A.ID HAVING COUNT(B.ID)=1) B ON A.品番=B.品番) LEFT JOIN (SELECT A.品番,A.ID,MAX(A.金額) 金額Z FROM 参照テーブル A LEFT JOIN 参照テーブル B ON A.品番=B.品番 AND (A.金額<B.金額 OR (A.金額=B.金額 AND A.日付>B.日付)) GROUP BY A.品番,A.ID HAVING COUNT(B.ID)=2) C ON B.品番=C.品番 ORDER BY A.品番 PostgreSQLなので、英大文字や漢字のフィールドの 名前は""で囲まないとダメかも知れません。そこは 臨機応変にやってください。 ★金額も日付も同じものは無いという前提です。 仮にこれがあると、1位のレコードが2個になり、 COUNT(B.ID)=0のデータは無くなります。 この場合は結合条件に金額と日付が同じならIDの 小さい方を数えるように条件を追加してください。
http://blogs.yahoo.co.jp/kensinisnek/10176003.html 9. 以下のメッセージが出力されたら、接続は成功ですので、「OK」をクリックしてください。　他のメッセージが表示される場合、何かしら設定に問題があると思われます。 の画面は出ましたか？
SELECT Code, MIN(Name) FROM tbl GROUP BY Code ORDER BY 1 です。
もう10日以上前なのでご覧になっていないかも、ですが。 .exeと言う事はDBサーバーはWindowsですね。 SQL Serverでは標準で使える機能ではありますが（推奨はされていませんが）、PostgreSQLのトリガーで使用するPL/pgSQLでは面倒な手順が必要です。 （商用のORACLEの場合も同様） まず、使うのはPL/pgSQL以外に、この場合、C言語も必要です。 C言語関数 http://www.postgresql.jp/document/8.3/html/xfunc-c.html 但し、ご自分で検索されるとわかると思いますが、ほぼ全てのサンプルはUnix/Linuxです。 （と言うかWindowsの例は探せませんでした） DBを操作するアプリケーションを作成されているのであれば、そちらで行った方がよいと思います。 私自身は、PostgreSQLではありませんが、以前、ORACLEで外部コマンドを実行する処理を作った事があります。 （方法は上記リンクと似たような感じで、やはりC言語でライブラリをコンパイルする必要があります） Cに関しては初心者ではありませんが、正直、サンプルレベル以上の、仕事で使えるレベルにするにはかなりハマるな、と思いました。 Windowsだと権限周りも面倒そうなので、更にハマる事、必至だと思います。 （何より事例が少ない） それと、もし 「DBサーバーはUnix/Linuxだが実行したいexeはリモートのWindows上」 と言う事でしたら、もはやトリガ内で何かする、と言うのはあり得ません。 （私が上司なら即座に却下します）
UPDATE テーブル名 SET ID_TMP=ID_INFO で全レコードに対し処理されます。
こんなことすると出来るっぽいですよ。 select id, name, array_to_string (array(select b.goal from tbl b where b.id = a.id order by b.goal), '、') as strAgg from tbl a group by a.id http://www.geocities.jp/oraclesqlpuzzle/postgresql/postgresql-memo.html
>vb.netからpsqlコマンドの実行がそもそも可能なのかどうか、 >(Linux上のpsqlコマンドなのだから、vb.netから実行できない？) vb.netからサーバのLinux上のpsqlコマンドを実行できたとして、 （多分、大抵の人にはできない。 　Linux上にアプリを常時起動しておいて、vb.netのアプリと会話してpsqlを起動するという 　大変面倒な方法ができる人なら別ですが。） >copyコマンドを使用して、クライアントにあるcsvファイルのデータを >DBテーブルに一括登録したいと考えております。 ということは、Linuxから、クライアントのWindows7のファイルにアクセスしないといけない ということになります。 （これはさらに大変では？ 　ftpかなにかでファイル転送してLinux上に格納したファイルを処理すればできるかもしれませんが、 　コード変換とかどうするのだろう。。。） ということで、 Windows版のpsqlを使ったらどうでしょう？ 以下のＵＲＬ参照。 http://www.psn.ne.jp/support/database/psql.html 但し、ざっとみただけでは、Windows7対応済みかどうかはよくわかりませんでした。 もし使えるなら、クライアント上でpsqlが動かせるので、バッチファイル等にしておくと vb.netから起動できるはずです。
これとか？ http://lets.postgresql.jp/documents/technical/backup/3
8.3.1 からのアップグレードという事ですよね。 簡単に言うと、8.3.19 へのバージョンアップはバグフィックスのみ、9.1.4 へのバージョンアップは大幅な機能追加・性能改善を含みます。 ■ 8.3.19 への移行 ・バグやセキュリティの改善のみでアプリケーションの動作への影響は無し。 ・機能・性能的な変化も無し。 ・移行作業は楽。今までのデータディレクトリがそのまま使える。 　http://www.postgresql.jp/document/8.3/html/install-upgrading.html ■ 9.1.3 への移行 ・大幅な機能追加・性能改善がされている。(詳細は最後の方のリンク先を参照) ・デフォルトの動作が変わっている部分もある。 　→ ただし、設定によって8.3系と同じ動作にする事は可能。 　　http://www.postgresql.jp/document/9.1/html/release-9-1.html#AEN107104 ・移行作業では基本的にデータのダンプ・リストアを行う必要がある。 　http://www.postgresql.jp/document/9.1/html/upgrading.html 　→ ただし、pg_upgrade というツールを使えば少し時間が短縮できる。 　　http://lets.postgresql.jp/documents/technical/contrib/pg_upgrade 　　http://www.postgresql.jp/document/9.1/html/pgupgrade.html 偶然ですが、私が関わっているシステムも先日8.3系から9.1系にアップグレードしました。 移行作業でデータがきれいになった影響もありますが、目に見えて速くなりましたよ。 ■ 参考 PostgreSQL 8.4 の新機能 http://lets.postgresql.jp/documents/technical/8.4/ PostgreSQL 9.0 の新機能 http://lets.postgresql.jp/documents/technical/9.0/1 PostgreSQL 9.1 の新機能 http://lets.postgresql.jp/documents/technical/9.1/1
これを参考に http://www37.atwiki.jp/kuronekosoft/pages/16.html あらかじめPostgresql側で接続するためのデータベース、ユーザーがないといけません。
通常は小文字となりますが、二重引用符で括られていた場合は区別します。 http://www.postgresql.jp/document/9.1/html/tutorial-table.html
1:index作成の目安について 検索の条件になる項目で、重複があまり無い項目を作成すれば良いのでは無いでしょうか。また、テーブル作成時に特定のカラムに対してPKを設定するのであれば、PKには自動的にindexが付与されるので、ベット作成の必要は無いかと思われます。 いったん、テーブルを作ってみて、使いたいSQLをexplain analyzeで実行してみて、処理が遅い部分に関係しているカラムに対してindexを設定して行く方法をお勧めします 2:複合indexのメリット indexサイズが小さくなります。ただ、指定の順番を間違うとindexが使われなくなるときもあります。 3:indexの付与対象について indexはテーブルのカラムに対して付与するので、同一カラム名のindexを他のテーブルに作ったからと言って、違うテーブルで作成しなくて良い訳ではありません。 4についてはご質問の意図がよくわかりませんでした。 私の回答がお役に立てるようであれば幸いです。
replace( to_char(created, 'YYYY年MM月'), '年0', '年') as created_styled
ご質問の内容が、一つの重たい処理をしている時に、マルチコアを使いたいというものでしたら、postgresqlの設定ではどうにもなりませんので、処理を分散させ、並列にクエリを投げる様なリクエストに書き直すぐらいしか、もしかしたら対処策が無いかもしれません。
postgre自体が問題ならとりあえずアップデートしてみるのもありかもしれませんね。 ver.8.3.3とかではそもそもそういうバグがあったらしいですし。 ともあれ、CPU使用率100%なのがどのプロセスなのかを明確にする必要があるかと思います。 お使いのディストリビューションが分かりませんが、Redhat系なら「ps aux」でプロセスごとのCPU使用率が見れるので、まずはその辺を調べることをお勧めします。 あとメモリもfreeとかで見てみて下さい。 スワップしまくりみたいな状況だとそういうこともあるかもしれません。
　@@C:/path/xxx.sqlでCドライブのpathというパスにあるxxx.sqlというSQLファイルを実行するのはOracle Databaseが提供しているSQL*PLUSの機能で、当然ながら同等の機能がpsqlコマンドに実装されているかどうかは分からない、という点はまず最初に理解していただきたい。 　ところで、psqlには\iという内部コマンドがあり、これを使えば同等の事はできると思われる。以下、Linux（今回動作検証に使ったのはOracle Linux 5.8＋PostgreSQL 8.1.23）での例。 【コンソール】 postgres=# \i '/path/hogehoge.sql' 【ファイルの中身】 \i '/path/xxx.sql' \i '/path/yyy.sql' \i '/path/zzz.sql' ・ ・ ・
SELECT * FROM getCgyData('hoge'); で、どうですか？
> 上記のSQLでanumとbnumとcnumが同一の時は > 最小のdnumのみ抽出されるということでよろしいでしょうか。 baseが同一のものの中であれば、そうなります。 ただし、 base anum bnum cnum が同じでも no が違えば別々に出力されますが、恐らくそれは問題ない動作ではないのでしょうか？ 少なくとも、ご質問に例示されているデータについては例示されている通りの結果が抽出されます。 VIEW定義内のSELECT文は、特に難しい事をやっている訳ではないので、ご自身で精査されると良いと思います。 1. 2つのテーブルを no が同じもので内部結合 　同じ値の no が両テーブルに存在するものだけが、取り出されます。 　http://www.techscore.com/tech/sql/SQL6/06_02.html/ 2. 1で取り出されたデータを no name code base anum bnum cnum でグループ化 　つまり最終的な出力項目の内の dnum 以外全てが同じものごとに一まとめにしています。 　http://www.techscore.com/tech/sql/SQL5/05_08.html/ 3. 2のデータから no name code base anum bnum cnum と dnum の最小値を出力
#3 に私が書いた条件は合っていたのでしょうか？ 合っていたとして・・・。 > 上記のSQLで可能でしょうか？ 可能ではないですね。 ただし別の方法を使ったSQLでは可能です。かなり冗長ですが。 ---------------------------------------- SELECT * FROM tbl a WHERE EXISTS (SELECT * FROM tbl b WHERE (a.aaa = b.aaa OR a.ccc = b.ccc OR a.ddd = b.ddd OR a.eee = b.eee OR a.ggg = b.ggg) AND a.bbb <> b.bbb) AND NOT EXISTS (SELECT * FROM tbl b WHERE a.aaa = b.aaa AND a.bbb = b.bbb AND a.ccc = b.ccc AND a.ddd = b.ddd AND a.eee = b.eee AND a.ggg = b.ggg AND a.hhh > b.hhh) ORDER BY aaa, bbb, ccc, ddd, eee, ggg ---------------------------------------- NOT EXIST句は aaa,bbb,ccc,ddd,eee,ggg が同じで hhh が小さい行が存在しない、つまり hhh が最小の行という条件を表しています。 また、window関数を使っても同じ事が出来そうです。 蛇足ですが、なかなか回答が付かないからといってマルチポストするのはやめましょう。
100 以上の引数をもった関数を定義できるようにするには、ソースコードを修正してコンパイルしなおす必要があります。 ヘッダファイル src/include/pg_config_manual.h 内の定数 FUNC_MAX_ARGS を修正してください。ソースコードのコメントには約 600 まで増やせるということです。 100 以上の引数をもつ関数を定義すること自体、設計に何らかの問題がありそうなので、そちらを見なおしたほうがよいと思います。 あるいは、引数を配列や複合型で渡すことを考えたほうがいいかもしれません。
結果空のSQLは SELECT * FROM TBL_TOKUI T WHERE EXISTS(SELECT ' ' FROM TBL_SHAIN S WHERE T.area_code=ANY(S.area_code)) で可能です。
データベースの全てのファイルが欠損または破損していないのであれば、 新しいディスク上の同じディレクトリに展開してあげればそのまま起動 できると思いますが。 ただし、データベースのファイルが１つでも欠損または破損している場合は 過去のバックアップがないと復旧できません。 > 新サーバに同じバージョンのPostgreSQLをインストールして、古いファイルを上書き > すればいいでしょうか？ 実行ファイルとデータベースは別に考えてください。 データベースとは initdb で作成されるファイル群です。 実行ファイルであれば壊れていても上書き再インストールで問題ありません。
なんとなくですが、チューニングでどうにかなるレベルの話じゃなくても、設計の問題のように思えます。 SELECT * FROM tbl_test WHERE f条件 = TRUE; のSELECT自体が遅いのではなく、その結果をパケットデータにして、 VPN経由でMS-ACCESSに転送する部分が重いのではないでしょうか？ つまり、SQLのリザルトデータが大量すぎるのが問題なので そのリザルトを使ってさらにMS-ACCESS側でさらに絞り込んでいるのなら そのロジックをACCESSからSQL側に移転させれば、一気に　解決できるように思われます。 たとえば、 更新時は、更新する対象のデータのみを取り出すSQLにする。 挿入前の衝突チェックなら、衝突チェックをACCESS側でなく衝突チェック用のSQLを投げる。 一覧表示なら、ページ分割にして　limit句で部分取り出しにする。 データ検索も、ACCESS側でなくSQLで実装する。 といった具合に。
黒猫 SQL Studioかなぁ NEXTは使ったことないのでお勧めといっていいのかわかりませんが。
Select句の中で四則演算ができます。 あとは、二つのテーブルを結合すれば問題ないはずです。 例： Select (p1.point - p2.point) From point_1 p1, point_2 p2 where p1.id = 1 and p2.id = 1; 私の環境ではSQLを実行できないので 上記の例で正しいかどうかは分かりませんが、 こんな感じです。
一般的には２回目の方が早くなります。 理由は、１回目はHDD上のテーブルから情報を読みますが、この時メモリー上にキャッシュされます。 ２回目はメモリー上にキャッシュされた情報を読むので、HDDを読まない分早くなります。
PostgreSQLにはストアドプロシージャはありません。ストアドファンクションで代用することになります。 ただし、ストアドファンクションではトランザクションの制御が内部でできないのがちょっと面倒です。
primary key項目は，unique（一意）かつ not null（非空値）である必要があります。 primary keyは１つのテーブルに１つだけ設定できます。 primary keyはただ１つの項目だけから成る必要はなく，複数の項目から成る複合キーであってもかまいません。 http://ja.wikipedia.org/wiki/主キー
>ERROR: value too long for type character varying(5) >CONTEXT: PL/pgSQL function"getrenban" line 19 at SQL statement line 19と言う事は code5 := ''''; SELECT TO_CHAR(renban, ''00000'') INTO code5; ↑ この辺ですよね。 で、「長過ぎてvarchar(5)に入れられない」と怒られています。 PL/pgSQLは実務で使った事がないのですが、オラクルのPL/SQLの観点で回答します。 5桁の数字が入ったintegerの変数をTO_CHARすると結果は6桁になります。 +-が一桁付加されるからです。 (正の場合は半角スペース) なので「長過ぎてvarchar(5)に入れられない」と怒られたわけです。 代入時にスペースをトリムすれば解決します。 それと、クリア時のダブルクォートが気になりましたが、コンパイルが通っているので、これは問題無いのでしょうね。
もともと親子関係においては (1)子は親の値しか使用できない。 (2)親は子が存在する間は削除できない。 (3)親は子が存在する間は変更できない。 というルールなのです。 だから、ON DELETE とかON UPDATE は オマケみたいなもので、本来は無いと 考えるべきです。 DELETEはキー整合をとりますが、 TRUNCATEは何も考えずバッサリ なので、処理速度は断然有利です。 その代わりON DELETEが利かず、 不整合が生じる可能性があるため 外部キー参照のあるテーブルでは使用 できません。 外部キー参照は物理的に整合性を保つ ためには便利ですし、親子結合で行う クエリも高速です。但し、データの追加や 削除で、リレーションシップの更新を伴う ため、こういう関係を持たないテーブルの 追加/更新より時間がかかるという欠点も あります。 かつて、CPUの性能が悪く、DBが遅い 時代にはリレーションの設計は大事な 要素でした。しかし、何時の頃からか リレーションは廃れてしまい、今は取り 入れない方が普通になりました。 レコード数が大量で親子関係の参照機会が 多く、データの追加/変更/削除の頻度が 低い場合は外部キー参照は有効です。 それ以外では物理的な関係は持たない方が よいでしょう。
はじめまして。 ・作成者 　create_user 　create_user_id　 　regist_user 　regist_user_id ・作成日 　create_date regist_date ・更新者 　update_user 　update_user_id 　upd_user 　upd_user_id ・更新日 　update_date 　upd_date お好きな物をどうぞ。 作成者と更新者は名前を入れるのか、IDを入れるのかで使い分ければ良いかと。 ＞また命名で気をつける事がありましたらアドバイスいただけたら幸いです。 予約語(comment等既にSQLに存在するもの)は使わないほうがいいですね。(*1) ぱっとみわかり易い（5年後・10年後見たとしても）名前を付けるとか、コーディングする際使いやすい名前を付けるとか、他システムと連携する場合があるなら、統一するとか。 *1 PostgreSQLはどうか知りませんが、Oracleの場合予約語に"か'でくくれば列名に使えるので。
POSTGRESQL 8.1.3 http://www.postgresql.jp/document/pg813doc/html/sql-grant.html 参照 も POSTGRESQL 8.2.0 http://www.postgresql.jp/document/pg820doc/html/sql-grant.html 参照 も grant命令にTRUNCATEはないですが。 POSTGRESQL 8.3.0もなかったけど、 POSTGRESQL 8.4.0 http://www.postgresql.jp/document/pg840doc/html/sql-grant.html 参照 にはあるようですね。
COALESCE(F5,G6.M2) 列名は適宜調整してください。 COALESCE(評価する値,Nullの場合の代替値) 評価する値がNullでなければ、評価する値がそのまま返されます。 評価する値がNullなら、Nullの場合の代替値が返されます。 OracleだったらNVL関数 ACCESSだったらNz関数
select * from　テーブル名 where date_part('hour', 取得時間) between 18 and 19; または select * from　テーブル名 where date_part('hour', 取得時間) >= 18 date_part('hour', 取得時間)　< 20;
PostgreSQLではDELETE文の拡張構文として「USING」が使えます。 DELETE FROM (1) USING (2) WHERE (1).カラムA= (2).カラムA AND (2).カラムB=X マニュアルを参照してください。 http://www.postgresql.jp/document/9.0/html/sql-delete.html
>Bテーブルを調査して、重複となるレコードを ターゲットが違うでしょ。Bには重複レコードは できないんだから・・・ AテーブルからBテーブルのキーとなる項目で グループ化し、そのレコード数が2以上ならば 重複になる。 SELECT 契約番号,ユニット番号,資源番号, 入力日,COUNT(契約番号) AS 件数 FROM Aテーブル GROUP BY 契約番号, ユニット番号,資源番号,入力日 HAVING COUNT(契約番号)>1
ANo.3ですが、参考のURLを書き忘れていました。 http://www.sql-reference.com/string/substring.html
CSVのテキストに出力するために COPY TO を使っているのならば、 booleanをintegerにキャストして出力すると 1/0 になります。 COPY (SELECT b::int FROM (VALUES(true),(false)) T(b)) TO 'xxx.csv' WITH (FORMAT 'csv')
varcharとtextでたいした違いは無いと思います。 ただ、厳密なデータベース容量の計算などをする場合には、varcharのほうがよいかもしれません。 以下参考にどうぞ。 http://lets.postgresql.jp/documents/technical/text-processing/1
ANO.1です。 select kate1 kate,kingaku1 kingaku from kudamonouriage ・・・ は、 select kate1 as kate,kingaku1 as kingaku from kudamonouriage ・・・ のようにasを入れてください。 (Postgresは、asが必須だったのをうっかり。)
> JavaやPerlで作成したWebアプリからのDB操作を行なっていますが、 > プログラム側で意図的にスレッドを作ったりはしていません。 であれば無効にしても問題ないと思います。 Javaに関して言えば、JDBCなので（Type 4、つまりTHINが前提ですが）libpqを 使用しないでしょうし、Perlに関して言えば、そもそもPerl自体がthreadを有効にして コンパイルされている必要がありますし。有効化されていたとしても、勝手にスレッドが 走り出すということは恐らく無いでしょう。
> Undefined first referenced > symbol in file > sched_yield /var/tmp//ccVp73Io.o sched_yieldが見つからないと言っています。 それは、Solarisではsched_yieldがlibc.soにもlibpthread.soにも含まれていないからです。 では、それがどこにあるのか？ librt.soにあります。 なので、LIBSに-lrtを設定してconfigureしてみては如何でしょうか？ $ LIBS=-lrt ./configure --prefix=/usr/local/postgres --without-readline --enable-thread-safety ところで、configureで失敗したテストプログラムは以下ですが、 $(srcdir)/src/test/thread/thread_test.c 222行目の問題箇所を見ると、/* if this is a portability problem, remove it */ と書いてあるので、以下の２行を消してconfigureしてもOKかもしれません。 while (thread1_done == 0 || thread2_done == 0) sched_yield(); あと、余談ですが、psqlを使用することがあるなら、--without-readlineはあまりお勧めしません。
OUTパラメータとRETURNS integerは同時には使えないと思いますが、 以下のような呼び出し方ではいかがでしょう？ OUTパラメータを除いた「IN, INOUT引数だけを持つ関数」として呼び出すのがポイントです。 CREATE OR REPLACE FUNCTION raise_test(in i_data_num numeric, out o_data_num numeric, out o_data_char character varying) /*RETURNS integer*/ AS $$ BEGIN o_data_num := i_data_num + 100; o_data_char := 'XYZ'; END; $$ LANGUAGE plpgsql; DO $$ DECLARE data_num numeric; data_char character varying; BEGIN SELECT * INTO data_num, data_char FROM raise_test(5); RAISE INFO '% / %', data_num, data_char; END; $$; 結果 → INFO: 105 / XYZ
・NEW の値を使う場合には、FOR EACH ROW トリガを使う必要がある。 ・テーブルAに仕掛けたトリガの NEW は、テーブルAの行を表している。 といったあたりがポイントと思われます。 ↓こんな感じでどうでしょうか？ CREATE FUNCTION update_edit_b() RETURNS TRIGGER AS $$ -- (OPAQUE はかなり古い書き方？) BEGIN UPDATE Table_b SET Column_b = true WHERE Table_b.A_id = NEW.id AND NOT Column_b; -- (複数回更新する際に、無駄なUPDATEを避ける) RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE TRIGGER trgger_a AFTER -- (BEFOREのほうが若干効率が良いので、置き換えも検討すべし) UPDATE OF a ON Table_a FOR EACH ROW -- (STATEMENTではなくROWを指定) EXECUTE PROCEDURE update_edit_b;
PL/pgSQL から、出力パラメータ (OUT 引数) のある関数を呼び出す場合、 引数ではなく返値として値を受け取る必要があります。 PERFORM ではなく、SELECT INTO を使ってみてください。 CREATE OR REPLACE FUNCTION fn_raise(OUT o_v1 int, OUT o_v2 int) AS $$ BEGIN o_v1 := 123; o_v2 := 456; END; $$ LANGUAGE plpgsql; DO $$ DECLARE v1 int; v2 int; BEGIN SELECT * INTO v1, v2 FROM fn_raise(); RAISE WARNING 'v1=%, v2=%', v1, v2; END; $$; WARNING: v1=123, v2=456
No1です。 DB環境がMacやLinuxなどのUNIX環境だったりします？ 改行コードは LF(\n) → UNIX系 CR(\r) → 旧Mac CRLF(\r\n) → Windows系 という様になっているので、テキストをCRLFで作った場合は ああああ\r\nいいいいい こうなりますので、ちょっと外しているかもしれませんが、 これをLF系環境のDBで更新した結果 ああああ\r ←\rは文字として認識 いいいいい ←\nは改行コードとして改行される こんな感じになってるのではないでしょうか。 一度テキストの改行コードをLFにしてみるとどうなりますか？
PostgreSQLにはgenerate_seriesという関数があります。これを使うと簡単に連続値が得られます。 後、テーブルＡの件数が少ないか、キー１に索引があれば select a, case when exists ( select 1 from テーブルＡ where テーブルＡ.キー１ = s.a ) then '有り' else '無し' end from generate_series( 100, 109 ) as s(a); も検討してみてください。
まったく同じSQLですか？ ・explain する時間が短縮される ・キャッシュ(ディスクまたはメモリ)にデータや実行計画が残っている ・物理ファイルに対してのアクセスが(キャッシュにより)高速化される ・最初は共有ロックを掛ける時間がかかっている ・メモリがページングされない 等があるのではないかと。 厳密なのはanalyzeしたり統計情報を見るなりした方が良いと思いますけど。
SQLのSELECT文の解釈順序が WHERE ↓ GROUP BY ↓ HAVING ↓ SELECT ↓ ORDER BY なのでORDER BYのところだけは指定できます。 集計関数の条件ですからHAVING句で指定してください。 パフォーマンス問題はデータの状況によりますから一概に言えません。 WHERE A=1 の部分で十分に絞り込めるなら問題にはならないでしょう。
サブクエリで複数項目を取得する事はできません、よってサブクエリを使うのであれば、別に指定する必要があります。 サブクエリを使わない方法も有ります。 select 商品, 価格, user_id, user_name from products, user_master where user_id=1 and 商品ID=1; です。
#ANDじゃなくてORだよな。 未検証。 http://www.postgresql.org/docs/9.0/static/functions-aggregate.html >bit_or(expression) ってのは使えるだろうか？ #この関数、他DBで使えるかなあ？極力移植性は高くしておきたいんだけどなあ
> 3008 ? S 0:00 /opt/PostgreSQL/9.0/bin/postgres -D /opt/PostgreSQL/9.0/data > と表示されますが、このフォルダにはファイルのコピーは出来ません。 > アクセス権が無いようですが、そう言うものなのでしょうか？ はい。PostgreSQLのサービス実行やデータベース管理のためのユーザーが 登録されており、そのユーザーだけにアクセス権が与えられているはずです。 ユーザー名は postgres が一般的だと思います。 例えば自分の手元だとこんな感じです。 [root@www ~]# ls -ld /opt/PostgreSQL/9.0/data drwx------ 13 postgres postgres 4096 11月 1 12:55 /opt/PostgreSQL/9.0/data > …インストールはこのユーザーで行ったはずなのですが。 途中 su や sudo コマンドを使って、postgres ユーザーや root の権限で インストールを行っていないですかね。 ひとまず root に su して、/opt/PostgreSQL/9.0/data の下を 調べてみてはどうでしょうか。
ソースコードを見る限りマクロで定義した値をそのまま使っていて、 パラメータなどでは変更できないように見えます。 こちらのマニュアル（9.1.1）を見た限りでも、 コンパイル後に変更できないように見えます、 http://postgresql.jp/document/current/html/index.html ということで、 > Windows版はどのように設定すれば良いのでしょうか？ ソースコードは公開されているので、どうしてもということであれば 独自にBuild する以外に方法はないように思われます。
64bitのWinXPに32bitのPostgreSQLをインストールし、スタックビルダでODBCドライバをインストールしたため32bitのODBCドライバがインストールされている可能性があります。 C:\WINDOWS\SysWOW64\odbcad32.exeを実行するとインストールされている32bitODBCドライバが確認できます。 もし、OSが64bitならPostgreSQLも64bitにするのも一法です。 ただし、MS ACCESSなどが32bitだとODBCリンクできるのは32bitのドライバで構成されたDSNですので、odbcad32.exeでDSNを登録した方がいいかもしれません。
Windows7 psql9.0.4 psql9.1.1 では再現しませんでした。 いったん、9.1.1にバージョンアップして様子を見てはいかがですか。
no int default X'FFFFFFFF'::int みたいな感じで。
SQLの規格としてはUNIQUE制約を指定した時にINDEXを作成するかどうかは決められていませんが（SQL規格にはINDEXの記述がない）、私が知るかぎりはPRIMARY KEY制約、UNIQUE制約を指定した場合はすべてのRDMSでINDEXが暗黙に作成されます。 PostgreSQLも同様です。 ですから、 CREATE INDEX id ON tableA (id); とする必要はありません。PostgreSQLではエラーになりませんが、Oracleなどでは既に索引が作成されている列に同一の内容で索引を作成しようとするとエラーになります。 暗黙に作成されたINDEXも暗黙に作成されたINDEXも同様に使用されますので速度の向上が見込めます。 後、UNIQUE制約ですが Oracle→NULLは複数個許可する。暗黙作成される索引にNULLを含めない。 PostgreSQL,MySQL→NULLは複数個許可する。暗黙作成される索引にNULLを含む。 SqlSERVER→NULLは1個のみ許可する。 DB2→NULLを許可しない と扱いが違うので注意してください。
こんな感じでいかがでしょう。 CREATE TEMPORARY SEQUENCE tseq; CREATE TEMPORARY TABLE ttbl ( LIKE {元テーブル名} ); ALTER TABLE ttbl ADD COLUMN new_id integer; INSERT INTO ttbl SELECT *,nextval('tseq') FROM {元テーブル名}; INSERT INTO {新テーブル名} SELECT new_id,node_id_1,node_nm_1 FROM ttbl UNION SELECT new_id,node_id_2,node_nm_2 FROM ttbl;
OrangeCup150さんが想定されている意図であるなら・・・ １．PHPにてランダムの半角英数文字列（固定桁長）を生成する（８桁とか） ２．SELECTして１の値と既存との重複チェック ３．重複があれば１と２を繰り返し。なければそれでOK。 serial型などは今どきなら自動でINDEXもつくので、ユーザーID的なものとは別にあってもいいと思いますよ。プライマリキーになるので、他のテーブルとの結合もしやすいし。 ユーザーの情報をいじくったりする時には、そのserial型の値を使って操作してやったほうが速度も出やすいですから。
じゃぁ SELECT a.*, b.*, c.* FROM a LEFT JOIN b ON a.key = b.key LEFT JOIN c ON b.key2 = c.key2; でいいんじゃ
表ごとにくぎる (A INNER JOIN B ON X) INNER JOIN C ON Y が一般的です。 条件ごとにくぎる A INNER JOIN B INNER JOIN C ON Y ON X のはエラーにならなくても分かりにくくなるのでバグの元。 だいたい、こう書くなら A INNER JOIN B INNER JOIN C where Y and X って書いたほうがまだ分かりやすいと思うし、 それをいうなら普通は、 from A,B,C where Y and X と書くでしょう。 ## 外部結合の場合は最後の書き方ができない（かできるけどANSI標準でない）とかありますけど。
↓とかでどうでしょう？ 試してないので微妙に間違ってる部分あるかも？だけれども。 SELECT MAX(sum_buynum) FROM ( SELECT RCT_NO, SUM(BUYNUM) AS sum_buynum FROM TRN_RECEIPT_DETAILS GROUP BY RCT_NO )
PHPが初期設定のままであればエラーは表示されません。 エラーメッセージが /var/log/httpd/error_log に出ていると思いますので確認してみてください。
------------------ 日付 入出庫 在庫 3/4 0 30 3/5 10 40 3/6 -5 35 3/7 -20 20 ----------------- の3/7の在庫は15ですよね。 表示するだけなら select t.日付, t.入出庫, ( select t3.在庫 + sum(入出庫) from テーブル where 日付 <= t.日付 ) from テーブル t, ( select t2.在庫 from テーブル t2 where t2.日付 = ( select min(日付) from テーブル ) ) t3; でいけます。
パフォーマンス重視、予約IDに空き番が出ててもいいならシーケンスが一番いいと私も思います。 予約IDに空き番が出ると困るなら、仕方がないので予約IDテーブル（1レコード）を作成し トランザクション開始 UPDATE RETURNNING か UPDATE して SELECT で予約IDを取得 予約テーブルと予約明細テーブルにINSERT COMMIT or ROLLBACK なら後続トランザクションは予約IDテーブルのUPDATEでWAITになるから重複は発生しない。 （その代わりにここがボトルネックになる危険がある）
質問に自分で書いているとおり、-C オプションを指定すると、データベースを作成してそのデータベースに対してリストアを行います、 -C オプションを指定しないと、pg_restore コマンドの -d オプションで指定したデータベースに対してリストアが行われます。 以下のように pg_restore コマンドを実行して -C オプションのあり・なしで SQL がどのように違うかを確認してみてください。 $ pg_dump -F c test > test.dump $ pg_restore test.dump $ pg_restore -C test.dump -C オプションを指定した場合には、CREATE DATABSE コマンドでデータベースを作成した後、\connect コマンドでそのデータベースに接続していることが分かります。
psql コマンドでリストアする plain 形式のダンプファイルの場合には、pg_dump コマンドの実行時に -C オプションを指定してデータベースの作成に必要なコマンドもダンプするようにしてください。 pg_restore コマンドでリストアする custom および tar 形式のダンプの場合には、pg_restore コマンドの実行時に -C オプションを指定してデータベースの作成後にリストアするようにしてください。
ステレオミックスという機能を使います(マイクは使いません). ちょっと長いのですが, 以下のページが詳しいです. http://www18.atwiki.jp/live2ch/pages/151.html 頑張ってください.
普通に考えると、他のユーザーのパスワードは管理者といえども見れないようにできているはずです。もし使い回ししているとしたら、ひとつパスワードが分かってしまえばいたずらし放題になってしまいますからね。 ということで正規の方法ではほぼ見られないと思います。あるかどうかはわかりませんが、非正規のクラックツールのようなものがあれば可能かもしれません。
quote_literal 関数は役に立ちますか? 中の引用符をエスケープするだけでなく、 値を引用符で囲むところまでやってくれるようです。 http://www.postgresql.jp/document/9.0/html/functions-string.html
ひとつはDBにバイナリ型項目を作ってそこに書き込み、読み込みを行う方法。 http://blog.xole.net/article.php?id=425 または、DBには画像ファイルのファイルパスのみ保存し、画像ファイルはファイルシステムで管理するやりかた。 バイナリデータをTEXT（Base64）に変換してDBに保存するやり方 http://neta.ywcafe.net/000774.html などがあります。
リストアしようとしているコマンドはCOPY FROMですか?
~= は幾何データ型の演算子で、位置や形が同じかどうかの比較になります。 幾何データ型の = は面積が同じかどうかの比較になります。 point 型は平面における座標「点」なので、面積を持たないから = が 使えないのではないかと思います。 幾何関数と演算子 http://www.postgresql.jp/document/pg904doc/html/functions-geometry.html > "同じを示す"~=演算子はpoint、box、polygon、およびcircle型に対し通常の等価概念を示すことに注意してください。 > これらのいくつかの型は=演算子を持ちますが、=は面積の等しさのみを比較します。 > その他のスカラー比較演算子（<=など）は同様にこれらの型の面積を比較します。 幾何データ型 http://www.postgresql.jp/document/pg904doc/html/datatype-geometric.html
8.4なら「unnset関数」が使えます。 select item,count(*) from ( SELECT unnest(val) as item from sample_tbl ) t group by item order by item;
postgreSQLでは歴史的経緯で「role」が使われていました。 その後「user」が導入されたので意味的には同意です。 Oracleのような「権限を集約した概念」という意味はありません。
># gcc sample.c ># gcc -I/usr/include sample.c ライブラリの指定がないみたいですが……環境変数とかで指定しているのでしょうか？ 「PostgreSQL libpq gcc」で検索して適当に見つかるページですが… http://www.fireproject.jp/feature/postgresql/programing_libpq/connect.html より… >これをコンパイルするには,ヘッダとライブラリの指定が必要である. >gcc -I/usr/include/postgresql/ -lpq connect.c ということで、-lpqも必要かと思われますがいかがでしょう？
> $sql = "select kaiin_no form store_table where kaiin_no = ".$kaiin_no; > Warning: pg_query(): Query failed: ERROR: syntax error at or near "form" at character 17 あ! すみません。 form がまちがいです。 正しくは from です。 $sql = "select kaiin_no from store_table where kaiin_no = ".$kaiin_no; ANo.3 は全部 form になってますね。。。 偉そうなことを書いておきながら面目ないです。。。
http://d.hatena.ne.jp/higepon/20090310/1236668808 現状では対処不可のようです。（オフィシャルでは） PostgreSQLのOIDが64nitになるのを待つしかないですかね。
## php、PostgreSQLはさわっていないのであまり答える気はなかったけど。 チェックボックスを利用した質問の複数選択した回答ということなので、 漢字検定3級以上と英語検定3級以上にチェックを入れた場合、 //テーブル作成 ********=> create table sample03( ********(> 資格 int); の「資格」にはなにをいれるのでしょう？ ひょとして、23といれたい？ html上（というかブラウザ上というかそのDOM上ではというべきか？）では、sikaku[]は配列として扱われています。 だから、$sikaku = $_REQUEST["sikaku"];の結果は配列変数を受け取ると思うけど、 ・・・文字列変数として受け取れるのかもしれません。 （ここは私はわかりません。） 配列変数となっているなら$sikaku[0],$sikaku[1],・・・を順につなげる必要あるはずです。 で、SQLですが、 insert into sample03 values('$sikaku') のように''で囲むと文字型になり、数値型の項目に値を入れるときは大抵のデータベースではエラーに なります。（PostgreSQLはよく知りませんけど、タブンエラーになるはず） ここかもしれません。 どちらにしろ、$result にエラーが返ってきているのでは？ $result　か他のエラーコードなどを参照できるようにして確認するほうがいいでしょう。 ## 申し訳ないけど、これの方法は私はわかりませんので他の方の回答待ちしてください。
WINDOW関数が使えるなら select pkey, user, pass, comment, update_date from ( SELECT user_accounts.*, log.comment, log.update_date, row_number() over(partition by user_account.pkey order by log.update_date ) rn FROM user_accounts LEFT JOIN log ON user_accounts.user = log.user_accounts_pkey) T where rn = 1; そうでなければ SELECT user_accounts.*, log.comment, log.update_date FROM user_accounts LEFT JOIN ( select * from log where not exists ( select 1 from log l2 where log.user_accounts_pkey=l2.user_accounts_pkey and log.update_date<l2.update_date ) ) l ON user_accounts.pkey = l.user_accounts_pkey
>どのように設定したらよいのかわかりません。 手順としては １．ODBC ドライバをダウンロードする http://old.postgresql.jp/interfaces/index.html http://nami.jp/psqlodbc/ これを使うのが早いと思います。 ２．クライアント PC に ODBC ドライバをインストールする ３．接続テストを行う >PostgreSQLサーバに接続できません。 > >お使いのPostgreSQLサーバのバージョンが6.3以上である場合、postmasterの起動オプションに“-i”を指定してください。これを指定しないとpostmasterはTCP/IPによる接続を拒否してしまいます。 > >PostgreSQLサーバのホスト認証設定ファイル（data/pg_hba.conf）は正しく設定してありますか。この設定ファイルで他のホストからの接続を許可してあげてください。デフォルトのままでは他のホストからの接続は拒否されてしまいます。 http://www.interwiz.jp/software/PsqlODBC/faq.html >外部サーバーにあるデータベースにODBCを使用することは可能なんでしょうか？ 技術的には可能ですが、セキュリティ上、許可されていないことが多いと思います。 DB サーバ側のセキュリティ設定が外部からの接続を許可するように設定していること、DB ユーザアカウントが外部からの接続を許可されていること、 TCP/IP 接続が許可されていること、ファイアーウォールの設定で許可されていることなどを確認してみてはどうでしょうか。 まあ、わたしは PostgreSQL の詳細は分かりませんが、参考にしていただければ幸いです。
VACUUMのイメージは下記のページが詳しいです。 http://www.geocities.jp/sugachan1973/doc/funto60.html また、VACUUMはテーブル単位に実行できます。 FULL VACUUMを安全に停止する手段があれば、ファイルの再構成を行っていますから、再実行すれば前回の分はVACUUM済になる理屈ですが、FULL VACUUMを安全に停止する方法わかりません。 下手をしてファイルシステムに不整合を起こしてはなにもなりません。 お使いのPostgreSQLのバージョンはなんでしょうか？ 個人的には現在8.4系列あたりが一番安定している気がします。 VACUUMもバックグラウンドで行ってくれますので。
一応「MSXML2.XMLHTTP」という手段があります。EXCEL VBAからHTTPリクエストを投げてサーバーから結果を受け取るというものです。 http://d.hatena.ne.jp/end0tknr/20081115/1226755041 ただし、問題はあります。 (1)VBAからリクエストされたSQLを処理して結果を返すサーバー側プログラムが必要です。 (2)そして、その場合、最低限認証する仕組みの造り込みとユーザー名、パスワードの暗号化が必要でしょう。 そうしないと、とんでもないセキュリティホールをつくることになりかねません。
クライアントにODBCを入れてみる方法もあります。 （サーバーが外部だと、サーバ側のアクセス権や通信ポート解放等で難しいかもしれません） http://allabout.co.jp/gm/gc/47352/ http://www.postgresql.org/ftp/odbc/versions/msi/
文字データよりも数値データの方が良いと思います。 それも、使い方によるのですが、 アドレスのデータベースを作り、それと関連付けると、 文字データの取得もできるのでそちらの方が良いと思います。 データ容量を減らす意味でも数値データの方が良いです。
安定性から言えば8.4系の方が枯れている可能性が高いと思います。 ただ、pgpoolの頃ですがinsert into ～ select が使えない、シリアル値が保証されないなどの制限事項があったと思います。pgpool-II ではそこのあたりがどうなっているか調査する必要があると思います。 pgpool-IIの長所としてはコネクションプーリング機能があげられます。
SELECT coalesce(MAX(fld), 0) FROM tbl ; ではいかがでしょうか。
私も見たことのないメッセージですがよければエラーメッセージが出るSQLとテーブル構造を教えてください。
http://www.postgresql.jp/ オンラインマニュアル ==> 日本語マニュアル http://www.postgresql.jp/document/ バージョン8.3 ==> PostgreSQL8.3最新版 日本語マニュアル http://www.postgresql.jp/document/8.3/index.html 日本語ドキュメント一式のダウンロード http://www.postgresql.jp/document/8.3/postgres.tar.gz
import.txt、 export.txt のファイルのある場所は psql コマンドを 実行したときのカレントディレクトリになります。 TeraTerm で大学のコンピュータに接続しているのならば、ファイルは 大学のコンピュータ上にあり、自宅のPCにはありません。 エクスポートしたファイルを自宅のPCに転送する必要があります。 Tera Term での接続時にSSHを選んでいるのであれば Tera Term の メニューの[ファイル] → [SSH SCP]でファイルの送受信ができると 思います。 またWinSCP 等のツールでも SCP によるファイル転送ができると 思います。
RHEL 6 に標準でバンドルされているパッケージは 8.4.4 です。 それ以外のリリースをインストールしたいなら野良ビルドする必要があるでしょう。 （他のリリースやディストリでコンパイルされたパッケージを使うのはもってのほか） 普通は Linux がサポートされていて（サポートされています）、かつコンパイルが 通れば（通るはずです）OKとすべきです。 http://www.postgresql.jp/document/9.0/html/supported-platforms.html いちいちディストリ/リリース毎にテスト/動作確認なんてしていないはずです。 なので、品質保証の部分は自分でテストを繰り返して向上していく必要があります。
PostgreSQLに限らず、統計情報を取得する場合テーブルやインデックスのアクセスが発生しますから、全く影響がないということはありません。 Oracleなどでは大きなテーブルのanalyzeの点にサンプリングする比率を指定できたりできますけれど。 できるだけDBへの負荷が少ない時間帯を選んで実行するしかないと思います。
yahoo知恵袋でも回答しましたが、テーブル設計に問題があります。 まず、「正規化」を勉強してください。 チームテーブルと選手テーブルテーブルを分ければ select チームテーブル.team from チームテーブル inner join 選手テーブル on チームテーブル.team=選手テーブル.team where 選手テーブル.name='mori' で行けます。
&& 演算子 (重複する, 共通要素を持つ) を使います。 SELECT * FROM (VALUES (ARRAY[1,3,5]), (ARRAY[3,8,9,10]), (ARRAY[2,6]) ) T(arr) WHERE ARRAY[1,2,6] && arr;
【質問 1】への回答 はい、アーカイブ先のディレクトリに保管されていない WAL ファイル分の更新は消失します。また、更新の頻度が高い場合には 1 つ以上の WAL ファイル分の更新が消失する可能性があります。 なお、WAL ファイルがアーカイブ先のディレクトリに保管されるのはサイズが 16MB になったときではありません。WAL ファイルは最初からデフォルトで 16MB 分のサイズが確保されており、メモリ上の更新がディスクに反映されて不要になった場合 (完了済み WAL ファイルになった場合) にアーカイブ先のディレクトリに保管されます。 【質問 2】への回答 前述のように WAL ファイルのサイズは最初から 16MB であり、完了済み WAL ファイルになっていない状態で保管しても、正常に復旧できない可能性があります。 WAL ファイルを強制的にアーカイブ先のディレクトリに保管する方法がいくつかあります。 1 つは以下のように pg_switch_xlog 関数を実行することです。 =# SELECT pg_switch_xlog(); もう 1 つは archive_timeout パラメータを設定することです。前回 WAL ファイルがアーカイブ先のディレクトリに保管されてから archive_timeout パラメータに指定した時間を経過するとアーカイブ先のディレクトリへの保管が強制的に行われます。ただ、WAL ファイルのサイズは 16MB に固定されているため、あまりに短い時間を指定してしまうとディスク容量を圧迫してしまいます。 いずれにしても PITR (ウォームスタンバイ) では WAL ファイルがアーカイブ先のディレクトリに保管されるのは非同期なので更新が消失することは回避できません。 9.0 で追加されたストリーミングレプリケーションを使用すれば、16MB の WAL ファイル単位ではなく WAL レコード単位でデータを同期できるので、消失する更新はより少なくなります。とは言え、ストリーミングレプリケーションも非同期なので更新が消失することは回避できません。 更新の消失を回避するには、pgpool-II などの同期レプリケーションのミドルウェアを使用するか、現在、開発中の 9.1 で追加される同期のストリーミングレプリケーションを使用する必要があります。
以下の SQL でどうでしょうか。 test=> SELECT * FROM test WHERE array_length(xpath('/a/b[c="1" and d="1"]', xml), 1) > 0; xml -------------------------- <a> + <b><c>1</c><d>1</d></b>+ </a> (1 行)
複数結合したいテーブルに異なる別名を付けて結合すれば良いかと。 例) ---------------------------------- SELECT 名前, k1.県名 as 出身県, k2.県名 as 現住所 FROM 人名表 p left join 県名マスター k1 on p.出身県 = k1.コード left join 県名マスター k2 on p.現住所 = k2.コード; -------------------------------------
WindowsVISTA以降は\Program Files内のファイルを直接編集できません(UACのため)。 編集結果を他の場所に保存して、コマンドプロンプトを「管理者として実行」で開き該当のフォルダにコピーしてください。
initdb コマンドでデータベースクラスタを再作成する必要はありません。 postgres=# CREATE DATABASE test WITH TEMPLATE = template0 ENCODING = 'UTF-8' LC_COLLATE = 'C' LC_CTYPE = 'C'; CREATE DATABASE
ファイル名が同じなら、人数も同じ値が入っているという前提で．．． select ID, sum(人数) as 集計 from ( select ID, ファイル, 人数 from テーブルA group by ID, ファイル, 人数 ) group by ID; で、どうでしょうか。
1. Linuxのユーザー"database_6"でログインする。 2. psqlを使ってデータベースを"database_6"を、 PostgreSQLのユーザー"postgres"で開く。 psql [オプション] [データベース名 [ユーザー名]] psql database_6 postgres 3. COPYコマンドを実行する。 > ERROR: could not open file "/home/database_6/database_euc_4.csv" for reading: 許可がありませえん Linuxの"database_6"ユーザー以外で操作していませんか？ > -bash: COPY: command not found psqlを使わずに、直接LinuxのコンソールでSQL文を実行しようとしていませんか？
bash: psql: command not found　は psql コマンドにパスが通ってないだけですね。 FATAL: database "postgres" does not exist　は postgres ってデータベースが無いよって言ってます。
7.x の PostgreSQL では COPY コマンドが WITH CSV をサポートしていないようです。 http://www.postgresql.org/docs/7.2/static/sql-copy.html http://www.postgresql.org/docs/7.4/static/sql-copy.html には WITH CSV がありません。 http://www.postgresql.org/docs/8.0/static/sql-copy.html http://www.postgresql.org/docs/8.4/static/sql-copy.html には WITH CSV があります。 できるだけ安定した新しいバージョンの postgresql-8.x を利用するのが望ましいのですが、 何か理由があって 7.2.3 を使うのであれば、COPY コマンドではない方法を探す必要があります。
http://oshiete.goo.ne.jp/qa/6748718.html のあとに何をやったんですか？ ># rpm -qa|grep postgres >を実行すると、何も表示されません。 rpmパッケージで入れていないのなら当然出てきません。 >/usr/local/pgsql/bin/postmaster ということは、ソースからmakeしたんじゃないんですか？ であれば、make install以外に、自分で設定ファイルをコピーする必要があるのかも知れません。 # 何度か回答していますが…Redhat8.0は手元にありませんし、 # postgreSQLも使っているワケではないので、細かいところは判りません。
>これは、.bashrcで追加した下記内容が読み込まれていないからでしょうか？ どのユーザーの.bashrcに設定しているのか…とかの問題もありそうですが… initdbを実行する前に printenvで設定されている環境変数確認してみてはどうですか？ ちなみに、環境変数に設定しなくても-Dオプションで指定すれば上書きされる(オプション指定の方が優先)のようです。
>$ initdb >-bash: initdb: command not found パスは通っていますか？ 一般ユーザで操作可能ですか？(こちらの場合は別のエラーになるでしょうけど) >postgresでログインしようとしましたが、パスワードの初期設定が分かりませんでした。 rootユーザーからsuコマンドで切り替えれば…そのまま入れませんか？ または、rootユーザでpasswdコマンドでパスワードを設定してみてはどうですか？ # ログインシェルとかホームディレクトリとか設定されている必要があるかも知れませんけど。
NEWに対して動くか試していないので分かりませんけれど 動的にテーブルやカラム名を指定するときは SQL文を文字列の結合||で作って、EXECUTEします。 こんな感じではないでしょうか。 EXECUTE 'INSERT INTO "テーブル名２" VALUES(NEW.' || rec.attname ')'; 動いたら是非教えてください(^^)
基本は同じです。 psql コマンドでデータベースに接続できていますか？ ユーザーやテーブルが作成できているなら、そこで COPY tablename FROM '/var/test/testdata.csv' WITH CSV; のようにすればＯＫです。 パスの書き方がWindowsと異なるだけでコマンドの構文はまったく同じです。
>3.でcommand not foundと表示されるため、# yum search postgresqlを実行しましたが、command not foundと表示されます。 そもそも…Redhat Linux 8.0用のyumコマンドが入っているんですか？ http://www.atmarkit.co.jp/flinux/rensai/linuxtips/599endrhlup.html だと、Fedora Legacyに「あった」ようですが、Fedora Legacy自体が既に終了していてサポートされていないハズですが……。 >postgresql-7.2.2-1 7.2.2が既に入っています。 サポートの終了しているRedhat Linux 8.0でどうにかするのは、もはや無謀…かと思われますが……。 # 自力でビルドするにしても、必要とするライブラリがRedhat Linux 8.0で用意できるかどうかも判りませんし…。 メモリ増設するなりしてもう少し新しいディストリビューションに移行した方がよい…かと思われますが……。 # ただし、実行環境の方も新しいものに置き換えできるのであれば…となりますけど。 閉じられたのでこっちで… >ところで、Linuxの場合、メモリを増設すると自動で認識されるのでしょうか？ たいてい、そのまま認識します。 4Gオーバーの場合はカーネルを換えるなどが必要になる場合もありますが…。
PostgreSQL 8.3 ですと、「最新の「更新日付」のレコードを抽出」の箇所でセルフジョインが必要になります。 具体的なSQLはこのような感じです。最新の日付を max() で計算しているので、更新日付のデータ型を date にするか、文字列の場合はゼロ埋め ("2011/04/03") しておいてください。 CREATE TABLE テーブルA (名前 text, 点数 integer, 更新日付 date); INSERT INTO テーブルA VALUES ('AAA', 98, '2011/4/1'), ('AAA', 60, '2011/4/3'), ('BBB', 70, '2011/4/2'), ('BBB', 35, '2011/4/4'), ('DDD', 98, '2011/4/1'), ('EEE', 47, '2011/4/5'), ('GGG', 80, '2011/4/6'); CREATE TABLE テーブルB (名前 text, 判定 integer); INSERT INTO テーブルB VALUES ('AAA', 0), ('BBB', 1), ('CCC', 1), ('BBB', 1), ('DDD', 0), ('EEE', 0), ('GGG', 1); SELECT 名前, 点数, 更新日付, CASE WHEN max_a.名前 IS NOT NULL THEN 0 ELSE 判定 END AS 判定 FROM (SELECT 名前, max(更新日付) AS 更新日付 FROM テーブルA GROUP BY 名前) AS max_a JOIN テーブルA USING (名前, 更新日付) RIGHT JOIN テーブルB USING (名前);
PostgreSQLの環境がないので試すことができないのですが、 connectby()関数を使ってみてはどうでしょうか。 「PostgreSQL 階層問合せ」などで検索してみるといいと思います。 参考になれば幸いです。
その後、以下のような文書を見つけました。参考になれば。 http://www.unisys.co.jp/tec_info/tr94/9405.pdf
REINDEXをテーブルごとに行っているならば、以下の手順でデッドロックは回避できます。 BEGIN; LOCK tbl IN ACCESS EXCLUSIVE MODE; REINDEX TABLE tbl; COMMIT; ただ、REINDEX中は参照も更新も待たされるため、基本的には、オンライン処理と並行しては実行できません。代わりに CREATE INDEX CONCURRENTLY + 古いインデックスを DROP INDEX というような運用を行うことはよくあります。
TEXT型で入っているんだったら、文字列操作でいけるでしょう。 > '10010000' から5桁目の値　'1'　のみを取り出す方法です。 「右から5桁目」=「左から4文字目」ということでしたら、列名XXXに対して、 SELECT … ORDER BY substr(XXX,4,1) DESC で出来るかと思います。 桁数が8桁とはかぎらず「右から5文字目」を見る必要があるなら、 SELECT … ORDER BY substr(XXX,length(XXX)-5+1,1) DESC で。
ウィンドウ関数の lag() を使えばお望みの結果が得られます。 -- tblは得意先マスタと製品マスタの結合結果として SELECT CASE 列1 WHEN lag(列1, 1) OVER (ORDER BY 列1, 列2) THEN NULL ELSE 列1 END, 列2, 列3 FROM tbl; 列1 | 列2 | 列3 -----+--------+----- A社 | A製品1 | A@1 | A製品2 | A@2 | A製品3 | A@3 B社 | B製品1 | B@1 | B製品2 | B@2 | B製品3 | B@3
本来の質問は、 > WITH句の中で、RECURSIVEを複数回使用できるのか なのでは？ WITH RECURSIVE は、連続実行も入れ子にもできるため、後は書き方の問題です。 再帰クエリを2段重ねたいのであれば、入れ子にするのはいかがでしょう？ WITH RECURSIVE r AS ( 　WITH RECURSIVE Middle AS (...) SELECT ... FROM Middle JOIN 在庫テーブル UNION ALL 　SELECT * FROM r ) SELECT ... FROM r;
timedateはDATE型ということでしたら、整数の加減算は日単位なので、 SELECT timedate FROM testtb WHERE timedate BETWEEN current_date - ? AND current_date; ではいかがでしょうか。 参考までに、TIMESTAMP型の場合には SELECT timedate FROM testtb WHERE timedate BETWEEN current_timestamp - (? * interval '1days') AND current_timestamp; のような書き方ができます。
NO.1です。 UPDATE player_tbl SET nenrei = extract(year from age(current_date, to_date(birthday,'YYYYMMDD') )) FROM player_tbl ;
何とか 「configure」「make」「mke install」で行けました。 参考にしたのは以下のページです。 http://90h-tech.blogspot.com/2010/02/postgresql.html ただ、ディレクトリィの書き込み権限でエラーが出るなどいくつか修正が必要です。 既に8.4をインストールした環境だとremoveしても、make結果でエラーが発生する可能性はありますね。
SQL2 では DECLARE d_current DATE:= NULL; が不要です。この2行を削除すれば、結果が返ることを確認しました。名前がかぶっているため、OUT パラメータを隠してしまっているようです。
はじめまして、通るすがるともうします。 ご質問の内容なのですが、設計手法についてのご質問かと判断してお答えします。 ＤＢ（ＲＤＢリレーショナルデータベース）の設計について、以下の要領でテーブルを 決定します。（概要ですが） １．ＤＢに持たせる必要な項目の洗い出しから始めます。 ２．次にそれらをあるカテゴリ別に分類していきます。 ３．各々のカテゴリについて関係を分析する。 ４．カテゴリ毎の項目属性について検討する。 ５．テーブル名、項目名の付け方のルールを検討し、項目名を付与する。 という具合に設計を進めていきます。 カテゴリとは（エンティティ）、その業務の内容を熟知していなければできません。 いきなり、入力イメージが出てきて、それにシーク番号がついたイメージを記述 されても、他の人はその業務について無知な訳ですからアドバイスのしようが ないことになります。 データベース設計は、ＤＢ構築、テーブル定義などの知識とは別に設計手法なる 知識および経験が必要となります。 まず、「データベース設計」というキーワードで検索してみてください。 また、それらについて専門書がありますので、何冊かそれらの書物を読み 試行錯誤し研究することが必要と思います。 これらを誤って、設計し入力イメージ、項目追加により作成したテーブルが大幅に 変更となり大変なことになったシステムを私は多く見てきました。 これとは、別に性能についても検討をしていきます。 たとえば、一つのテーブルに数千万件、数億件のレコードが入るとします。 これらを一つのテーブルスペースに配置した場合、検索に時間がかかりレスポンス が低下するのであれば、使い勝手が非常に悪くクレームが上がるかもしれません。 レスポンス低下の原因として、これだけでもなくｐｏｓｔｇｒｅｓのメモリ割り当て、１テ ーブル当たりの項目数、項目属性、テーブルレコード長などの原因により低下する こともあるかと思います。またインデックス等の検討も必要となります。 さらに、サービス運用時のインデックス分割監視によるレスポンス低下による 作業方式、ハード障害時の対応方法等も検討しなければなりません。 なにぶん回答文字制限により説明不足かもしれませんが、効率的な設計ができるこ と、ご検討を祈ります。
gccで64bitアプリケーションを作成する場合は「-m64」オプションが必要なようです。 現時点のconfigureで作成されるMakeｆｉｌｅにはこのオプションが有効になっていないのではないでしょうか。 http://journal.mycom.co.jp/special/2005/compiler/013.html http://blog.jojo.jp/?eid=1010185
.NETについては分かりませんが、SQL中で演算する必要がないなら、SQL中で文字に型変換してしまって、文字で受け取るといった方法もあります。 select c1,c2 from t1 [where ・・・] といったselect文で、例えばc2列がnumeric(8,2)であるなら、 select c1,to_char(c2,'S999999.99') as c2 from t1 [where ・・・]
すでにテーブルが存在する状態で、ダンプファイルからリストアしようとした時のエラーのようです。 「(4)再度、リストア」の時の、データベースの再作成(dropdb/createdb) は本当に成功していますでしょうか。 (3)のODBCで接続した時に、testdbにコネクションが張られた状態となり、 　testdbがdropできず、残ったままで、リストアしているのではないかという気がします。 　(SQL実行中でなくても、コネクションが1つでも張られている限り、 　データベースのdropはできません。） (4)のsudo -u test dropdb testdb　実行後に、psql -l で確認すると、testdbは 　消えておりますでしょうか。 (外していたらすいません)
行統計情報の収集機能を有効にしていますか。 stats_row_level = on また、バージョンが違いますが、下記などが参考になると思います。 http://oshiete.goo.ne.jp/qa/5775824.html
あくまで個人の経験からの話です。 記載されている内容から、 「could not receive data from server: Software caused connection abort(0x00002745/10053)」 の時点でPostgreSQLのサービスが落ちて、サーバー自体の再起動時に、PostgreSQLのサービスが 上がって正常復旧。という状況かと思われます。 障害が起きた時に実行したSQL文は、select文でしょうか。 それならば、キャパシティをオーバーする大量行数のクエリが返るSQLでハングすることはありえても DBMS(PostgreSQL本体)や、データベースがぶっ壊れることはまずないと思われます。 また、select文ならばトランザクションの復旧などは不要です。 PostgreSQL8.1は、Windows版でしょうか。 「アーカイブ形式のバックアップだと一部テーブルのレコードが一切復元されない」のは、 はもともとである気がします。 今回の障害以前に、アーカイブ形式のバックアップ＆リストアは成功した実績はありますでしょうか。 私は、8.1のWindows版で、アーカイブ形式で上手くいったためしがないので、 これは“使えない機能”と判断し、いつも必ずプレーンテキストでダンプしてました。 全テーブルのレコード数一覧をとる方法ですが、私は、 select count(*) from テーブル1; select count(*) from テーブル2; select count(*) from テーブル3; … とSQL文を羅列したファイル(仮にc:\temp\getcnt.sqlとする)を作り、コマンドラインから、psqlで \o c:\temp\res.txt \i c:\temp\getcnt.sql \q のように、ファイル（この場合、c:\temp\res.txt）に実行結果を書き出して、数えています。 （なお、Windows版の場合、psql を使うときは、 　>psql -U postgres <データベース名> 　のように、ユーザ名(postgres)を指定してpsqlに接続する必要があります。） ご心配でしたら、ためしに別の名前のデータベースを作って、そこにダンプをリストアしてみて、 行数をカウントして本番サーバと同じであれば特に問題ないのではと思います。 過去、PostgreSQL(Linux版)のデータベースがぶっ壊れた状態も経験していますが、 その時は、ダンプ時にエラーが出ました。特定のテーブルに差し掛かった時に 読めないと怒られるという状況でした。 ぶっ壊れた原因はメモリ障害でした。SQL文ごときでデータベースがぶっ壊れるというのは まずありえないのではないかと思います。
マニュアルから 「区切り文字、QUOTE文字、NULL文字列、復帰、改行文字を含む値の場合、全体の値の前後にQUOTE文字が付与されます。」 すなわち、これらの文字を含まない場合はQUOTEされません。 強制的にQUOTEするには、項目を指定してFORCE QUOTEする必要があります。 http://www.postgresql.jp/document/current/html/sql-copy.html
pg_class テーブルの relpages と reltuples の比を取ってみると参考になるかと。 例えば、1行当り1000Byte以上使っているテーブルを表示するには下記の様にします。 例) ------------------------------------- select relname, reltuples::int8, relpages::int8, CASE WHEN reltuples > 0 THEN (relpages::int8 * 8192) / reltuples::int ELSE (relpages::int8 * 8192) END as per_row from pg_class where relkind = 'r' AND relpages::int8 >= 2 AND CASE WHEN reltuples = 0 THEN TRUE ELSE (relpages::int8 * 8192) / reltuples::int > 1000 END order by per_row desc; ----------------------------------------- 1行分のデータが少ないはずの無いテーブルが含まれていたら、おそらく更新・削除による不要なデータが溜まっているのかと。 なお、ブロックサイズがデフォルト以外の場合は、8192を実際のブロックサイズに変えて下さい。
>理想原価を抽出したい は、部品と予定購入数みたいな数値を渡すと上記テーブルから記載の条件で原価を取得する、 という意味で合ってますか？ とりあえず、そう考えて書いてみました。 select 部品,原価 from ( 　select t.* 　　　　　--部品ごとに購入数で並べた時、前レコード前が存在するときはその購入数・存在しない時は0 　　　　　,lag(購入数,1,0) over(partition by 部品 order by 購入数) + 1 下範囲 　　　　　--部品ごとに購入数で並べた時、後レコードが存在するときは0・存在しない時は99999999 　　　　　,lead(0,1,99999999/* ※1 */) over(partition by 部品 order by 購入数) 上範囲 　from t) where 部品 = 'A'/* ※2 */ and (310 /* ※3 */ between 下範囲 and 購入数 or 310 /* ※3 */ between 購入数 + 1 and 上範囲) ; ※1にはこれ以上の購入数はありえない、という値を設定してください ※2・※3は検索条件にあたる部品・購入数を設定してください。 ただ、PostgreSQLの環境がないのでOracle10gで試したものですので上手くいかないかもしれません。 PostgreSQL8.4から分析関数が利用できるようなので大丈夫かなと思いますが・・ http://www.postgresql.jp/document/8.4/html/functions-window.html
こんばんは。 多分postgresはウィンドウ関数が使えたはず・・・？ select カテゴリ, 商品名, case when 日付が1月なら（ここの条件がわからん・・・） then 値 else 0 end as 1月, case when 日付が2月なら（ここの条件がわからん・・・） then 値 else 0 end as 2月, sum(値) over(partition by カテゴリ) as カテゴリ合計 以下略・・・ 最近postgresやってないので、SQL忘れた・・・。 考え方はあってると思いますが？
\encoding は、データベースサーバとクライアントとの間で 文字コードを変換することを指示します。 \encoding SHIFT-JIS とすれば、クライアントが扱う文字コードは SHIFT-JIS として、データベースに登録する際は SHIFT-JIS から データベースの文字コードに変換され、データベースからデータを 取り出した場合は、データベースの文字コードから SHIFT-JIS に 変換されて取り出されます。 しかし、これとは別に端末ソフトウェアが扱う文字コードがあります。 ご利用になられている端末ソフトウェアは何でしょうか。 TeraTerm, Putty それとも Linux 上で Gnome 端末でしょうか。 これらの端末ソフトウェアにも文字コードの設定があり、UTF-8 と 設定した端末では SHIFT-JIS に変換されて取り出されたデータは 正しく表示されません。 質問されている例では、端末ソフトウェアの文字コードが UTF-8 と 設定されているのに、データベースからデータを SHIFT-JIS や EUC-JP で取り出しているために化けているのだと思います。
１．user idとして、postgresを作成します。 　　# adduser postgress 　　# passwd postgress 2..インストールディレクトリーの野作成 　　# mkdir -p /usr/local/pgsql 　　# chown postgres.postgres /usr/local/pgsql 　　# chmod 755 /usr/local/pgsql 3.ソースの解凍/インストール 　　% su - postgres 　　% cd /usr/local/pgsql 　　% tar xvf /xxx/xxx/postgresql-8.4.5.tar.gz 　　% cd postgresl-8.4.5 　　% ./configure --with-perl 　　% make all 　　% make install 　　% cd doc 　　% make install デフォルトのインストール先が/usr/local/pgsqlになっているので、これを指定する必要はありません。 4.自動起動設定 　　# cd /usr/local/pgsql/postgresql-8.4.5/contrib/start-scripts 　　# cp linux /etc/rc.d/init.d/postgresql このpostgresqlを修正し、$PGDATAを/home/postgres/dataに変更します。 chkconfigを使って、起動設定をします。 5.シェアードライブラリー設定 　　# cd /etc/ld.so.conf.d 　　# vi postgresql /usr/local/pgsql/lib 　　# ldconfig 6.データベースの初期化 　　% su - postgres 　　% initdb -E UNICODE 7.設定ファイルの初期化 　　下記ファイルに初期設定を追加します。 　　/home/postgres/data/pg_hba.conf 　　/home/postgres/data/postgresql.conf 8.postgrsqlの起動確認 　　# /etc/rc.d/init.d/postgresql start 　　# ps -ef | grep postgres ここで、タスクが5個ぐらい起動していれば、正常です。
設定の問題ではなく、PostgreSQL本体にメモリリークのバグが原因と思われます。徐々にメモリ消費が増えていってしまいます。 9.0.2で修正されているので、アップデートしてみてください。 - Fix long-term memory leak in autovacuum launcher (Alvaro Herrera) バージョンアップしないで対処となると、PostgreSQLサービスを定期的に停止／再起動するくらいしか手がありません。
pg_dump --schema-only と --data-only で、スキーマとデータを分けてダンプしてはいかがでしょう？ スキーマのほうにテーブルとインデックスの定義の両方が含まれてしまうため、テキストエディタ等で手作業で分離する必要がありますが、データを含んでいないのでファイルサイズも小さくなり、編集しやすくなるかと思います。
以前使用していたバッチに提示されている内容をコピペしただけで動作確認していません。 オプション"-t"を指定して行のみ表示にする必要があります。 for /f "usebackq tokens=*" %%i in (`call "C:\Program Files\PostgreSQL\8.2\bin\psql.exe" DB名 -t -c "select count(*) from table"`) do @set RESULT=%%i echo %RESULT%
MeCab が 00001 を 1 つの単語として切り出してインデックスを作っているので、基本的には 0000 で検索してもヒットしません。 MeCab を使うような分かち書き方式の全文検索では、単語を切り出すときに使う辞書によるので、お望みのようなことを行うには N-gram 方式の全文検索が適しています。PostgreSQL では Senna や Groonga といった N-Gram 方式の全文検索エンジンと組み合わせた textsearch_senna や textsearch_grronga を使うのがいいでしょう。 ただ、PostgreSQL 8.4 以上をお使いのようですので、前方一致であれば MeCab でも 0000 をインデックスを使って検索できます。 SELECT * FROM table1 WHERE tsv @@ to_tsquey('japanese', '0000*');
LINUXにデフラグはありません。 Postgresは追記型なので、Updateを繰り返すと、ファイルがディスク内で細切れになり、遅くなります。 バキュームはホールを無くしてくれますが、細切れになったファイルはそのままです。 遅くなったら、バックアップ後、mkfs.ext3でファイルシステムを作り直して、リストアするしかないですね。 http://www.linuxlic.com/command/mkfs.html それが嫌だったら、ホールを再利用するOracleに乗り換えた方がいいですね。
環境が無いので適当ですが、こんな感じですかね。 select 店ＩＤ, 商品ＩＤ from ( select 店ＩＤ, 商品ＩＤ, row_number() over(partition by 店ＩＤ order by random()) as n from table where 店ＩＤ in('000001','000002','010000','011111','020000') ) where n = 1
インストールして一度起動しないと,PostgresのDBが作成されないので、エラーになっているだけでは？
要件に矛盾があります。 > 1 |a |作業中 |1 「No=1」かつ「名称='a'」の行は2行あり、それぞれ「状態」は「作業中」と「準備中」があるので、どの「状態」とすればいいのか決められません。 「作業中」もカウントするというなら、例えば次のようなSQLで実現可能です。 -- sum関数 select "No." ,"名称" ,sum(case when "状態"='作業中' then 1 else 0 end) as "作業中数" ,sum(case when "状態"='準備中' then 1 else 0 end) as "準備数" from "tblA" group by "No.","名称" order by "No." ; -- count関数 select "No." ,"名称" ,count(case when "状態"='作業中' then 1 else null end) as "作業中数" ,count(case when "状態"='準備中' then 1 else null end) as "準備数" from "tblA" group by "No.","名称" order by "No." ;
BETWEEN A AND B は「A以上B以下」を表す式です。 http://dev.mysql.com/doc/refman/4.1/ja/comparison-operators.html 中学受験勉強でやる「植木算」と同じですね。 つまり、A, BにDATE型を指定すれば１日が重なるし、 No.1の補足のようにDATETIME型を指定すれば１秒間が重なります。 したがって、その本の内容は 「日付が変わった直後の１秒間を除けば」正しい答えが得られることになります。 著者の詰めが甘いってことですね。 より正確を期すなら＞＝と＜を使って書いたほうが無難です。
最近のPostgreSQLがどこまで出来るのかよく知りませんが、 下記でいけると思います。 SELECT Bテーブル.* FROM Bテーブル LEFT JOIN Aテーブル ON Bテーブル.キー項目 = Aテーブル.キー項目 WHERE Aテーブル.キー項目 IS NULL
タイトルが悪すぎると思いますけど。 「同じような制約を何度も定義する必要がある」ということ自体が、問題なのでは？ 同じような定義をたくさん行う必要があるというなら、SQLの動的実行（SQLを文字列で組み立てて前処理（prepare）して実行（execute））をすればいいのでは？ その時に「星座名が必要」、「手作業でやったらタイプミスや重複して書き込むといった人員的なミスがある」といったことなら、事前に星座表（星座名で一意にしておく）を作っておいて、その検索結果をSQLの組み立てに利用（文字連結していく）すればいいと思いますよ。 そもそも、星座表を参照する参照制約にすれば、検査制約で星座名をだらだらと書く必要はないですけど。
#1 です。 余計なお世話かもしれませんが、親子関係で階層的にデータを持たせるのは、主たる要素の意味合いの粒度が同じ場合の方が好ましいです。 例えば、前便のサンプルで頻出する社員テーブルの場合、主キーは社員ID、エンティティの意味する粒度は親でも子でも変わらない「社員」です。 ご質問の場合、アジア→日本→東京（地域→国名→地名）のように粒度が荒いので、マスタとして今後、使いにくくなっていく可能性があります。 既に設計済みでもう変えられないなら、仕方ありませんが。 また、単純に地名マスタ程度の意味合いしかないのであれば、今のままでも問題無いと思います。
Windowsみたいなので、FINDSTRコマンドを使うといいと思います。 FINDSTR /B [a-zA-Z] 外部ファイル.txt | psql -c "COPY table1 FROM stdin DELIMITERS ' ' NULL ''" FINDSTR /B [0-9] 外部ファイル.txt | psql -c "COPY table2 FROM stdin DELIMITERS ' ' NULL ''" 外部コマンドを使わないんだったら、table1にトリガを定義して英字でなければtable2に挿入するように作り込むという手もありますね。
　大概のＲＤＢＭＳで、サポートされ、一応使える配列型ですが、実は、ＳＱＬとは人一倍相性が悪いです。ついでに、インデックスとはもっと相性が悪いです。 　そもそも、リレーショナルデータベースを学ぶ時に、テーブル設計の一番最初の方で学ぶことの一つに 　「繰り返し項目を無くしましょう。」 　というのがあります。 　繰り返し項目の直接的な表現が配列であり、その変形が、「線分１」「線分２」「線分３」とフィールドを並べていくやり方です。両方とも、テーブルを設計する最初の段階で排除しなければならないデータ形式です。 　なぜかという理由の一つが、あなたが今やろうとしている事が出来なくなるからです。 　今回の事例で、線の集合が何を表すのかが今ひとつ、質問からは読み取れませんが、例えば、線の集合が一つの形を表すのだとすれば、 　create table shape_tbl (id serial, note varchar(20) , primary key (id)) ; 　create table line_tbl (shape_id integer, line_id serial, line_coordinates lseg 　　　　　　　　　　　　　primary key(shape_id, line_id)); 　と構成するべきかと思います。 　これなら、質問の検索は、単純に 　select * from line_tbl where line_coordinates && lseg((0,80),(0,80)); 　で検索できますし、形に関する情報も添付する必要があるのであれば、shape_tblをshape_idをキーとして連結すればＯＫです。 　形毎の座標を列挙するのも、shape_idで結合すれば、別に複雑な話ではありません。 　インデックスも、line_tblのline_coordinatesに対してなら、問題なく張れます。（ただし、線分に含まれる座標のインデックスは・・・・無理です。線分に含まれる点の数が∞ですから。両端の座標に対してなら、幾何関数を使ってインデックスを張ればいけるかな。） 　使ってはいけないのなら、なぜ、配列型をサポートするのか。ごくごくまれに、配列で表現することが素直なデータも存在するからです。でも、これを使う時には、十分な配慮と考慮が必要です。 　間違っても、配列の要素をスキャンして検索するＳＱＬなんて事は考えてはいけません。配列で表現することが素直であると宣言した限りは、そのデータは原則として一群のものとして取り扱われるはずですし、一部を扱う際には、そのための関数が用意されているはずです。演算が必要なら、その演算のための関数も用意されているべきでしょう。少なくとも、ＳＱＬ文で、配列の要素にアクセスすることは無いはずです。（例えば、integer型において、各桁のどこかに1が含まれているかどうか・・・なんてＳＱＬは書きませんよね？文字列において、部分文字列を検索する時には、専用の演算子と関数が用意されていますね？そういう事です。） 　テーブル構造を変えることが、何らかの事情で出来ないのであれば、配列内の座標を扱うための一連のユーザー関数を定義するしかないと思われます。例えば、is_exist_point(座標群, 検索座標)とか言った形の関数ですね。これがあれば、配列の中に特定の座標があるかどうかが、SQLで検索できます。がやっぱり、泥縄ですね。
物理メモリーは何メガバイト積んでいるのでしょうか.１GB未満は問題がありますね。 postgres.confの設定はどうなっていますか? ＃ディスクアクセスの高速化設定 fsync = off wal_sync_method = open_sync の設定はしていますか. ＃物理メモリー使用量の設定 shared_buffers = 2048 sort_mem = 1345 vacuum_mem = 8192 ※上記のサイズは、128KByte単位です。 この設定だと、Postgresの物理シェアードメモリーバッファサイズが256MBになります。 でも、8万行程度のインサートは10秒ぐらいで終わると思います。 Postgresは、メモリーをいっぱい積んで、設定を正しく行えば、高速に動作しますよ. 但し、Ver 8.3以降ですが。
マニュアルはここみたいですね。 http://pgpool.projects.postgresql.org/pgpool-II/doc/pgpool-ja.html PostgresSQL 9.0でレプリケーションがサポートされた見たいなので、 そちらに移られてもどうでしょうか。 レプリケーションはOracleでも初期はトラブル続発でした。 ましてや、PostgreSQLで使おうなんて、私は夢にも思いませんね。
>S-JISの文字コード表にない "京"のS-JISは、"8B9E"だと思うのですが… ところで、CSVファイルをメモ帳やExcelで開いとき、"京"はどのようになっていますか？ ここで正しく表示されているなら、EUCに変換する際にミスをしていると考えられます。 また、正しく表示され、EUCにも変換出来ているなら、Windowsアプリ側の問題となります。 メモ帳などで表示されないのなら、EUCに変換出来なくて当然ということになります。 それから、Windows側のＯＳは何ですか。 ＯＳにより、フォントのバージョンに違いが有ります。それが関係している可能性も考えられます。 WindowsXPではダメでも、Windows7では正しく表示されるかも知れません。 そのあたりをもう一度見直されてはどうでしょうか？
コレーション（lc_collate）と文字型（lc_ctype）は PostgreSQL 8.3 まではデータベースクラスタの作成時にしか指定できないので、pgAdmin III でデータベースの作成時に選択できないようになっているものと考えられます。
サーバ、クライアントとも　ポートが空いているのなら、 postgresql.confで例えば 　listen_addresses　= ‘localhost’ として待ち受けのIPアドレスを限定していないか pg_hba.confで 　host all all 127.0.0.1/32 trust 等で接続元をlocalhostのみ許可になっていないか をチェックしてはどうでしょう
>Cent osのデータベースサーバーの選択としてpostgrsqlをインストールしました。 バージョンは？ >いつの間にか/var/lib/pgsql/dataにも出来ています。 CentOS5.5のリポジトリから入るものだと、 /etc/init.d/postgresql で PGDATA=/var/lib/pgsql によって指定されています。 そのままスクリプトを読んでいくと、 /etc/sysconfig/pgsql/postgresql というファイルがあれば、そちらでオプションなどを上書き可能なようですので、 PGDATA=/pgsql と記述すれば切り替えてくれるのではないでしょうか？ # /etc/sysconfig/pgsql/S64postgresql かも知れませんが… あるいは、 rm -rf /var/lib/pgsql ln -s /pgsql /var/lib/pgsql として、シンボリックリンクを張るとか。
提示されたデータ以外に例えば次のようなデータがあった場合、user=f、gが検索される必要があると言うことでいいですか？ insert into "num" values ('f',1100) ,('f',2100) ,('f',2300) ,('g',2300) ; (1) -- idの値が、2200台では2201と2202しか持たないuserを得る select x."user" from "num" as x inner join (select "user" from "num" where "id" between 2200 and 2299 group by "user" having count("id")=2) as y on x."user"=y."user" and x."id" in(2201,2202) group by x."user" ; (2) -- idの値が、2200台を持たないuserを得る (select "user" from "num" group by "user" ) except (select "user" from "num" where "id" between 2200 and 2299 group by "user" ) ; (3) -- 二つのクエリをunionで繋ぐ -- idの値が、2200台では2201と2202しか持たないuserを得る select x."user" from "num" as x inner join (select "user" from "num" where "id" between 2200 and 2299 group by "user" having count("id")=2) as y on x."user"=y."user" and x."id" in(2201,2202) group by x."user" union ( -- idの値が、2200台を持たないuserを得る (select "user" from "num" group by "user" ) except (select "user" from "num" where "id" between 2200 and 2299 group by "user" ) ) ; (2)のクエリで得た結果を(1)にunionで繋ぐため、()が増えていることに注意してください。
select * from pg_catalog.pg_class,pg_catalog.pg_statio_user_tables where relkind='r' and pg_catalog.pg_statio_user_tables.relid=pg_catalog.pg_class.relfilenode ですかね。
更新(削除を含む)がなければバキュームはしなくていいです。 初期データを放り込んだ後でインデックスを作成すればリインデックスは不要なのですけどね。 ま、時間があればリインデックスしてください。
pg_dumpの出力は文字列です。 だから、tailとか使えば、エラーが発生した直前のレコード等が見えると思います。
PostgreSQL の FAQ に用意されているこれが多分公式.
PHP4用 $from = date('Ymd');//今日の文字列 //1ヵ月後の文字列 $time = getdate(); $time['mon']++; if($time['mon'] > 12){ $time['year']++; $time['>mon'] = 1; } $to = sprintf('%04d%02d%02d', $time['year'], $time['mon'], $time['mday']); //SQL文の作成 $sql = "select ee,ti,na,ca from テーブル名 where ca = 'カテゴリー名'"; $sql .= " and ee>='$from' and ee<='$to'"; $sql .= " order by ee asc"; 月末日の考慮はしていないので1月30日の時、2月30日になってしまうけど一応このような感じで。
簡単には実現できないです。 データベースの一覧は pg_database を参照すれば取得できますが、スキーマとテーブルの一覧は接続中のデータベース内のものしか取得できません。 接続中のデータベース内のスキーマとテーブルの一覧であれば以下の SQL で取得できます。 SELECT n.nspname, c.relname FROM pg_namespace AS n JOIN pg_class AS c ON (n.oid = c.relnamespace) WHERE c.relkind = 'r'; どうしても別のデータベース内のスキーマとテーブルの一覧を取得したい場合には、dblink などのモジュールを使用する必要があります。 ただ、dblink を使用しても PL/pgSQL 関数などを作成せずに 1 つの SQL で実現するのは困難です (私の技術がないだけかもしれませんが)。 以下の SQL でデータベースの一覧を取得し、各データベースに接続してスキーマとテーブルの一覧を取得するのが簡単だと思います。 SELECT datname FROM pg_database WHERE datallowconn;
pg_toast は TOAST テーブル、pg_temp_xxx (xxx はセッションごとに異なる) は一時テーブルが作成されるスキーマです。 ちなみに TOAST テーブルというのは巨大なデータを内部的に分割して格納するためのテーブルです。TOAST については参照 URL を読んでみてください。
サーバーにログインできれば、COPYコマンドでCSVファイルの入力は可能だと思いますが。
Windowsの環境変数ですか。 set PGDATA=D:\PGDATA とかですかね。 ごめんなさい、デフォルトは知らないです。
結論から言ってしまうと、不要になった WAL セグメントは再利用されるので、一定以上のディスク容量は消費しません。 WAL セグメントはビルド時に明示的に指定しない限り 1 個あたり 16MB であり、通常、セグメント数は (2 + checkpoint_completion_target) * checkpoint_segments + 1 個以下なので、PostgreSQL 8.4 のデフォルトの設定のままであれば 64MB (((2 + 0.5) * 3 + 1) * 16MB) 以下になります。 あと、checkpoint_timeout パラメータは WAL セグメントを作成する間隔ではなく、チェックポイントを実行する間隔を指定するパラメータです。 まず、WAL やチェックポイントが何なのかを理解したほうがいいと思います。
トリガーって無いんだっけ？
>「そんなところに作ってんじゃねーよ！ >ちゃんと自分でスキーマ作ってそこに入れてくれ！」 と言って直してもらう程の事です。 何と言っても「共通資源」ですからねぇ。無秩序に 作成／変更／削除されたらどうするんでしょ？
postgresqlのバージョン、バージョンが同じでもその環境によって動作が異なります。 質問をする際は最低限バージョンを明記した方が回答しやすくなります。 >CURRENT_DATEは日付型でSUBSTRでとりだした日付は文字列 >なのに何故正しく比較できているのでしょうか？ >日付型の形式の文字列であれば、RDBMSがかってに日付型にしてくれるのでしょうか？ ご想像のとおりです。いい感じに処理をしてもらっている状態です。 本来は日付と文字列のどちらかを変換して型をそろえる必要がありますし、SUBSTRの引数も日付型ではなく文字列を与えるべきです。 ちなみに私は8.4.1を使用していますが、提示されているようなSQLはエラーとなります。 参考URLをひととおり読んでみてください。 7.4から8.4にバージョンアップした経験があるのですが、システムで発行しているSQLがバタバタとエラーになり、日頃いい加減なSQLを書いていたのだと思い知らされました。
pg_encoding_to_char関数で文字エンコーディング名に変換できます。 => SELECT datname, pg_encoding_to_char(encoding) FROM pg_database; datname | pg_encoding_to_char -----------+--------------------- template1 | UTF8 template0 | UTF8 postgres | UTF8 (4 rows)
PostgreSQLのCASE文を調べると良いです。
postgreSQLの環境はないのですが、下記の様なSQLでは抽出できないでしょうか。 SELECT no FROM date_tbl WHERE start_date <= now() AND end_date >= now() ただし、now()はトランザクションが開始された時刻を返すそうなので、厳密な比較を行いたい時や、コネクションプーリングなどを使用している場合は注意が必要なようです。
回答番号: No.2 の続きです。 aForm.getPrefecture() などの戻り値が null ではなく空文字 ("") の場合には、coalesce 関数の 1 つ目に渡している条件式の結果が NULL になりません。空文字の場合には NULL になるように nullif 関数をかませるとうまくいくと思います。 String selectStatement = "SELECT * FROM test,test_list WHERE test.id = test_list.id " + "AND coalesce(prefecture=nullif(?, ''), true) " + "AND coalesce(low_price>=nullif(?, ''), true) " + "AND coalesce(low_age>=nullif(?, ''), true) " + "AND coalesce(sameday_select =nullif(?, ''), true) " + "AND coalesce(terms_select =nullif(?, ''), true)" + "AND coalesce(category=nullif(?, ''), true)"; 値が指定されていない場合に aForm.getLow_price() などの int 型の戻り値がどうなるかが分からないのですが、0 を返すなら nullif(?, 0) などと書き換えてあげる必要があるかもしれません。
このような感じでしょうか。 括弧を使って条件を区切る事で抽出可能かと思います。 SELECT 　* FROM 　q_table WHERE 　( 　　(パターン='001' AND データA='P1だけ') 　　OR (パターン='002' AND データB='P2のみ') 　　OR パターン='003' 　) 　AND データC='共通' ※インデントのために全角スペースを使っています。
こんにちは。 おまじないです。 データベース名=>SET client_encoding to 'SJIS'; 毎度タイプするのがいやでしたら、 postgresql.confでclient_encodingを修正しましょう。
一応、レプリケーションで調べてみると Slony-I，Rserv，dbmirror etc 等出てきました。どれも、Linuxでの動作実績がありそうですが・・・。
gzipのWindows版を使う http://www.gzip.org/ >--format=c オプションで出力したファイルは解凍のみの方法が分かりませんでした format=cはPostgresSQLで使うことだけを考えているもののようです。 format=pのテキストを単純に圧縮したものではないようです。
pg_dumpコマンドによってデータベース内のデータをファイルに出力する際、とくにオプションを指定しなくてもzlibライブラリによってファイルが圧縮されるということです。
アプリケーションといっしょにPostgreSQLを配布するということは、アプリケーション自体のインストーラはあるのでしょうか。 アプリケーションのインストーラがあるのであれば、PostgreSQLのバイナリはインストーラ形式だけでなくZIP形式でも配布されているので、それを適切な位置に配置するようにインストーラを作りこめばいいと思います。 あくまでインストーラ形式のバイナリでコマンドラインからインストール（いわゆるサイレントインストール）したいということなら、最新バージョンの8.4ではBitLock InstallBuilderでインストーラが作成されているので、そのドキュメントを参照してみてください。コマンドラインから--helpオプションを指定してインストーラを実行すると指定できるオプションが表示されます。 実際に確認したわけではありませんが、--mode unattendedオプションとWindowsのサービス名やアカウント名などを指定すればできそうな感じです。
まず、前置きです。 表の定義情報などが登録先は、RDBMSによりカタログ、ディクショナリなど管理方式や呼称が異なり、その参照方法も独自のコマンドを使ったり、SQLのSELECT文で行えたりします。 各RDBMSごとにバラバラである「定義情報の参照方法」について、標準SQLで情報スキーマ(information_schema) が規定され、各RDBMSによる実装も進みつつあります。 たとえば、標準SQL準拠で情報スキーマを実装しているRDBMSでは、 表名一覧・・・データベース名、スキーマ名などを条件に、information_schema.tables 表を検索 表の構成列一覧・・・データベース名、スキーマ名、テーブル名などを条件に、information_schema.columns 表を検索 を参照すれば、名称などを同じように得られます。 ただし、データベース、スキーマ、ユーザなどのRDBMSにより概念に違いがあるものは、どの表のどの列に情報を入れているかを確認する必要があります。 さて、列名やデータ型ですが、前述のように information_schemaのcolumns表を検索すれば得られます。 ここで問題になるのは、データ型です。 文字型、数値型、日付型など様々なデータ型があり、また長さを指定するものや指定しないものがありますよね。 単純にchar、varchar、integer、dateなどのレベルの情報であれば、data_type 列で得られるのですが、長さなどの情報はdata_type列の内容により、参照すべき列が異なってきます。 どのレベルまで知りたいのか分かりませんが、実際にcolumns表の内容を確認し、得たい情報を自分なりに調べてみてください。 PostgreSQLの information_schema.columns 表 の詳細については、以下を参照してください。 http://www.postgresql.jp/document/pg830doc/html/infoschema-columns.... information_schema.columns 表 の検索例は、次のような感じです。 select table_schema as scm ,table_name as tbl ,ordinal_position as "no" ,column_name as clm ,data_type ,character_maximum_length ,character_octet_length ,numeric_precision ,numeric_precision_radix ,numeric_scale from information_schema.columns where table_name in('t1','t2') order by table_name,ordinal_position
「time 定数」で「指定した定数をtime型と認識してね」という構文であり、「time 列名」という構文はありません。 標準SQL準拠の書き方であれば、 CAST(列名 AS TIME) [AS 別名] PostgreSQL独自の書き方であれば、 列名::time といった書き方もあります。
pg_dumpコマンドの引数に -h localhost を追加すればよいと思います。
pg_stat_activity ビューを参照すれば、実行中の SQL とその PID を特定できるので、 test=> SELECT procpid, current_query FROM pg_stat_activity; procpid | current_query ---------+---------------------------------------------------------------- 17288 | <IDLE> in transaction 17287 | UPDATE branches SET bbalance = bbalance + 1487 WHERE bid = 5; スーパーユーザでデータベースに接続し、その PID を指定して pg_cancel_backend 関数を呼び出してあげれば、実行中の SQL をキャンセルしてサーバとの接続を切断できます。 test=> SELECT pg_cancel_backend(17287);
Accessのクエリで正しく処理されるようなので、sqlの問題ではなくvbaでのtokucdの取得方法に問題があるのではないでしょうか？ どのように取得しているのかわかりませんが、そちらをもう一度見直してみてはどうでしょうか？
Window版は使ったことないのですが、エラーを見る限り、 ユーザpostresがないか、あってもCREATEDB権限がない。またはPostres自体が起動してない。 一番簡単にデータベースを作成するにはまずcreateuserでスーパーユーザを作り、 createdb -U super_user -W super_user_password DATABASE_NAME とするか、Windows管理者(または管理者権限のあるユーザ)でログインし直して、 createdb DATABASE_NAME を実行する。
こんにちは。 >例えばサーバーへODBC＆ADOで接続した場合、 >ワークテーブルの取扱方法（接続方法）が分かりません。 素のPostgreSQLからAccessへの接続する方法はありません。ですから、 基本的には クライアントのAccessからPostgreSQLに接続することになります。 したがって、Jet-SQLの機能でPostgreSQL上のテーブルを外部テーブルとして 処理します。 で、どうするかですが、リンクテーブルが使えなくなってしまったので SQLのIN句を使います。 PostgreSQLからAccessにデータを渡すのは INSERT INTO jettbl (f1, f2, f3) SELECT f1, f2, f3 FROM [ODBC;DRIVER=PostgreSQL35W;SERVER=srv1;DATABASE=db1;UID=xxx;PWD=yyy;].pgtbl; こんな感じでできます。これを参考にされればこの逆は想像できませんか。
bash等のB sh系では 変数名=値 コマンド.... とすると、変数に値を(一時的に)設定してコマンドを実行します。 > PSQL='COPY bat_test FROM ' '''/test/test.csv''' ' with DELIMITER ' ''',''' この文ですが、環境変数 PSQL='COPY bat_test FROM ' をセットした状態で '''/test/test.csv''' ' with DELIMITER ' ''',''' を実行する、という意味になります。 'は 2つずつペアになるので ''が空文字列 '/test/test.csv'が/test/test.csv ''が空文字列 となり、 /test/test.csv がコマンドとして実行されます。 が、実際には実行属性が無いので permission denided になります。 (実行属性があったとしても、test.csvが実行できるとは思いませんが) この行全体をPSQL変数に設定したいのなら PSQL="'COPY bat_test FROM ' '''/test/test.csv''' ' with DELIMITER ' ''','''" と、全体をダブルクォートでくくるとか PSQL='COPY bat_test FROM '\ '''/test/test.csv'''\ ' with DELIMITER '\ ''',''' と、スペースを\でエスケープて、単語の区切りとしての意味を無効にします。 ところで、'''を、 'の中に'を入れる目的で使ってませんか? VisualBasic等はそういう書き方をしますが、bashではその意味では使えません。 'のなかに'は書けないので、全体をダブルクォートでくくる PSQL="COPY bat_test FROM '/test/test.csv' with DELIMITER ','" とか、シングルクォートの前でいったんシングルクォートを閉じて、"'"か\'でシングルクォートを単独で使い、再びシングルクォートを始める PSQL='COPY bat_test FROM '\''/test/test.csv'\'' with DELIMITER '\'','\' とかします。 #等幅フォントで見ないとわかりずらいものになってしまいました。
私も同様の症状でインストールに失敗した一人です。 原因はWindows7 OS のセキュリテイ機能にあります。 ポイントは「一般ユーザー」でログオンし実行することです。 対策の手順として以下の通りに実行してみてください。 1.Windows7に管理者ユーザーでログオンして、権限：管理者としてユーザー「postgres」 を追加してください。（必ずパスワードを忘れないように） 2.アンチウィルスソフトの一部に影響を与えるものがある為念のためサービスを一旦停止 します。 ファイヤーウォールは有効のままで大丈夫です。。 3.Windowsを一旦ログオフして、一般ユーザー（管理者権限でない）でログオンし直します。 4.PostgreSQLのインストーラーのダウンロードですが、Windows7のOSに合わせて32ビット 用か64ビット用を選択して実行してください。 5.ダウンロードしたインストーラーを右クリックしてプロパティを表示させます。 「全般」タグの一番下「属性」の部分に「このファイルへのアクセスはブロックされる 　　　　可能性がある・・・」 と表示されている様なら「ブロックの解除」ボタンをクリックして解除してください。 6.インストールの開始でまずインストーラーファイルを右クリックし 「管理者として実行・・・」をクリックして実行します。 「管理者ユーザー」選択のダイアログボックスが表示されたら「postgres」を選択し 登録したパスワードを入力します。 これで正常にインストールが開始されるはずです。 7.途中インストールフォルダの指定する画面が出たらデフォルトの 「C:\Program Files (x86)\PostgerSQL\xxx」を「C:\PostgerSQL\xxx」等の ディレクトリに変更し最後に「postgres」ユーザーのパスワード入力画面では Windows7の「postgres」ユーザーパスワードを入力しインストールを完了してください。 8.最後にWindows7の管理者ユーザーでログオンしなおして「postgres」ユーザーの権限を 管理者から一般ユーザに変更し直して終了です。
VACUUM が適切に実行されずに性能が低下していることを前提として回答します。 更新頻度の高い巨大なテーブルが存在する場合には、自動バキュームの設定をテーブルごとに調整したほうがいいと思います。 デフォルトの設定のままでは、UPDATE や DELETE で不要になった行が 50 行 (autovacuum_vacuum_threshold) + 全行数の 2 割 (autovacuum_vacuum_scale_factor) を超えた場合に VACUUM が実行されます。 例えば、テーブルの行数が 100,000 行の場合には不要な行が 20,050 行を超えると VACUUM が実行されますが、100,000,000 の場合には 20,050,000 行を超えるまで実行されません。同じ 2 割であっても 2 万行と 2 千万行では性能への影響が違います。 PostgreSQL 8.3 であれば、pg_autovacuum テーブルにエントリを追加すればテーブルごとに自動バキュームの設定を行うことができます (参考 URL を見てください)。 あと、その他に気になることとしては、デフォルトでは自動バキュームで同時に起動できる VACUUM は 3 つ (autovacuum_max_workers) までなので、更新頻度の高いテーブルが大量に存在する場合には、自動バキュームが特定のテーブルへの VACUUM につきっきりになってしまい、VACUUM の実行されないテーブルが発生して性能が低下してしまう場合があります。
　はじめまして、通りすがると申します。 　上記質問の内容ですが、検索レスポンスの遅延として考えられるのは何もｓｑｌによる 　検索レスポンスだけではないと思います。 　検索した結果が非常に多いが検索時間はわずかで済んでいるにも関わらずそれをｗｅｂ サーバーが回線を通して、結果的にクライアントへの表示できる形にするために時間を とられている可能性もあります。よって画面設計（遷移））も含めて見直す必要がある かと思います。 　例としては、２０件、５０件、１００件と一度に表示できる件数をクライアントで指定 できるようにして、その分がＤＢサーバーで検索完了したらその分だけ表示する。クライ アントから、次のページまたは、前のページ表示のための指示を受けてからその分の 検索のみを実施し表示する方法もあります。 　それ以外にも設計によって遅延している可能性があると思いますので、設計レベルから 見直したほうがよいと思います。 　
とりあえず実際にSQLを実行して試していないけど、訪問周期日数をinterval型にキャストして顧客訪問日に足してやればいいんじゃない？ SELECT テーブル1.顧客番号, テーブル1.顧客名, テーブル1.顧客訪問日 + (テーブル2.訪問周期日数 || ' days')::interval FROM テーブル1 JOIN テーブル2 USING (顧客番号); 何かこんな質問がつい最近もあったような気がするけど。 排他制御についてはどんな仕様か言ってもらわないと答えづらい。
phpとpostgresは同じネットワークにあるんですか？ 環境で変わったのはそこなんですから、とりあえずパケットトレースしてみては？
>INSERT 0 1が大量に表示されて遅いです。 ということはbak.sqlを開いて見ると"INSERT"コマンドが使われているんでしょうか？ もしそうならpg_dumpしたときのPostgresが古いんじゃないですか。 私のはVer.8.3ですがdumpファイルをみるとcopyコマンドが使われています。 ほぼ同じ１GBのファイルですが、数秒で終わりました。
参考になるかわかりませんが。 私は少し前にVB.NETを使用してWindowsアプリケーションの開発をしました。 PostgreSQLとVS2008の接続をnpgsqlを使いました。(初めて使いましたが特に問題なく接続できました) 参考にならなかったらごめんなさい＞＜
Administrator権限のあるUserIDでインストールしていないのでは。
通りすがりです。 確認を実施していただいてありがとうございます。 さて、当方の環境として確認しましたのは、以下のようになっております。 １．windows版　postgres8.3 ２．linux版　postgres8.3 　postgres.confの中身を確認しましたがいずれも、tcpip_soketなるパラメータ 　は存在しませんでした。ただググってみますと、7.4.5の時代にはあったようです。 　なお、接続のために設定した内容については以下のようにしました。 　１．windows版 　　　　特になし 　２．linux版（SentOS5.1） 　　　postgres.conf 　　　　listen_addresses=*　'受付ＩＰアドレスを追加する。（この場合無条件に受付） port=5432 '規定値 max_connections=xxx '規定値　100　データベースサーバに同時接続する最大数 　　　　unix_socket_permissions　規定値　0777　ユーザとグループのみ接続を許可すに変更 　　 pg_hba.conf host all all 192.168.1.x/32 password 　　　　　'メンテナンス対象クライアントのアドレスを設定する。なお接続はパスワードを要求する。 以上の設定で接続が確認されました。 　接続の確認は、ＬＡＮ上のwindowsＰＣから、pgadminにより確認。 　ｐｈａｄｍｉｎにより接続確認ができた場合には、あとはプログラムの問題なので、そこで切り分け。 　といったぐらいです。 　　 　クライアント側からの接続方法も言語、バージョンによりまたは、記述ミス等もあると思いますので 　接続できない場合には、一応疑って色々と試してみます。 　　なお、ｐｏｓｔｇｒｅｓｓ８．４のマニュアルにも、特にＴＣＰＩＰ接続については 　基本有効となっており、オプションとしてｓｓｌの設定が必要云々を記述されております。 　おそらく、昔、この記述があったが最新版において無くなったのではないでしょうか？ 　そちらの環境で、pgadminによる（その他接続方法でもかまいません）接続試験はご確認された 　のでしょうか？ 　参考までに、接続に関するパラメータの説明は、 　　http://postgresql.jp/document/current/html/runtime-config-connection.html 　　項　18.3.1　を参照ください。 　　　8.4版のマニュアルです。 　　 　
これでどうでしょう。 Select A + (B || 'm')::interval from hoge
posgresql.confというのがありはずですからそれでportを指定できます。 再インストール希望の場合、--prefixを変更しなければ--with-pgportで上書きされます。
mimzyさんの言うとおりで、psqlと接続先のPostgreSQLのバージョンが一致しておらず、psqlで解釈される\d（テーブルなどの一覧を表示）などのバックスラッシュコマンドの実行がエラーになる場合があることを警告するメッセージです。とくに大きな害はありません。 psqlを実行したサーバとPostgreSQLが動作するサーバが同じなのにも係わらず警告のメッセージが表示されるとしたら、コマンドのサーチパスが正しく設定されていないのではないでしょうか。 PostgreSQLをソースコードからインストールした場合には、--prefixオプションを指定していないとPostgreSQLのコマンドは/usr/local/pgsql/binディレクトリにインストールされます。デフォルトでは環境変数PATHに/usr/local/pgsql/binディレクトリが含まれていないので、OSの標準的なパッケージとしてインストールされたpsqlが優先されているかもしれません。
演算子~*の~は正規表現に一致する検索、 *は大文字小文字を区別しないという意味 です。 正規表現'.*>[^<]*★.*<.*'について 始めの".*"は任意の文字列を示します。 "."は任意の文字、"*"は0回以上の一致を 表わします。次の">"はタグの終わりを表す 文字です。次の"[^<]*"は"<"でない文字が 0回以上（"*"です）続くことを示します。 "[]"はグループ化、"^"は否定を意味します。 例えば[^0-9]は「数字ではない」ということ。 '.*>[^<]*'は'～>～'ということです。 この後にキーワードが続きます。 ★の後の'.*<.*'はもうお分かりですね。 '～<～'ということです。この記述は ">"と"<"の間にあるキーワードを探すことに なります。但し、<xxx y="aa>bb" z="★">の ようなタグがあると、誤認します。">"が 引用符の中かどうか分かりませんからね。 気をつけていただきたいのはキーワードの中に "."とか"*"のように正規表現上、意味のある 文字を含む場合はエスケープする必要があると 言うことです。 以下を参考にして、試行錯誤してみてください。 http://www.postgresql.jp/document/pg842doc/html/functions-matching.html#FUNCTIONS-POSIX-REGEXP 少し前のバージョンでは"+"を正しく解釈して くれませんでした。現バージョンで直っている かどうかは不明です。
データの量がわからないので 3時間が長いのかは判断できませんが・・・ １．テーブルごとに小分けにする VACUUM ANALYZE table ２．解析の対象を限定する VACUUM ANALYZE table (column [, ...] ) ３．メモリを増やす
root から su - postgres で postgres ユーザーにスイッチして createdb (適当なデータベース名) psql -f sqlファイル データベース名 もし、ダンプファイルの場合は cat sqlファイル | psql データベース名
そういう事でしたら、ダミーのテーブルを作ってデータをインポートした後、 再ロードしてみてはどうでしょう？
ALTER DATABASE name RENAME TO newname > MySQLや他のデータベースも同じ方法で可能なのでしょうか？ DBによると思います。例えばOracleだと制御ファイルの再作成が必要です。
　このふたつの言葉の違いを、説明するなら・・・ＭＳ（マネージメントシステム）の部分の差ですね。 　こう考えてみればよいかもしれません。 　データベースという世界があります。これは、データを関連づけて保存し、後で検索・運用するためのシステムに関する全般を指す言葉です。（世の中にあるデータベースはリレーショナルデータベースだけではありません。他にもいっぱいあります。） 　データベースの機能を実現するための理論の一つがＲＤＢ（リレーショナルデータベース）です。これは、データを表の形で表し、それを保存・検索するための手段を表した理論です。（例えば、通信の世界のプロトコルとか、プログラミングの世界におけるアルゴリズムとかと対比させるとわかりやすいかな？） 　理論は、実際のコンピュータに実装しないと、役に立ちません。ＲＤＢを実際に実装したもの・または稼働しているＲＤＢを動かすためのプログラムセットをＲＤＢＭＳと言います。世の中で稼働しているオラクル・ＳＱＬ　ＳＥＲＶＥＲ・ＭＹＳＱＬなどが、この一例です。 　まぁ、普通は、こんなに厳密に言い分けることも少ないでしょうし、ＲＤＢ＝ＲＤＢＭＳでも、大きな問題は無いです。あなたが、理論書を書こうとしているなら別ですけどね。
日本語特有の問題なので、確信はもてませんが、 invaild byte sequence for eoncoding "EUC_JP":0x8de5" はサーバが読み込んだ際、0x8de5に対する定義が書き込まれたものと違うというメッセージだと思われます。 postgresのバージョンを同じにして試されてはどうでしょう？
ログに出ているのは pg_class テーブルの reltriggers カラムが無いというエラーですね。reltriggers カラムは8.4から無くなったようです。(参考URL) お使いの接続ソフトが、テーブル・カラムなどのメタ情報を取得しようとして失敗しているのでしょう。 8.4 に対応している接続ソフトを使えばよろしいかと。
一応、PostgreSQL の話ですよね。 イマイチ、ピントがあっていない気がするので ・psql db これですが、コマンドラインで 、データベースに接続しているだけなので、立ち上げているわけではありません。 ・postgresql なら help でコマンドが見られるのでそれを見た方が良いとは思います 普通にDBで使うコマンドは ・create table テーブルを作成する ・select テーブルのデータを検索する ・insert テーブルにデータを追加する ・delete テーブルのデータを削除する ・update テーブルのデータを更新する 普通は、このくらいかな。 SQL でググって探せば、もっと良い答えにめぐり合うでしょう。
SQL のみでやるなら Dodonpa2 さんが回答したように dblink を使う必要がありますね。他の DBMS はよく知りませんが少なくとも PostgreSQL では基本的に接続中のデータベース内のテーブル以外は参照できません。 コマンドラインでの操作が OK なら psql で db1 内のテーブルのデータを COPY で出力した結果を db2 に流し込めば対応できるはずです。
回答が無いのが不思議ですが、 PostgreSQL では、バキュームという操作が必ず必要でした。 大雑把に言えば、PostgreSQL は常に追記することでデータベースを 更新していくのですが、更新の回数ごとにDBにゴミデータが 蓄積されていくのです。 このゴミデータを開放して、DBを整理するのがバキュームという 操作になります。 古いバージョンだと、DBを止めないと出来なかったのですが、 最近では、オートバキュームといい、自動でしかもDBを 止めずに出来るようになりました。 オートバキュームにしろ、手動でバキュームにしろ、現状の PostgreSQL には、必ず必要な操作なので、行なう必要があります。 このメッセージは、オートバキュームを設定していないと言うメッセージなのでしょう。 手動でバキュームをすれば問題なしでもいいですが、質問者はそれ以前のようなので、資料やマニュアルを調べて、オートバキュームを設定することを勧めます。
> エンコード SQL_ASCII ASCII って 1バイト文字ですよね。 マルチバイト文字を正しく認識できないのでは？
単価適用日のカラクリを考えると、指定日以前で最大の日付と一致する データが対象となるようですね。 SELECT A.商品名,B.単価 FROM 商品マスタ A LEFT JOIN (SELECT X.* FROM 商品価格 X LEFT JOIN (SELECT 商品ID,商品詳細ID,MAX(単価適用日) 適用日 FROM 商品価格 WHERE 単価適用日<='2009-11-18' GROUP BY 商品ID,商品詳細ID) Y ON X.商品ID=Y.商品ID AND X.商品詳細ID=Y.商品詳細ID AND X.単価適用日=Y.適用日) B ON A.商品ID=B.商品ID AND A.商品詳細ID=B.商品詳細ID
どうして、わざわざこんな扱いにくいテーブルにしているのでしょうかね。。。 select hob,count(hob) from ( select hob1 as hob from hoge_db where hob1 is not null union all select hob2 as hob from hoge_db where hob2 is not null union all select hob3 as hob from hoge_db where hob3 is not null ) as x group by hob order by hob
再質問の意味が分かりません。 参照整合性は例えばBigに"A","B","C"しかないなら、Midには"D"とか 作れないということですし、Midに"A"がある時はBigの"A"を削除でき ないということです。実際に参照されているかいないかはクエリを 実行しないと分かりません。それと、参照整合を設定していない項目は 変更可能です。これも含めて更新不可能にしたいというのであれば、 やり方を考え直す必要があります。
すでに回答が付いていますが、 PostgreSQLでは、テーブルを結合して削除することは出来なかったと思います。 対策としては、下記の方法が考えられるかと。 1. 削除時には、先に user_rel_group テーブルの該当レコードを消してから member テーブルのレコードを消す様にする。 例) --------------------------------------------------- DELETE user_rel_group WHERE userid = 10030118; DELETE member WHERE userid = 10030118; ------------------------------------------------------- 2. ALTER TABLE 文で参照整合性制約を付け直す。 ------------------------------------------------------- ALTER TABLE user_rel_group DROP CONSTRAINT user_rel_group_userid_fkey; ALTER TABLE user_rel_group ADD CONSTRAINT user_rel_group_userid_fkey FOREIGN KEY (userid) REFERENCES user (userid) ON DELETE CASCADE; -------------------------------------------------------
Oracleが特別なのであって、NULLと空文字列''は通常は別物です。 よって、NULLと空文字列の業務上/運用上の違いを明確にすることが 先決なのであって、初期値をどうするかはその後の話です。
PostgreSQLのバージョンは、何でしょうか？ また、libpq.dllは、どのバージョンのものを使っているでしょうか？ 日本語対応などで、かなり古いlibpq.dllを使っていると、md5が未対応ということもあったりします。
デッドロックが何かを理解していますか？ デッドロックというのはロックの要求がすくみの状態になって互いにロックの開放を待ち続けてしまう状態です。 例えば、以下のように 2 つのテーブルを作成してデータを挿入し、 CREATE TABLE foo (id integer); INSERT INTO foo VALUES (1); CREATE TABLE bar (id integer); INSERT INTO bar VALUES (1); 2 つの psql を起動します。ここでは 2 つの psql を見分けるために psql1、psql2 と呼ぶことにします。 1. psql1 で foo テーブルの id = 1 の行をロック BEGIN; SELECT * FROM foo WHERE id = 1 FOR UPDATE; 2. psql2 で bar テーブルの id = 1 の行をロック BEGIN; SELECT * FROM bar WHERE id = 1 FOR UPDATE; 3. psql1 で bar テーブルの id = 1 の行をロック SELECT * FROM bar WHERE id = 1 FOR UPDATE; bar テーブルの id = 1 の行は psql2 がロックしているので待たされる。 4. psql2 で foo テーブルの id = 1 の行をロック SELECT * FROM foo WHERE id = 1 FOR UPDATE; foo テーブルの id = 1 の行は psql1 がロックしているので待たされる。 5. psql1 は foo テーブルの id = 1 の行をロックしつつ bar テーブルの id = 1 の行に対するロックが開放されるのを待ち、psql2 は bar テーブルの id = 1 の行をロックしつつ foo テーブルの id = 1 の行に対するロックが開放されるのを待ち、互いにロックが開放されるのを待ち続ける状態になります。これをデッドロックと呼びます。 6. PostgreSQL にはデッドロックを検出する仕組みがあるので、後からロックしようとした psql2 のトランザクションがアボートされます。 ERROR: deadlock detected DETAIL: Process 26267 waits for ShareLock on transaction 709; blocked by process 26261. Process 26261 waits for ShareLock on transaction 710; blocked by process 26267. HINT: See server log for query details. 従って、「デットロックを回避する為に、自動コミットをやめ、手動コミットに変更したいです。」という質問に対する回答としては、手動コミットに変更してもデッドロックは回避できません。デッドロックを回避するにはロックする順序を揃える必要があります。 また、回答番号: No.2 で athanasius さんが回答しているように、明示的にロックしなくても、同じテーブルの同じ行に対して更新しようとした場合には暗黙的に行ロックが取得されるので、先にロックを取得したほうが更新してから、次にロックを取得したほうが更新するだけでデータの不整合は発生しません。 「システム全体を手動コミットに変更するには、どうしたら宜しいのでしょうか？」という質問に対する回答としては、psql によるすべての接続で手動コミットを強制する方法はありません。 ただ、~/.psqlrc に「\set AUTOCOMMIT off」と書いておけば接続時に自動コミットが無効になります。
CentOSのファイアウォールでtcp/5432がブロックされていませんか？ CentOS上で system-config-securitylevel-tui を実行し、 Other portsにpostgres:tcp を追加してみてください
原因の切り分けが必要？！ もう一台端末を構築し、ODBCで接続し問題ないようなら トラブってる端末をＯＳインストールから再構築してみては？ （例えば旧ドライバのレジストリの残骸が悪さしてるとか考えられるため）
PostgreSQL 本体の機能では実現できませんが、contrib モジュールの dblink を使えばできます。 dblink のインストール方法は PostgreSQL のインストール方法によって異なりますが、RPM パッケージであれば postgresql-contrib というパッケージをインストールし、以下のように dblink の関数などを定義します。 psql -f /usr/share/postgresql/contrib/dblink.sql (データベース名) データベース名には他のデータベースにアクセスしたいデータベース名、例では app1_db を指定します。なお、dblink.sql のパスはパッケージによって異なる場合があります。 dblink をインストールすれば以下のように関数を呼び出して別のデータベース内のテーブルを参照できます。 SELECT * FROM dblink('dbname=common_db', 'SELECT * FROM postcode') AS postcode(postcode text, pref_name text); dblink について詳しくは PostgreSQL のマニュアルを読んでください。 http://www.postgresql.jp/document/pg840doc/html/dblink.html ただ、質問の例にあるデータベース名やテーブル名を見ていると、アプリケーションごとに名前空間を分けたいだけのようなので、それであればスキーマを使ったほうがよさそうな気もします。
テーブルスペースを使えば、データベースクラスタを作成しなおすことなく、新しいディスクにテーブルやインデックスの格納先を移動できます。 具体的には CREATE TABLESPACE で新しいディスク上にテーブルスペースを作成し、格納先のディスクを変更したいテーブルやインデックスに対して ALTER TABLE ... SET TABLESPACE や ALTER INDEX ... SET TABLESPACE を 実行すれば移動できます。
回答番号: No.2 に対して訂正があります。 > 手元の psql で確認した限りでは、トランザクション内で SELECT を実 > 行してコミットしていない状態だと、SELECT の対象となっているテーブ > ルの他にいくつかのシステムカタログに対しても Access Share Lock が > 取得されたままでした。 と書きましたが、これは psql 内でテーブル名などの補完を行ったためで した。 いずれにしてもトランザクション内で SELECT を実行してコミットせずに 放置しているのであれば、対象となるテーブルと、そのテーブルに定義さ れたインデックスにも Access Share Lock が取得されたままとなるので、 トランザクションをコミットするようにしてみてください。 トランザクション内で更新していなければロールバックでも構いません。
> 全データベースにわたって一気にやる方法はないでしょうか？ その場合は、pg_dumpallコマンドを使用します。 下記URLを参考にして下さい。 http://www.postgresql.jp/document/current/html/app-pg-dumpall.html
こんにちは。 >インストール画面で >ユーザー名、パスワードを入れる欄があり、何度やっても、 >「パスワード」が間違っています、と表示され、先に進めません。 >（何も入力しなくても、passwordと入力しても先に進めません。） パスワードが違ってないとしても、そのパスワードが何のパスワードかが 問題かもしれないです。Windowsのサービスアカウントのパスワードか、 Postgresのスーパーユーザpostgresのパスワードかどちらでしょう。 バイナリ版のインストーラを使ったのでしたら、Windowsサービスアカウントの パスワードはデフォでランダムな値が自動的に割り振られていたと思ったので こちらはそのまま、「次へ」をクリックしたのだろうと想像します。ということで 「password」はスーパーユーザのパスワードと感じますがいかがでしょう？ もし、私の想像が正しければ弾かれているパスワードとはWindowsサービスアカウント のパスワードで、これを記録（メモ）はしているでしょうか？していれば、 それをインストーラで入れてみてください。 もし、記録していなければ、Windowsのサービスアカウント(postgres)を削除してください。 これで再インストールできないでしょうか。 Vistaは所有してないのでXPでの削除法を記載しておきます。 管理者権限でログイン。 コントロールパネル→管理ツール→コンピュータの管理ダイアログ内の 左側のツリービューで ローカルユーザとグループの下のユーザを選択。 右ペインに「postgres」アカウントがあるのでこれを削除。
>副問い合わせは1列のみを返さなければなりませんというErrorが生じます。 >なのでwhere句を追加しましたが、結果は同じです。 where句を追加したということは行と勘違いされているのでは？ 『(select numberStr,TO_NUMBER (numberStr,'000.000') from number)』の部分で 「numberStr」と「TO_NUMBER (numberStr,'000.000')」の2列返しているという意味です。 「numberStr」の方を削除すればエラーにはならないと思います。
CPAN(http://www.cpan.org/) のモジュールサーチで、一撃で見付かりますよ。 http://search.cpan.org/~mergl/pgsql_perl5-1.9.0/Pg.pm
２個提案します。 １．Aでupdateする前にcvs形式でファイル保存して、Bではselectせずにcvsを見に行く。 ただ、１レコードならいいですけど、膨大なレコードの場合 考え物だと思います。 ２．Bでselectする時にFOR UPDATEをつければAが更新中だったら 更新が終わるのを待ってからselect出来ると思います。 ただ、Aが数秒おきに行われるということなので、 Bのselectが終わったらすぐにロックを解除しないとAが数秒間 止まる可能性を考えなければなりません。
そちらの環境のPostgresのバージョンが分からないですが、 手元の環境ではこんな感じで取れます。 select count(t1.ページ名) , t1.ページ名 from (select ページ名 , ユーザID from テーブル group by ページ名 , ユーザID)as t1 group by t1.ページ名
そもそも、Pgsql、動いていますか？止まっていても同じメッセージが 出る場合があります。 プロセスが動いているか確認してみて下さい。 プロセスが動いている場合、 ホスト側で、 psql -h localhost -p 5432 を実行して見て下さい。 同じメッセージになりますか？ 同じならば、以下のような対処も可能です。 http://www.ne.jp/asahi/nature/jp/moteviewtroubleshoting.htm
シェルからpsqlコマンドで psql -l とするか、psql内からメタコマンドで \l とするかで確認できます。 ＃公式ドキュメントに載ってますよ。
PostgreSQL日本語ドキュメント http://www.postgresql.jp/document/ Postgresqlの運用をしているのなら、一通り、目を通して置くべきかと思いますが、 読んでみましたか？
No2ですが、以前の質問の回答を利用すると、これで 同一コードで日付が重複していても問題なさそうですね。 こんなことできるのか。。。勉強になった。 SELECT DISTINCT ON (コード) コード , 枝番 , 年月日 FROM テーブル WHERE (コード , 年月日) IN (SELECT COALESCE(A.コード,B.コード) AS コード, COALESCE(A.年月日,B.年月日) AS 年月日 FROM (SELECT コード,MIN(年月日) AS 年月日 FROM テーブル WHERE 優先='優先する' GROUP BY コード) AS A FULL OUTER JOIN (SELECT コード,MIN(年月日) AS 年月日 FROM テーブル WHERE 優先='優先しない' GROUP BY コード) AS B ON A.コード=B.コード )
> memberInfor join goodsInfor join orderInfor > on memberInfor.membernum=orderInfor.membernum > and goodsInfor.goodsname=orderInfor.goodsname; は orderInfor join memberInfor on memberInfor.membernum=orderInfor.membernum join goodsInfor on goodsInfor.goodsname=orderInfor.goodsname; ではないですか？
こんにちは。 >csvファイルのデータを既存のデータと比較して重複なしで登録する方法を教えて下さい。 普通にやるなら、TemporaryでCREATE TABLEしてそこにCOPY FROMでインポートを してINSERTを発行するストアドを作成すればできるとおもいますが。 ちょっと楽をしようとお思いでしたら、石井達夫さんがつくられたexttableが あるのでそれをお試しになればいかがでしょう。 http://ring.riken.jp/archives/misc/db/postgresql-jp/exttable/?C=N;O=D サーバのプラットフォームがWindowsでしたら、拙作のExtensionsをVectorに 登録しましたので小生のハンドルネームで探してみてください。
ソース自体は正しいと思います。 コネクション文字列の内容が正しければ接続は可能かと思います。 pgAdmin等での接続は可能ですか？ 若しくは他のクライアント等からの接続の可否は如何ですか？ 念のためlisten_addresses = '*'も確認した方が良いと思います。
keikenchiフィールドが数値型であれば、 UPDATE chara SET keikenchi=keikenchi+5 WHERE name='勇者' で、更新可能です。
EXISTSを使って商演算を行っていく順序を書いておきます。 SELECT A.番号, A.氏名, A.年齢, A.好物,B.好物 FROM 机1 A,机2 B とすることで、机1と机2の全ての組み合わせが出力されます。 | 番号 |氏名|年齢|　好物　| --------------------------- | １２ | あ | １ | りんご | | １２ | あ | １ |すいか | | ２３ | い | １ | すいか | | ２３ | い | １ | りんご | | ４５ | え | ３ | すいか | | ４５ | え | ３ | りんご | 上の表から机1に含まれないレコードを抽出します。 SELECT A.番号, A.氏名, A.年齢, A.好物,B.好物 FROM 机1 A,机2 B WHERE NOT EXISTS (SELECT * FROM 机1 C WHERE A.番号=C.番号 AND A.氏名=C.氏名 AND A.年齢=C.年齢 AND B.好物=C.好物) | 番号 |氏名|年齢|　好物　| --------------------------- | １２ | あ | １ |すいか | 最後に机1から、番号=１２,氏名=あ,年齢=１　ではない番号、氏名を抽出します データの重複を回避するため、DISTINCTを使用しています。（別に、GROUP BY でも構いません) SELECT DISTINCT D.番号,D.氏名 FROM 机1 D WHERE NOT EXISTS (SELECT A.番号, A.氏名, A.年齢, A.好物,B.好物 FROM 机1 A,机2 B WHERE NOT EXISTS (SELECT * FROM 机1 C WHERE A.番号=C.番号 AND A.氏名=C.氏名 AND B.好物=C.好物) WHERE D.番号=A.番号,D.氏名=A.氏名,D.年齢=A.年齢) 上のSQLだと、少し冗長なのでまとめると、 SELECT DISTINCT A.番号,A.氏名 FROM 机1 A WHERE NOT EXISTS (SELECT 1 FROM 机2 B WHERE NOT EXISTS(SELECT 1 FROM 机1 C WHERE A.番号=C.番号 AND A.氏名=C.氏名 AND A.年齢=C.年齢 AND B.好物=C.好物)) となります。
DB2とかORACLEなら通るはず。 SELECT ID,COUNT(DISTINCT 項目CD) FROM TABLE WHERE 評価結果=○ GROUP BY ID,項目CD ACCESSなら、こっちで。 SELECT ID,COUNT(項目CD) FROM (SELECT DISTINCT ID,項目CD FROM TABLE WHERE 評価結果="○") GROUP BY ID
上記の設定で問題ありません。 敢えて指摘するのであれば必要のないアーカイブログの削除が運用に組み込まれていないようなので、運用を続けていくうちにアーカイブログがディスク容量を圧迫する可能性があります。ベースバックアップを取得した時点でそれ以前のアーカイブログを削除したほうがよいでしょう。 また、アーカイブログの追加が1日に1回程度ということについては、あなかたが管理するデータベースの更新の頻度が比較的低いことが原因だと考えられます。 データの更新によって発生するトランザクションログがアーカイブログとして保存されるタイミングは、メモリ内に蓄積されたデータの更新が実際にディスク上のテーブルファイルに反映され（これをチェックポイント処理と呼びます）、トランザクションログが不要になった時点です。 更新の頻度が低い場合には、PostgreSQLのバージョンによって対応は異なりますがチェックポイントの頻度を高くするか、定期的にトランザクションログをアーカイブログとして保存するようにarchive_timeoutを調整するといいと思います。細かいことを言い出すと切りがないので、不明なことがあれば言ってください。
LIMITで正しいと思います。
CentOSの環境が手元にないのであくまで推測になります。 おそらく起動スクリプト内でpostgresユーザの環境変数が参照されていないことが原因だと思います。まず、/etc/rc.d/init.d/postgresqlの内容を確認してPGDATAの値に何が指定されているかを確認してみてください。多分、以下のような行が含まれていると思います。 PGDATA=/var/lib/pgsql/data ファイルを直接編集してPGDATAを変更してもいいですが、PGDG (PostgreSQL Global Development Group: PostgreSQLの開発元)が配布するパッケージ、もしくはそれをベースにしているパッケージであれば、/etc/sysconfig/pgsql/postgresqlというファイルを作成し、ファイル内に以下のような行を追加するとデータベースクラスタの位置を変更できるはずです。 PGDATA=/usr/local/pgsql あと、日本語のデータを格納するのであればinitdbの実行時に--no-localeオプションを指定したほうがいいでしょう。
アイディア募集ってことでいいのかな？ このシステムの目的がわからないので、的はずしちゃう可能性大なのだけど。 自分だったら 備品マスタ : 備品番号、備品名 備品テーブル : 備品番号、備品シーケンス、購入日（、償却日） 貸し出しテーブル : シーケンス番号、社員番号, 備品番号、備品シーケンス、貸出日（、返却日） みたいにするかな。 備品管理ってことは、例えばノートパソコンが何台あってそのうち何台貸し出されてるって管理が必要だよね。はじめは10台かもしれないけど、1台壊れるかもしれないし。ノートパソコンには備品番号＋備品シーケンスを貼っておけば管理しやすいでしょ。 > 貸し出しテーブルには上記以外にもカラムを複数入れるので、 > 1レコードで社員番号から借りている備品を抽出したいのですが、 これの意味がよくわからないのですが、何故に1レコードじゃないと駄目なのでしょうか？ 表示の問題なのでしょうか？ 複数抽出で結合して表示ではどうですか？ まぁ、究極をいえば、 貸し出しテーブル : 社員番号, 備品番号、備品シーケンス、貸出日、返却日、 備品番号２、備品シーケンス２、貸出日２、返却日２、 備品番号３、備品シーケンス３、貸出日３、返却日３、 備品番号４、備品シーケンス４、貸出日４、返却日４・・・・ って１００個もつくっておけばできないことはないけど 管理が大変だし、絶対止めたほうがいいと思うけど・・・。
>>1.レンタルサーバーへの一般的な接続方法 一般的というものはないと思えます。レンタルサーバの方から指定された接続方法を使ってください。 >>2.PHP・Perlを必ず使わないと接続できないか (できればJAVA経由で接続したいです) サーバの方がPHP,Perlで接続してくれといわれています。なので、かなりの高い確率で、できません。 >>3.バージョンは一致しないと無理か 指定された言語での接続方法を使って接続すれば、バージョンの相違は発生しないと思います。ただ、自分のプログラムの記述方法が該当のバージョンでの記述方法と相違がある場合は、プログラムの修正が必要になると思えます。
sqlでやります。 ALTER ROLE xxxx with password '????????'; 自分以外はsuperuserでやる必要があります。
こんにちは。 テーブル空間を作ってはだめですか？
8.2からRETURNINGというのがあるらしい。 http://blog.ozacc.com/archives/001613.html
回答がつかないので。 古い資料ですが http://www.interdb.jp/techinfo/postgresql/p-1-02.html にPostgresql7.3時代の制限値があります。ここらあたりは変わっていない のでは。 データベース数、テーブル数の制限は分かりませんが実用上問題はないの ではないと思いますが。
下記のページにPostgreSQLのSQLの文字列定数についての説明が有りますので、記述できない文字などについてはここを見ると良いでしょう。 http://www.postgresql.jp/document/pg837doc/html/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS さて、シングルクウォートを含む文字列定数への対応としては下記の3つが考えられます。 1. 文字列中のシングルクウォートとバックスラッシュ(\)を\でエスケープする。 2. ドル引用符を使用する。 3. プレースフォルダを使用する。 2は、$xxxx$ のようなドル記号で囲まれた文字列を引用符代わりに使う、PostgreSQL 独自の機能です。 'hoge' と書く代わりに $xxxx$hoge$xxxx$ の様に書けます。 詳しくは下記のページを見て下さい。 http://www.postgresql.jp/document/pg837doc/html/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING 3は、SQLの定数の位置に?を書き、PreparedStatement の set～～() メソッドを使って値を指定する方法です。下記のページが参考になるでしょう。 http://www.atmarkit.co.jp/fjava/rensai2/webopt11/webopt11.html http://sdc.sun.co.jp/java/docs/j2se/1.4/ja/docs/ja/guide/jdbc/getstart/preparedstatement.html
ここのカテゴリ通り、RDBMSはPostgreSQLですか？ バージョンは？ >countの速度が行数に比例して遅くなって >行数が増えてもcountの速度が落ちないようにしたいのです。 >CREATE INDEX などは設定してあります。 「件数に比例」ということなら、インデクスを有効利用できていないのでは？ 削除やキー更新が数多く発生しているなら、VACUUMで統計情報を取り直すことで改善できるかも知れません。 ただ、この質問内容では、どういった対処が適切かを、他人には判断できません。 もしもっと具体的なアドバイスが欲しいなら、 (0)RDBMS名とバージョン (1)表の構成列とそのデータ型 (2)インデクスの定義 (3)SELECT文の具体的な内容 といったことを提示してください。
MySQLはライセンスが面倒。 Posgreはけっこう普及してたし、詳しいエンジニアも多いと思うので、ライセンス的にMySQLが使えないような場合、Posgreを選択するって言うのはけっこうあると思う。 昔は、機能が限られていて、まあ速いだけのMySQLだったけど、今は何でも出来るし、これといって欠点は無いと思うので、他のRDBMSと比較して、MySQLのほうが劣っている点というのは特に無いと思います。 パフォーマンスも得手不得手はあるものの上位に入ると思う。 欠点というか劣っているというか、他のRDBMSからMySQLに移行するのは簡単だけど、MySQLが便利すぎるせいかMySQLから他のRDBMSに移行する場合に少し面倒。 私の場合、MySQL使いたいけど、仕方なく、他のRDBMSを選択することもある。 PosgreはLOBの仕様的な制限とか扱いが面倒なので、私ならFirebirdにする。 Firebirdはgroup byとかが弱い気がするけど、ほかと比べると比較的簡単に MySQLから移行できる。 以上主観。 参考：性能比較表（2005年作成らしいけど） http://www-css.fnal.gov/dsg/external/freeware/mysql-vs-pgsql.html
select sum( case when val=9984 then 1 else 0 end ) as cnt1, sum( case when val=1234 then 1 else 0 end ) as cnt2, sum( case when val=9876 then 1 else 0 end ) as cnt3, sum( case when val=4567 then 1 else 0 end ) as cnt4 from テーブル でやるか select val,count(*) from テーブル where val in ( 9984, 1234, 9876, 4567 ) group by val でやるか
oracle, ms sqlserverでも同様になります。 同じレベルでつけた列名を参照しようというのに無理があると思います。 意図は良く分かりませんがやるならインラインビューを使って select a, a+3 b from ( select 1 a ) のようにやるのが妥当だと思いますが。
対象のテーブルに OID が存在する場合は、下記の様なSQLでできると思います。 DELETE FROM target_table WHERE col1 = 1 AND col2 = 2 AND oid != ( SELECT MIN(oid) FROM target_table WHERE col1 = 1 AND col2 = 2 ); 8.1 以降だと、テーブル作成時に WITH OIDS が指定されているか、default_with_oids設定変数が有効でなければ、OIDは追加されません。8.0 以前では、テーブルの作成時に WITHOUT OIDS が指定されているか、default_with_oids設定変数が偽に設定されていなければ、OIDシステム列がOIDが追加されます。 http://www.postgresql.jp/document/pg836doc/html/datatype-oid.html 対象のテーブルにOIDが無い場合は、いったん全てDELETEした後に1つだけINSERTし直すしかないかと。
PostgreSQL 8.3.7 で試してみました。 SELECT DISTINCT ON (コード) コード , 枝番 , 年月日 FROM テストテーブル WHERE (コード , 年月日) IN (SELECT コード , MIN(年月日) FROM テストテーブル GROUP BY コード ); でどうでしょう。
SJISは、8.3.7でもサーバ内のエンコーディングとしては使用できないので、他のエンコーディング方式にする必要が有るかと。 http://www.postgresql.jp/document/pg837doc/html/multibyte.html#MULTIBYTE-CHARSET-SUPPORTED さて、サーバ内のエンコーディングが違う場合のデータ移行ですが、 pg_dump の出力には「SET client_encoding = ～～～」が入るようですので、特にスイッチなどは無くても大丈夫だと思います。なお、ダンプファイルの文字コードを指定したい場合は「-E encoding」を使います。 ただし、移行元のデータ中に、移行先の文字コードに割当てられないものが存在する場合はエラーになります。
$1（保存先のファイル名）がちゃんと渡っているか、 パスやファイル名にspaceがないか RAISE DEBUG等で確認してみては如何でしょうか。
>PostgreSQL の 7 から8 へ 7とか8とかでは、範囲が広すぎます。もっと具体的に、バージョンを明記しましょう。 >型の扱いが厳しくなった訳か、syntax error となります。 型の扱いの問題なら、syntax errorでなく、別のエラーになるように感じます。 具体的なSQLの記述、エラーメッセージの内容といったものを示せませんか？ 予約語の追加といったものなら、syntax errorも考えられますけど。 ともかく、記載内容が具体的でなく、根拠の疑わしい推測だけなので、他人が適切に回答するのは困難です。
こんにちは。 >VC6のアプリ、WinXP、Postgreのlibpq.dll >※Postgreはインストール >↓ >VC6のアプリ、WinXP、Postgreのlibpq.dll >※Postgreは非インストール は >クライアント側にもPostgreSQL(DB)のインストールが >必要なのでしょうか？ という意味なんですか。もちろん、クライアント側は必要ないです。 最初のコメントでも申しましたが、どんなアプリかわからないと コメントはつきづらいです。このエラーメッセージでしたら、例えば MFCアプリなのにランタイムがないとかなどの依存関係や、libpq.dllが 適切な場所に配置してあるかなどから確認してはいかがでしょう。
SQLというかデータベースのサンプルとして適していると思いますよ。 どのように項目を分けるかとか、どのようなテーブルが必要になるかなどの設計から、検索を行うSQLの書き方とか、得るものは大きいと思います。 がんばってみてください。
なかなか回答がつかないようなのでアドバイスをば。 異なるDB間でSQLを使って差分を抽出することは不可能だと思います。 バックアップは素直にPostgreSQLの機能を使って行いましょう。 その方がはるかに現実的です。 どうしてもVB6.0を使ってやりたいなら・・・ ・A_DBのAテーブルに対する更新(Insert/Update/Delete)履歴を全て保存しておいて、B_DBのBテーブルに同じSQLを発行する。 ・Aテーブルが追加(Insert)しかされない(Update/Deleteがされない)前提であれば、レコードにシーケンス番号を振っておき、前日の処理以降のデータをInsertする。
マニュアルを参考にして http://www.postgresql.jp/document/pg815doc/html/client-authentication.html#AUTH-PG-HBA-CONF 何がよく分からないのか提示してください。 質問の要件のみだったらこんな感じじゃないかな。 # TYPE DATABASE USER CIDR-ADDRESS METHOD host all all 127.0.0.1/32 trust trustのとこはauth-methodから選択してね。
何をやりたいのか、説明及び提示データが少なくて、分かりづらいです。 >できれば、多次元配列の「b.code」の記述順で表示したいのですが、 >下記のSQL文を実行すると「a.code」の記述順で表示されます。 認識に誤りがあります。 データ量が少ない、削除をまったく行っていないといった要因で、「a.code」の記述順のように見えているだけです。実際には、どういう順序で検索されるかは、order by指定がないので、RDBMS側では保証していません。 配列を使う目的は、何でしょうか？ PostgreSQLのマニュアルでも、配列は使用せず、別の表とした方がいいと書かれています。 order by b.code[1:1] を追加すれば、現状の提示された範囲のデータでは、期待の動きになるようです。ただ、もっと多様なデータが格納されていた場合、どういった結果になるのを期待しているのか、提示内容だけでは判断できません。
テーブルAとBは、同じサーバにあるのでしょうか？ CSVファイルなどの媒介は、必要ないのでしょうか？ データ件数は、どのくらいあるのでしょう？ insert ～ selectの1文で可能なのですが、ストアドプロシジャでやりたいでしょうか？ データ件数が多量の場合、select文で条件検索し、何回かに分割して行うこともできます。 insert into B select id,1,bsum1 from A union select id,2,bsum2 from A
perl -p -e "s/\"\"//g" 入力ファイル > ワークファイル で前処理して copy into テーブル from ワークファイル with csv null '' で入力してみては。
Linuxのシステム文字コードは、EUCですか。 /etc/sysconfig/i18nファイルの１行目 LANG="ja_JP.eucJP"と設定されていなければ スーパーユーザーで設定変更する。 /etc/bashrcに環境変数を設定する。 export LANG="ja_JP.eucJP" 再ログインして、テーブルのINSERTを再試行してください。
私の担当する顧客のPostgreSQL－DBも120万件以上のデータがあります。 1・お使いのバージョンであれば問題ないはずです。ただし、VACUUM時にSELECTなどのレスポンスは当然落ちます。 2・私の方針（笑）では、キー情報のUPDATEが多くない限り、VACUUM ANALYZEまたはFULLは、多くても１週間に１回しかVACUUMしません。 DBの構造にもよりますが、２～３千件のINSERTで3時間に1回のVACUUMは 多い気がしますが、3時間に1回VACUUMしないとレスポンスが悪いのでしょうか？ このあたりはマシンのスペックによってもかなり影響されるので、はっきりとした答えは出ないでしょう。 検索などのレスポンスが悪い場合は、ANALYZEも有効ですが、やはり 定期的にdump＆restoreするのが一番いい方法なんですがね。 ノンストップ運用なら無理ですが・・・・
英数字の hoge_id が人間にとって有意な文字列なら、変更したい場面があるかも知れませんね。 変更しても結合相手に追従して欲しいなら、結合キーはおっしゃるとおり serial とかの別の項目にするのが良いでしょう。
select 名前 from A union select 名前 from B union select 名前 from C union select 名前 from D
マニュアルを見てみたところ、ALTER TABLEでの既存列のNOT NULLの追加や削除は、PostgreSQL 7.3で実装のようですね。 >テーブルを作り直さずに、既存のテーブルのカラムへの制約の追加、削除をしようとしています。 ALTER TABLEで、NOT NULLを許可しない列の追加などを行うと、内部的にはテーブルの作り直しが行われますよ？
まったくのあてずっぽうですけど 1件に絞ろうとしてもどう絞ってよいかわからなくなるようなデータだから？ limit 500 とか limit 100 とか数字を減らしながら試して どこで遅くなるか見てみたらなにかわかるかもしれませんよ。
MySQLは商売に使うとライセンス料が必要だが PostgreSQLは無償。 ただし、MySQLは営利会社が管理しているので 金を払っただけサポートを受けられる。 無責任だが多分。
インストールできますよ、私も両バージョン同時に使ってますので。 確かにポットを変われば良いですね。 pgAdminnIIIについては、自動的に新しいサーバーを追加されます。
postgresql 8.3.5のpsqlで \df roundとしてみると exam=> \df round List of functions Schema | Name | Result data type | Argument data types ------------+-------+------------------+--------------------- pg_catalog | round | double precision | double precision pg_catalog | round | numeric | numeric pg_catalog | round | numeric | numeric, integer (3 rows) round(実数、整数）の場合、実数の型はnumericを受け付けるようです。 なので、double型？のかわりにnumericを使うか x::numeric みたいにキャストしてみてはいかがでしょうか。
読みにくいですけどこれで求められるようです。 試したのは8.3.5 ですが、たぶん7.4でもいけるはず。 select tbl.id1 from ((select id1 as id,id2 as id2_0 from t_tbl where id3 = 12) as t12 left outer join (select id1,id2 from t_tbl where id3 = 8) as t8 on (t12.id=t8.id1)) as tbl where tbl.id2_0 < tbl.id2;
質問の答えになっているかどうかわかりませんが '3 second'をvarcharではなくinterval型にしたらどうでしょうか。 下記の例だとちゃんと計算できるようです。（postgresql 8.3) select timestamp '2009-01-15 18:23:05.872415+09' + interval '3 second';
変則的ですが、これでよければidがユニークでなくても大丈夫ですし、集合関数を使わなくてもOKです。 select dm.id,case when ex1.point is null then 0 else ex1.point end from (select ? as id) as dm left join ex1 on dm.id = ex1.id; ?を適当に変えてください。 chukenkenkouさんの発想はこれですよね。
（遅い場合で0.xx秒）が遅いのかどうかは不明ですが・・ 4000万レコード程度あるテーブルのクエリーが0.00xxx秒というのは どういうSQLでしょうか またどうやって測ったのでしょうか？EXPLAIN ANALYZEでしょうか？ 28件のTABLEへはどういったインデックスを張ったのでしょうか？ 条件にある主キーカラムにインデックスを張っていますでしょうか。 主キーカラム以外の条件を取り除くか、もしくはすべての条件カラムを含む 複合索引を張って検索を行ってみてはどうでしょうか。＾＾ ＃EXPLAINでカラム2のIN関数でインデックスを使用しない事があれば ＃(カラム2=bbb OR カラム2=ccc)に置き換えてしてみて下さい。
詳細な情報が書かれていないが PostgreSQL 8.* の psql内 のことならば configure時に readline を禁止していなければ コマンド履歴は有効です。
こんにちは。 pg_stat_activityビューあたりが該当するのかな？ 詳しくはドキュメントの「第 26章データベース活動状況の監視」 (8.3.4の場合)をごらんください。
ググッただけですが、 PostgreSQL 8.0 で tcpip_socket パラメータは listen_addresses に置き換えられています。
select min(c1),min(c2),min(c3) into d1,d2,d3 from t1; でダメ？
題意に沿っているかちょっと分かりかねる部分がありますが select distinct l1.first_name, l1.last_name from list l1 where exists ( select 1 from list l2 where l1.no <> l2.no and l1.last_name = l2.last_name and l1.first_name <> l2.first_name )
こんにちわ。 SQLインジェクションに限れば、PQexecParamsやPostgreSQL自身に穴が無いかぎり、出来ると思いますけどね。
サーバ以降準備中だそうです。 先週、メーリングリストに登録した人たちにはメールしようとしたらしいですが、保留状態になっていたらしいです。
SQLの基本操作の一つである「group by」を、理解できていませんね。 基本操作から、しっかり勉強すべきです。 >実はgroup by も試してみたのですが、どうもうまくいきません。 >とりあえず、下記のようなSQLを書いてみました。 >select name,max(amount),customer >from test.deal,test.person >where person.id=deal.person_id >group by name >order by max(amount) desc 理解できていないまま、いい加減なことをやっていますよ？ > ERROR: column "deal.customer" must appear in the GROUP BY clause or be >used in an aggregate function; >言われるままに、group byの中にcustomerを入れると下記のような結果に >なり、group byを付けても付けなくても同じになります エラーの内容を取り違えて、デタラメな対処を行っていますよ？ >group by を使用するとして、名前の重複を避けるにはどのようにしたら 名前の重複を起こさない（つまり、どのデータを活かすか？）が、不明瞭だし、SQLとして指定されていないのですよ。 どうしたい（どのデータを活かしたい）のですか？ また、得たい結果（仕様）で、まだまだ不明瞭な点があります。 person_id毎に、最大のamountを得るのは簡単です。 しかし、同じperson_idで求めた最大のamountが、二箇所以上のcustomerで記録されていた場合、どういう結果を得たいのでしょうか？ 理解できていないのに、デタラメの上にさらにデタラメを繰り返すのでなく、簡単なクエリから順次、組み立てていきましょう。 今回のクエリは、次の(1)～(3)の順に組み立てていくと、具体的な仕様が明確でない部分が明確になり、SQLの理解も進むと思います。 (1)test_deal表で、person_id毎に最大のamountを得る (2)(1)に該当するtest_deal表のidを得る 　→全idとするのか、最大のidあるいは最小のidとするのか、仕様の明確化が必要 (3)(2)のidと、test_person表を結合する
データが何件くらいある表を、定義変更しようとしているのでしょうか？ ALTER TABLEで、NULLが可な列の追加なら、格納済の行に影響しませんが、NOT NULL列の追加の場合、格納済の全行が更新されるので、格納済データ数に比例して、処理時間が掛かるようになります。 商用RDBMSでは、NULL可の列だけ追加可能で、NOT NULL列の追加を禁止していたりします。
PostgreSQLでは、Oracleに似た「階層問い合わせ」という機能が、標準搭載ではないですが、実装されています。 http://www.thinkit.co.jp/free/marugoto/2/1/23/1.html MySQLでは、まだこの辺の機能は実装されていません。階層を制限した形で実装するとか、ストアドプロシジャで作りこむといった対処になると思います。 標準SQLでは、SQL99で「再帰クエリ」(with句を使用）が規定されており、MySQLでも将来的には実装するのではないかと思います。
　う～ん・・・・定期的ではなくPostgreSQL自身がvacuumすべき(と判断した)タイミングでvacuumするから「auto」vacuumなんですがね。そういう用途でautovacuumは使えませんと思いますがいかが。 　ところでご存知かも知れないがautovacuumは一定間隔で起動されPostgreSQLの統計情報を参照してある値が閾値を超えていたら勝手にvacuumして終了するというものだ。なので、「autovacuumの起動に先立って実行され、統計情報を参照してautovacuum_vacuum_threshold、autovacuum_analyze_threshold、autovacuum_vacuum_scale_factorを丁度vacuumされるような閾値に調整してやった上でPostmaster自体を再起動するようなツール」を作ってやれば実現できそうではある・・・・けど・・・・明らかに本末転倒だよね。 　vacuumdbを使いたくない理由がわかればプロの人が何かクールな対案を練ってくれるかも知れません。
気づいた点　(他の原因かもしれないが...) HTML または PHP スクリプトで文字コードの記述が無い。 ブラウザで正しい文字コードを手動で選択していない。 と思う。 (httpd.conf の言語設定もデフォルトのままかな?)
できるかできないかは、やってみれば分かる事ですね
こんにちは。 当社も同じ様な要望がありまして、現在作成中の方法を挙げます。 基本的に、ネット上で別ドメインにあるRDBMSを更新する物です。 システム概要は、ローカルDBを登録・更新の際にRSS形式のxmlファイル にその内容を書き出します。 その後XML-RPCプロトコルに添ってリモート側のAPIプログラムをキックします。 (ローカルURLとRSSファイルの所在パスをパラメータとして） リモート側では、pingレシーバプログラムが待ち構えています。 パラメータを受け取り、それを元にRSSファイルを取得してそのファイルを検証チェックし不整合がなければDBを更新して更新完了メッセージをRSSファイルへ書き出す。エラーがある場合もRSSファイルへ書き出す。 ネットで流行しているブログやサイトのRSSリーダーの仕組みを応用したまでです。 欠点は、API上の排他制御が厄介かなという感触です。 弊社の場合、言語はjavaで実現中です。 ご参考になれば幸いです。
いきなり、は難しいのではないでしょうか。 どちらもCSVに落とすユーティリティはあると思うので、というか SELECT文の実行結果が即ち、CSV（区切り文字はともかく）でしょう。 CSV→XMLはググると何件かヒットしますよ。
要するに、３回目の改行以降をパージしたいと言うことでしょう。 select substring(txt from 1 for sec+thd) || --★5 replace(substring(txt from sec+thd+1),kai,'') --★4 from (select txt,sec, position(kai in substring(txt from sec+1)) as thd,kai --★3 from (select txt,position(kai in txt) as sec,kai --★2 from (select txt,chr(10) as kai from table) A) B) C --★1 fromを複数のサブクエリにしたのは分かり易くするためです。 ★1：txt(対象項目)とkai(改行文字)のみのクエリを起点とする ★2：txt中で改行位置を検索し、その位置をsecとする ★3：txtのsec+1以降にある改行位置を検索し、その位置をthdとする ★4：２回目の改行位置(sec+thd)+1以降の改行を空文字列に置換する ★5：２回目の改行位置(sec+thd)までの文字列と結合する 但し、改行が２個未満のデータがあった場合の動作は未確認です。
下のアドバイス、少し訂正。 「totojimaさんが持参したデータを使って、 そのデータをデータベースにロード（格納）して、 totojimaさんが作ったプログラムを テストしましょう」という意味でしょう。
それなら早く言ってよ（笑） to_char(開始時刻, 'HH24:MI') >= '13:30' AND to_char(終了時刻, 'HH24:MI') <= '15:40' http://www.postgresql.jp/document/pg734doc/user/functions-formatting.html 参考URLの文章の中に関連事項のリンクもあったはず。
以下は一例です。 SELECT field1 FROM T GROUP BY field1 HAVING MAX((CASE WHEN field2 in (1,2,3) THEN 1 ELSE 0 END) |(CASE WHEN field2 in (101,102,103) THEN 2 ELSE 0 END))=3 その他、サブクエリでAグループ、Bグループを作り、INNER JOINする 方法などが考えられます。
pgAdminIIIではパスワードを入れるとアクセスできるのですから、 パスワードはそれでいいのです。 psql: role "Owner" does not exist　と出るのは、 Windowsのコマンドプロンプトからpsqlでアクセスするときは、 OSのユーザがデフォルトになっているためです。 postgres　ユーザでログインするには、コマンドプロンプトで 明示的に-Uオプションを付け、 psql -U postgres <データベース名> としてログインせねばなりません。
パスワードが表示されていないだけで、入力されているんですよ。 だから、 psql: FATAL: password authentication failed for user "postgre" アクセス権が無い（パスワードが違ってる） paql: fe_sendauth: no password supplied パスワードが入力されていない（Enterを押しただけ） というエラーが返ってきています。 表示されませんから、正確に入力してみましょう。
Viewは更新可能ではないので、カーソルタイプやロックタイプに 指定できる値が限られています。とりあえず以下を試してください。 adoRS.CursorType = adOpenKeyset　→　adOpenForwardOnly adoRS.LockType = adLockOptimistic　→　adLockReadOnly
PgAdminの設定が「パスワードを保存する」になっていませんか。
RDBMSにより、「データベース」の概念が異なっているので、分かりづらい部分ですね。 PostgreSQLでは、「複数データベースの操作」は未実装のようです。 http://www.postgresql.jp/document/pg823doc/html/ddl-schemas.html 「サーバに接続しているクライアントは、単一のデータベース、つまり接続要求で指定したデータベース内のデータにしかアクセスできません。」
こんにちは。 DELETE FROM table1 AS T1 USING (SELECT user_id, instance_id FROM table1 ORDER BY random() LIMIT 100) AS T2 WHERE T1.user_id = T2.user_id AND T1.instance_id = T2.instance_id; こんな感じでだめですか？
select id_sub, ( select array_to_string(ARRAY(select id_sub_code from table2 where table1.id_sub=table2.id_sub ), ',') ) from table1; なんて参考になりませんか。
create or replace function trg_b_test() returns trigger as $$ declare i int; begin if old.fall=0 and new.fall=1 then update a set fall0=1 where a.aid = new.aid; end if; select count(*) into i from b where b.fall=0 and b.aid=new.aid; if i = 0 then update a set fall1=1 where a.aid = new.aid; end if; return new; end; $$ language 'plpgsql'; drop trigger trg_b_test on b; create trigger trg_b_test after update on b for each row execute procedure trg_b_test();
SELECT * FROM Ａテーブル LEFT JOIN Ｂテーブル USING("Key1", "Key2") UNION SELECT * FROM Ａテーブル RIGHT JOIN Ｂテーブル USING("Key1", "Key2") で取得できるでしょう。
ためしていませんが select 年月, sum( case 担当者 when '太郎' then 金額 else 0 end ) as 太郎, sum( case 担当者 when '次郎' then 金額 else 0 end ) as 次郎, sum( case 担当者 when '三郎' then 金額 else 0 end ) as 三郎 from テーブル group by 年月
PostgreSQL 7.x と 8.3 のデータベースを別々の場所に作成し、 かつ TCP の接続ポートも別にすれば可能です。 最初に、PostgreSQL 7.x と 8.3 を configure オプションの prefix を違う内容 (例えば /opt/pgsql74 と /opt/pgsql83 とか) にしてインストール。(パッケージだと /usr とかにインストールされてしまうので) あとは PGDATA を別々の値に設定した状態で initdb して $PGDATA/postgresql.conf の port を変更。(デフォルトは 5432) アプリからの接続時はそれぞれのデータベースに対応する Port 番号を指定すればよいです。
>日本語は通らないという理解でよいのでしょうか？ データベースのテーブルのフィールド名及びフィールドの値に日本 語文字を設定すると文字化けするという解釈ですか？ 因みに、自分でソースからコンパイルしてインストールしない限り デフォルトのエンコーディングはSQL_ASCIIです。 phpにて利用したいのであれば、DBをクリエイトする時に、EUC_JPを javaにて利用したいのであれば、utf-8を指定してDBをアロケーション すれば問題ないはずです。 postgresqlにてフィールド名に日本語を使用したシステムは構築したことがないのでなんとも言えませんが？ 本番環境・開発環境にて現在利用していますので、ご参考になれば幸いです。
>・データは月次60000件、年間72万件のデータを数年間保持する必要あり 過去のデータについても頻繁にアクセスするのか、稀なのか等によって、設計の仕方が変わってきます。 >何ヶ月、何年と運用を重ねていくながで数十万、数百万のデータによって、アプリケーションの処理が極端に重くなったりデータ容量の上限に 達するといったことはあるのでしょうか？ 設計の仕方によります。 例えば、インデクスを有効利用できない検索条件を指定したり、order by、group by、distinct等で作業メモリ（or ファイル）を使ったソートが発生するようなインデクスの定義、SQLの記述をすれば、当然、データ量が増えるにしたがって性能劣化します。また、多量のデータ更新や削除が発生しているのに、計画的にデフラグしないなら、性能劣化してしまいます。 逆に、インデクス設計とSQLの記述が適切に行われているなら、母体データ量が増えても極端に性能劣化はしません。 >Postgresの容量が2GB 何の容量ですか？ どこで拾った値でしょうか？ 「パーティショニング」、「クラスタ」などのキーワードを調べてみてください。
Oracleだったら UPDATE tableA set c = 3 WHERE 条件◆ and (a1, a2) in (select a1, a2 from tableA where b=1 and c=1) だったような。
UPDATE tableA set c = 3 WHERE b=0 and c=1 and a in ( select a from tablea where b=1 and c=1 ) では
どこが具体的に分からないのでしょうか？ >期待結果　a-1　　　a-2　　　b-1　 c-1　 >￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣ >　　　１　　　bbb　　　aaa　　　ddd　 eee >　　　２　　　ggg　　　bbb　　　ccc　　　※ >　　　３　　　bbb　　　mmm　　ddd　　　※ >　　　４　　　ggg　　　aaa　　　ccc　　　qqq >※は空白でもNULLでもよい 4番目の値を間違っていませんか？ 4 ggg mmm ccc qqq　　ですよね？ 1～4の通番も値として持つのですか？ 列名に「-」を使うのですか？ その場合、減算と区別するために、「"」で囲む必要がありますよ？ PostgreSQLのバージョンは何ですか？ あまりに古いと、具体例を提示しても、wanton_dogの環境では実行できないかも知れません。 以下の例は、TABLE1に通番の列（seqno）があるものとします。 -- EX1 -- 簡単なLEFT OUTER JOIN（結合のための列が2個） select seqno, t1."a-1",t1."a-2","b-1","c-1" from table1 as t1 left join table2 as t2 on t1."a-1"=t2."a-1" and t1."a-2"=t2."a-2" ; -- EX2 -- EX1のSQLを、nullの場合、値を置き換える -- nullを判別する関数は複数あったり、RDBMSにより違う。 -- coalesce関数は、主要なRDBMSで実装されている select seqno, t1."a-1",t1."a-2", coalesce("b-1",'BLANK') as "b-1", coalesce("c-1",'BLANK') as "c-1" from table1 as t1 left join table2 as t2 on t1."a-1"=t2."a-1" and t1."a-2"=t2."a-2" ; -- EX3 -- EX1のSQLを、インラインビューから得る形に変える select seqno, t1."a-1",t1."a-2","b-1","c-1" from (select * from table1) as t1 left join (select * from table2) as t2 on t1."a-1"=t2."a-1" and t1."a-2"=t2."a-2" ; -- EX4 -- EX1のSQLを、行値構成子（行値式）を使用する形に変更する。 select seqno, t1."a-1",t1."a-2","b-1","c-1" from table1 as t1 left join table2 as t2 on (t1."a-1",t1."a-2")=(t2."a-1",t2."a-2") ;
こんにちは。 直接の回答ではないのですが、VB2005で ADOを持ち出すのは何か理由があるのでしょうか？ .NETとCOMはあんまり相性がよくないので、普通は .NET Framework データプロバイダ(Npgsql)を 使うと思います。
ログインid は、何を使っていますか？
原則 バージョンの高いものから低いものへの移行は、うまくいかないで しょう。 pg_dump -D で、データを INSERT コマンドとしてダンプしてみては どうでしょうか。
> ヘッダファイルが見つからないのは探す場所が違うんだろうな、何でだろうな…とか。 ヘッダなりライブラリなりの置き場所には慣例的な決まりがありまして、 /usr/include /usr/lib などになります。 黙っていても探してくれるのはそれらのディレクトリだけなので、ほかの場所に置いてあっても探してくれません。ということで別途教えてやる必要があります。 -I ヘッダファイル探索ディレクトリ -L ライブラリファイル探索ディレクトリ -l 使うライブラリの名前 libXXX gcc -I/usr/local/pgsql/include -L/usr/local/pgsql/lib -lpq -o sample sample.c こんな感じになります。 また、コンパイル＆リンクはこれでできますが、そのままだと実行する時に sample が libpq.so の位置を知らないのでエラーになります。これは環境変数で指定できます。 export LD_LIBRARY_PATH=/usr/local/pgsql/lib この環境変数は設定した以後に起動される「全ての」プログラムに対して影響するので、不毛なトラブルの原因になる場合がありますから注意してください。 > ソースからとパッケージからのインストール何が違うのかとか。 RPM インストール rpm コマンド一発で全部勝手にやってくれます。そのお手軽さがウリです。ヘッダやライブラリは上記の規定のディレクトリに配置されるので、追加オプション指定は不要になります。 なお、この方法だと、当然ながら当該ホストの「全ての」ユーザがそのインストールの影響を受けることになりますのでその点はご注意ください。 ソースからのインストール 昔はこちらしかありませんでした。各種環境設定は全て自前でやる必要があります。裏で勝手にゴソゴソやられるのは気に入らんとか開発の都合上複数のバージョンを使い分けたいとかいう人向けです。上級者向けと言われるのはそのためです。
(1)7.2ではvacuum,analyzeに加えreindexも必要、一度すべて試行してからEXPLAINをしてみる。 (2)7.2ではIN関数が不得意なので 　where k3='100' or k3='200'・・・ 　に置き換えるか、PGversionを8.2などに上げてみる
普通に考えれば、unionを使うと思います。
失礼しました（文面をよく読んでいませんでした）。 半角全角変換関数ですがデータベースがutf8で作成されているのが前提 ですが、plperluを使えば以下のようにできます。 CREATE or REPLACE FUNCTION perl_h2z (varchar) RETURNS varchar AS $$ use utf8; use Unicode::Japanese; my ($a) = @_; if (! defined $a) { return undef; } my $b; $b = Unicode::Japanese->new($a)->h2z->get; return $b; $$ LANGUAGE plperlu; ご参考までに。
PostgreSQLでは、バージョンにより違いがあるかも知れませんが、char(n)のnは、バイトでなく文字数です。 これは、全角や半角の文字を実際に格納できるか試してみれば、すぐに分かることです。 ちなみに、MySQLでは4.0まではバイト数、4.1以降は文字数と、仕様変更されています。
複数のサーバーでデータベースを構成することです。 「クラスター」とは「かたまり＝群れ」の事です。 テーブルによってサーバーを分けたり、キーの範囲で分けたりして負荷分散を図ります。
>年間データテーブルと年間テーブルから当日だけのViewがある 日本語で説明された上、曖昧な説明になっていますが。。。 「年間データテーブル」と「その年間データテーブルから、当日分だけ見るように条件指定したビュー」があるということですか？ >Viewから検索した方が早くはならないのでしょうか。 なぜ、そういう考えが出てきたのでしょうか？ ビューは、実体のない表で、検索時には基の表から検索されます。したがって、基の表にどういうインデクスを定義していて、ビュー中の検索条件でインデクスを有効利用できる指定になっているかで性能が左右されます。 ただし、一部のRDBMSでは、ビューを「実体のある表」とできたり、「ビューにインデクスを定義する」といった拡張仕様を持っているものもあります。 PostgreSQLでは、そういった拡張仕様を持っていなかったと思います。そればかりか、ビューを使用しての更新禁止という制限があったと思います。
翻訳がおかしいようですね。 原文はそれぞれ ・Will be installed on local hard drive ・Entire feature will be installed on local hard drive ・Entire feature will be unavailable となっています。意訳すると ・インストールする ・いずれ使えるように用意だけしておく ・インストールしない です。
>※ちなみに動的に生成されたＳＱＬはこんな感じになります。 >SELECT col1 >,SUM( CASE WHEN col2 = 1 THEN val END ) AS col_name1 >,SUM( CASE WHEN col2 = 2 THEN val END ) AS col_name2 >FROM t1 >GROUP BY col1 >ORDER BY col1; int,int,intと3個を列として受け渡したいのだから、次のようなユーザデータ型を定義します。 CREATE TYPE test_type -- (INT,INT,INT)の3項目の受け渡し用 AS　 (a INT, b INT, c INT); そして、このユーザ定義型の変数で、受け渡しができると思います。
私も以下の条件で同じ事象が発生しました。 apache:2.2.9 php:5.1.6 postgresql:8.3.1 phpPgAdmin:4.2 原因は、/var/lib/php/session のディレクトリ権限が不足していたので、 apacheでも書き込めるようにしました。 （環境の違いによりディレクトリが異なるかと思います） なお、php.iniで、display_errors=Onとすることでエラー出力され 対応方法がわかりました。
>SELECT SUM( c2 ) AS sum_c2,SUM( c3 ) AS sum_c3 > FROM t1 > WHERE c2 IS NOT NULL > GROUP BY c1 selectの選択列にc1列も指定しないと、どのc1のc2集計、c3集計かが分からないですよ？ 方法は二つです。 一つは、表の検索しない列に対応する値を、selectの選択列でダミーの定数で指定する方法です。 つまり、次のように指定します。 select null, -- c1列に対応 SUM( c2 ), SUM( c3 ), null -- c4列に対応 from ～ なお、ストアドファンクション中で付けた別名は、呼び出し側には渡らないようです。 そのため、別名で参照したい場合は、 select null as dmy_c1, sum(c2) as sum_c2, sum(c3) as sum_c3, null as dmy_c4 from func1() のように呼び出します。 もう一つの方法は、 select c1,sum(c2),sum(c3) from ～ と、今回の場合、int,int,intの3個の値を列として得たいなら、 create type test_type -- (INT,INT,INT)の3項目の受け渡し用 as 　 (a INT, b INT, c INT); というユーザ定義型を作成し、そのユーザ定義型で受け渡しするストアド・プロシジャを作るというやり方です。 この場合、呼び出しは、 select a as c1, b as sum_c2, c as sum_c3 from func1(); のように行います。
select avg( case when day_end is null then current_date else to_date(day_end,'yyyy/mm/dd') end - to_date(day_start,'yyyy/mm/dd') ) from a では
こんにちは。 >VALUES("ここはどういう感じで書けばいいですか？”） 行で抽出したdataを区切り文字(Delimiter)で分割して、各値をカンマ(,)で 区切って記述します。(動的にSQLステートメントを生成する場合) >*　この「data」は一行単位ですが、どういう形式でテーブルにINSERT INTO　できますか？ 数値型でしたらDelimiterで分割するだけでいいですが、 文字列でしたら、単一引用符(')をつけないといけないです。 >*　VALUES の値は必ず、具体的な値ではなければなりませんか？ 動的にSQLステートメントを生成する場合はそうですが、先に申したように 文字列は単一引用符(')で囲まなければならないなどややこしいので、 パラメータを使用できるPQexecParamsを使うと、値はパラメータに渡せば いいので楽になるかもしれません。 以下にPQexecParamsの例を記述します。(VC++ MFC) //テキストファイル(カンマ区切り)のPostgreSQLテーブルへのインポート //引数 pszFileName : テキストファイルへのフルパス // pszTblName : テーブル名 1>int CopyFromString(TCHAR *pszFileName, TCHAR *pszTblName) 2>{ 3>//接続/////////////////////////////////////////////////////////// 4> PGresult *pRes; 5> TCHAR *pCnInfo = _T("host=xxx port=5432 dbname=xxx user=xxx password=xxx"); 6> PGconn *pCn = PQconnectdb(pCnInfo); 7> 8> if (PQstatus(pCn) != CONNECTION_OK) 9> { 10> TRACE(_T("Fail Connect Server\n")); 11> PQfinish(pCn); 12> return 1; 13> } 14> 15>//Table フィールド数取得///////////////////////////////////////// 16> CString strCmd; //SQLステートメント 17> int column_count; //フィールド数 18> 19> strCmd = _T("SELECT COUNT(*) FROM information_schema.columns WHERE table_name = $1;"); 20> pRes = PQexecParams(pCn, strCmd, 1, NULL, &pszTblName, NULL, NULL, 0); 21> 22> if (PQresultStatus(pRes) != PGRES_TUPLES_OK) 23> { 24> TRACE(_T("Fail Get Column:%s\n"), PQresultErrorMessage(pRes)); 25> PQclear(pRes); 26> PQfinish(pCn); 27> return 1; 28> } 29> column_count = _tstoi(PQgetvalue(pRes, 0, 0)); 30> PQclear(pRes); 31> 32> //テキストファイルOpen////////////////////////////////////////// 33> CStdioFile file; 34> CFileException e; 35> if (!file.Open(pszFileName, CFile::modeRead | 36> CFile::shareDenyWrite | 37> CFile::osSequentialScan, &e) 38> ) 39> { 40> CString strErr; 41> e.GetErrorMessage(strErr.GetBuffer(255), 255); 42> strErr.ReleaseBuffer(); 43> TRACE(_T("File Open Error:%s\n"), strErr) ; 44> return 1; 45> } 46> 47>//メイン///////////////////////////////////////////////////////// 48> int nRet = 0; 49> int start; 50> int idx; 51> CString strData; //Text行データ 52> CString strTemp; //SQLステートメント補助 53> CString *pstrItem = new CString[column_count];//行データ各項目 54> 55>//SQL(INSERT)ステートメント生成 56> strCmd = _T(""); 57> for (int i=0; i<column_count; i++) 58> { 59> strTemp.Format(_T(",$%d"), i+1); 60> strCmd += strTemp; 61> } 62> // INSERT INTO tblname VALUES ($1, $2, $3, $4); 63> strCmd = _T("INSERT INTO ") + CString(pszTblName) + _T(" VALUES (") + strCmd.Mid(1) + _T(");"); 64> 65> //データ読込み & テーブルへの書込み 66> while (file.ReadString(strData)) 67> { 68> //Text行の読込み & データ項目取得 69> start = 0; 70> idx = 0; 71> for (int i=0; i<column_count; i++) 72> { 73> idx = strData.Find(_T(","), start); //Delimiter "," 74> *(pstrItem + i) = strData.Mid(start, idx == -1 ? strData.GetLength() : idx-start); 75> start = ++idx; 76> } 77> 78> //Tableへの書込み 79> pRes = PQexecParams(pCn 80> , strCmd 81> , column_count 82> , NULL 83> , reinterpret_cast<const char * const *>(pstrItem) 84> , NULL 85> , NULL 86> , 1); 87> if (PQresultStatus(pRes) != PGRES_COMMAND_OK) 88> { 89> TRACE(_T("Fail Insert Data:%s\n"), PQresultErrorMessage(pRes)); 90> nRet = 1; 91> } 92> 93> //後始末 94> for (int i=0; i<column_count; i++) 95> { 96> *(pstrItem + i) = _T(""); 97> } 98> PQclear(pRes); 99> } 100> 101> delete [] pstrItem; 102> file.Close(); 103> PQfinish(pCn); 104> 105> return nRet; 106>} この場合でもテキストの一行の データをDelimiterで分割しなければなりません。53でフィールド数分データ格納用の 領域を確保して69～76で分割しています。前コメントでも申しましたように VC++ MFCのCStringで楽してるので、Cでしたらこの部分をmalloc、callocで領域を 確保してstring.hをインクルードしてstrncpyなどを使って分割することになりますが、 時間があればアップします。
同じテーブル構成で-d-Dが必要になったことは無いです。 7.4→8.3以降の場合は、移行先の8.3のpg_dumpでdumpする必要があります から、特にバージョンの差異もここでは考えなくて良いのかもしれません
すごく長いSQLですね。 INやORを使わずにEXISTSで書けばどうでしょうか？ 文字数じゃなくパフォーマンスのせいだと思います。
必要ありません。
バージョンの記述がないので、 私の使用しているTera Term PRO Ver2.3で説明しますね。 Tera Termの設定保存は １「Setup」－「Save setup..」をクリック 　　(お使いのプラグイン等によっては「設定」→「設定の保存(S)...」と日本語の場合もあるようです) ２　TERATERM.INIが表示されるのでそのまま「保存」をクリック 以上です。 次回からは保存した時点の設定状態で起動されます。
こんにちは。 >ADOとODBCの違い と >AccessからPostgresのデータをいじる時の利点、欠点はなんでしょうか？ 質問内容が違いますが、何をご質問になりたいのでしょう？ 具体的におっしゃってください。
こんにちは。 >Access上でリレーションが未定義でサブフォームを作成することが出来ません。 実際のエラーメッセージは何でしょう？ サブフォームということは、サブフォームコントロールの リンク子フィールド、リンク親フィールドが設定できないという 理解でいいのでしょうか？ >基本的にCreateTableするときに、なにやらリレーション設定する構文が必要だったのでしょうか？ こちらの環境ではリレーションシップを作成しなくても、上記プロパティを 設定すればできたので特に必要はないと思います。 Access、Postgresのバージョン、テーブルの状態、メイン・サブフォームの レコードソース、メインのサブフォームコントロールのリンク子フィールド、 リンク親フィールドプロパティなど、具体的にアップされるとコメントが つくかもしれません。
　そのダンプがEUC-JPなんではないのかな。（ダンプを取ったときクライアントエンコーディングがEUC-JPになっていた） 　で、入れなおそうとしているFC6のデフォルトエンコーディングは多分UTF-8なのだろうからダンプをUTF-8として（クライアントエンコーディングをUTF-8として）読もうとして失敗しているのではないでしょーか。 　そのダンプを一旦nkfでUTF-8に直してしまうか、psqlのクライアントエンコーディングをEUC-JPに変更して入れてみたらどうでしょ。 　現在のDB（PostgreSQL内の全DB）のエンコーディングを調べるにはpsqlで入って\lとすれば良い、が、サーバーエンコーディングはあまり関係はないと思うよ。クライアントエンコーディングを調べるには同じくpsqlで\encodingだ。
自分なりに考えたSQLは、ないのですか？ 日付だけで、行は一意に識別できるのですよね？？？ SQL例です。 select 日付,入会数,退会数,(select sum(入会数-退会数) from t1 where 日付<=x.日付) as 累計 from t1 as x order by 日付
1行1行に累計を返すというのは、SQLでやるにはあまり効率的でない（アプリケーションでやった方が、より軽快）ですけどね。 SQL例としては、以下のような方法があります。 select id,売上,入金,(select sum(売上-入金) from t1 where id<=x.id) as 累計 from t1 as x order by id
普通のグループ化でよいのでは？ SELECT * FROM (SELECT no,MAX(date1) AS date1,MAX(date2) AS date2 FROM TA GROUP BY no) ORDER BY no,date1,date2
LOBはSQL99で標準SQLに入ったばかりだし、操作するのにアプリケーションを作成する必要があり、RDBMS全体の機能としては局所的なものなので、雑誌や書籍類で取り上げられる機会は少ないと思います。 >ラージオブジェクトを使って、バイナリファイル（ここではPDF）を保管するメリットがあるのか？ メリットとしては、 (1)障害運用を一元化できる (2)セキュリティの管理を一元化できる (3)PDFデータを管理するテーブルのデータと、PDFの内容の不整合を防げる などでしょう。 デメリットとしては (1)PDFの内容を確認したい場合、RDBMS経由でないとダメ。検索や更新用のアプリケーション等を作っておく必要がある。 (2)PDFのデータを管理するのに、RDBMS側でも管理情報が必要になり、DBの容量が増える などです。
VACUUM FULLだけでは索引の不要領域は開放されないようです。 http://www.postgresql.jp/blog/98
#2回答者です。 「違い」について、追記します。 「違い」は、「表の定義の中で指定する」のと、「インデクスの定義で指定する」といったところです。表定義で指定すれば、DDLを逆生成した場合など、「インデクスの定義がどうなっているか？」といった手間が省けます。 その一方、表の定義そのものを変更するので、不慣れな場合はちょっと怖いかも。 一方、インデクス定義で作成する場合、表の定義自体はそのままなので、そういった不安はないと思います。
こんにちは、angelinaane様 以下のSQLではいかがでしょうか？ SELECT tablea.ID,tablea.name FROM tablea LEFT JOIN tableb ON tablea.id = tableb.id WHERE tablea.name LIKE '%あああ%' AND tableb.kubun = 1 and tableb.naiyo >= 0 UNION SELECT tablea.ID,tablea.name FROM tablea LEFT JOIN tableb ON tablea.id = tableb.id WHERE tablea.name LIKE '%あああ%' AND tableb.kubun = 2 and tableb.naiyo >= 5 UNION SELECT tablea.ID,tablea.name FROM tablea LEFT JOIN tableb ON tablea.id = tableb.id WHERE tablea.name LIKE '%あああ%' AND tableb.kubun = 3 and tableb.naiyo <= 8 単純にUNIONで結合しただけです。 一応、条件通りだと思うのですが、もっと複雑な気がしています。 もしかして、 >区分1のとき内容が0以上　かつ >区分2のとき内容が5以上　かつ >区分3のとき内容が8以下 この条件は可変とか・・・ だとすると、プログラム中でSQLを組むだけなんですけどね。
こんにちは、angelinaaneさん select * from テーブル where substring(項目 from '\,|[0-9.-]+') = 項目 and cast(substring(項目 from '\,|[0-9.-]+') as float8) <= 4 これでいかがでしょうか？
はじめまして、titokaniさん SELECT EXTRACT(EPOCH FROM lastdate) FROM table ORDER BY lastdate DESC LIMIT 1 これでいかがでしょうか？ 一応、以下の構成で試しています。 OS:VineLinux4.2 Database:PosgreSQL8.2 pgAdmin3(WinXp)
LASTVAL()は、マニュアルを見る限りPostgreSQL 8.3から登場しているようですが？ $sql = 'SELECT LASTVAL()'; $denpyo_no = $row['LASTVAL()']; 一般的には、 SELECT LASTVAL() AS LV のように別名を付け、 $denpyo_no = $row['LV']; のように別名で参照します。
再度登場です＾＾； それでしたら「SELECT_ID」フィールドに教師、保護者、学生などを、「OPTION_ID」に学年を定義すれば良いのでは？
以下のような感じでテーブルを結合すればよいと思いますが。 SELECT table1.ID table2.NAME FROM table1 table2 WHERE table1.ID = table2.ID AND table1.ID=$id
今回の例では、元々括弧を使う必要はないので、不必要な括弧を書かないようにすればいいのでは？ また、クエリを部分的にビューにしてしまえば、SQLは簡潔にできます。
こんにちは。 >-iオプションを付けて起動すれば、TCP/IP接続できるようになると知って、 どこからの情報かわかりませんが、postmasterのオプションのことを 指しているのでしょうか？ でしたら、以前のバージョンのドキュメントですが、 ------------------------------------------------------------ リモートクライアントからのTCP/IP（インターネットドメイン） 経由の接続を可能とします。このオプションを設定しない場合には、 ローカルからの接続のみが使用可能となります。 このオプションは、postgresql.conf内のlisten_addressesを設定すること、 あるいは-hを*に設定することと同じ意味を持ちます。 ------------------------------------------------------------ あるので、postgresql.confとpg_hba.confの該当オプションを 適切に設定してみてください。
当方、PostgreSQL 8.0を使っていますが、 select * from t1 as x left join t2 as y on x.c1=y.c1 という別名を使った構文は使えるようです。 また、以下のようにインラインビューにする方法はどうでしょうか？ select * from (select * from t1) as x left join (select * from t2) as y on x.c1=y.c1
お疲れ様です。 where current_date >= to_date( dt, 'yymmdd' ) + 7 で抽出できませんか？
こんにちわ。 「C:\Program Files」内のPostgreのフォルダを消さなければだめだったと思います。
export PGCLIENTENCODING=UNICODE を指定するか pg_dumpallでなくpg_dump "database名"で個別 バックアップ どちらかでうまくいきませんか
配布元のサポートページ http://www.postgresql.org/docs/faqs.FAQ.html の　1.4）What platforms does PostgreSQL support? を見たら、動作保障されているOSの中には 「WindowsVista」（エディションに関係なく）がないようですが…？ 動作保証がないなら、正しく動かなくてもなんら不思議なことはありませんけど。
URLを貼り忘れました。 http://www.postgresql.jp/ また、差が出ているポイントは、テスト環境ではMerge Join、本番環境ではNested Loop さらにloops=38となっている部分だと思います。 具体的に「SQLのどの記述の部分」ということは、インデクスの定義とSQLが分からないと具体的にはアドバイスできません。
実質、丸投げじゃないですか！ >このあとの記述が複雑でわかりません この程度の関数で複雑というなら、自分で関数を作るのは無理なのでは？ と言いつつ、関数の作成例を、以下に示します。 もっと簡略化もできるのですが、逆に分かりにくくなるので、あえてこれ以上、簡略化しません。 １．定義 create or replace function bool2int (pBool bool) returns int as $$ declare vInt int; begin if pBool=true then vInt:=1; elseif pBool=false then vInt:=0; else vInt:=null; end if; return vInt; end; $$ language 'plpgsql' ; ２．実行 select bool2int(true),bool2int(false),bool2int(null);
PostgreSQLの話でいいのでしょうか？ >powergresでalter文でカラムの追加・削除等を行うと PostgreSQLに対しては、どんなalter文が生成されるのでしょうかね？？？ >追加したカラムに紐づくテーブルのデータが消えてしまったりすることはあるのか？　（alter文でカラムを削除した時のデータ以外のデータ） 「紐づく」というのは、いろいろな解釈ができてしまうのですが。。。 列の追加や削除時、そのテーブルの他の列のことですか？ それとも、外部キー等のことでしょうか？ default値がnullの列の追加や削除では、そのテーブルの行削除や他の列が影響を受けることはありません。 一方、default値がnot nullの場合は、全行にdefault値を入れるために、削除＆追加が一時的に発生するようです。 後者は、RDBMSによっては、「格納済の行がある状態でのnot nullの列追加」を禁止しているものもあります。 >・その詳細な理由がほしいです。 「詳細な理由」とは、どういう意味でしょうか？ 標準SQLやPostgreSQLが、そういう仕様になっている理由ということですか？ 「仕様を決めた人に聞いてください」と回答したくなってしまいますが。。。 それとも、「その仕様が書かれているマニュアル等の箇所」という意味でしょうか？ 階層型DBやネットワーク型DBでは、レコードの定義やデータをそのままに残しての列の追加や削除という概念がありませんでした。 RDBでは、定義やデータ移行などの方法を大幅に柔軟にしています。その中の一つということでは？ http://www.postgresql.jp/document/pg820doc/html/sql-altertable.html
PGPASSWORD=○○○ /usr/local/pgsql/bin/psql -U postgres -h xxx.xxx.xxx.xxx testdb
>文字コードは、 >ポスグレとソースは「EUC-JP」 >表示は「UTF-8」です。 文字コードが違うということですが、http_outputで変換するように記述されてますか？それとも自前で変換して出力いるのでしょうか？
文章だけでは、いろいろな受け取り方ができます。 得たい結果例、やってみたことを具体的に示しましょう。 time列のデータ型を示すべきだし、PostgreSQLのバージョンも書いておき ましょう。 例えば、以下のように表示したいということですか？ 時間帯___________________件数 2006-12-01 00:00:00 3 2006-12-01 00:00:01 2 2006-12-01 00:00:02 3 2006-12-01 00:00:03 3 timestamp型を使っているなら、to_char関数、group by句,count関数を組み 合わせるとできるのでは？
画面に出てファイルに残らないなら標準出力じゃなくエラー出力なんでしょう。 コマンド >> ログファイル 2>&1
t2.id(t1.id)のIndexが使用されていないのでしょうか。 explain select～で検索方法を確認した方が良いかと思います。
ALTER文でカラムの位置を変更することはできません。 どうしてもカラムの位置を変える必要がある場合、(多くの場合、SELECT文等でデータを抽出する時に順番を整えれば良いと思いますが・・・)ANo.1の方がおっしゃるように一度、テーブル内のデータをバックアップして、テーブルを作り直し、再度データを入れる必要があると思います。 > SQL形式でカラム名指定するモードでバックアップ おそらくpg_dump -D [table_name]の大文字Dオプションのことだと思います。 カラム名まで保持したINSERT文を生成するので、テーブルの順序が変更された場合に対応できます。
例えば、こんな感じ。 SELECT Hinmei, Tani, SUBSTR(hiduke,1,4) as Nen, SUM(CASE SUBSTR(hiduke,5,2) WHEN '01' THEN ryou ELSE 0 END) as "１月", SUM(CASE SUBSTR(hiduke,5,2) WHEN '02' THEN ryou ELSE 0 END) as "２月", SUM(CASE SUBSTR(hiduke,5,2) WHEN '03' THEN ryou ELSE 0 END) as "３月", SUM(CASE SUBSTR(hiduke,5,2) WHEN '04' THEN ryou ELSE 0 END) as "４月", SUM(CASE SUBSTR(hiduke,5,2) WHEN '10' THEN ryou ELSE 0 END) as "１０月", SUM(CASE SUBSTR(hiduke,5,2) WHEN '11' THEN ryou ELSE 0 END) as "１１月", SUM(CASE SUBSTR(hiduke,5,2) WHEN '12' THEN ryou ELSE 0 END) as "１２月" FROM masta WHERE hiduke BETWEEN '200801' AND '200812' GROUP BY Hinmei,Tani,Nen
SELECT A,B,C, 'aaa' as D FROM TEST;
こんにちは。 普通にpg_dumpでバックアップはとれると思います。
こんにちは。 >気になるのがon,off両方の場合で最初にマスターテーブルを検索している（ >Seq Scan on マスターテーブル名）ようなのです。 例えば、 CREATE TABLE t_base (F1 int, F2 int, CONSTRAINT t_base_pkey PRIMARY KEY (F1) ); でマスタテーブルを定義して CREATE TABLE t_drive1 INHERITS (t_base); CREATE TABLE t_drive2 INHERITS (t_base); ・ ・ とパーティションを作成したとします。 極端な話、t_baseに10万レコードあり、各パーティションに1レコードしかなく、 あるパーティションにある（例えばt_drive2にある)レコードを検索しようとしても 時間的にはほとんどかわりません。 というのは、最適化してもマスタテーブルであるt_baseは必ず検索されるからです。 この場合は(t_baseとt_drive2が検索されると思われます) ですから、マスタテーブルにはレコードを格納しないで、すべて子テーブルに 記録しないとパーティショニングの効果は薄れるかと思います。 このへんはドキュメントにもかかれていますのでご確認ください。
No.1です。 列の属性をtimestampにして実行してみました。 Welcome to psql 8.2.0, the PostgreSQL interactive terminal. farm=# create table testtbl6 (hoge timestamp); CREATE TABLE farm=# insert into testtbl6 values('2007-12-31'); INSERT 0 1 farm=# select * from testtbl6; hoge --------------------- 2007-12-31 00:00:00 (1 row) farm=# select * from testtbl6 where hoge between '2007-01-01' and '2007-12-31'; hoge --------------------- 2007-12-31 00:00:00 (1 row) farm=# select * from testtbl6 where hoge between date '2007-01-01' and date '2007-12-31'; hoge --------------------- 2007-12-31 00:00:00 (1 row) ●時間だけを多少進めたデータを追加してみました farm=# insert into testtbl6 values('2007-12-31 01:00:00'); INSERT 0 1 farm=# select * from testtbl6; hoge --------------------- 2007-12-31 00:00:00 2007-12-31 01:00:00 (2 rows) farm=# select * from testtbl6 where hoge between '2007-01-01' and '2007-12-31'; hoge --------------------- 2007-12-31 00:00:00 (1 row) farm=# select * from testtbl6 where hoge between date '2007-01-01' and date '200 7-12-31'; hoge --------------------- 2007-12-31 00:00:00 (1 row) よって、あなたのDBに登録してあるデータは、2007-12-31と午前０時を少し回っているデータが登録されているため、 検索でヒットしないのではないのでしょうか？
$sql = "insert into m_lecturehistory (lecturecode, lecturedate ) values ('{$line[0]}',"{$line[1]}");"; なぜ、直接入力した場合に、日付を　「'」でかこったのに 変数に代入したときには　「"」でかこったのでしょう '{$line[0]}' の部分と同じ感覚でSQL文つくればいいだけです $sql = "insert into m_lecturehistory (lecturecode, lecturedate ) values ('{$line[0]}','{$line[1]}');"; つまりこうするだけ
リモートデスクトップで該当マシンに接続してインストールしようとしませんでしたでしょうか？ PostgreSQLはリモートデスクトップ接続ではインストールできませんので該当マシンに直接インストールしてください。
name1 || name2 as fullname ではいかがでしょうか？
とりあえずpostgreSQLでしたら発行するSQL文の頭にexplainを付けて、QUERY COSTを確認してみてはいかがでしょうか？ cost=の数字が極端に大きくなるところが律速です。
もう解決したかもしれませんが。 pg_dump/pg_restore実行前に export PGCLIENTENCODING=*** で文字コード指定で動作するような気がします
PostgreSQLは最後尾に追加することしかできなかった気がします。 ですので、'AFTER'以降はエラーになると思います。
pgpoolはSQLレベルのレプリケーションを行うだけなので、切り離した後の復帰まではサポートしていないと思います。 障害が発生した場合は、障害機を切り離す縮退運転として切り離した機は復帰させないようにします。障害を解消した場合は、正常機も一旦止めて、両機のデータを完全同期させる必要があります。（データ部分をrsyncする等でよいでしょう） というのも、pgpoolの場合、目的としているのが「不意の障害で運用を止めないこと」ですので、復帰のときに止めなくて済むようにはなっていませんので。もしそのようにしたいのであれば、分散クラスタ（PGCluster）や非同期レプリケーション（Slony-I）とかを検討すべきでしょう。
number型は、Oracle独自のデータ型で、PostgreSQL等では実装されていませんが？
標準の5432以外に設定した場合は psql -p 5433 のように -p オプションでポート番号を指定してください。
PostgreSQL 8.0を使い、1台のPCでサーバ＆クライアントにして使っています。 私の環境では、以下のように設定していますが、質問者さんの環境ではどうなっているでしょうか？ >頭に「#」があるということは その行は実行されていないということですよね？ そうです。その部分は大丈夫ですね。 (1)pg_hba.conf →IPアドレスは、127.0.0.1になってますか？ 　※cseを使うため、私の環境ではmd5をtrustに変更しています。 # host all all 127.0.0.1/32 md5 host all all 127.0.0.1/32 trust (2)pgAdminIIIを起動し、サーバ名を選択時、ホスト名=localhostとなっていますか？ →もしなっていないなら、「編集」→「プロパティ」で変更してください。
1台のPCを、サーバ＆クライアントにするのですね？ PostgreSQLのサービスは、動いているのですね？ もし、動いていないなら、PostgreSQLのインストールフォルダの\data配下に、 pg_hba.conf postgresql.conf に、IPアドレスを指定している場所があるので、「127.0.0.1」以外になっていないか確認してください。 この二つのファイルは、pgAdminIIIで、メニューバーの「ファイル」から編集できます。 pgAdminIIIだけが繋がらないなら、サーバ名を選択した状態で、メニューバーの「編集」→「プロパティ」で、「アドレス」が「localhost」か「127.0.0.1」以外になっていないでしょうか？
接続できないトラブルの原因は大きく分けて以下の3つ 1.経路が繋がっていない。線が繋がっているように見えても、論理的に切断されている場合もある。 2.接続先(今回はPostgreSQL)が接続を受け付けていない。 3.接続元(今回はPHP5)が接続しにいく設定になっていない。 PHP君は「PostgreSQL君が接続を待ち受けていないよ」と言っている。なので、2番ではないかと考えられる。PHP側でpg_connectにhost=hogehogeを記述していないので正しいマシンに接続にいっていないという3番の可能性もあるにはあるんだけど。 見るべきはPostgreSQLの設定。とりあえず postgresql.confを開いて、 listen_addresses = '*' という風になっているか確認。無ければ次のいずれかに設定する。 listen_addresses='127.0.0.1' listen_addresses='<マシンのIPアドレス>' listen_addresses='*' 上から順番に安全だ。ただし、一番上はPHPとPostgreSQLが同じマシンで動作していなければいけない。 ところで、恐らくここで詰まったという事は、これが解決しても次の段階で詰まると思われる。上のpostgresql.confと同じ場所にあるであろうpg_hba.confもあわせて確認しておきたい。とりあえず設定例だけ掲載しておくので後は検索いただきたい。 host all all 127.0.0.1/32 password sameuser
移動でなくコピーですが (後で A の A1 を DROP すれば良い) テーブルのエクスポートをBにインポートします。 例 一行で書くと $ pg_dump -t A1 A | psql B
あいまい検索の場合、カラム名 LIKE '%キーワード%' ですね。 複数のキーワードを重ねる場合、ANDやORがあります。ANDは両方とも含む場合、ORはどちらかを含む場合です。 即ち、「今日　天気」のどちらかが含まれる場合は、 SELECT * FROM table WHERE ( title LIKE '%今日%' ) OR ( title LIKE '%天気%' ); というクエリを発行すれば良いです。()は無くても同じですが、条件を重ねる場合はあった方が見やすいかもしれません。
recipe_ingredients表のmaster_id列と、vegetables表のvegetable_id列が対応しているのですね？ recipe表の野菜の名前はカタカナですが、vegetables表のname列はひらがななのですか？ などなど、いろいろと引っ掛かる点があるのですけどね。 SQL例を示しますから、実行結果が期待通りか確認すると共に、どういうことをやっているか調べてみてください。 select tR.* from tR inner join (select R_id from tRI inner join tV on M_id=V_id where name in('ズッキーニ','トマト') group by R_id having count(*)=2) as x on tR.R_id=x.R_id order by tR.R_id
スキーマ分けがいいと思いますが、現状そのような設計だとすると使いこなせない可能性も高いので・・・、もう一つ簡単な代替方法を。 データをプログラム側に渡してしまえば、その中で比較処理は出来ます。具体的には、table.idを配列で取るなり、他にも処理があるのであればオブジェクトで取るなりして、table2.idに対し、in句かループ文でupdateしていけばいいです。 ただし件数が多い場合はかなり処理が重くなる可能性があります。やる場合はデータ件数をきちんと考慮してくださいね。
失礼ながら、いろいろな勘違いをしているようです。 update文で、複数の表を更新することはできません。あくまでも、1表だけです。 他の表の列値で更新することは可能で、サブクエリを使う方法以外に、 update 表1 set 列2=表2.列2 from 表2 where 表1.列1=表2.列1 のように、ジョインで得られた結果で更新可能ですが、更新対象はこの例では表1です。 updateでこの例のように、複数表を指定する構文を持っているRDBMSがあり、RDBMSにより構文が違う場合もあります。 >UPDATE TABLE_A INNER JOIN TABLE_B on TABLE_A.ID=TABLE_B.ID2 複数のRDBMSを知っていますが、このような構文は、見たことがありません。なぜ、このような構文を思いついたのでしょうか？ 外部キー（参照制約）についても、正しく理解されていないようです。 参照制約は、以下の制約で親子間の不整合を防ぎます。これは、階層DBやネットワーク型DBの特性を、RDBMSに取り入れたものです。 親子間の不整合の発生をRDBMS側で防止してくれる一方で、オーバヘッドがあったり、運用上の注意（親の表を削除する場合、子の表を先に削除など）が必要になります。 アプリケーション側で不整合を発生させないようにできるなら、わざわざ参照制約を使う必要はありません。 表定義でのディフォルトの指定（NO ACTION）での動作は、次のようになります。 (1)子のいる親の主キーは、更新できない。 →子の外部キーを一旦、null等に更新し、子のいない状態で親の主キーを更新。その後、子の外部キーを親の主キーと同じ値に更新する。 (2)子のいる親は、削除できない。 →子を削除してから、親を削除 表定義で、「ON UPDATE CASCADE」、「ON DELETE CASCADE」を指定した場合は、次のような動作になります。 (1)親の主キーを更新すると、子の外部キーも自動的に更新。 (2)親を削除すると、子も削除。 どちらの動作をさせたいでしょうか？ それにより、表定義を変えるか、SQLの発行順などが変わってきます。 ＝＝＝＝＝例１(NO ACTION)＝＝＝＝＝ １．定義 create table tbl1 (pkey char(2) primary key, data varchar(10)); create table tbl2 (pkey int primary key, fkey char(2), data varchar(10), constraint tbl1_tbl2 foreign key(fkey) references tbl1(pkey) match simple on update no action on delete no action ) ; create index tbl2idx1 on tbl2(fkey); ２．操作 (1) 子のいない親の主キー更新 update tbl1 set pkey='10' where pkey='04'; (2) 子のいる親の主キー更新 -- 子を更新して、親との関係を一時的になくす update tbl2 set fkey=null where fkey='03'; -- 親を更新 update tbl1 set pkey='05' where pkey='03'; -- 子を親に対応付け update tbl2 set fkey=tbl1.pkey from tbl1 where fkey is null and tbl1.pkey='05'; または update tbl2 set fkey='05' from tbl1 where fkey is null; ＝＝＝＝＝例2(CASCADE)＝＝＝＝＝ １．定義 create table tbl1 (pkey char(2) primary key, data varchar(10)); create table tbl2 (pkey int primary key, fkey char(2), data varchar(10), constraint tbl1_tbl2 foreign key(fkey) references tbl1(pkey) match simple on update CASCADE -- no action on delete CASCADE -- no action ) ; create index tbl2idx1 on tbl2(fkey); ２．操作 (1)親の更新の背景で、子も更新 update tbl1 set pkey='05' where pkey='03'; ※子の表に対する操作は、SQL上はないが、RDBMSにより更新されている。
> ERROR: test_id_seq.nextval: you don't have permissions to set sequence wash_h_test_id_seq in test.php sequenceに関する権限が与えられてないって言われてるので、 GRANT ALL ON SEQUENCE wash_h_test_id_seq TO PUBLIC; とすれば動くのではないでしょうか？
>その2つのテーブルの差分を知りたいのですが、 >（Ａを基準と考えＢとの差分：つまりＡには存在しないデータ抽出） Aを基準なら、普通は「Aにあり、Bにない」だと思いますが？ 紛らわしいので、「t1にあり、t2にはない」として、SQL例を示します。 -- 例1 not existsを使う select c1 from t1 where not exists(select * from t2 where t1.c1=c1) -- 例2 not inを使う select c1 from t1 where c1 not in(select c1 from t2) -- 例3 left joinを使う select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c1 is null
遅くなりました。 extension=php_pgsql.dll こちらは、最後がdllなのはWindows版です。 Linuxだと、 extension=php_pgsql.so ただ、モジュールが有効になっていないなら、エラー内容がfunction not definedなど関数が定義されてないよというものになるはずです。 今回は実行はしたけど、pg_connect内でエラーが起きてるってことになるので、そちらは除外してもいいのかなとおもいます。 現時点で考えられるのは、 １．SELinuxに引っかかっている fedora core 6とのことなので、デフォルトだとSELinuxが有効になっているのではないかなぁと。 それに引っかかっているって可能性は否定できません。 SELinuxがONになっているようであれば、試しにOFFにしてやって確認してみてはいかがでしょうか ２．普通に認証に引っかかっている これは原因もいくつか考えられます。 根本的な確認になりますが、まずpsqlコマンドでの接続はできますか？ psqlコマンドで、postgres以外のユーザーだとどうでしょうか？
contans→contains issus\es →issues でしょう。 ”あなたのローカルのAdministratorグループには、Interactive Usersが含まれています。 セキュリティ上の問題を引き起こす共通設定エラーです。” ？というような内容。 TIGRLISというようなアカウントドメインが不明ですが、これは不要な気がいたします。 また、PostgreSQLをAdministratorでインストールしてはいけないと、インストーラのしょっぱなに赤字で警告されていたような。。。
管理者ガイド http://www.postgresql.jp/document/pg653doc/ej/admin/admin.htm ユーザガイド http://www.postgresql.jp/document/pg653doc/ej/user/user.htm こことか http://www.postgresql.jp/document/pg800doc/html/ 概要 http://itpro.nikkeibp.co.jp/members/ITPro/oss/20050124/155152/ これが初歩の初歩 http://allabout.co.jp/internet/database/closeup/CU20020205/index.htm
10や3という数値定数を指定すると、データ型がint（整数）と仮定されます。そして10/3も演算の中間結果もint同士の演算なので、データ型はintになるため、ここで小数点以下が切り捨てられます。 これを防止するには、10や3を10.000や3.000のように、データ型にdecが仮定され、小数点以下を保持できるようにします。小数点以下の精度をどのくらい保証できるようにしたいかにより、10.0や10.000あるいは、10.00000のように指定します。 今回のケースでは、 select to_char(10.000/3.000, '99D999'); のように指定すれば、期待した結果を得られます。 他のRDBMSでも細かくは確認していませんが、同じようなことが言えます。またSQLに限らず、プログラミング言語でも演算の中間結果がどういうデータ型になるか注意しないと、演算精度がまったく違うものになります。
できます。 MySQLのデフォルトポートは3306、PostgreSQLのデフォルトポートは5432。 待ち受けポートが重複していなければ問題なく可能です。 （実際に開発用マシンでは、Oracle、MySQL、PostgreSQL、MS SQL Serverのうち複数が同時稼働しています） なお、メモリは多めに積みましょう。
TIME型は24:00:00までしか入らないのですね。 ごめんなさい。 表示時間が0時に掛かる場合の検索条件をORで加えてみてはどうでしょう。 select * from test where (a <= b and a <= CURRENT_TIME AND CURRENT_TIME < b) or (a > b and (CURRENT_TIME < b or a <= CURRENT_TIME)); /* テストデータ */ insert into test values ('21:00:00', '2:00:00'); -- 9時から24時まで表示 insert into test values ('9:00:00', '0:00:00'); -- 0時から9時まで表示 insert into test values ('0:00:00', '9:00:00'); insert into test values ('15:00:00', '20:00:00'); /* 結果（試験時、22時30分）*/ a | b ----------+---------- 21:00:00 | 02:00:00 09:00:00 | 00:00:00 (2 rows)
少し勘違いがあるようです。 create tableで指定するprimary keyやuniqueは、重複チェックを効率的に行なうために、内部的にインデクスを定義しています。このインデクスだけをdropできてしまうと、矛盾する状態になってしまいます。 primary keyやuniqueで定義されるインデクスを削除するには、alter tableでprimary keyやuniqueの制約自体を削除する必要があります。 primary keyやuniqueで定義されるインデクスは、PostgreSQLの内部処理でインデクスを定義するため、名前も自動的に決められます。 一方、重複可のインデクスは、create indexでユーザが定義し、名前もユーザ側で指定したものになります。
DDL（定義系）SQLでいいなら、PostgreSQLを含め多くのRDBMSでは、 create index文を使います。 create [unique] index インデクス名 on 表名(列名1[,...]) uniqueを指定すれば重複禁止、省略すれば重複可のインデクスになります。 http://www.postgresql.jp/document/pg800doc/html/sql-createindex.html
可能のようです。 http://windowsvista.ms/index.php?soft http://www.iwahrt.com/iwahrt/ListProblemSolution.do?problemNo=185&categoryNo=13
plperl.dllはPostgrSQL側のモジュールなので、 Perlのディレクトリを探してもみつかりません。 PostgreSQLのインストールされたディレクトリを探してください。 > "C:/Program Files/PostgreSQL/8.2/lib/plperl.dll": ここにあると思うんですけど。 5.6のディレクトリを5.8よりも後に登録しておけば 両方をPATHに置くのもできると思いますが、 perl56.dllだけPostgreSQLのディレクトリに 放り込んでおいても動くような気がします。
こんにちは。 以下を参考にしてみてください。 http://kashinya.com/blog/archives/2006/11/postgresqlpostgresql.html http://www.orca.med.or.jp/receipt/guidance/rebld/snc.rhtml
>「エラーになる」、「動作しません」 どういう事象になるのか、具体的に書きましょう。 何かエラーメッセージやエラーコード類は、出ていませんか？ 「WHERE tel LIKE N'090%'」の「N」の意味を知った上で、この書き方をしていますか？
これでどうですか？ substring(id from 1 for length(id)-2) || '-' || substring(id from length(id)-1 for length(id))
PostgreSQL のホスト別アクセス制御設定ファイル pg_hba.conf　の hostとlocalの行はどうなっていますか？このファイルの設定でhostからアクセスができないようになっているとphpのpg_connect()の引数にhost=****となっている場合アクセスできません。
追記です。 PostgreSQL-8.2.4 (CentOS 4.5) Access2000 (Windows2000) ODBC PostgreSQL Japanese 7.03.02.60 で試したら改行もそのままコピーできました。
こんにちは。 ２．終了時点でpsqlは実行されているので、３．で再びpsqlを呼び出す 意味がわかりません。もしかして、 >psql -U ユーザー名 -d データベース名　-f　"c:\20070822EXPDAT.db" はpg_restoreの間違い？ あと、 >pg_dump -U ユーザー名 -f %DATE:~0,4%%DATE:~5,2%%DATE:~8,2%EXPDAT.db DB名 <dmp.txt プレーンテキストでダンプしてますけど、これでうまくpg_restoreできましたっけ？ pg_dumpののとき -Fcオプションをつけてダンプしたら、リストアがうまくいかない ですか？
#1、#2回答者です。 >仮にhp_body、hp_urlにindexを指定する場合、 >create index hp_table_ix1 on hp_table(hp_timestamp, hp_body, >hp_url) >とすればよいのでしょうか？ 3列でインデクスを構成したければ、そういう指定になります。 インデクスを利用し性能を出すための検索条件等の書き方と、インデクスの定義方法はお分かりですか？ 不必要なインデクスを定義すると、insert、update、deleteでは、オーバヘッドになってしまいます。 なお、primary keyを指定した列には、PostgreSQLがユニークチェックするために内部的にインデクスを定義します。したがって、同じ構成列のインデクスを定義するのは、更新処理等でオーバーヘッドになるだけです。 インデクスの有効利用について、いくつか例を示します。 なお、データ件数が相当に少ない（100件とか）場合は、PostgreSQLに「インデクスを使うより、表データを直接見た方が早い」と判断される場合があります。 また、analyze文等でコスト情報（重複度合いなど）を収集している場合は、以下の説明とは違ってくる場合があります。 ＜例1＞単一列でインデクスを構成 (1)インデクスの定義 create index t1ix1 on t1(c1) (2)インデクスを有効に利用できる検索 　次のような検索で、インデクスを有効利用できます。 select * from t1 where c1='a' -- =条件 select * from t1 where c1 between 'a' and 'z' -- 範囲条件 select * from t1 where c1 like 'a%' -- 前方一致 select * from t1 where c1 in('a','b','c') -- in条件 また、以下のような操作でも、インデクスが活用されます。 select sum(c1) from t1 -- 集合（集計）関数 select * from t1 order by c1 -- ソートやグループの指定 select * from t1 order by c1 limit 100 offset 100 -- limit、offsetは有効利用できるインデクスがないと、表のデータ部を空読みして読み飛ばすことになる。インデクスが利用できれば、インデクス上で読み飛ばしできる。 インデクスを有効利用できる検索条件と、利用できない検索条件があった場合は、インデクスで絞り込んだ後、表の格納データで条件が評価されます。 select * from t1 where c1='a' and c2>100 また、ソート(order by）やグループ指定(group by）、重複排除(distinct）指定時、利用できるインデクスがないと、表データを見てソートが行われることになります。 （検索条件でデータが絞り込まれている場合は、そのデータのみ） select * from t1 order by c2 ＜例2＞複数列でインデクスを構成 (1)インデクスの定義 create index t1ix2 on t1(c1,c2,c3) (2)インデクスを有効に利用できる検索 　次のような検索で、インデクスを有効利用できます。 select * from t1 where c1='a' -- インデクスを構成する先頭列にインデクスを有効利用できる条件あり。 ただし、この検索の場合はc1だけのインデクスがあればいいので、c1～c3でインデクスを構成していた場合、キー長が長くなる分、1個のインデクスページで管理できる情報数が少なくなり、インデクスのI/Oは多くなります。 select * from t1 where c1='a' and c2=100 -- インデクスを構成する先頭列に加え、他の構成列も、インデクスを有効利用できる条件あり select * from t1 where c1='a' and c2=100 and c3>50 select * from t1 where c1='a' and c3>50 -- c2の条件がない場合、インデクスの利用効率はc2の条件がある場合比べ悪い select * from t1 where c1 between 'a' and 'z' order by c1,c2 -- 条件式で絞り込む以外に、ソート指定がインデクス構成列と同じ並び(昇順、降順は、まったく同じor全部逆）であればソート抑止できる。group byやdistinctの背景でもソートが行われるので、その場合も同様。
はじめまして。 pointテーブルのデータに該当する状態のmemberテーブルのデータに対してポイントを数えると考えてよろしいでしょうか？ memberテーブルにデータを一意に特定する列がないので、member_idという列を定義して考えてみました。 (1)～(3)の条件と、ソート条件を満たしたSQL文は、次のようになると思いますが、如何でしょうか。 select m.member_id, count(m.member_id) from member m inner join point p on extract(year from age(now(), birthday)) >= p.min_age_cd and extract(year from age(now(), birthday)) <= p.max_age_cd and m.graduate_cd=p.graduate_cd and p.prefecture_cd like '%' || m.prefecture_cd || '%' group by m.member_id order by count(m.member_id) desc, m.member_id
次のSQLを試してみてください。 select (select count(*)+1 from t1 as x where x.c1<y.c1 or x.c1=y.c1 and x.c2<y.c2 or x.c1=y.c1 and x.c2=y.c2 and x.c3<y.c3) as no, c1,c2,c3 from t1 as y order by no;
使用しているOSなどの環境が分かりませんが。。。 情報スキーマのroutines表に、ストアドプロシジャの定義内容が格納されています。 http://www.postgresql.jp/document/pg800doc/html/infoschema-routines.html select routine_definition from information_schema.routines where routine_name='ストアドプロシジャ名' 何らかのGUIツール等を使わずにroutine_definition列を見ると、見づらいです。 pgAdminIIIが使えるなら、ファンクション一覧を表示させて、そこから選択した方が、整形して表示してくれます。
select ～ from 表名 where id not in(1,2,30,40) ただし、性能を重視するなら、「～以外」といｔnot系を使うのではなく、その「～以外」のものを肯定の条件で指定した方がいいですよ。 もちろん、インデクスを定義していることが前提です。
インストールしたのは、Windows版のPostgreSQLですか？ Postgresというユーザが、作成されていませんか？ 最初から他力本願では、オープンソースを使いこなすのは難しいですよ？
（バックアップをしっかり取っていれば）ログイン後、いきなり実行して問題無いと思います。 PostgreSQLはデータベース毎に文字コードを指定できるので、実行するのは後者 > #データベースを作成するときにエンコードを指定する場合 > CREATE DATABASE test ENCODING 'EUC_JP'; だけで良いと思います。
まず、きちんとしたSQLになっているか確認するのがよいと思います。 var_dump("INSERT INTO aas(number,name) VALUES('$number','$name')"); とやってみるとどうでしょうか。 ダブルクォート("")間は内は文字列として認識されるため、 変数が正しく認識されないかもしれません。 "INSERT INTO aas(number,name) VALUES('$number','$name')" ↓ "INSERT INTO aas(number,name) VALUES(".$number.",'".$name."')" でどうでしょうか。
>しかし上記のように省略するとエラーが出ます。 具体的には、どういうエラーですか？ 下記の例のように、serial指定列を省略して、格納可能です。 ＜定義例＞ create table t1 (c1 serial, c2 int); ＜格納例＞ insert into t1(c2) values(100); 明示的にnextvalで指定する場合は、連番型につけられた名前を指定する必要があります。この名前は、「表名_列名_seq」という名前になります。 上記の例では、次のようなSQLで格納できます。 ＜格納例２＞ insert into t1 values(nextval('t1_c1_seq'),200);
Postgresへ接続出来ないと言うより、単なるパースエラー（構文エラー）です。10行目に接続部分がありますが、ひょっとしたらそれより前（9行目）に問題がある可能性もあります。 もう一度確認してみて下さい。
>勤務時間外勤務開始時間を'18:00:00'と言った形で書くと型が合わないと言われてしまいます。 >(timestampは日付まで入力されているので確かにそうなのですが) とおもうのであれば勤務終了時間をcastすればいいだけでは？ （castで上手くいくことは検証済みです）
COPYコマンドにはオプションでカラムを指定できます。指定した順に出力されます。 http://www.postgresql.jp/document/pg803doc/html/sql-copy.html 「タイムスタンプ部分」は「タイムゾーン」のことですね？ タイムゾーン不要ならCREATE TABLEの時に"without time zone"しておくのが一番簡単です。 http://www.postgresql.jp/document/pg803doc/html/datatype-datetime.html 既に定義済みのテーブルからどうしてもタイムゾーン無しのデータをエクスポートしたいのなら、一旦ビューテーブルを作ってそのビューテーブルをエクスポートするとよいでしょう。 cretate view v1 as select cast(col1 as timestamp without time zone),col2 from t1;
以下でざっくりは動くと思いますが、SQLインジェクションなどの対応がまったくできていません。 ローカルでお試しになられるのはいいかと思いますが、公開されるのはどうかと思います。 前の方が言っておられるようにHTMLの勉強はもちろん、Webアプリ（この場合PHPとPostgreSQL）の勉強をされたほうがいいと思います。 何か一冊本を買うことをお勧めします。 ---- 1) HTMLページ <? require('../include/init.inc'); $email = $_POST['email']; ?> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP" /> </head> <body> <form action="Test1.php" method="post" name="myFORM"> <INPUT type="checkbox" name="name[]" onclick="chg()" value="aaa">：aaa <INPUT type="checkbox" name="name[]" onclick="chg()" value="bbb">：bbb <INPUT type="checkbox" name="name[]" onclick="chg()" value="ccc">：ccc <INPUT type="checkbox" name="name[]" onclick="chg()" value="ddd">：ddd <INPUT type="checkbox" name="name[]" onclick="chg()" value="eee">：eee <INPUT type="checkbox" name="name[]" onclick="chg()" value="fff">：fff <INPUT type="hidden" name="email" value="<?php echo htmlspecialchars($email); ?>"> <input type=submit value='選択'> </form> </body> </html> >　→ ここで配列のデータを変数に入れる処置が必要？ ここというか、次のPHPで必要になります。 2) Test1.php <? require('../include/init.inc'); $email = $_POST['email']; $name = $_POST['name']; // このままですと $name は配列です // 登録先（keyword）のデータ型はキャラクタなので // 文字列ないし、シリアライズする必要があるでしょ。 // これは、使用ほうほうによって決めるべきです。 // 文字列にする場合（項目をカンマ切りで） // $name = implode(",", $_POST['name']); // シリアライズする場合 // $name = serialize($_POST['name']); // 今回はとりあえず文字列にする // 文字の長さなどチェックが必要 $name = implode(",", $_POST['name']); $sql = "BEGIN; update mailing_list_sentaku set keyword = '" . $name . "' where mailing_list_name = '" . $email . "'; COMMIT;"; pg_query("$sql"); ?> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=EUC-JP" /> <body> SQLを確認<br /> <?php echo htmlspecialchars($sql); ?> </body> </head>
それ以外にも、以下のようなコマンドを使ってデータベースサーバプログラムの起動が出来ますよね。 postmaster -D /usr/local/pgsql/data ただ、以下のURLのドキュメント内には、次のような記述があります。 「何を実行するにしても、サーバはPostgreSQLユーザアカウントで起動させなければなりません。 rootであってはいけませんし、他のユーザでもいけません。」 パッケージによるインストールであれば、自動でpostgresユーザが作られているはずだと思うけど。（Debianは使ったことないので、確証はなし。） su - postgres 上記のコマンドでログインするなり、パスワードを忘れたのならroot権限にてpasswdコマンドから変更するなりした後、もう一度postmasterを起動してみよう！ ちなみに、パーミッション関係のエラーは、「Permission denied」ですよね。
#3で提示したような結果でいいなら、下記SQLで実現できると思います。 select x.id,y.id as 重複id from t1 as x,t1 as y where (x.sdate between y.sdate and y.edate or x.edate between y.sdate and y.edate) and x.id<>y.id order by x.id,y.id;
どうしても縦（＝別の行として）に表示したいですか？ 横に並べる形でもいいなら、簡単なSQLで実現可能と思います。 select sum(case syuusi when '収入' then kingaku else 0 end) as 収入, sum(case syuusi when '支出' then kingaku else 0 end) as 支出, sum(case syuusi when '収入' then kingaku when '支出' then -kingaku else 0 end) as 収支 from suitoh_table where hiduke like '2007-5-%' and syuusi in('収入','支出') ;
こんばんは。 ＞configure: error: readline library not found パッケージ版のreadlineを利用して、Postgresqlをコンパイルするのなら、 開発用ヘッダファイルなどを含む、readline-develパッケージもインストールしてください。 (＃４で回答しているのですが。。。） yumコマンドを使えば、ネットからダウンロードしてくれます。 # yum install readline-devel ちなみに、PostgreSQL8.3の正式リリースはまだ先ですので、何か不具合があっても 自己解決してください。
オンラインマニュアルのページは参照されましたか？ 「8章データ型」を参照してみてください
基本的に可能です。 遠方にあるサーバのポートを開放する必要があります。 あと、pg_hba.confの設定も必要になると思います。 postgresql.confの設定も必要ですね。 PostgreSQL ODBC Driverも必要かと。 （蛇足：ODBC接続よりも直接接続のほうがいいのでつみきWebさんの Common SQL Environmentを使用し、ODBC接続しないでやったほうが簡単だと思います） 勉強になると思いますので、あえて詳しく書いておりません。 試行錯誤してみてくださいね＾＾
よく質問を読みましたら、「PHPで」ということですね。大変失礼致しました。 (1)pg_meta_data関数を使うか、PostgreSQLのシステムカタログを直接 参照するかでクエリを返し、PHPでSQL文の形に整形する。 (2)pg_dumpのバッチファイルを作っておいて、 　system()とかで実行し、できたファイルをPHPで読み込む。 くらいしか思いつきません。
例えば、誕生日が入っているbirthday列から求めた現時点での年齢が、43～44才を検索するなら、以下のようなSQLが考えられます。 select * from t1 where extract(year from age(current_timestamp,birthday)) between 43 and 44
データ件数がどのくらいあるのかは分かりませんが、ユニークなキーもなく、likeの任意一致をorでつなぐという方法は、性能を出せませんよ？ select * from t1 where 入荷日 in( select max(入荷日) from t1 where 発売日 between '2007-05-01' and '2007-05-05' and (商品名 like '%○○%' or 商品名 like '%××%' or 商品名 like '%△△%') ) and 発売日 between '2007-05-01' and '2007-05-05' and (商品名 like '%○○%' or 商品名 like '%××%' or 商品名 like '%△△%')
確かにVACUUMをFULLオプションをつけて実行した場合に，その後VACUUMを行う必要はありません。 FULLオプションは，テーブルに対する排他ロックをかけてまで，不必要な行を削除するという動作をします。 逆に言うと，デッドロックが発生するぐらいのSQL文と平行でVACUUM FULLが走ってしまうと，そのSQL文は確実にデッドロックしてしまいます。 ディスクをかなり圧迫しているわけではない場合には，毎日行うVACUUMは「VACUUM」で，たまに「VACUUM FULL」でよいのでは？ないでしょうか。
WHERE句の書き方が違うと思います。 複数の条件であれば = ではなく、IN を使います。 　　WHERE p_id IN (条件1, 条件2, …)
>エラーがでてうまくいきません どういうエラーなのか、具体的にメッセージの内容を書きましょう。 havingで集合関数（集計関数）以外を指定する場合は、その列がgroup byで指定されていなければなりません。 havingでなく、whereで指定することを考えてみてください。 SELECT code,COUNT(code) AS cnt FROM test WHERE date(date) >= '30前の日付' GROUP BY code といった感じになりましが、当初のやりたかったことと合致していますか？
PostgreSQLよりも、PHPの記述に問題があるような気がします。 たとえば、 $total_Time = pg_query($con, $sql); $total_Time = pg_fetch_result($total_Time, 0, 'total'); の部分は、本来別ものの値を扱うのに、$total_Time という名前の変数を使いまわしていますが、 $res = pg_query($con, $sql); $total_Time = pg_fetch_result($res, 0, 'total'); というように分けて書いたほうが混乱がありません。 本題ですが、echo $sql; はどうなっておりますでしょうか。 もし、$total_Timeで差し込んだ部分が、空になっているなら、 ""内に直接変数を置いているため正常に認識されないのかもしれません。 $sqlは、あくまでも文字列ですので、 ここは、"もじれつ".$hensu のように　. で文字列連結をするほうが安全です。 「総労働時間」列のデータ型が数値なら $sql = "UPDATE 労働時間テーブル SET 総労働時間 = ".$total_Time." WHERE id = 'ログインしている人のID';"; 文字列なら $sql = "UPDATE 労働時間テーブル SET 総労働時間 = '".$total_Time."' WHERE id = 'ログインしている人のID';"; かと思います。
>1015 >1045 >と値がある場合、本来であれば[11.00]で表示されるはずが 21.00では？（＾＾； SELECT SUM(ROUND(労働時間/100, 0)) + ROUND(SUM(MOD(労働時間,100)) / 60, 2) AS total FROM テーブル WHERE id = 対象者のID; こんな感じでどうでしょう？ ＞SUM(ROUND(労働時間/100, 0)) 時間の部分は、労働時間を100で割って、少数切り捨てた部分。それから合計。 （SUMの位置に注意、順番が違うと計算が狂います。） ＞ROUND(SUM(MOD(労働時間,100)) / 60, 2) 分の部分は、100で割った余りの部分。合計してから、60で割って時間へ直す。
ANo.2の回答は間違ってました無視してください。 bbbの部署名と商品名がnull表示されているのを見落としていました。 select um.名前,case when hi is not null then b.部署名 else null end,s.商品名,hi from (select m.名前,m.部門,u.商品id,max(u.日付) as hi 　　　　from (売上 as u) right outer join (名簿 as m) on (u.名前 = s.名前 and s.商品id = '1'） 　　　　where m.部門 = '1' 　　　　group by m.名前,m.部門,u.商品id) as um 　　left outer join 商品表 as s on (um.商品id = s.商品id) 　　,部門表 as b where um.部門 = b.部門 ですかねぇ。 テスト環境が無いので実行していませんが、 サブクエリー（またはView)を使用することと、条件分岐の組込み関数を使えばよいかと。
#1回答者です。 提示された表定義、データを使って実機確認したところ、私の環境では問題なく検索できました。 PostgreSQL 8.0.0（Windows版）で、pgAdminIIIから操作しています。 ＝＝＝表定義＝＝＝ create table t_nyusatsu (fno bigint not null, id character varying(18) not null); ＝＝＝格納データ＝＝＝ insert into t_nyusatsu values(43,'000000000000216871'); insert into t_nyusatsu values(44,'000000000000216871'); insert into t_nyusatsu values(43,'000000000000999999'); ＝＝＝確認した検索SQL＝＝＝ select * from t_nyusatsu where (fno, id) in ((43, '000000000000216871')); select * from t_nyusatsu where (fno, id) in ((43, '000000000000216871'),(44, '000000000000216871'));
環境変数 CLASSPATH を指定していても、実行時やコンパイル時に -classpath を指定してしまえば、そっちの設定が優先されるようになっていたように思います。 従って、環境変数を有効にしつつ -classpath を使用したいのであれば、 -classpath dir:$CLASSPATH のようにしてあげる必要があるのではないかと思います。 > どちらにすればよいのか、そして、どのようにbash_profile修正するの > かを教えてください。 好みの問題かもしれませんが、書くのであれば .bash_profile よりも .bashrc の方が良いかと。 > 参考書やネットを調べていますと、『rootにはインストールするな』と > いうのもあれば、『rootでインストールしろ』などとあり、情報が交錯 > しています。 PostgreSQL は root でなくてもインストールできるように設計されています。root でなくても使えるものを root でインストールする必要は全くありません。
> 拡張子が.gzとなっているのですがこのままアップロードしていいの > でしょうか？ tar & gzip で複数ファイルがアーカイブされ圧縮されています。アップロードの前に伸張処理が必要でしょう。 gzファイルの伸張に関しては、参考URLを見てください。 サーバ上でtar、gunzip, gzip コマンドが使えるなら、サーバで伸張処理もありです。
(1)maxキー取得及び+1して格納を、トランザクションの一番最後で行うなど、DBの排他区間を最短になるようにする。 (2)重複エラー時のリトライ処理を作りこむ などは、必須になります。
マニュアルみればいいのでは？ PostgreSQL 8.2.3の数値データ型のマニュアル http://www.postgresql.jp/document/pg823doc/html/datatype-numeric.html 同じく全データ型一覧 http://www.postgresql.jp/document/pg823doc/html/datatype.html 整数ならbigint（別名int8）。 小数点数ならdouble precision（別名float8）。
initdb を実行する時に -E EUC_JP を指定すればいいでしょう。 あるいは、インストール時に .configure のときに指定してもいいです。
>この処理がその他のことで長い時間が掛かりますので >排他をかけたくないと思っています 最大値を拾って、+1して、insertするのですよね？ それを排他制御なしで行えば、データとインデクス間などでDBに不整合が起こったりしますよ？ 一時的に占有してしまうなら、まだ分かりますが。 ロールバック等が発生して、途中の番号に抜けが生じることは許されないのでしょうか？もし途中に欠番が生じてもいいので、順次、ユニークな番号でいいなら、PostgreSQLには、連番型（serialまたはsequence）があります。 http://www.postgresql.jp/document/pg823doc/html/datatype-numeric.html#DATATYPE-SERIAL
RDBMSはPostgreSQLでいいのですか？ select * from t1 where 単価 between 1000 and 1200 and char_length(商品名)>=5
データベースの再構築をする必要は無いと思います。 環境変数の PGCLIENTENCODING=SJIS を定義するだけでいいと思います。これにより、EUC_JPで保存されたデータを取り出すときに自動的にシフトJISに変換されます。
マニュアルに「前方一致（'abc%'等）でないと、インデクスは使用しない」と明記されています。
PostgreSQLは、オープンソースのデータベースです。 システム開発、運用に携わらないのであれば、知識として不要です。 また、適切なファイヤーウォール設定が成されていれば、そのようなアクセスは、気にする必要もありません。 問題は、ルータからPCに5432ポートでアクセスがある事ですね。 外部から5432ポートにアクセスされても、ルータでブロックしておけば、 何の問題もないのですが、それをPCに通しているとなると、 ファイヤーウォールの役目を果たせていない格好になります。 いわゆるセキュリティホールです。 よって、ファイヤーウォールの設定に不備がある可能性が高いです。 ファイヤーウォールの設定の中で変更した個所（特にDMZ設定など）を見直して下さい。 攻撃者は、サーバがあるとかないとか関係なく無作為に攻撃してきます。 不要なポートは全て閉じておくのが基本です。
#1回答者です。 Windows版のPostgreSQLに関して、インストール手順等がまとめられた記事がありましたので紹介しておきます。
select case when 時間テーブル.makeday + '1 weeks' < now() then 0 else 1 end; でいいと思います。 答えが論理値 t か f でいいならもっと簡単です。 select 時間テーブル.makeday + '1 weeks' >= now()；
ご期待の回答ではありません。 バキュームかけて止まった経験は無いのですが、 経験上、vacuumdb　実行してもゴミがどこまで無くなっているのか疑問です。 処理速度の問題でvacuumdbを掛けるのであれば、 pg_dump　でバックアップとり、dropdb → createdb →　pgsql -e　で作り直すと早くなりますよ。
「マスコットのロゴについて」のページがありました。下記をご覧下さい。 詳細は、右上端にある連絡フォームから問い合わせるのが良いでしょう。
currvalで取得出来ます。
http://japan.internet.com/linuxtoday/20050201/5.html http://itpro.nikkeibp.co.jp/members/SI/oss/20031017/1/
dateフォルダにあるpostgresql.confのclient_encodingの値を変更しておけばいいのではないでしょうか。
一般的な形式なら、 SELECT ～ FROM <テーブル名> WHERE ～ORDER BY <フィールド名> になります。なので、 SELECT * FROM 定価>=100000 ORDER BY 定価
存在しないものは、作り出すか、結合するしかありません。 問い合わせ中で作り出すのは、無駄なコストが掛かるだけなので、カレンダー表を作り、結合するのがシンプルだと考えます。
適切な インデックスを設定するためには、 インデックスに対するある程度の知識が必要になります。 http://www.postgresql.jp/document/pg820doc/html/indexes.html （バージョンによって多少内容が違うかもしれません） サイト内の下記３つが、お薦めです。 11.2. インデックスの種類 11.5. 一意インデックス 11.9. インデックス使用状況の検証 実際にどのようなデータが入るのかが重要なポイントであると思いますので、 「ここに付けましょう」といった回答はしたくないのですが・・・ ・データが件数があまり多くない。 ・NAME,COMMENT,ADDRESS 列あたりには文字列が入る（varchar型？) のであれば、INDEX はプライマリーキー(ID)のみとして、 他のINDEXを考えるよりも、定期的に VACUUM ANALYZE することをお薦めします。 いかがでしょう・・・ 質問者様のレベルがわからず、陳腐な回答でありましたら申し訳ない。
Windows版は使ったことがないので、推測ですが >$con = pg_connect("user='postgres' dbname='test_db' password='grjtf'"); ではなく $con = pg_connect("user=postgres dbname=test_db password=grjtf"); では？
>ODBCが必要ということでWindowsXP側には入れたのですが、 ↑このドライバーはpostgreSQL用ODBCドライバーでしょうか？（念のため） postgreSQL用ODBCドライバーはpostgreSQL側にインストールする必要はありません。このドライバーをAccess側（windowsXP）にインストールして使うことになる。もちろん、AccessからpostgreSQLにつながるには設定が必要です。 Accessのメニューー＞ファイルー＞テーブルのリンクをクッリクすると、ダイアログが表示される。そこでデーターベース種類をODBCに指定する。次にODBC設定（選択画面）が表示されるので、postgreSQLのホスト情報やデーターベース名前、ユーザ名、パスワードをいれる。
テーブル設計を経験すると分かると思いますが、プライマリキー以外で条件検索、結合、ソートやグループ化という検索が必要になることが少なくありません。 そういう場合に、CREATE INDEXでプライマリキー以外のインデクスを定義します。 また、プライマリキー以外で重複を禁止したいカラムがある場合も、CREATE INDEXでUNIQUEを指定して制約を設けます。 インデクスを無闇に定義すると、更新等でオーバヘッドになります。また、母体データ件数、データ値の種類（個数）なども、インデクスを付けるべきか否かを判断する上で考慮する必要があります。
すいません、補足です。 UPDATE hoge1 SET name = (select b.name from hoge2 b , hoge1 a where b.id = a.id ) ; の何が悪いか、という点ですが、 副問い合わせの中で「hoge1 (AS) a 」としてるのに、最初にupdate hoge1 としてるのが アウトとなるようです。ただこの場合、AS句のスコープも関係してきますので、 こういう場合は素直にテーブル名を書いたほうがよいです。 http://osb.sra.co.jp/PostgreSQL/Manual/PostgreSQL-7.4-ja/queries-table-expressions.html#QUERIES-FROM 辺りがヒントです。
TO_CHARで変換するかそのまま2006-12-14 09:00:28.853324+09で取り出してからPHPの正規表現で・・・というのでいいでしょう。 まあTO_CHARの方が手っ取り早いでしょうね。 SELECT TO_CHAR(hugehuge,'MM月DD日HH24時MI分') from hogehoge
システムカタログのpg_class表を検索することで、知ることができるようです。 (1)pg_class表を検索して、容量を知る例 http://www.postgresql.jp/document/pg820doc/html/disk-usage.html (2)pg_class表の列構成 http://www.postgresql.jp/document/pg820doc/html/catalog-pg-class.html
せめてcronの中身くらいは見せて欲しかった・・・・。 まぁ、状況から推測すると、次のような感じではないか。 １．cronはroot権限（少なくともpostgres権限じゃない）で動く。 ２．cronから実行されたシェルではpg_dumpへのパスが通っていない。 ３．なので　null > backupfile　となり、ファイル「backupfile」は作成されるが、DOSで言う「コマンドまたはファイル名が違います」状態で、何も追記されない。 もし、cronの奴が pg_dump hogehoge > backupfile になっていたら、 /usr/bin/pg_dump hogehoge > backupfile と、pg_dumpをフルパスで指定してあげると良いだろう。 ※あくまで推測です。はずしていたらごめん。 解決しなければどうせなので補足などで再び質問してください。その際、cronの中身、PostgreSQLはRPMかソースから入れたか、を挙げてくれればありがたい。
「値 AS 名前」は、クライアントソフトに名前を返したり、表示したり、SQLで操作するために指定しています。 値にNULL定数を指定することも、値や演算に名前を付けることも、SQLの基本機能です。 この場合は、UNIONしている二つの表のうち、最初の表には列「RES_NO」に該当する値がないので、NULLを入れているのでしょう。 UNIONする表は、列数やデータ型が一致している必要がありますからね。
いくつかの準備作業が必要です。 (1)libpq.dllの取得＆コピー (a)取得元URL http://www.interwiz.koganei.tokyo.jp/index.html 　のPostgreSQL関連情報 (b)コピー先 CSE展開先フォルダ (2)PostgreSQL側の設定変更 　CSEが対応しているlibpq.dllではmd5認証ができません。 　PostgreSQLのインストールフォルダ下の「\data\pg_hba.conf」を開いて、下記の「md5」の部分を「trust」に変更してサービスを再起動してください。 　# IPv4 local connections: 　host all all 127.0.0.1/32 md5 　↓ 　host all all 127.0.0.1/32 trust (3)CSE起動時のサーバ名、データベース名 　サーバ名＝localhost 　DB名＝dbspace1　　←新たなDBを作成していない場合
通常のメンテナンスでVACUUM FULLをつかうことは無いと思います。通常はVACUUM ANALYZE で、VACUUM FULL をしなければならないような事態にならないように、一定間隔で行います。VACUUM FULL が必要になるというのは、ある意味緊急事態で、ディスクのスペースが足りなくなってこのままではダウンしてしまうような時に行います。こういうことは普通の状態ではないので、どれくらいの期間でVACUUM FULLをするかという質問はナンセンスだと思います。どのくらいの期間でVACUUM ANALYZE をやっておけば、VACUUM FULLをしなくてすむかという質問なら意味がありますけど。
koumoku3にナル値が入っている場合は、(1)+(2)=(3)とはなりません。 ナル値が入っている行数をxとすると、(1)+(2)+x=(3)になります。
$img_dataの内容がおかしいのでしょうか？ $img_dataの内容が正しいなら、PHPの問題なので、PHPのカテゴリで質問した方が回答あると思います。 ＞header('Content-Disposition: inline; filename=' . $img_data); PHPは分らないので、参考意見ですが、ファイル名に生データ入れてる様に見えますが、ここは問題ないですか？ ＞print"${img_data}"; エスケープしたデータを、そのまま出力しているように見えます。アンエスケープして、バイナリ出力するべきでは？ 中途半端な回答でごめんなさい。
ROUND内の条件文を括弧に入れてください。 SELECT ROUND(( SELECT 0.2*(SLECT number FROM sample WHERE id =1))); これで構文上は通ると思います。
今ちょっと時間がなくて申し訳ないのですが、 ポイントインタイムリカバリ（PITR）で対応可能と思われます。 参考ＵＲＬを掲載しておきますので、よかったらどうぞ。 PostgreSQLのバージョンによっては対応していませんのでご注意ください。
「情報スキーマ」を活用してください。 「columns」表で各表の列情報が分かるので、目的のデータベースやスキーマ毎に行数を求めれば、それが列数になります。 【検索SQL例】 select table_catalog,table_schema,table_name,count(*) from information_schema.columns where table_schema='public' group by table_catalog,table_schema,table_name
案1)エディタ等を使って、二重引用符を除去してからインポートさせる。 案2)インポートするのに十分なレコード長をもったインポート専用テーブルを作成して、そこに一旦インポートさせてから、適当に加工して目的のテーブルにinsertする。 案3) copy with csvが使えるバージョンにあげる。 ――とか。
FC5のデフォルトは分からんが・・・・。 > V8.1からpostgresql.confファイルの編集はしなくてよい事になったのでしょうか？ 　ssh接続って・・・・別端末からsshでFC5に接続後、psqlを叩いたって事？　だよね？ 　この場合はUNIXドメインソケットが使われています。tcpipソケットは使われていないので閉じられているのかも知れない。調べるには、別端末からtelnetなどで接続してみると良い。デフォルトポートだと、 $ telnet FC5のマシンのIPアドレス 5432 > 今回はFedoraCoreからyum installで導入したのですが、これは最新のモジュールをダウンロードし、インストールしているという認識でよいのでしょうか？ 　そうね。yumを使っているのなら最新版が入ったんじゃないかな。
incho0922さんのSQLに補足しいますと、 DELETE FROM A_TABLE AS A_TABLE_1 WHERE ID = ( SELECT ID FROM A_TABLE AS A_TABLE_2 ORDER BY mDate LIMIT 30 ) だと、副問い合わせの文では複数行返してしまいますので"="だとエラーになってしまいます。 ですので、 DELETE FROM A_TABLE AS A_TABLE_1 WHERE ID IN ( SELECT ID FROM A_TABLE AS A_TABLE_2 ORDER BY mDate LIMIT 30 ) ならご希望の結果が得られると思います。
＞考えられる原因を教えてください。 ＞マカフィインターネットセキュリティ 現状与えられた情報ではこれ以外に無いと思います。
数十万件だと毎回実行するにはなかなか厳しい感じですね。 状況から察するに, name にインデックスを張ってもあまり有効に働かないみたいですね。 アプリケーションを考慮して, name と versionの最大値 の組み合わせの抽出が頻繁に行われるようでしたら, name と versionの最大値の二つの列を持つ参照用のテーブルを作成して, そこから参照するようにしてはどうでしょうか。 software_table に INSERT/UPDATE/DELETE が発生したら, 上記のテーブルをトリガを利用して書き換えればよいと思います。 # もちろんプログラム側で対応しても構いません name と versionの最大値の組み合わせの参照がそれほど発生せず, アプリケーション的にも多少時間がかかるのが許されるならば, 副問い合わせやソートのやり方でもよいと思いますよ。
PostgreSQL での配列は使ったことが無いのでちょっと調べてみました。 配列要素の追加は下記のように出来るようです。 UPDATE test SET data = array_append(data, 10); UPDATE test SET data = data || ARRAY[10] しかし, マニュアルに配列要素の削除についての項目が見当たりませんでした・・・。 結構検索してみたのですがどうにも見つけられず, 配列関数としてもサポートされていないようですし, もしかしたら無いのかも？ ^^; # data - ARRAY[6] とかやってもだめでした。
CGI側を変更すればよいのではないでしょうか。 Jcode.pm等のモジュールを使用するのがよいかと思います。
最終的に PHP から PostgreSQL に接続したい, ということでしょうか。 yum で PHP をインストールしたとのことですが, 取りあえず下記2点を確認してみて下さい。 ・phpinfo() を実行して pgsql の項目が表示されるかどうか ・（表示されていなければ）PHP の PostgreSQLモジュールはインストールされているか % rpm -qa pgsql で, php-pgsql がインストール済みか確認してみて下さい。 # PHP の PostgreSQLモジュールは, php-pgsql という名前だと思います
検索(SELECT文発行)時に DB1 と DB2 のどちらかに参照を分散させたいということですよね？ 設定ファイル(pgpool.conf)の load_balance_mode が true になっているかどうかを確認してみて下さい。 (デフォルトでは false です) replication_mode = true load_balance_mode = true であれば, DB2 も参照して負荷分散ができるようになります。
ちなみに、CSEでhttp://www.hi-ho.ne.jp/tsumiki/cse_10.htmlを試してみては如何でしょうか。 JDBCで接続するDbVisualizer（http://www.dbvis.com/products/dbvis/）とかは如何でしょうか。
担当者テーブルのUserCode=222のEndTimeは、9月2日のデータの誤りですね？ update文にfrom句を使う指定方法があり、これを使うと簡単です。 update 既存テーブル set UserCode=担当者テーブル.UserCode from 担当者テーブル where InDate between StartTime and EndTime
起動時の最初のプロセスIDでしょう。 二重起動防止のためのファイルではないでしょうか。 postmaster.pidのファイルの中身のプロセスIDが起動していませんか？
Oracle　Generic　Connectivityという製品を使えば Oracleから、PostgreSQLのODBCドライバーを介してPostgreSQLに対して、SELECT,INSERT,UPDATE,DELETEなどのSQL文を発行することは可能です。
ズバリ必要です。 VACUUMを実行するする理由は大きく２つです。 ・DELETE文やUPDATE文発行により断片化した領域の開放により 　アクセス速度の低下を抑制する。 ・不要となったトランザクションIDの開放により、トランザクション 　IDのオーバーフローの抑制する。 今回、１つ目の項目を見て、不要と判断していると思いますが、 実は２つ目も非常に重要です。放置して、オーバーフローが発生すると データは存在するけど、参照できないと言う事実上、致命的な破壊 現象を招く結果となります。 よって頻繁でないにしても、定期的にチェックは必要です。 私は、このIDを一日一回チェックするようにして、15億を超えていたら VACUUM実行するようにスケジューリングしています。 幸い、Ver.7.4以上の場合、VACUUM中のDBアクセスも可能となりました ので負荷は大きいですが、システムが停止する事はないと思います。
ご希望に合うかどうか分かりませんが４つほど 思いつきました。 １．Slony-I ２．SRAが提供しているCLUSTERPRO for Windows 　　（共有ディスク方式） ３．NECのftサーバ ４．単純な二重化機能を自分で作る。 ３はハードウェアで実現する２重化なのでご希望とは 合わないかもしれませんが。 自分もLinuxですが、２重化システムを構築していて、 予算の関係で４となりました。
　なんだか、設問が無理っぽい気がするのは、PED02744同感です。 　無理を承知で解くならば・・・ 　おそらく、設問１は消去法で解くほかないんでしょうね。 　まず、（１）はa4の値の時矛盾するので×。 　（２）は、矛盾なし。 　（３）は、b1・c1の時矛盾します。 　（４）は、矛盾なし。 　（５）は、d1の時とd2の時に矛盾します。 　というわけで、正解は２と４なのかな・・・（意味が考えられないから与えられたデータで矛盾があるかどうかを追及するよりしょうがないでしょう。） 　というわけで、ＡＢ→ＣＤと、Ｂ→Ｄの従属関係があることがわかったことにします。というか、この設問（１）で提起された以外の従属関係は「ない」と解釈しないとこの問題解けないような気がします。 　第一正規形は間違いありません。 　第二正規形に関しては、候補キーＡＢの真部分集合であるＢに対して、Ｄが従属しているので、候補キーＡＢに対して、非候補キーのＤは完全従属となっていません。よって、第二正規形ではないことになります。 　第二正規形でないとすれば、当然第三正規形でもありません。 　ところで、kireinooneさんのかかれるように、R1(A,B,C) R2(B,D)とすれば、第二正規形は満たします。それと同時に、推移則を適用できるパターンも存在しなくなるので、（推移則を適用するには、最低でも３カラム必要ですが、R1の候補キーは(A,B)となるので、事実上２カラムとなる）第三正規形も同時に満たす。ということになってしまいます。 　でも、これって、第２正規形を満たした時点で第３正規形が自動的に成立するというのもなんだか、すごく気味が悪いです。問題としてほんとに成り立ってるのかしら？という不安を感じます。 　
pg_dump のオプションで D　をつけて、カラム名指定インサート文でダンプするのが確実ですので、これでいかがかと。 ただし、この方法は時間はかかります。（また、バージョンが違うのでiオプションをつけたほうがよいかもです。） 例： ダンプするファイルが　dumpfile.sql、 データベース名が、mydbname だった場合、 # su - postgres $ pg_dump -F p -D -v -i -f dumpfile.sql mydbname とか。
平均点は、静的に持つのですか？ こんな感じで、目的の結果は得られると思います。 select t."class",t."name",t."average" from (select x."class",x."name",x."average",count(*) as num from oshiete_goo as x,oshiete_goo as y where x."class"=y."class" and x."average"<=y."average" group by x."class",x."average",x."name" ) as t where t.num<=3 order by t."class",t.num ;
LIKE を ILIKE にすれば大小同一視されます。
＞このエラー表示だけは何とかして表示されないようにしたいと思います。 見る限り、特にエラーはないようですが、何か困っているのですか？
select A || '-' || B ans , C from テーブル でしょうか。
>特に-の演算子が調べられませんでした 普通に、負数や減算ですよ？ >Update テーブル名 set No = 5 - No where No in ('2', '3'); 上記例では、文字なのか数値なのか、必ずしも正しい使い方ではありませんが。。。 文字のように記述（'で囲む）しても演算できると仮定して説明します。 Noの値が2か3なら検索して、5-Noするのですから、 No=2なら3、 No=3なら2 という結果が得られます。 つまりこの質問で示されていた、2←→3の入れ替えに特化した方法です。 >もう少し効率の良い書き方、関数等ご存知の方 具体的なことを聞きたいなら、具体的な例を示して質問しましょう。
なんかデータ型についての認識がおかしいような。 >date default current_timestamp型 と書かれていますが、 date型のデフォルト値current_timestampというカラムですよね。 参考URLは8．1．4のマニュアルですが、見てみてください。 date型は、年月日用の型です。 仮に秒単位まで表示されても、0で桁埋めしてあるか、日よりも細かい精度は一切保証されません。 つまり、日よりも小さい時間以下の単位の値がまったくでたらめな数値が返ってきても文句は言えないということです。 秒単位まで精度が欲しいのであれば、素直にtimestamp型を使うことをお勧めします。
>rdate timestamp default 'now' この文の意味としては、rdateというtimustamp型（日時を表す）の列に、insert時に値を設定しなかった場合、システムから現在日時を受け取って格納するという意味です。 >MySQLの場合、どのような属性が適切なのかをお教えいただければ データ型のtimestampは、PostgreSQL、MySQLの双方に存在し、日時を表す点では等価と考えて問題ないでしょう。 →実際にはPostgreSQLの方が、timestamp型でもいくつかの表現形式を持っているという違いがあります。 default 'now'というのは、PostgreSQLの独特の記述で、一般的な表記方法としてdefault current_timestampという表記がPostgreSQLでも等価の意味で行えます。この表記方法は、MySQLでも同じです。 →PostgreSQL 8.0.0では、default 'now'と記述すると、最初のinsert時に受け取った現在日時がその後も繰り返し受け渡しされ、これはバグだと思われます。current_timestamp指定では、insert毎に最新の日時が仕様通り返されます。 PostgreSQLでも一般的なSQLの書き方にすれば、今回のケースでは、MySQLでもそのままの文で表定義を行えます。 CREATE TABLE session ( sid varchar(32) primary key, uid varchar(16) not null, password varchar(16), rawdata varchar(512), rdate timestamp default current_timestamp );
ninoといいます。 vacuumについて vacuumdb というシェルから実行できるコマンドがありますのでこちらを使ったほうが良いかと http://www.postgresql.jp/document/pg814doc/html/reference-client.html 直接SQL文を　psql に渡すには、 echo " SELECT * FROM test " | psql testdb 実行結果 -bash$ echo "SELECT * FROM test " | psql testdb id | name ----+---------- 1 | hoge 2 | hogehoge (2 rows) -bash$ psql の　-f オプションを使えば　SQLを記述したファイルを実行できます。 http://www.postgresql.jp/document/pg814doc/html/app-psql.html 上記について　同じようにするには -bash$ echo " SELECT * FROM test; " > test.sql -bash$ cat test.sql select * from test; -bash$ psql -f test.sql testdb id | name ----+---------- 1 | hoge 2 | hogehoge (2 rows) または -bash$ psql testdb < test.sql id | name ----+---------- 1 | hoge 2 | hogehoge (2 rows) >同じテーブルに対し\copy...fromを同時に実行した場合、問題はないのでしょうか？ これは、自分で試してみましょう。 まずは自分で試して、確認することが一番です。
ninoといいます あまりお役には立てませんが、 postgresql　のメーリングリストで質問された方が、良い回答が得られるのではないかと思います。 gostgresql　や　pgAdminIII　の開発に参加しておられる方もおられます。 技術的な解決方法を提示していただけるかも。 私なりの解決方法としては、 １　pgAdminIII　が使用するpg_dumpを現状のPostgesqlのバージョンのものに入れ替える （　pgAdminIII　をwindows環境で使用されている場合は、この対応はできません。　win対応版は　8.0以上です） ２　pg_dump のソースを改造して、check_function_bodies = 'false'　を　コメント文にする。 これもwin環境では、コンパイルの環境を構築する必要があると思うので、結構難易度が高い気がします。 Linux等の環境でソースから導入されいる場合は、その場所さえ特定できれば、win環境に比べれば比較的容易かも知れません。 残念ながら、私はこの技量を持ち合わせておりません。 やはり postgresql.jp　のメーリングリストに参加して投稿するのが近道のような気がします。 あとはどうでもいいことですが 私もpgAdminIIIを愛用しておりますが、バックアップには使用しておりません。 直接sshでサーバに接続して、pg_dump　コマンドを操作しております。このほうが使いやすいですね（私にとってはですが）
＞# rpm -e postgresql ＞と入れてみたのですが、関連付けられているためか ＞削除できません。 関連付けされているパッケージもいっしょに削除すればいいでしょう。
#2回答者です。 「FETCH ALL IN カーソル名」の使い方がよく分からなかったので、代替案としてPL/pgSQLを使用する方法を考えてみました。 (1)関数の定義 recという行データ受け取り変数を使い、受け取った特定列の参照は、「変数名.列名」で行えます。 create function functest1() returns int as ' declare car cursor for select * from t1; rec record; begin open car; loop fetch car into rec; if not found then exit; end if; update t2 set c2=0 where c3=(select c3 from t3 where c1=rec.c1); end loop; close car; return 0; end; ' language 'plpgsql' ; (2)関数の実行 select functest1(); (3)関数を削除する場合 drop function functest1();
pgAdminIIIに付属のpg_dump と、postgresqlのバージョンの不整合により発生するのでしょう。 pgAdminIIIを使いたいのであれば、Postgresqlのバージョンをあげるしかないのでは？ (でも　こんな発想は本末転倒ですが...） COMPRESS　にしなければ、バックアップファイルの編集で対応可能でしょうが、そんなことまでして、使用する意味がないような気がします。
試しにSQLを作ってみました。 create table STAFF (ID smallint, 名前 varchar(10)); create table LABOR (ID smallint, 社員ID smallint, 年月日 date, 時間数 smallint, プロジェクトID smallint); insert into STAFF values(101,'川口'); insert into STAFF values(111,'宮本'); insert into STAFF values(123,'中田英'); insert into LABOR(社員ID,年月日,時間数) values(101,'2006-01-05',8); insert into LABOR(社員ID,年月日,時間数) values(101,'2006-02-01',10); insert into LABOR(社員ID,年月日,時間数) values(101,'2006-02-15',5); insert into LABOR(社員ID,年月日,時間数) values(101,'2006-03-01',8); insert into LABOR(社員ID,年月日,時間数) values(101,'2006-03-03',10); insert into LABOR(社員ID,年月日,時間数) values(101,'2006-03-10',12); insert into LABOR(社員ID,年月日,時間数) values(111,'2006-01-10',5); insert into LABOR(社員ID,年月日,時間数) values(111,'2006-01-15',10); insert into LABOR(社員ID,年月日,時間数) values(111,'2006-01-31',5); insert into LABOR(社員ID,年月日,時間数) values(111,'2006-02-10',8); insert into LABOR(社員ID,年月日,時間数) values(111,'2006-02-20',8); insert into LABOR(社員ID,年月日,時間数) values(111,'2006-03-20',10); insert into LABOR(社員ID,年月日,時間数) values(123,'2006-01-20',8); insert into LABOR(社員ID,年月日,時間数) values(123,'2006-01-21',8); insert into LABOR(社員ID,年月日,時間数) values(123,'2006-01-22',8); insert into LABOR(社員ID,年月日,時間数) values(123,'2006-03-03',5); insert into LABOR(社員ID,年月日,時間数) values(123,'2006-03-04',5); insert into LABOR(社員ID,年月日,時間数) values(123,'2006-03-05',5); select x.名前, coalesce(sum(case when date_part('month',年月日)=1 then 時間数 end),0) as １月, coalesce(sum(case when date_part('month',年月日)=2 then 時間数 end),0) as ２月, coalesce(sum(case when date_part('month',年月日)=3 then 時間数 end),0) as ３月, coalesce(sum(case when date_part('month',年月日) between 1 and 3 then 時間数 end),0) as 合計 from STAFF as x,LABOR as y where x.ID=y.社員ID group by x.名前 order by x.名前 ;
ディストリビューション付属の Postgresql は使ったことないので 正確なことはわかりません。 １　postgresが起動していたら、停止する ２　PGDATA で指定されている dirを削除する。 ３　PGDATA を設定しているファイルを編集して　新しいpathを設定する。 　　(　postgresqlの起動ファイルと postgresユーザの .bssh_profile等　） ４　initdb を行う。 ５　postgresを起動する でいけるとおもいますが 以下は　ご存知であれば、読み飛ばしてください。 initdbを行うときは　encoding と　locale 設定に注意しましょう。 （日本語を扱う場合は　--no-locale 設定は必須です）
ActivePerlをお使いということですので、ppmでインストールできるとよいのでしょうけれど、 デフォルトのppmデータベースには該当するモジュールは登録されていないようです。 検索してみたところ、ちょっと前のバージョンですがActivePerlで動かした実績が見つかりました(参考URL参照)。 もしご自分でモジュールをコンパイルできる環境にあるのなら、 CPANからソースアーカイブを持ってきて、自分でコンパイル&インストール するのもよいかもしれません。対応していれば、 perl Makefile.pl make make install 程度のステップで済みます。
phpPgAdmin　は使ったことがないのでわかりませんが SQL文で、serial型のコラムを追加する方法です。 以下のテーブルがあった場合 create table public.test1 (name text); serial型のコラム　id　を追加するには　以下のSQL文を順に実行します。 1 シーケンスを作る CREATE SEQUENCE public.test1_id_seq; 2 int4型のid　コラムを追加する ALTER TABLE public.test1 ADD COLUMN id int4; 3 id に not NULL制約を追加する ALTER TABLE public.test1 ALTER COLUMN id SET NOT NULL; 4 idコラムのdefault値を設定する。 ALTER TABLE public.test1 ALTER COLUMN id SET DEFAULT nextval('public.test1_id_seq'::text); 以上を、参考にすれば、設定可能かと思います。 基本的には serial型があるのではなく、 serial 型にすると このようなSQL文が実行される　と私は理解しておりますが ちなみに、psql で確認すると以下のように Type は　integer(int4) なります。 create table public.test1( id serial ); \d test1 Column | Type | Modifiers --------+---------+------------------------------------------------------- id | integer | not null default nextval('public.test1_id_seq1'::text)
PostgreSQLには、「SERIAL」というデータ型があり、これがMySQLのauto_incrementに相当します。 いくつかの商用RDBMSと同じように、CREATE SEQUENCEもサポートされています。 既存の表に列を追加する場合、SQLでなら 「ALTER TABLE 表名 ADD COLUMN 列名 SERIAL」 で行えます。
