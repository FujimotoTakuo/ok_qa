DECLARE @RESULT TABLE( NAME varchar(10) ) DECLARE NAMEs CURSOR FOR SELECT NAME FROM @CLASSROOM DECLARE @NAME varchar(10) DECLARE @iCount int DECLARE @i int OPEN NAMEs FETCH NEXT FROM NAMEs INTO @NAME WHILE (@@FETCH_STATUS = 0) BEGIN SET @i = 0 SELECT @iCount = [COUNT] FROM @CLASSROOM WHERE NAME = @NAME WHILE @i < @iCount BEGIN INSERT INTO @RESULT(NAME) VALUES(@NAME) SET @i = @i + 1 END FETCH NEXT FROM NAMEs INTO @NAME END CLOSE NAMEs DEALLOCATE NAMEs SELECT * FROM @RESULT こんなのどうでしょう。
2つの結合が出来たのなら、それを一つのテーブルと見立てて、それと3つ目のテーブルとをJOINすればいけますよ。 SQLはデータベースによって方言があるので、参考URLは参考として(考え方は同じです)Accessではどう表現するか試してみてください。 頑張ってください。
こんにちは、No1です 二箇所そのように直して貰えればいいと思います。 バックアップとってから試す癖付けて下さいね。
https://www.microsoft.com/ja-jp/download/details.aspx?id=42299 上記のページからダウンロードしようとしているのですね。 データベースエンジンと Management Studio の２つをダウンロードすれば、たいていの場合は問題ないかと思います。 データベースエンジンは、32ビットOSにインストールする用と、64ビットOSに32ビット版をインストールする用があるようですね。 前者が「Express 32BIT\SQLEXPR_x86_JPN.exe」で、後者が「Express 32BIT WoW64\SQLEXPR32_x86_JPN.exe」みたいですね。 Management Studio は、「MgmtStudio 32BIT\SQLManagementStudio_x86_JPN.exe」でいいですね。
merge 連絡テーブル using 顧客テーブル on 連絡テーブル.番号 = 顧客テーブル.番号 and 連絡テーブル.名前 = 顧客テーブル.名前 and 連絡テーブル.地域 = 顧客テーブル.地域 and 連絡テーブル.性別 = 顧客テーブル.性別 when not matched by source then delete; 動作確認してないけど、こんな感じで。 注意点としては、SQL Server 2008以降であることと、最後に ; が必須なことかな。
select 商品マスタ.* from 商品マスタ inner join (select 1 as 商品コード union all select 2 as 商品コード union all select 3 as 商品コード union all select 1 as 商品コード) as B on 商品マスタ.商品コード = B.商品コード こんな感じ？
このソースだとおそらくリンクテーブルを使っているのだと思います。リンクテーブルは読み込みの制御が出来ません。つまりAccessからNOLOCKなどを出してもSQLサーバーには届かないということです。リンクテーブルは近所のデーターを一緒に持ってきてAccessの中でクエリを掛けるので全員が同じことをすればロックは掛かります。 回避策はSet cn = CurrentProject.ConnectionをADOの接続に変更してTransactSQLで書き直すことです。 Dim CN As ADODB.Connection Set CN = New ADODB.Connection CN.Provider = "SQLOLEDB" CN.ConnectionString = "Persist Security Info=true;" & _ "Data Source=サーバー名;" & _ "Initial Catalog=XXDB;" & _ "User ID=XXXX;" & _ "Password=1234" CN.Open　’ この場合SQLの認証をドメインにしたほうが良いですけど、アプリケーションユーザーIDを作ってSQL認証でも構いません。推奨はされていませんが。
１、無理だと思います。 ビューは一つのテーブルに作成されたビューでのみ変更は可能です。 1つのテーブルの変更を他に反映させる場合はトリガーを使う方法が一般的です。両方同時の場合はストアドプロシージャを作成するべきです。
＞データ量が膨大になってしまう為、ディスク容量やインデックス等貼ったとしてもパフォーマンスが落ちないか等不安になってしまいます。 データ量が膨大になれば当然パフォーマンスは落ちます。 でも、10年間も手を加えずに動いているシステムは滅多に見ません。 Windows Server 2008 R2自体、2018年には延長サポートが終了してしまいます。 そのままあと８年動かすとは考えにくい。 システムの詳細が分からないので何とも言えませんが、とりあえず、実際に稼働させて状況見ながら改善でもよい気もします。
(1) DBのバックアップ時にログファイルも含めるというオプションがある。コミットとは関係ありません。含めない場合はベットログファイルをバックアップする必要がある。 (2).pubsは間違え昔のサンプルDB。modelでよいです。 (3) 排他制御というのは別の概念でありバックアップとは関係ありません。バックアップコマンドでは避けているだけでありその意味でログファイルは必要ということ。 <手順> 通常のシステムで10個もDBがあるというシュチュエーションが良く分かりませんが本当に10個あるならそうです。 システムDBは構成情報と統計情報を格納しているだけなので、そこまでリアルタイム性を求めません。あとから再統計コマンドを流しても問題ありませんが、まあこれでもOKです。 リアルタイム性を求めるならログファイルのほうが大事であり。さらにログファイルを順番に戻す必要があります。
更新されたら別テーブルにそれを記録するトリガーを用意するとかですかね。（まあ、そのテーブル自体も操作されたら終わりですけど）
そもそもですがSQL Server 2008 Expressはブラウジングできる設定にされているのでしょうか。Expressでは個人使用を目的としているのでブラウジングがオフだったはずです。 WINサーバーなので当然SQLサーバー専用ポートは空いていると思いますが、もし閉じている場合は有効にする必要があります。 Win認証についてはまずドメインの管理を勉強し、そこからなのでハードルは一気に高くなりますが、出来ればWIN認証のほうが良いです。SQL認証というのは普通は使いません。 ユーザー登録だけでなく当然PC登録、DNSの登録等複雑な管理になってきます。
1433 ということは名前付きインスタンスではなくデフォルトインスタンスですよね？ SQL Server Browser の UDP ポートも許可してみるとか？
Access側から直接SQL文を投げつけてレコードセットを取得する方法はいかがでしょうか。 Form1のテキストボックス2の更新後処理イベントに以下の文を貼り付けてみて下さい。 Dim cn As ADODB.Connection Dim rs As New ADODB.Recordset Dim strSQL As String strSQL = "SELECT dbo.Total(" & Me.テキストボックス1 & ", " & Me.テキストボックス2 & ") AS A" Set cn = Application.CurrentProject.Connection rs.Open strSQL, cn, adOpenStatic, adLockReadOnly Me.テキストボックス3 = rs!A rs.Close: Set rs = Nothing: cn.Close: Set cn = Nothing
select * ,'('+rtrim(cast(datepart(yy,来月)-datepart(yy,契約日)as char(4)))+'年後の1ヵ月前)' as 契約終了1ヵ月前の区分項目 from (select 契約番号,契約日,dateadd(mm,1,getdate())as 来月 from 契約データ)x where (datepart(yy,来月)-datepart(yy,契約日))%3=0 and datepart(mm,来月)=datepart(mm,契約日) でどうでしょうか。
データをどう溜めるかではなく、蓄積されたデータをいかに使うかがを考えて見てはいかがでしょうか。 記録したデータはどんな形での出力や利用を考えていますでしょうか？ 帳票や、検索の仕組み、業務上の要件など、利用の際に必要な項目を洗い出せば、どんなふうにマスターを作ればいいのか自然と見えてくると思います。
ありえない小さな数字からありえない大きな数字まで。とします。 生年月日の年なら0から9999とか、月なら1から12とか。 全件持ってくるのであれば条件指定しないsqlを書いたほうが速いです。
バックアップ（と言ってもテーブル間の行コピーだよね？）を実行する前に「backup log DB名 to disk N'NUL'」を実行するようにしてみたらどうでしょう。それで毎回うまくいくようになるとしたら、やっぱりトランザクションログの拡張が原因です。 それでもなるようなら・・・・僕には分からない。 あ、もちろんbackup logを実行するのはデータベース管理者とよく相談してからにして下さい。トランザクションログをNULに吐くというのは実質切り捨てなのでデータベース全体がクラッシュしてそれを復旧する時に一部直せない箇所が出てくる可能性があります。
参考URLで「SQL Server to Oracle Migration Tools」セッションをご確認ください。 ３つ挙げられてます。
(1) パラメタライズドクエリで実行したいということでしょうか？ -v オプションでできるかと。 http://workaholist.hatenablog.com/entry/20100218/1266490685 (2) -o オプションに与えるファイルパスを動的に変えるようにすれば良いでしょう。 (3) できません。通常は IIS 上に ASP などのサーバプログラムを作って対応します。そして、ASP でプログラムを作るのであれば、普通は sqlcmd を使うのではなく ADODB などを使用します。 https://support.microsoft.com/ja-jp/kb/300382
このあたりじゃないでしょうか。 http://www.mytechmantra.com/LearnSQLServer/The-remote-procedure-call-failed-0x800706be-Error.html
こんな感じでどうでしょうか。先頭列はあった方がわかりやすいのでつけています。 SELECT 'テーブルA',* FROM (SELECT [Key],Komoku1,Komoku2 FROM テーブルA EXCEPT SELECT [Key],Komoku1,Komoku2 FROM テーブルB) a UNION ALL SELECT 'テーブルB',* FROM (SELECT [Key],Komoku1,Komoku2 FROM テーブルB EXCEPT SELECT [Key],Komoku1,Komoku2 FROM テーブルA) b ORDER BY 2
【アドバイス】 テーブル[TEST] 1_goods A_2015/05/01 2_goods A_2015/06/01← 3_goods B_2015/05/01 4_goods B_2015/06/01← 5_goods C_2015/04/01 6_goods C_2015/05/01← 7_goods D_2015/07/01 2015/06/30直近の各goodsのレコードとして←の３つを抽出したいのでは？ 【テストテーブルを明示されること】 テーブル[TEST]は、わずかに３列と７行。でも、間違いなく質疑応答に際しての共通の素材として役に立ちます。質問文にかかる具体的なテスト資料を明示されることをお薦めします。
SQL Serverを止めた状態ならZip等で圧縮できます。 但し、Zipの場合4GBを超えるファイルを圧縮するには、ZIP64と言うヘッダ形式を扱える圧縮ソフトが必要になります。 例えば、WinZipならVer.9以降がZIP64に対応しています。 また、DBの容量に空きが有る状態なら、Management Studioから対象のDBを選択し、右クリックメニューから「すべてのタスク」→「データベースの圧縮」と選択する事でDBファイル自体を小さくする事も出来ます。 ＃ただし、こちらの方法は、DB管理者と相談の上行った方が良いと思います。 個人的には64GB位ならそのままコピーしても良いんじゃないかと思います。
TCPコネクションを切断しているところって回答で良いのでしょうか。 素人ってありますが、どの程度の素人なのでしょうか。 回答ですが、もっと細かく最初の行からA、Bと何か、TCPとは何か、54が何を意味するのか、ポート番号やACK、FINなどは何か．．．の解説が欲しいのか、そもそも、このパケットとは何なのかって話がしたいのか、具体的に質問された方が良い回答がもらえると思います。 データベースのカテゴリーですが、ひょっとしてデータベースのパケットの話だったでしょか。
＞SQL Server2008 R2 Standard 引用先の情報は SQL Server 2008は該当しませんね。 まぁ設定方法は同じでしょうけれど。 SQL Server2008ではOSが32bitの場合であっても AWE (Address Windowing Extensions) がサポートされているので 4GB を超える物理メモリを使用できます。 さて、Mircosoft SQL Serverは最大サーバメモリを絞ってないと、すぐに実メモリを食いつぶしてしまうようです。 主にＤＢのキャッシュとして使われますがこれは基本的に開放されることは無く、空きメモリがほとんど無い状態となってします。 マイクロソフト側はこれに関して、「空きメモリが減ってもDBサーバとしての性能に影響はない」と言っています。 確かに「DBサーバ」には影響が無いように見えますが、他の動作にかなり影響します。 例えばメンテナンスでRAIDユーティリティを動かしたり、リモートメンテナンス時のアクセスがかなり緩慢になりますね。 一時的にSQLの仕様メモリを開放する方法です。 「オブジェクトエクスプローラー「を右クリックし、プロパティを選択します。 「ページの選択」から「メモリ」を選び、「最大サーバーメモリ」のサイズを変更します。 メモリ量を設定したら「OK」をクリックして完了です。 で、最後に質問の回答 ＞SQLで使用されるメモリサイズは、積んでるメモリサイズによって変わるのでしょうか。 最大サーバーメモリーサイズを設定していない（デフォルト）の場合、搭載メモリサイズによって変わります。 利用可能なメモリサイズの空容量が10MBから4MBになるまでどんどん使用してしまいます。
select A.* from A, B using (ab, cd) where B.ef = '3';
>>再度の質問で申し訳ありませんが、私が使いたいアドインは、やはり、Expressバージョンでは出来そうにないのでしょうか？ MSDNをみると、無償のExpressバージョンでは使えないようですね。 価格コムで見ると最安で、SQL Server 2014 Standard 　３２万～みたいですね。
プロジェクトで使ってるってことは直接SQLServerへ書き込んでいるとおもいます。それが使えなくなるって事は規制されるって意味だと思います。つまり直接オブジェクトを作られたりすると壊れる可能性もあり、アクセス権で制御するってことですがそこまでするって事は、システム部が管理をちゃんとしていると言うことでしょう。逆にいまで自由にやらせてた事がふしぎです。 もしフォームを作っているならテーブルをリンクさせることになるでしょう。それがODBCリンクテーブルです。 でもこれは直接SQLに書き込むよりは負荷が高く複数で利用するならお勧めしません。 それにクエリとかはどうしますか 。パススルークエリとかで持ってきて、更新はVBAで書かないと危険です。リンクテーブルで更新はしない方が破壊を免れます。ODBCは接続は簡単だけど大きな多人数システムには危険です。参照だけなら使えると思います。でもプロジェクトにくらべれば非常に遅い検索になります。 基本的はパススルークエリをODBCで使うくらいが妥当です。 あとはVBAでADOをOLEで使うなどが本来です。 試すだけならリンクテーブルで全てのテーブルにリンクして試す事は出来ます。
select 住所 from 住所テーブル where '東京都東京市東京1-1-1' like '%' + 住所 + '%' ※[住所]列に '%' が入っているデータがあると意図通り 　の結果が返らないことがありますが、住所データなら 　ば大丈夫でしょう。
'と'で括られた中のフィールド名は[]で括る。 select geography::STGeomFromText('POINT([緯度] [経度])',4326)) from 取込テーブル
命令は呪文じゃないので、意味を考えるようにしましょう。 desc (値の大きい順=日付の新しい順) を asc (値の小さい順＝日付の古い順) に変えれば出来るでしょう。
あと、 結合キーは商品CDだけでいいんですか？ 部門CD,店舗CD,商品CDの３つセットじゃないんですか？
＃１だけど、Where条件の話ね。 列見出しはDayで囲うが、1～31で並んだら、 ドラッグ＆ドロップで入れ替えて
いろいろやりかたはあろうと思いますが 本番環境のサーバ名をSV01,データベース名をDB01, 開発環境のサーバ名をSV02,データベース名をDB02と仮定します。 SV02のManagement Studioでの作業 １ SV01とのリンクサーバを設定する 　　サーバーオブジェクト内のリンクサーバーを右クリック ２ DELETE,INSERT のストアドを作成する。 CREATE PROCEDURE TestJOB AS BEGIN DELETE FROM TABL1 INSERT INTO TABL1 SELECT * FROM SV01.DB01.dbo.TABL1 END ３ SQLServerエージェントでTestJOBを実行するジョブを作成する。 SQLServerエージェントにはスケジュール機能があります。 ストアドを実行するコマンド USE [DB02] GO DECLARE @RC int EXECUTE @RC = [dbo].[TestJOB] GO 以上ですがそれぞれの、やりかたは検索してみてください。 ちなみに、リンクサーバの設定方法はhttp://www.dcns.ne.jp/~sk7n2jch/Acc02.html 参考までに。 と、ここまで書いてEXとはエクスプレスエディションのことですか？ だとするとSQLServerエージェントは使用できないので sqlcmdを使用したバッチファイルを作成して、Windowsタスクスケジューラか フリーのスケジューラを利用するしかないです。 めも帳に上記ストアドを実行するコマンドを貼付け TestJOB1.sql で保存 同じくめも帳で下記参考バッチファイルを作成しTestJOB.bat で保存する。 @echo off echo ********* データ転送中です。 ********** sqlcmd -S SV02 -U ログインID -P パスワード -d DB02 -i C:\TestJOB1.sql pause ファイル名は任意です。拡張子.sql .bat に注意して下さい。
　実は、内部でやってることは全く同じです。 　（マニュアルの内容からすると、current_timestampは単純にgetdateを呼び出すだけのラッパー関数、又はその逆の可能性が高いです。） 　何が違うかというと、getdateは、sqlserverの方言です。ただし、sqlserverの世界では昔から使われている形式です。（プログラミングの際にキーを叩く回数もこっちが少ないか（笑）） 　一方、current_timestampの方は、ANSI SQLの正規の名称です。そのため、他のＤＢＭＳに移行する時に、楽かもしれないですね。 　たんにそれだけのことなんで、動きに関しては何の影響も無いのですが、まぁ、折角ＡＮＳＩ　ＳＱＬ表現があるわけですから、特に理由が無ければ、current_timestampを使っておいた方が将来の移植や他人が読む為には都合が良いと思います。
mdfファイルをNAS上に配置したいということですよね。 OSが書かれていませんが、Windows Server 2003以外であればシンボリックリンクで出来たという事例を見たことがありますので試す価値があるかもです。 デタッチ・アタッチをする方法ですが。 mklink /d NGだったら、切り分けとしてWindowsの共有フォルダでどうなるかを確認したらいかがでしょうか。 NAS NGでWindows共有 OKならば、問題はTS-X2.0TL/R5 が対応してないということになりますね。 上手くアタッチ出来たとしてもサポートされている構成とは言いがたいので、 別の回答者さんも書かれていましたが、iSCSIを使用するのがベストな選択だと思います。 TS-X2.0TL/R5がiSCSI対応ではないところがつらいですが。
圧縮というのがWindows＋NTFSで利用できるディレクトリの圧縮（ZIPじゃない方。エクスプローラの設定によってはディレクトリ名が青くなる奴。）の事を指していると仮定すると以下の回答になります。 単純でも完全でも問題が起きる事はないと思います。 また、パフォーマンスに関してはほとんどの場合でより悪くなります。 理由は、今までディスクアクセス＋データの取捨選択だったSELECT文が ・ディスクアクセス＝圧縮の分だけ読み込み自体は若干速くなりますが、読み込むセクタの位置が圧縮によってずれるためシークに余計な時間が取られます。 ・展開＝ディスク上で圧縮された状態のデータファイルから読み取ったデータをメモリ上で展開する必要があります。これはWindowsが管理しますがこのオーバーヘッドは意外と大きいです。 の2つです。データファイルが大きくなればなるほど不利になるでしょう。 Windowsの圧縮フォルダー（ZIPじゃない方）はパフォーマンスを犠牲にしてディスクの容量を増やすための仕組みです。 SQLSERVERなどのリレーショナルDBMSではパフォーマンスチューニングは別のアプローチを取るべきでしょう。
SELECT CASE WHEN 項目1 = 1 THEN '月' ELSE '' END+ CASE WHEN 項目1 = 2 THEN '火' ELSE '' END+ CASE WHEN 項目1 = 3 THEN '水' ELSE '' END AS 曜日 FROM テーブル1 って感じで、ELSE を書けば良いかな？試してないけど。
select T1.id, T1.配列, T2.id, T2.配列 from テーブル1 as T1 inner join テーブル2 as T2 on CHARINDEX(T2.配列, T1.配列) > 0 って感じでどうかな？試してないけど。
Access2003のクエリでよければ。 SELECT IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[Bコード],[テーブルA].[Aコード]) AS コード, IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[名称],[テーブルA].[名称]) AS 名称, IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[住所],[テーブルA].[住所]) AS 住所 FROM テーブルA RIGHT JOIN テーブルB ON テーブルA.Aコード = テーブルB.Aコード GROUP BY IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[Bコード],[テーブルA].[Aコード]), IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[名称],[テーブルA].[名称]), IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[住所],[テーブルA].[住所]) ORDER BY IIf(IsNull([テーブルA].[Aコード]),[テーブルB].[Bコード],[テーブルA].[Aコード]);
この辺でお尋ねになった方がよかないですか？ https://social.msdn.microsoft.com/Forums/ja-JP/home?forum=sqlserverja https://social.msdn.microsoft.com/Forums/JA-jp/home?forum=vbgeneral ※メンバーの方々が読みやすいように適宜改行を入れてください。 ※やむを得ずマルチポストを行う際は必ず明記し、結果は全てのサイトに報告すること。
SELECT TOP 1 商品コード, 商品名 FROM 受注履歴 ORDER BY 受注履歴.価格 DESC; これは Access のSQL文。 SQL SERVER　でも ORDER BY 句で単価の高い順に並べトップの１行のみを取得するという考え方は同じ。ただし、Top句の書き方は TOP 1⇒TOP(1) になります。 http://msdn.microsoft.com/ja-jp/library/ms189463.aspx
<Ａ><Ｂ>のテーブル名がありませんので、 仮に、テーブル名を <A>・・・TABLE_A <Ｂ>・・・TABLE_B とするなら、SQL文でテーブル結合することで行えます。 SELECT TA.商品,　　　　　　　　　　　　　…(4) TA.商品番号,　　　　　　　　　　…(4) TB.会社名,　　　　　　　　　　　…(5) TA.単価　　　　　　　　　　　　　…(4) FROM TABLE_A AS TA　　　　　　　　…(1) INNER JOIN TABLE_B AS TB　　　　　　　　…(2) ON TA.商品番号 = TB.商品番号　…(3) 回答としては上記になります。 (1)<A>の表(テーブル)を基準にして、 (2)<B>の表(テーブル)をJOIN（結合）します。 　 ※AS TAの「TA」部分はTABLE_Aの別名です。 　　　TABLE_Aという名称をTAという代わりの名前で使用できます。 　　　もともとのテーブル名が名前が長いときなどに、略称等で使用する場合などに便利です。　　　 　　　構文）　テーブル名 AS テーブル代名 　　　ちなみに、この別名のことをエイリアスといいます。 (3)<A>と<B>の表を結合付ける条件です。 　 ここが一番重要なポイントで、 <A>と<B>の項目を見比べたときに、<A>のどの項目から、 　 会社名を持ってこれるかを考えてください。 　 <A>の商品番号と<B>の商品番号を紐づけると、 　 <B>の会社名が持ってこれますよね。 　 ※すでにご存知かもしれませんが、表(テーブル)同士を結合するときに重要なのは 　　　テーブルのキー項目が何であるかという事を意識するとわかりやすいと思います。　　　 　 (4)で取得出力したい、項目名をSELECT句に、カンマ'区切り（,）で指定します。 (4)の部分では、表<A>の項目を並べています。 (5)3番目の列に、表<B>の会社名を並べています。 ここまでがSQl文の内容です。 ※上記のSQL文では、INNER JOIN (内部結合)というものを使用しています。 　　　結合する方法にもいくつかありまして、下記のようなものがあります。 　　　 LEFT OUTER JOIN (左外部結合) 　　　 RIGHT OUTER JOIN (右外部結合) 　　　 FULL OUTER JOIN （完全外部結合） 　　　 当質問が解決したら、興味があれば調べてみると良いと思います。 　　　 まずはこの編から、覚えて押さえておきましょう。使い方は上記のキーワードで探せば 　　　 ネットを調べればわかりますので、ご自身で頑張ってみてください。 <C>については、下記ヒントだけ書いておきます。 From TABLE_C AS TC1 INNER JOIN TABLE_C AS TC2 ON <この部分は自分で考えてみてください。> 商品とグループをどう紐づけるかですよね。 あとは頑張ってみてください。
こういうことでしょうか？ select S_Id , count(case C_Id when 1 then 1 else null end) Count_1 , count(case C_Id when 2 then 1 else null end) Count_2 , count(case C_Id when 3 then 1 else null end) Count_3 , count(case C_Id when 4 then 1 else null end) Count_4 , count(case C_Id when 5 then 1 else null end) Count_5 , count(case C_Id when 6 then 1 else null end) Count_6 , count(case C_Id when 7 then 1 else null end) Count_7 from Person where Z is not null group by S_Id; C_Idの種類分だけ列記しなくてはいけませんが・・
Select * From "曲名テーブル" as t1 Left Join "アーティストテーブル" as t2 On t1."アーティスト番号1" = t2."番号" Left Join "名前テーブル" as n_t1 On t2."アーティスト" = n_t1."番号" Left Join "アーティストテーブル" as t3 On t1."アーティスト番号2" = t3."番号" Left Join "名前テーブル" as n_t2 On t2."アーティスト" = n_t2."番号" Where (n_t1."名前" like '%大塚愛%' or n_t2."名前" like '%大塚愛%') 純粋にorでどちらかがhitすれば出るようにしてるだけですね。 頂いた情報をもとに書くとすればこんな感じでしょうか。 作曲者と編曲も同じようにすれば大丈夫です。
INSERT INTO TABLE_A (NAME_A) VALUES ('あいうえお') INSERT INTO TABLE_B (A_ID,NAME_B) VALUES (SCOPE_IDENTITY(), 'さしす')
SELECT * FROM Orders WHERE cast(data as unsigned) >= 25; って感じでしょうか。 文字列のままでは大小比較は出来ませんので型を変えて処理しましょう。 また、文字列型のカラムで値が入っているカラムは数値型に定義変更が出来なかったと思いますので、別途数値型のカラムを用意してUPDATE文で新しいカラムにキャストしながら値を入れ、古いカラムを削除するというやり方で型を変えていくしかないでしょう。
>※私はシステムはど素人なので、なるべく簡単に教えて頂けたら嬉しいです。 でもやることは十分玄人の領域な気が…。なので簡単に、は不可能でしょう。 以下、#1さんと同じように、AccessファイルからSQLServerへデータ読込、書込する環境を構築することを目指します。違うのは概要だけ。#1さんはきちんとシステムを構築する方法を書かれていますが、私は概要だけ。なんで概要だけかは後述。 (1)SQL Server Expressをダウンロードして、サーバー(もしくはサーバーに見立てたPC)にインストール。 (2)Accessのテーブルを(1)のSQL Serverに作成。 (3)ここからはPC側の作業 (4)ODBC接続を作成 (5)現行のAccessに(4)を使ってリンクテーブル作成。 (6)(5)のAccess内のクエリ、フォーム、レポートなどを必要に応じた修正を行う。 (7)動作確認 (8)各PCにODBC接続を設定＆Accessファイルを配布。 概要はここまでです。如何でしょう、ご自分でできそうですか？ 作業の概要はこの通りなんですが、サーバー機の選定とか"細かい"作業はかなり省略…というか書いてません書けません。特に(6)は実際にAccessファイルを見ないときっちりアドバイスはできませんし、作業ボリュームや難易度も見えてきません。…ということで(業者への発注は想定外のようですがｗ)業者も見積には難渋するでしょう。さくっと見積もりが出てくることもあるでしょうけど、かなりバッファをとった高額なお見積りかと。正直、見積もり作るのにお金がほしい内容です。 どうしてこんなことをグチグチ書いているかというと、大変申し上げにくいのですが、自称素人の方には難易度高め。業者に任せるか、類似のパッケージを探された方が、不具合などのリスクも軽減され、業務への影響も少ないかと。 ご健闘をお祈りしております。
FULL OUTER JOIN
残念ながら、秒を消すことができません。 http://msdn.microsoft.com/ja-jp/library/ms187819.aspx
select distinct * from ( select b as X from table_A union select c as X from table_A ) as table_B こんな感じ？ ちなみに、SQL Server 2008R2 で動作確認しています。
SELECT * FROM table WHERE field NOT LIKE '[0-9][0-9][0-9]-[0-9][0-9][0-9]'
試してないけど set @maxseq = @maxseq - 1; bulk insert test_table from 'C:\data\test.csv' with (firstrow = 1,lastrow = @maxseq,formatfile = 'C:\ImportOrg_Fmt.xml'); でうまくいくような気がする。 それでだめなら declare cmdstr as varchar(2000); set @maxseq = @maxseq - 1; set cmdstr = 'bulk insert test_table from ''C:\data\test.csv'' with (firstrow = 1,lastrow = ' + @maxseq + ',formatfile = ''C:\ImportOrg_Fmt.xml'')'; exec (cmdstr); といった感じで書く。 execは http://msdn.microsoft.com/ja-jp/library/ms188332.aspx 参照。
バージョン違いのアタッチはおすすめしません。そのDBは2005のままですから。いずれはエラーが出る可能性もあります。 むしろ2014はバージョンアップの対象になってますので、アップグレードが出来るはずです。そちらをおすすめします。 それでもトリガー、ストアド、ファンクションは見直しが必要な場合もあります。
まず、問題はないというところから。。。 ＞SELECT ＞伝票日付, ＞店舗CD, ＞店舗部門CD, ＞SUM(伝票合計) AS 日別合計 ＞FROM TT売上伝票 >GROUP BY 伝票日付,店舗CD,店舗部門CD ＞HAVING 伝票日付 BETWEEN '2014-04-21' AND '2014-05-20' AND 店舗CD IN(1,2,3,4) ＞ORDER BY 伝票日付,店舗CD,店舗部門CD HAVING句は抽出結果に対して処理されます。 ということで、１０年分データがあったら、１０年分の全件集計した結果に対して 伝票日付の条件にあうデータを探します。⇒非常に遅い。 普通は、WHERE句を使います。（抽出対象に対して処理されます） WHERE 伝票日付 BETWEEN '2014-04-21' AND '2014-05-20' AND 店舗CD IN(1,2,3,4) という感じです。⇒ 何年分のデータがあろうが、１か月分を対象として抜き出してから集計されます。 (group by の手前に書いてください) ＞リレーションし、店舗名、店舗部門名を表示したいのですが、書き方が分かりません。 Unionについてから。 unionは複数のselectの結果を合わせて出力するときに使います。 設計的には不適切ですが、例えば、１週単位で別のテーブルに持っているなら SELECT 伝票日付,店舗CD,店舗部門CD,SUM(伝票合計) AS 日別合計 FROM TT売上伝票４月第３週 WHERE 伝票日付 BETWEEN '2014-04-21' AND '2014-05-20' AND 店舗CD IN(1,2,3,4) GROUP BY 伝票日付,店舗CD,店舗部門CD union SELECT 伝票日付,店舗CD,店舗部門CD,SUM(伝票合計) AS 日別合計 FROM TT売上伝票４月第４週 WHERE 伝票日付 BETWEEN '2014-04-21' AND '2014-05-20' AND 店舗CD IN(1,2,3,4) GROUP BY 伝票日付,店舗CD,店舗部門CD union ・・・ という風に記述して、４月第３週から５月第２週までのデータをそれぞれのテーブルから取得します。 （例が悪いと思っている理由は、通常は年単位のテーブルや別々の種類のテーブルから 　unionするのが一般的なため。） で、望みのものは、 SELECT d.伝票日付, d.店舗CD, t.店舗名, d.店舗部門CD, b.店舗部門名, SUM(d.伝票合計) AS 日別合計 FROM TT売上伝票 d JOIN TM店舗 t t.店舗CD=d.店舗CD JOIN TM店舗部門 b b.店舗部門CD=d.店舗部門CD where 伝票日付 BETWEEN '2014-04-21' AND '2014-05-20' AND 店舗CD IN(1,2,3,4) GROUP BY 伝票日付,店舗CD,店舗部門CD ORDER BY 伝票日付,店舗CD,店舗部門CD と、結合した結果を集計するか、 SELECT x.伝票日付, x.店舗CD, t.店舗名, x.店舗部門CD, b.店舗部門名, x.日別合計 FROM ( SELECT 伝票日付,店舗CD,店舗部門CD,SUM(伝票合計) AS 日別合計 FROM TT売上伝票 WHERE 伝票日付 BETWEEN '2014-04-21' AND '2014-05-20' AND 店舗CD IN(1,2,3,4) GROUP BY 伝票日付,店舗CD,店舗部門CD ) x JOIN TM店舗 t t.店舗CD=x.店舗CD JOIN TM店舗部門 b b.店舗部門CD=x.店舗部門CD ORDER BY x.伝票日付,x.店舗CD,x.店舗部門CD と集計した結果にJOINするかします。
再帰SQL（クエリ）の出番だと思いますが、持ち合わせていないので リンクだけです。ご勘弁。 http://www.atmarkit.co.jp/fnetwork/tokusyuu/01sql99/sql99_1b.html
execute('select * from [test].[dbo]' + '.[test]') ならできます。 文2では、from以下が単なる文字列となってしまっているのです。 なので、全体を文字列とみなして、executeで処理することになります。
他の方が仰るように、ソースを見ながら修正ではコストが膨大になると思います。 それよりは、どのような機能が欲しいのか整理して1から依頼した方が早そうです。 なおこのようなカスタムメイド型のツールもあるようです。 http://www.eye-brain.jp/rakuchin.html
＞　もし自動採番にしていた場合、後述されてます ＞　＞ちゃんと外部キー制約を付けたらRDBMSが削除を受け付けてくれない ＞　ならば、 ＞　番号の範囲を使い切ってしまっても1番に戻って採番が始まらないということになりますか？ シーケンスの設定次第ですが、番号を使い切ってしまったら１番に戻って番号を発行してしまいますので、ダブった番号を登録しようとしてしまいます。 販売員コードが主キーに設定されているなら、ユニーク値しか入れられませんので、INSERTでエラーが出ると思います。 ＞　＞外部キーとして参照されている場合、Table-Bに販売員コードが使われている限り ＞　＞Table-Aのレコードは削除できなくするのが普通です。 ＞　これは、永久欠番という考え方で宜しいでしょうか？ ＞　＞Table-Aにステータス情報を持つカラムを用意しておき、販売員が辞めたときはステータスを「退職」にして管理するのが普通です。 ＞　これも永久欠番という考え方で宜しいでしょうか？ どちらも永久にDBにデータを残すと言う事です。 別の人に同じ番号を発行しないという意味では永久欠番と言えるでしょう。 Table-Aは販売員のマスターテーブルですからデータを消さないという考え方をします。 DELETEでデータ削除することを「物理削除」と呼びます。 永久にデータが見られなくなるため、Table-Bから参照しようとした時エラーになってしまうので問題があります。 この場合、Table-Aにステータスカラムを用意し在籍中は「1」とし、退職したらデータを「0」にUPDATEすると言った方法を取り、販売員を検索する場合などはステータスが「1」のレコードだけを検索するようにして、プログラム上で見えなくします。 こういった方法を「論理削除」と呼びます。 これによって、データの不整合が発生を防げます。
言語が書いてないので、Cで scanf("%s %s",&str1,&str2); で Where[依頼書No]Like '%' + @str1 + '%' And[依頼日]Like '%' + @str2 + '%' とすればいいです。 ちなみにこれだけORをくっつけたら件数が増えると（数百件）時間がかかりますよ。
ANO1です。 PARTITION BY ID,flg毎に連番がふられるの意味は これ ↓ rank*　ID NO distination expensen rank flg 1 -2 A001 002 品川 1000 2 1 2 -1 A001 001 広尾 1000 1 1 1 4 A001 003 新宿 2000 4 0 2 5 A001 004 渋谷 1200 5 0 1 3 A002 001 大森 500 3 0 1 -4 A003 002 新宿 3000 4 1 2 -2 A003 002 品川 1000 2 1 1 2 A003 001 品川 1500 2 0 2 6 A003 003 池袋 1300 6 0 1 1 A004 003 広尾 4000 1 0 1 -3 A005 001 大森 500 3 1 2 -3 A005 002 大森 500 3 1 2つめのrank*がcase when flg = 1 then -1 else 1 end * rankの結果です。 これ順で、同じならNo順に連番が振られます。 で、 PARTITION BY ID,flg毎にというのは、 IDがA001でflgが、1のデータに対して、1から連番。 IDがA001でflgが、0のデータに対して、1から連番。 IDがA002でflgが、1のデータに対して、1から連番。 ・・・ という意味です。 Order by句の中にいれる項目や式は、select句と関係しないので、 以下に様なID毎の連番で結果を得たいのなら、 select句の中に別の記述をすればいいことになります。 ROW_NUMBER() OVER( PARTITION BY ID ORDER BY flg　desc, case when flg = 1 then -1 else 1 end * rank, no) というような記述でいいはず。
復元時にデータファイルとログファイルの格納先を指定して変更する必要があります。
INSERT INTO テーブル1(依頼No, 依頼日) SELECT MAX(依頼No)+100, '2013/05/13' FROM テーブル1
2008でなければいけない理由は? 最新の2014やその前の2012ではだめなのでしょうか?
あまり詳しくはないのですが、 msdb.dbo.sp_send_dbmail は、データベース メール キューに格納するところまでしか処理しなくって、 実際に、メールサーバとの接続をはじめとした送信処理は別のプログラムが動いているので データベース メール キューに格納することができたら戻り値０で戻ってくる。 実際に、メールサーバとの接続をはじめとした送信処理はその後で動くはずです。 >【mailitemid】のヘルプを見ると送信が成功した場合、IDが入ってくる のは、 mailitem_id　パラメタ。OUTPUTをつけて変数をセットしておくとそこに値がはいるはず。 http://technet.microsoft.com/ja-jp/library/ms190307.aspx より。 で、処理結果を知りたければ、上記のIDを元に http://technet.microsoft.com/ja-jp/library/ms187646.aspx あたりに載って入るViewを探してみるしかないです。 （どのviewを見ればいいかなどは試してみないとわからないので。）
問題はdbo.mail_test の権限なのでは？ このストアドは単独では実行できるのですよね。であればまずこのストアドの中身をそのままトリガーに記述して実行できるか試してみることです。 メールを飛ばす機能？だと思いますが、その場合権限は重要ですよ。
こんにちは。 イノ(inno)です。 RESTOREをクエリで実行する方法にして、下記のオプションを追加して実行してみてください。 WITH CONTINUE_AFTER_ERROR これはエラーが発生しても無視して復元すると意味です。 解決できるかは分かりませんは一応試してみてください。 例文） RESTORE DATABASE [データベース名] FROM DISK = 'C:\BackupFileName.bak' WITH CONTINUE_AFTER_ERROR
こんにちは。 イノ(inno)です。 CASE文を使えばできます。 もしくはJOINでもできますが、今回はCASE文を利用する方法を説明します。 下記のSQLを実行してみてください。 -- #### テストテーブル作成 CREATE TABLE dbo.Test ( [ID] int ,[NAME] varchar(10) ) -- #### テストデータ登録 INSERT INTO dbo.Test SELECT 1, 'A' UNION ALL SELECT 2, 'B' UNION ALL SELECT 3, 'C' UNION ALL SELECT 4, 'D' UNION ALL SELECT 5, 'E' -- #### 結果SQL SELECT [ID], [NAME] , CASE [NAME] WHEN 'A' THEN N'あ' WHEN 'B' THEN N'い' WHEN 'C' THEN N'う' WHEN 'D' THEN N'え' WHEN 'E' THEN N'お' ELSE '' END AS [VALUE] FROM dbo.Test -- #### 結果 IDNAMEVALUE 1Aあ 2Bい 3Cう 4Dえ 5Eお
こんにちは。 イノ(inno)です。 翌月10日を取得する時は下記のようにします。 DECLARE @Today DATETIME SET @Today = GETDATE() SELECT CONVERT(CHAR(7),DATEADD(MM,1,@Today), 111) + '/10' これが一番簡単です。 @TodayにDATEADD(MM,1,@Today)をして翌月に移動します。 CONVERTを利用して'yyyy/MM/dd'形式に変換して前から7文字を切り取ります。 その後に'/10'をつけて'yyyy/MM/dd'に変更します。 上記の方法はSQL SERVERの全バージョンから使えます。 SQL SERVER 2012ならば「EOMONTH」を使って下記のように記述して取得することができます。 SELECT DATEADD(day, 10, EOMONTH(GETDATE())) 「EOMONTH」はSQL SERVER 2012以上から使えます。
select min(残高) from (select 日付,金額,(select sum(case 種別 when '出金' then 0-金額 else 金額 end) from 売上テーブル t2 where t1.日付>=t2.日付)as 残高 from 売上テーブル t1)t です。
　解りやすいのは、with句を利用して、ROW_NUMBER列を形成し、本体select文側で、ROW_NUMBER列に対して条件付けしてあげることかな。 　例えば・・・ WITH JYUNITUKI AS (SELECT RETU1,RETU2,RETU3, 　　　　　　 ROW_NUMBER() OVER ( ORDER BY RETU1) AS ROWNUM 　　　FROM TABLE1 WHERE 条件いろいろ) SELECT RETU1, RETU2, RETU3 FROM JYUNITUKI J WHERE J.ROWNUM　BETWEEN 50 AND 100 　とかですね。
副問い合わせを使って「テーブルAのTOP10を抽出したもの」とテーブルBを外部結合したらどうでしょうか。 SELECT AA.列名, テーブルB.列名 FROM (SELECT TOP 10 列名 FROM テーブルA) AA LEFT OUTER JOIN テーブルB ON (結合条件) このようにFROM句の後に()をつけてSELECT文を記述すると、そのSELECT文の結果を一つの表（ビュー）として扱えます。
SQL Serverのエディションにもよりますがクライアントアクセスライセンスがクライアント数分必要になります。
#1 です。 補足に書かれた 「ログファイルではなくて、トランザクションログのフォルダについての質問になります。 」 の意味が良くわかりません。 ちなみに、質問文には「Logファイル」は有っても「トランザクションログ」とは書いてありません。 insert処理でLogファイルに書きこまれるのはトランザクションログです、 そして、トランザクションログは各データベースのログファイルに書かれます。 なので、データベースのログファイルについた書いたつもりですが 質問者の認識と異なる部分があるのかもしれません。 とりあえず書けば (1) 新規にデータベースを作成する場合には 　「サーバーのプロパティ」の「データベースの設定」にある 　「データベースの規定の場所」に設定されているフォルダが 　デフォルトのフォルダーになります。 　実際にデータベースを作成する際にそれを変更することも可能です。 (2) 既に作成されたデータベースについては、当然、あとから(1)を変更しても変わりません。 　「データベースのプロパティ」の「ファイル」にデータベースファイルとログファイルの一覧があります。 　これを変更したい場合は少し注意というか正しい手順で行う必要があります。 　マニュアル等を確認して行ってください。 あとはなんだろ？ 「SQL Server ログ」のことかな? これは、SQLサーバーをインストールした場所から変更できそうに無いですね。 インストール時に好きなところへ指定できるかは、少し調べてみないとわかりません。 でも、データの更新があったからといって、このログが書き込まれるわけでは無いので、 実際に、このログが頻繁に書き込まれているとするなら、他にエラーとかの原因が考えられます。
SQL Server はインストール時にその辺の必要な環境をチェツクしてダメならインストールを中止し、何が足りないかを知らせます。 ですからまずはインストーラーを走らせるのがいちばん早いです、
可能です。
クライアントツールに関しては製品版もExpress版も同じですので特に問題は有りません。サーバーのインストールに関してはSQL Server2005 Expressもインストールされているようですので、デフォルトではインストールは出来ません。2005Expressをアンインストールするか、アンインストール出来ない場合はインスタンス名を変更してインストールして下さい。通常のインストールではSQLEXPRESSがデフォルトのインスタンス名ですので2005で既に使われているはずです、別の名前に変更すればインストール出来ます。
詳細な情報が無いので、 「できますよ」としか言えませんが、 注意として、create view するユーザーは 元テーブルへのアクセス権限が必要です。
WHERE条件に「全ての列がNullで無い」を指定したら、personal_idを網羅できますか？ 同一ｉｄで複数行出てこないなら、そこから取得する。 複数行出るなら、Topキーワード使って一行に絞れば良さそう。 updateのwhere条件には、更新対象列 is Null入れとけば良いし。
テーブルは2列だけどインポートファイルは4列あるというエラーですね。 列の定義確認してください。
こんにちは。 そうでしたら、下記のようにしてみてください。 最初の回答の内容でエラーになったとしたら 現在のデータに日付型に合わないデータが含まれているからだと思います。 一応、下記のSQLだとエラーにはならないと思いますが、 間違えているデータは探して修正した方がいいかと思います。 -- #### テーブル作成 CREATE TABLE dbo.TempData ( RegDate varchar(10) ) -- #### テストデータ登録 INSERT INTO dbo.TempData SELECT '2010/1/1' UNION ALL SELECT '2010/1/2' UNION ALL SELECT '2010/1/3' UNION ALL SELECT '2010/1/4' UNION ALL SELECT '2010/9/5' UNION ALL SELECT '2010/10/14' -- #### データ確認 SELECT LEFT(RegDate,4)+'/' +RIGHT('0'+REPLACE(SUBSTRING(RegDate,6,2),'/',''),2)+'/' +RIGHT('0'+REPLACE(RIGHT(RegDate,2),'/',''),2) FROM dbo.TempData
SELECT SUM(CASE WHEN Code1='A1' THEN Val1 ELSE 0 END), SUM(CASE WHEN Code2='A1' THEN Val2 ELSE 0 END), SUM(CASE WHEN Code3='A1' THEN Val3 ELSE 0 END), FROM A
こんにちは。 nekopon299さんが記述しましたプロシージャー。。 CREATE PROCEDURE プロシージャー名 @ST INT =1 AS SELECT 得意先コード, 得意先名, よみ FROM dbo.[得意先マスタ] WHERE 得意先コ―ド =@ST RETURN このまま保存すれば保存ができると思います。 下記のようには保存できません。 CREATE PROCEDURE プロシージャー名 @ST INT =FORMS!TEST.FORM![得意先コード] AS SELECT 得意先コード, 得意先名, よみ FROM dbo.[得意先マスタ] WHERE 得意先コ―ド =@ST RETURN 上記の部分で「@ST INT =1」意味は@ST変数のDefault値として1を設定しますと意味です。 FORMS!TEST.FORM![得意先コード]値をあのプロシージャーに渡したい場合は方法が違います。 一旦、下記の方法でプロシージャーを正常に作成します。 CREATE PROCEDURE プロシージャー名 @ST INT =1 AS SELECT 得意先コード, 得意先名, よみ FROM dbo.[得意先マスタ] WHERE 得意先コ―ド =@ST RETURN その後、SQL SERVER Management Studioのクエリウィンドウから EXEC プロシージャー名 @ST = FORMS!TEST.FORM![得意先コード]値の数字を入力して実行してデータが表示されるかを先にご確認ください。 例えば EXEC プロシージャー名 @ST = 1 EXEC プロシージャー名 @ST = 2 のように実行します。 これで問題なかったらプロシージャーはもう大丈夫ですので、 プログラム側からSPを呼び方について再度調べてみて方がいいかと思います。
これでしょうか？ SELECT G.GROUP_ID, G.GROUP_NAME, stuff( ( select cast(',' as varchar(max)) + U.USERNAME from USER_GROUPS U WHERE U.GROUP_ID = G.GROUP_ID order by U.USERNAME for xml path('') ), 1, 1, '') AS USERS FROM GROUPS G ORDER BY G.GROUP_NAME ASC; http://social.msdn.microsoft.com/Forums/sqlserver/en-US/f09d4166-2030-41fe-b86e-392fbc94db53/tsql-equivalent-for-groupconcat-function?forum=transactsql
＞としないのには、トラフィックの問題以外に何か理由があるのでしょうか？ フィールドの並び順が「予期せぬ結果」になるからです。 例えば、最終的な抽出結果を「項目名が１行目に付かない、CSVファイルに落とす場合」を考えてみましょう。 CSVになった段階で「１番目の項目が何、２番目の項目が何、３番目の項目が何」と言う情報は失われます。 もし、誰かが、大元のテーブルのIDフィールドとuserフィールドを「逆の順番に並び替えた」とします。 SELECT * FROMだと「抽出結果が、１番目の項目がIDで、２番目の項目がuserである」と言う保証はありません。誰かが元テーブルのフィールドの順番を入れ替えてしまったかも知れません。 入れ替えたのを知らずに、そのままCSVファイルに落としてしまうと、「１番目の項目が何、２番目の項目が何」と言う情報は失われているので、想定外のCSVファイルが出来上がってしまいます。 SELECT ID, user FROMなら「抽出結果が、１番目の項目がIDで、２番目の項目がuserである」と言う事が保証されます。誰かが元テーブルのフィールドの順番を入れ替えても、結果は変わりません。 結果のフィールドの並び順が保証されるので、そのままCSVファイルに落としても、想定通りのCSVファイルが得られます。 SELECT文で「すべての項目が全部並べて書いてあって、抽出条件も何もなしで、全レコードを返している場合」がありますが、このSQL文の意味は「結果のフィールドの並び順を固定するため」なので、安易にSELECT * FROMに書き換えると、思わぬ所でバグを産んで、痛い目に遭います。
こんにちは。 下記のように「script.sql」にあるupdate文ごとに「GO」を付けて実行すればできます。 「script.sql」 update tablename set data1 = 'aaa' where data1 = '000' GO update tablename set data1 = 'bbb' where data1 = '111' GO update tablename set data1 = 'ccc' where data1 = '222' GO
No.2です。 不確かですがCOBOLでROWCOUNTは使えなかったような気がするので… SELECT COUNT(*) INTO :ホスト変数 FROM テーブル名 DISPLAY ホスト変数
SELECT tbl_1."請求ID" , tbl_1."請求先名 " , (Select 　　　　　　' ' + tbl_3."商品名" + "*" + "個数 " From "注文TBL" tbl_2 Left Join "商品TBL" tbl_3 On tbl_2."商品ID" = tbl_3."商品ID" WHERE tbl_1."請求ID"= tbl_2."請求ID" For_XML_Path('')) as "商品名" FROM "請求TBL" tbl_1 こんな感じだったかな～。コード検証はしていません！ For_XML_Pathで言うならば文字列の結合GroupByになったはずです。 MySQLでいう、group_concat関数ですね。
グラフィカル実行プランの表示 (SQL Server Management Studio) http://technet.microsoft.com/ja-jp/library/ms178071(v=sql.105).aspx 同じ実行プランであれば、差はありません。
SQL分の効率分析ツールなら、SQL Server Profilerを勧めます。 スタートー＞すべてのプログラムー＞Microsoft SQL Server 2008ー＞パフォーマンスツールー＞SQL Server Profiler 新しいトレースを作成して、実行すると、SQL文のパフォーマンスを見ることができます。 ご参考になれればと思います。
Access MDB からの移行というのであれば、Access ADP + Microsoft SQL Server が最も簡単かと。 http://oshiete.goo.ne.jp/qa/7439684.html
SQL Server 2000 は持ってないけど、'△△1' と '△1' は区別されたと思いますよ。 後ろの空白文字が無視されて他と思います。 '1' '△1' '△△1' '1△' '1△△' これを GROUP BY すると '1' '△1' '△△1' てな感じに
販売管理システムだけであれば特に問題はありません。将来拡張した時点で必要であれば有償版にされれば良いと考えます。制限としてはCPUは１ソケットまたは４コアですのでクアッドコア以上のCPUのマシンを使えば４スレッドまで動かせます。メモリが最大１GBですが３２BitOS自体が最大４GB（内ユーザー領域2GB）であった時代でもそこそこ動いていたので、さほど問題にはならないと考えます。データベースは最大４GBですが、１データベース単位なので、１テーブルの容量が4GBを超えない限り、複数のデータベースに分散して持てば回避可能です。
> SQL Server2012 Expressで作成したデータベースをＵＳＢメモリにバックアップしました。 [タスク]→[復元]メニューで復元できるのは、[タスク]→[バックアップ]でバックアップしたデータです。 (この方法でバックアップを取ったのならbakファイルができているはずです) 従って、mdfファイルとldfファイルからデータベースを復元するには 別の方法をとる必要があります。 このあたりを参考にしてみてください。 http://oshiete.goo.ne.jp/qa/4614355.html
SqlCommandとか使っていますか？この待機時間はデフォルトで30秒です。 SqlCommand.CommandTimeoutを変えてみてください。
一般にいわれるレンタルサーバじゃ無理と思いますが。 接続文字列の中でポート番号を書きますが（書かなければデフォルトのポート番号使用。） このポート番号が、WebブラウザとAccessやVBで使うODBCやADO(ADO.Net)etcで違っていて 一般にいわれるレンタルサーバでは、Web経由のアクセスしかできない設定のはず。 普通、サーバ側のポート設定などさせてくれないし、設定できても、 ファイアーウォールを通過できないとかになりそうです。 とややこしいことは置いておいて、お望みのことは、 ホスティングサービス、とかクラウドサービスとか呼ばれるサービスを探してください。 ま、レンタルサーバ業者もやってますので、レンタルサーバで探して、ホスティングやクラウドの 項目を見るということになると思います。 これらは条件がまちまち。業者毎に違うと思ってもいいと思います。 で、設定は逆に、社内ＬＡＮにサーバを置いているのとほとんど一緒。 単に接続するIPアドレスが替わるだけ、といったパターンもあります。 （クラウドのPaasやホスティング） 但し、ＯＳやデータベースはこちらで用意するという条件になるかもしれません。 また、サーバの設定などもこちらということになるでしょう。 （通常のサーバへの導入とほぼ同じ手順を、特定のツールかリモートデスクトップ接続で接続した 　サーバに対して行います。ＣＤ－ＲＯＭとかは、大抵、クライアントに接続されている装置を使う。 　業者ごとにまちまちかもしれません。） クラウドのSaasなら、データベースまで業者持ちというのもあるのかもしれませんが、 こうなるとサーバの設定は業者側がしていて変更不可。 接続文字列とかに制限（ポート番号はこれ、とか）がついてくるかもしれません。 ちなみに、ネットワークはVPN(仮想プライベートネットワーク)にして外部とつながない、 （外部とつなぐなら、HTTPとか別の方法を使うべき） とかにしておかないと不正侵入されて大変困ったことになります。
SELECT C1, ( CASE MIN( CASE C2 WHEN 'R' THEN 1 WHEN 'P' THEN 2 ELSE 3 END ) WHEN 1 THEN 'R' WHEN 2 THEN 'P' ELSE 'S' END ) AS C2 FROM Table1 GROUP BY C1 ORDER BY C1
こんにちは。 そうですね。 現在はそういう方法しかありません。 もしくは関数(FUNCTION)を作成してSQLを少しキレイに作成するのはどうでしょうか？ 下記のSQLをご参考ください。 １）「fnCharToTime」関数を作成します。 CREATE FUNCTION dbo.fnCharToTime ( @Strchar(6) ) RETURNS time AS BEGIN RETURN CONVERT(time, SUBSTRING(@Str,1,2)+':'+SUBSTRING(@Str,3,2)+':'+SUBSTRING(@Str,5,2)) END ２）結果 DECLARE @Str char(6) SET @Str = '090000' SELECT dbo.fnCharToTime(@Str) どうでしょうか？
動的SQL http://stackoverflow.com/questions/5019041/how-to-cast-variables-in-t-sql-for-bulk-insert
プログラムはサーバー２のテーブルを更新するのでにサーバー２接続する事とします。サーバー２でサーバー１へのリンクサーバーを設定します。リンクサーバーでサーバー２に接続したログインIDに対しサーバー１へのログインIDとパスワードを設定します。SQLでは「リンクサーバー名.データベース名.スキーマ名.テーブル名」とする事で別サーバーのテーブルを扱えます。
受注Tの単価がNULLの場合だけ単価Mから単価を引っぱってきたいという事ですよね？ 単価Mの抽出条件としては、製品CD・得意先CDが受注Tと同じで、数量FROMと数量TOの範囲が受注Tの数量を含んでおり、適用日が受注Tの受注日以前で最新のものとなります。 例) ------------------------------------------ SELECT 　製品CD, 　得意先CD, 　数量, 　COALESCE( 　　単価, 　　(SELECT TOP 1 単価 FROM 単価M TK WHERE 　　　JC.製品CD = TK.製品CD AND JC.得意先CD = TK.得意先CD AND 　　　JC.数量 BETWEEN TK.数量FROM AND TK.数量TO AND 　　　TK.適用日 <= JC.受注日 　　　ORDER BY TK.適用日 DESC 　　) 　) AS 単価, 　受注日 FROM 受注T JC; ---------------------------------------------- OLAP関数を使えばもう少しスッキリするかも知れません。
SQL Server 2005 Express は、Vistaまでのようです。(正式サポートは) http://technet.microsoft.com/ja-jp/library/ms143506(SQL.90).aspx Windows7で利用できるのは、2008以降のようですね。 http://technet.microsoft.com/ja-jp/library/ms143506(v=sql.100).aspx > もし対応していたとしても新しいExpress Editionに変えた方が良いでしょうか？ SQL単体での利用であれば、新バージョンの方がOSとの適合と言う点で推奨しますが、、 大抵はSQLを利用しているアプリケーション側に大きく依存する事となると思いますので、そちらの方の確認を。
実際に使ったことがないのであまり自信がないのですが、Access オブジェクトの SQLServer への移行にMicrosoft SQL Server Migration Assistant (SSMA) for Access というツールが使えるようなことが書いてあります。たしかクエリも Access オブジェクトの一種でしたよね。試してみてはいかがでしょうか。 SQLServer 関連ソフトウェアのダウンロードページ（SSMA for Access へのリンクあり）： http://www.microsoft.com/ja-jp/sqlserver/2012/downloads/default.aspx SSMA for Access の使い方（英語）： http://blogs.msdn.com/b/ssma/archive/2011/01/29/access-to-sql-server-migration-how-to-use-ssma.aspx
CASE WHEN @D = 0 THEN (dbo.TEST.D = dbo.TEST.D) '全データを WHEN @D = 1 THEN (dbo.TEST.D = 1) '値が1のデータを WHEN @D = 2 THEN (dbo.TEST.D = Is Null) 'データがNull のものを ↓ ((@D = 0 AND dbo.TEST.D = dbo.TEST.D) OR (@D = 1 AND dbo.TEST.D = 1) OR (@D = 2 AND dbo.TEST.D = Is Null) ) とした方がよいかと思います。
TABLE_BのCOLに「IDX_B」というインデックスがあるとして SELECT * FROM TABLE_A INNER JOIN TABLE_B ON TABLE_A.COL LIKE TABLE_B.COL+'%' option( table hint ( TABLE_B, index( idx_col) ) ) を試して見てください。
SQL　Sever は随分とご無沙汰。 で、非テストでアップ。 SQL Server のマニュアルを参照 http://technet.microsoft.com/ja-jp/library/ms184325.aspx ISNULL ( check_expression , replacement_value ) Nzは省略可。 ISNULLは省略不可。 replacement_valueを書いて下さい。 みたいですね。 なお、図の上がAND、図の下がOR。 どっちかが合っっていたらがORです。
--こんにちは。 --以下のSQLで実現可能です。SQL ServerでSQLの検証を行いました。 SELECT TBL_A.年月日 ,ISNULL(TBL_B.データ,'') AS データ FROM( SELECT '2013-08-01' AS 年月日 UNION ALL SELECT '2013-08-02' AS 年月日 UNION ALL SELECT '2013-08-03' AS 年月日 UNION ALL SELECT '2013-08-04' AS 年月日 UNION ALL SELECT '2013-08-05' AS 年月日 UNION ALL SELECT '2013-08-06' AS 年月日 UNION ALL SELECT '2013-08-07' AS 年月日 UNION ALL SELECT '2013-08-08' AS 年月日 UNION ALL SELECT '2013-08-09' AS 年月日 UNION ALL SELECT '2013-08-10' AS 年月日 ) AS TBL_A LEFT OUTER JOIN TBL_B ON TBL_A.年月日=TBL_B.年月日 --TBL_A：日付を管理するテーブル --TBL_B：日付と対になっているデータが登録されているテーブル
読ませていただくと、2がベストと思われます。 Webシステムにすることによって、SQL処理は本社のサーバーで実行され、結果がWebベースのテキストで飛んできます。 データーベースが一カ所のため、整合性にも問題ないですし、やり取りは結果のテキストだけですので、VBベースのシステムに比べるとかなり速くなると思われます。 ただ、インターフェイス面でVBのような手の込んだ処理が出来ないことがありますので、利用者から別の文句が出る可能性があります。 また、開発元ベンダーさんも実績が無いとのこと、そうなると、他の案ですが、 > 4.SQL Serverを各拠点に立て、ミラーリングする >（マスタや採番は一元化管理が必要です。データの整合性を保つのが困難な印象で、 > 4より1か2か3の方が良いシステム構成かと思います） マスタはそんなに頻繁に更新されるものでしょうか？ 採番は、絶対に連番でないと困るのでしょうか？ そのあたりを考え直すと、ミラーリングでも十分実用的になりますし、速度もほぼ本社並になることでしょう。 合わせて、緊急時のバックアップにも使えます。 ベンダーさんにその辺りのノウハウを持っていないか、聞いてみてはいかがでしょうか？ ターミナルサーバー、MetaFraame(Xen Desktop)、Horizon View、同じようなものですが、拠点側での同時利用者がどれぐらいの規模かによって、構成が決まります。サーバーにそれなりのコストがかかるのと、クライアントとして動かす中のOSのライセンスが結構ネックになります。 最後にあまり期待できないかもしれませんが、WAN高速化装置(アクセラレーター)と言われるものがあります。 http://www.itmedia.co.jp/enterprise/special/0706/wanoptimize/
こんにちは。 LEFT OUTER JOIN と　INNER JOIN は少し差があります。 下記のSQLを実行して確認してみてください。 CREATE TABLE #TempTableA ( Idx int , DataA varchar(10) ) CREATE TABLE #TempTableB ( Idx int , DataB varchar(10) ) INSERT INTO #TempTableA SELECT 1, 'A' UNION ALL SELECT 2, 'B' UNION ALL SELECT 3, 'C' UNION ALL SELECT 4, 'D' INSERT INTO #TempTableB SELECT 1, 'Z' UNION ALL SELECT 2, 'Y' UNION ALL SELECT 4, 'X' UNION ALL SELECT 5, 'V' 上記のSQLを利用してテーブル作成とデータを登録します。 その後、LEFT OUTER JOIN　でIdx値が３のデータを抽出してみます。 SELECT A.Idx, A.DataA, B.DataB FROM #TempTableA A LEFT OUTER JOIN #TempTableB B ON A.Idx = B.Idx WHERE A.Idx = 3 結果は下記のとおりです。 1件のデータが出ます。 ですが、#TempTableBテーブルにはIdxが3のデータがないのでnullのデータで表示されます。 IdxDataADataB 3CNULL 今回は、INNER JOINで実行してみます。 INNER JOINは両方のテーブルにデータが存在しないとデータが表示されません。 SELECT A.Idx, A.DataA, B.DataB FROM #TempTableA A INNER JOIN #TempTableB B ON A.Idx = B.Idx WHERE A.Idx = 3 ですので、1件も表示されません。 LEFT OUTER JOIN と　INNER JOINはこの差がありますので、 注意して適当なSQLを利用する必要があります。
こんにちは。 SQL Serverのシステムデータベースは４つがあります。 システムDBを表すFLAGとかはないので そのデータベース名を除いて抽出すればユーザーが作成したデータベースのみ抽出することができます。 SELECT [name] FROM sys.databases WHERE [name] NOT IN ('master','tempdb','model','msdb')
データーベースの操作(フロントエンド)はAccess2010で行うが、データーベースそのものは、レンタルサーバー(MySQL)に置きたい、ということでしょうか。 やって出来ないことは無いでしょうが、かなり難しいでしょう。 レンタルサーバー上にデーターベースを置くことにより、情報漏洩等の危険があります。 サービス元のポリシーにもよりますが、レンタルサーバーで「準備された」MySQLは、外部からの直接アスセスは許していないのではないでしょうか？ 試してみたいのであれば、以下の資料を参照ください。 データベース・サーバのフロントエンドとしてAccessを利用する http://www.atmarkit.co.jp/fwin2k/win2ktips/346dbaccess/dbaccess.html 外部ホストからのMySQL接続 http://linuxserver.jp/%E3%82%B5%E3%83%BC%E3%83%90%E6%A7%8B%E7%AF%89/db/mysql/%E5%A4%96%E9%83%A8%E6%8E%A5%E7%B6%9A%E8%A8%B1%E5%8F%AF%E8%A8%AD%E5%AE%9A.php その辺をひっくるめてやってくれるのがAzureですが、おそらく費用がかさむものと思います。 ところで、データーベースを「外」に置かなければならない理由はありますか？ (例えば、本店・支店など離れた環境でデーターベースを共有など) 同じ事務所内で、複数人利用するだけであれば、事務所内にサーバーを準備する方がすっきりすると思いますが。 一番手っ取り早いのは、ファイルサーバーにmdbファイルを置いてしまうことですが、 http://weba03.blog96.fc2.com/blog-entry-191.html のような危険がありますので、やはり、SQL Serverを準備するのが一番でしょう。 いままでAccessで作業できていたレベルであれば、無償のExpress Edition http://www.microsoft.com/ja-jp/download/details.aspx?id=29062 を利用する手もありますが、今後のことを考えると、Standard以上が欲しいところです。 http://www.atmarkit.co.jp/ait/articles/1007/21/news095.html http://www.microsoft.com/ja-jp/sqlserver/2012/default.aspx
SQL Server のインストール時にインスタンスを作成しますが、その際 ・既定のインスタンス ・名前付きインスタンス のどちらかを指定します。 既定のインスタンスは1つのサーバーに1つのみ作成可能で MSSQLSERVERというインスタンス名が付けられます。 名前付きインスタンスは自由に名前をつけることが可能です。 これは１つのバージョンのSQLServerがインストールされている場合でも 異なるバージョンの複数のSQLServerがインストールされている場合でも 同様です。 例えば、2005で既定のインスタンスを作成した場合は、2008では 名前付きインスタンスを作成する必要があります。 接続文字列としては、既定のインスタンスへ接続する場合は接続先として 「コンピューター名」を指定しますが、名前付きインスタンスへ接続する場合は 「コンピューター名\インスタンス名」を指定します。
できるよ。 SQL Server 2008 Workgroupは一つのWindowsマシンに50個まで同時にインストールできる。 その場合、気をつけなければいけないのは「インスタンス名」と「ポート番号」をそれぞれのインスタンスでどうするかだ。 インスタンス名は、例えばインスタンス名をANMOCHIとするとWindowsサービス名がMSSQL$ANMOCHIとなる。もう一つのインスタンス名をHENMOCHIにするとそちらはMSSQL$HENMOCHIになるので、それぞれのSQL Serverを独立して停止させるなどお互いに干渉し合わない。もちろん、ディスクとメモリとCPU は倍必要になる。それぞれのインスタンスでCALはどうなるかわからない（私は把握していないという意味）。インストールする時に「インスタンスの構成」ページで規定のインスタンス（これを名前無しインスタンスとも言う）か名前付きインスタンスかを選べば良い。相手が規定のインスタンスであれば、規定のインスタンスは選べなくなっているはずだ。また、ここで相手のインスタンスの詳細を見る事ができるので試しにインストールをここまで進めて確認してみるというのもいいだろう。 ポート番号は当然あっちが1433を使っているだろうから、あなたのシステムでは2433を使うなど、別のポート番号にしてあげないといけなく、Access側もそのポート番号に対してアクセスしなくてはいけない。 ただ、 > 既にインストール済は、会計ソフトです。 > 開発元に確認してないですが、既存のデータベースを使わせてもらうと > データの中身まで見れてしまうので、 ログインとデータベースユーザを適切にマッピングする事で、ログインAとログインBがお互いに相手のデータベースは見れないという設定にする事はできる。 そもそもお互い相手のデータベースユーザとマップする事は普通ないじゃろうて。 もちろん、相手のインスタンスにデータベースをアタッチさせてもらうとsaを共有する事になるのでそこらへんでトラブったときに喧嘩になる可能性はなきにしもあらず。 また、Windowsの管理アカウントも両方のデータベースを見る事ができるのにも注意。 さらに、相手のエディションがExpressである可能性もあるのでその場合は相乗りしない方がいいだろう。
独習データベース設計という本で勉強してました。 あとは、Okwaveさんや技術blog様の内容を見て理解してですね。 あとは、もうトライしてエラーを何回も吐き出して・・・何度もやり直しての繰り返しです ・まず、数量倍になってるのはどういうSelect文書いてるかわからないので知りません。 ・入れ子構造・・・余分な部分を考えないで一個一個みてけば理解できます ・int型はSQL側で計算できるのでいいですよ。あとサイズ軽くなるし ・GUIに頼るな！！(笑)ものによっては、リレーションするカラム名違うとかザラにあります。結局人間の手です ・まず、LeftとInnerだけは最低限覚えて使えるようにしてください(最悪の場合はLeft一本で後から追加してください)。Rightやらなんやらは後からや必要になった時に調べるなりして覚えてください。 ・メモ書きすぎたり、文章内容ふざけてるとぶん殴りたくなりますが、どんな動作を意図したかとか書いてるとわかりやすいですよ。後の自分自身にとっても へー、黒猫 SQL Studioなんてあるんですね～。付属のSQL Server Management Studioばっかつかってましたわ。
こんにちは。 MSSQLサーバーのテーブルで最新でInsertした直後に、そのレコードを削除して、 再度Insertした時のIDENTITY列の値はその前にInsertした時に使用された値が 再度使われることはありません。 手動で設定し直す限り。 #### Identityを設定する方法 テーブルを「デザイン」で開いてIdentityで設定するカラムを選択すると 【例のプロパティ】に「Identityの設定」があります。 スクリーンショットのように画面が見えない場合は、 「IDENTITYの設定」前にある「+」マークをクリックすると スクリーンショットのように表示されると思います。 そこで「(idである)」項目を「いいえ」から「はい」に変更すると設定は終わります。
HKEY_LOCAL_MACHINE です。 ＃　先の質問で「媒体」求められた経緯といい、 ＃　以前に製品版をインストールしたことがあるのなら ＃　もう少し違う操作が必要かも。
> win764bitにMicrosoft SQL Server 2008をインストールしたいです。 > それとも何かＣＤ－Ｒが必要なのでしょうか？ 製品版なら媒体が必要です。 SQL Server 2008がExpressなら、ダウンロードしたファイルを指定する。
ブラウザに認証ダイアログが表示されるのとデータベースの話はまったく関係ないでしょう。 新たに追加したaspxファイルの権限の問題では？ > ３．ノートPC（開発機）から本番機サーバにプログラムをコピー。 コピーしただけ？
副問い合わせと言われています。 http://www.sql-reference.com/select/subquery.html カッコ内のSQLの問い合わせ結果が必ず1件になる場合に利用できます。 ---- 何か一冊本を購入されることをお勧めします。SQL ServerもExpress版なら無料ですし。
10台くらいなら、Expressで十分では・・・と書いてしまうのでは野暮ですね。 購入に前向きならばMicrosoftに問い合わせたほうがよろしいかと思います。 Microsoftのライセンスは複雑すぎるため、下手な回答ができません。 1に関してはExpressいれればいいかと思います。 2に関しては・・・製品を有効にするのがあればサーバ機だけ使用できたはずです。 3に関して10台と考えればまぁ良いかと・・・ こっち方面離れて数年なので間違い等あるかと思います。 確実なのはMicrosoftさんに聞かれたほうが良いかと・・・見積もりで電話かけた記憶だけは今でもあります。
質問１： 過去に見にいった履歴が残ってるからですね。IPとかホスト名とかだとは思いますが。 履歴の消し方は、http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1330204363 こちらをご参照ください。 質問２： Drop句を覚えましょう Drop Database hogeでDBを削除 Drop Table hoge でテーブルを削除 Drop procedure hoge でプロシージャ削除です。 5日前ですからお気づきかと思いますが、GUIですから右クリックメニューの削除でも消せるちゃけせるんですけどね。
タスクマネージャのプロセスには現れていない。 プログラムの追加と削除にも無い。 ならアンインストール時に消し損ねたので レジストリから削除すればよいかと。 サービス一覧の中で、SQL Server(YAYOI) をダブルクリックすると 全般タブ中に サービス名 ○○○ 表示名 SQL Server(YAYOI) 後略・・・ となっているハズです。 コマンドプロンプトを立ち上げて sc delete "○○○" でEnter。 SQL Server Agent(YAYOI) も同様に。
case式を使って、 select YEAR("日付") as yere,MONTH("日付") as month,sum(case when "収支名" = '収入' then "金額" else "金額" * -1 end) as "差" from 収支 group by YEAR("日付"),MONTH("日付") こんな感じでどうでしょうか。 "収支名"には'収入'・'支出'しかない前提です。
メリット 検索が早くなる デメリット 更新や挿入の処理に時間がかかる ディスクやメモリをたくさん喰う RAMが少なくてテーブル数やデータ量が多いとスワップアウトするので検索が遅くなる RDBMSがインデックスの効率が悪いと判断したらインデックスを使用しないので資源の無駄遣いになる
SQL Server 2005 Express Editionにx64版はないのでは? ＞ 32 ビットと 64 ビット (WOW インストール) の両方のオペレーティング システムへのインストールをサポートしています。 と記述されていますから、x64ではWOWを使って32bit版を動作させるようになっていると思います。 http://www.microsoft.com/ja-jp/download/details.aspx?id=184
高速削除といえばTRUNCATEですが、WHERE句の指定があるので使えないです。となると、基本はIndexか条件見直しになるかと思います。 もし列idにIndexをはっていないようであれば、はってみてください。 あと、orではなくinを使ってみてはいかがでしょうか？細かい名称は忘れてしまったのですが、Management Studioには実行時のパフォーマンスを測定する機能があるので、orとinでそれぞれそのパフォーマンス値を比較すれば、具体的にどのくらい効果があるのか数値で確認できます。 ご参考までに。
＞DB名、ID、パスワード、ホスト名、ポート番号、MySQLのバージョン5.0.90 ＞[Microsoft][ODBC SQL State: '08001' SQL Server エラー: 6 [Microsoft][ODBC SQL Server Driver][TCP/IPSockets]指定された SQL Server が見つかりません。 --- 先方から指定のあったMySQLと、質問者様がお使いのODBCドライバーに互換性がありません。 Microsoft SQL Server はマイクロソフトの製品であり、MySQL は現在はオラクルがライセンスを管理しています。 MySQL に接続するなら、MySQL のODBCドライバーを使用してください。 MySQL用のODBCドライバを入手する方法。 http://mysqlweb.net/s/article/61906902.html
andとorで記述できます。 select * from table1 where @jouken = 0 and field1 = 1 or @jouken = 1 and (field1 = 1 or field2 = 1) or @jouken = 2 and (field1 = 1 or field2 = 1 or field3 = 1)
データベースが別マシンでも同じマシンでも基本的には同じ動きをします。SQL　Serverの場合ログインID別に接続されるデフォルトのデータベースが決まっているので、そのデータベース名に誤りが無いかか確認して下さい。当然ですが、作ったテーブルがログインIDに対しSELECT権限が有る必要もあります。
select * from テーブルA union select * from テーブルB order by あるカラム; で出来る思いますが、セレクトされるカラムがunionの前後で同じでなくてはいけませんので、テーブル構造に違いがあるのであれば　＊　ではなくカラム名を書き出してセレクトするカラムを指定してください。
select id,product,sum(price) from tbl group by id,product having sum(price)<>0 order by 1,2 です。
Date と Name が同一のレコードが複数在る場合や、同一のDateに a だけが存在して b, c が無い場合などはどういった値になれば良いのでしょうか？ 仮に Date と Name が同一のレコードが複数有る場合は最大の値、特定の Name の値が無い場合は null になるとすると、下記の様なSQLで取得できるでしょう。 SELECT Date, MAX(CASE WHEN Name = 'a' THEN Value ELSE NULL END) AS a, MAX(CASE WHEN Name = 'b' THEN Value ELSE NULL END) AS b, MAX(CASE WHEN Name = 'c' THEN Value ELSE NULL END) AS c FROM tbl GROUP BY Date; この様に CASE 式と集約関数を組み合わせは非常に便利です。 下記のページが参考になるでしょう。 http://codezine.jp/article/detail/404?p=2 http://codezine.jp/article/detail/751?p=1
http://msdn.microsoft.com/ja-jp/library/ms178569(v=sql.90).aspx こちらを見る限りパラメタpermissionは<permission,...n>となっているので、複数の権限を設定できると思います。というか他ベンダでは出来るのでSQL Serverでも可能でしょう。
一括でインポートするのが吉 http://nasunoblog.blogspot.jp/2012/05/sql-server_10.html
全て認識されている通りです。 > この場合、どの製品を購入するのが安価で済ませられるのでしょうか？ > サーバーライセンス×1とＣＡＬ×2でいいのでしょうか？ クライアント2台であればコアベースライセンスは必要ないと思いますので サーバーCALライセンスになりますね。 > 稼動後、もし、データベースサーバが、Windows server 2008R2(2CPU)と > なった場合、Windows7のサーバライセンスをアンインストールし、新しい > サーバにインストールし直せば使用できるのでしょうか？ > それとも、サーバライセンスの追加購入かコアパックの購入が必要でしょうか？ Windows7からアンインストールして2008R2にインストールすれば問題はない と思います。 「ライセンスのインストール/アンインストール」という概念はありません。 SQL Server 製品をアンインストールします。この場合サーバーライセンスの追加も 必要ありません。 > データベースをSQL server 2008R2で使用したい場合、購入するディスクキットを > SQL server 2008R2用を購入すれば、SQL server 2008R2 Standard Edition > として、使用できるのですか？ ダウングレード権がありますのでその通りです。2012 CAL は 2008R2への接続 でも使用できます。
＞"N002"のグループ内に"N"が存在したら"P"に置換したいです。 を「B_NOのグループ内に'P'が存在したら'P'に置換」と解釈しました。 SELECT REC_NO, B_NO , CASE WHEN 'P' IN (SELECT [TYPE] FROM Table1 x WHERE SUBSTRING(x.B_NO, 1, 4) = SUBSTRING(a.B_NO, 1, 4) GROUP BY [TYPE],SUBSTRING(B_NO, 1, 4)) THEN 'P' ELSE [TYPE] END [TYPE] FROM Table1 a
残念ながらSQL Serverの機能としては提供されていません。 プログラムの実装側で対応する必要があります。 今回のケースですとVBで、タイムアウトとリトライを作りこむしかないかと思います。
GROUP BYは集合関数、HAVINGは集合から条件で抜き出す関数。SELECTは集合体を構成する要素。 SQLとはそもそもがSELECTで抜き出した集合の塊ごとに処理する言語。手続きでは無い。箱と箱を組み合わせる積木のような言語と考えれば簡単。
DataRowのRowStateがModifiedになっているから。 DataRow.SetAdd()でRowStateをAddedに変える。
>>SQLサーバーに移行するメリットはありますか？ 将来、複数ユーザで使う可能性があるなら、移行するメリットはあります。 でも、ずっと一人で使うだけなら、移行しないほうが手軽でいいでしょうね。
(1)～（5）の設定でやりたいこと(1)(2)は満たせます。 「すべてのデータベースにバクアップファイルを作成する。」でバックアップごと、データベース毎に 異なるファイル名でバックアップが作成されます。 やりたいこと(3)の削除はご認識の通り、クリーンアップタスクで行えます。 バックアップの有効期限を設定する必要はありません。
select TableB.ID, TableB.名称, TableA.時間 from TableB left outer join TableA on (TableB.ID = TableA.ID);
SQLはSELECT文も含め命令の数は少なく、文法も単純ですので、確実に文法を理解して下さい。文法が単純な為、複雑な事をする場合、SQL文が長くなりますが、単純な文法の組み合わせですので、冷静に解析すれば必ず解けます。
データベースファイルというのは SQLサーバーが使用するデータを格納するファイルです。 (拡張子は データ用 MDB,NDB ログ用 LDB です。) 一般的にはデータベースにアクセスすると言うことは SQLサーバーの様なデータベースソフトに対してアクセスします。 データ操作と言う意味では、データベースファイルに直接アクセスすることはありません。 説明にもあるように SQLサーバーA から データベースX をデタッチすると データベースX に使用しているデータベースファイルはフリーになります。 そのデータベースファイルを別のSQLサーバーBに持っていき アタッチすると、データベースX が使用できるようになります。 データベースファイルを操作するのはこういった特殊な場合だけです。 プログラミングの勉強と言う意味では データベースファイルは使用しないと思って良いでしょう。
質問通りにSQL作るとこんな感じ SELECT MIN(t.個別ID) 個別ID, t.グループID, t.順位, t.個数 FROM table_1 t INNER JOIN (SELECT a.グループID, MAX(a.個数) 個数 FROM dbo.Table_1 a GROUP BY a.グループID) ex on ex.グループID=t.グループID AND ex.個数 = t.個数 GROUP BY t.グループID, t.順位, t.個数
>Express Editionではない、SQL Server 2012 Standardなどのデータベースは違う拡張子のデータ >ベースファイルになるのでしょうか？ 同じ拡張子です。データベース本体がMDFでトランザクションログがLDFの２種類です。 >もしそうなら、何故Express Edtionと有料バージョンではデータの持ち方が違うのでしょうか？ Express EditionはCPUの数、メモリーの容量、ファイルの容量に制限がありますが、プログラム自体はStandardと同じですので、データーの持ち方も同じです。 >ファイルをコピーして別PCに持って行けばファイルはひらけるものなのでしょうか？ 単に開く事はできません、アタッチと呼ぶ操作を行う事でデータベースとして使えるよううになります。 >■mdfファイルのデータをAccessにインポートできるのもなのでしょうか？ Accessのデータ構造とは異なるのでmdfファイルから直接インポートする事は出来ません、SQL Serverを介して行います。
単純に権限付与するならsysadminで、 GRANT exec ON xp_cmdshell TO <SQLLogin> ですが、この辺はある種のFAQで、もう一手間、二手間必要かもしれません。 http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.php?topic=42662&forum=7 http://ameblo.jp/sql-server/entry-10292432498.html http://bokuibi.blogspot.jp/2009/06/sql-server.html?m=1 http://support.microsoft.com/kb/890775/ja バージョンや認証方法でも対処法が変わります。 とは言え、（私は、仕事で使っていたのは2000が最後ですが）基本理念は変わっていないと思います。 ところで、bcpでサーバにファイルを吐いた後、クライアント側に持って来る処理は不要なのでしょうか？ ファイルサイズにもよるとは思いますが、C#とVBが使えるなら、それこそ、OLEDB、ODBC経由でCSV吐くサンプルは沢山転がっていると思います。 数100MB以上とかなら、サーバ側で吐いたのを圧縮転送の方がいいですけど。
replace関数を使うと良いよ。 replace ( カラム,'-','') ってするとハイフンを文字無しに置き換えてくれるからそれを検索すればいいよ。
ビュー自体には実データは存在しませんが、実データの見方を定義しているので、調査しようとしてい範囲によっては、調査の必要が有る可能性は有ります。ビューを沢山作ると、システムの解析が面倒になるので、あまり作らない事をお勧めします。
↓のページに載っている問題と同じですね。 http://codezine.jp/article/detail/751?p=1 スカラサブクエリを使った場合は下記の様な感じになるでしょう。 SELECT 名前, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '月') AS 月, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '火') AS 火, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '水') AS 水, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '木') AS 木, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '金') AS 金, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '土') AS 土, (SELECT 1 FROM 出勤テーブル b WHERE a.名前 = b.名前 AND 曜日 = '日') AS 日 FROM (SELECT DISTINCT 名前 FROM 出勤テーブル) a ORDER BY 名前;
select ID,名前,趣味 from 現在 union all select ID,名前,趣味 from 履歴 t1 where 履歴NO=(select max(履歴NO) from 履歴 t2 where t1.ID=t2.ID) and not exists(select ' ' from 現在 where 現在.ID=t1.ID) order by 1 です。
待ちますが、タイムアウトでデッドロックになります。 デッドロックになったら時間（1,2秒）を待ってもう一度更新に行きましょう。
1) 値段の集計 SELECT 販売支店, 出身国, SUM(値段) AS 値段 FROM テーブル GROUP BY 販売支店, 出身国 ORDER BY 販売支店, 出身国 (2)車種の頻度順 SELECT COUNT(*), 車種 FROM テーブル GROUP BY 車種 ORDER BY COUNT(*) DESC, 車種 (3) 合体 SELECT a.販売支店, a.出身国, SUM(a.値段) AS 値段 , ( 　　SELECT TOP 1 b.車種 　　FROM テーブル b 　　WHERE b.販売支店 = a.販売支店 AND b.出身国 = a.出身国 　　GROUP BY b.車種 　　ORDER BY COUNT(*) DESC, b.車種 ) AS 車種 FROM テーブル a GROUP BY a.販売支店, a.出身国 ORDER BY a.販売支店, a.出身国
>クエリをそのまま実行しました。 とありますが、その後ろには >この'dbo'というのはWITH句の前にある文に含まれているのですが、 と書いてありますよね。 これはそのまま実行したとはいえません。 どうしてその前のステートメントは開示していただけないのですか？（dboのキーワードがそのステートメント内にあるのですよね） ちなみにWITHステートメントは調べていただけましたか。 私はクエリも書きましたが検索していただくことを推奨してますが・・・ WITHステートメントを調べれば、このステートメントのスコープについてかかれており、直前・直後のステートメントでは セミコロンが必要なことも明記されています。 >入れてみましたがダメでした。 前回と同じなのか、別のエラーなのか、やはりこれではフォローできません。 ちなみに今回の事例のような場合、普通はNo.3のnharasawaさんのおっしゃるとおりfetchで処理していくのが一般的です。 update一文で処理をすれば、その意図がみえづらくなり後々困ることになるからです。
やりたいことを実現する方法としては、 where (@パラメータ１ is null or dbo.TEST.A = @パラメータ１) and (@パラメータ２ is null or dbo.TEST.B = @パラメータ２) とか where isnull(@パラメータ１,dbo.TEST.A) = dbo.TEST.A and isnull(@パラメータ２,dbo.TEST.B) = dbo.TEST.B とかcaseを使わない方法もいろいろあります。 CASEを使うのなら、 WHERE CASE WHEN @パラメータ１Is Not Null THEN @パラメータ１ ELSE dbo.TEST.A END = dbo.TEST.A AND CASE WHEN @パラメータ２Is Not Null THEN @パラメータ２ else dbo.TEST.Ｂ END = dbo.TEST.Ｂ とか。 TSQLのIFは条件によって、処理を分岐させますが、 CASEは条件によって、返す「値」を別々にします。 CASE～END = xxx 等のように書かないといけないです。 （という説明で分ってもらえるかな？あまり自信ないですけど。） なお、ANo.1の回答は、 左辺は、1。 右辺は、 パラメタがNull ならば 1 パラメタがNullでなければ （パラメタと値が等しければ1、さもなくば0） この結果の左辺と右辺を比較しています。
6.5の古いバージョンは問題が出ましたが、最近のバージョンは問題は出ないはずです。尚、クライアントからの接続は当然コンピューター名を変更する必要があります。
はじめまして、こんにちは 2名で共有する場合もSQLServerに移行した方がよいでしょうか？ ＞＞DBにアクセスする頻度によると思います ひとつのMDBテーブルをテーブルとその他に分けて使用しています。 テーブル部分を共有フォルダに入れて使っていますが 現在は一人が使ってる時はもう一人は使わないようにしています。 ＞＞共有フォルダに置いたMDBに他の端末からアタッチされているのだと思います 今のタイミングならSQLServerに移行できる時間があるのですが2名でも移行した方が良いですか？ ＞＞今後2名以上に増える可能性がある場合、移行した方が良いと思います アクセスは複数でファイルの共有をすると壊れやすいと聞いたのですが2名でもそうでしょうか？ ＞＞開くことが出来なくなるのだと思います 今後は2名が同時にテーブルの更新などを行う予定なのですが その場合はやはりSQLServerに移行した方が良いでしょうか？ アクセスのままでもイケますか？ ＞＞更新するテーブルの項目数にもよります どれ位のスキルをお持ちか解りませんが SQLServerをご存知と言うことでセットアップ、管理ツール、等は、お詳しいのだと思います 後は、移行のほうですが簡単に出来ると思います 単純にウィザードで作成したような一つのフォームでマスターなど参照せず一つのテーブルの数個程度のフィールドを更新するようなシステムならばSQLServerは必要ないでしょう SQLServerは名前のとおり、「SQL」を使用した時、真価を発揮します アクセスではクエリを作成すると自動的にSQLは作成されますが、本格的なシステムになると VBAを使用して、複数のマスタを参照しながら追加、更新、削除などを SQLで、記述し複雑な処理を行います 開発環境では、プロトタイプとして共有フォルダにテーブルを置いて各端末で開発を行い 本番環境でSQLserverに移行するやり方があります。 SQLServerはテーブルの変更が簡単に出来ないので、開発中にテーブルの項目を固めてからSQLserverにエクスポートした方が良いでしょう クエリーは、アクセステーブルで動いていてもSQLserverでは動かない場合もあります
・・・ from Aテーブル　left outer join Bテーブル on A.項目A1 = B.項目B1 where B.項目B2 = 'aa' でなくって、 ・・・ from Aテーブル　left outer join Bテーブル on A.項目A1 = B.項目B1 and B.項目B2 = 'aa' ということでいいはずです。
数値を日付に変えるのは通算日付になるので普通出来ません。つまりOracleでも文字列を日付に変換するはずです。 つまり文字にかえてからこれです。 http://dbhikaku.web.fc2.com/sqlserver_convert.html
OracleだとLag関数があるんですがね。 こちらが元ネタです。 http://www.geocities.jp/oraclesqlpuzzle/sqlserver2008-sql1-olap.html#2-16 with tmp(カラム1,カラム2,カラム3,rn) as( select カラム1,カラム2,カラム3,Row_Number() over(partition by カラム1 order by カラム2,カラム3) from テーブル ) select case when b.カラム1 is null then a.カラム1 else null end カラム1, a.カラム2,a.カラム3 from tmp a left join tmp b on a.カラム1=b.カラム1 and b.rn=a.rn-1 order by a.カラム1,a.カラム2,a.カラム3;
delete from テーブル名 where 日付 <= (select DATEADD(year,(-1),　GETDATE)） で削除出来ませんか
SQL2008 エクスプレスとACCESS2010 の環境ですがJet4.0 OLEDB は 使えています。(64bitではJet4.0 OLEDBは使えないらしい?) 以下のリンクを参考にされて下さい。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1452721059
## Nullじゃなくて''（空文字）が登録されているような気がしますが。。。 ## select case when 変数 is null then 'NULL' when 変数 = '' then '空' else 'OK' end ## from CSVファイル ## でNullと出ずに、空とでたらそうです。 ## 調べてみないと分らないので、それはさておき、 とりあえず、 convert(datetime,変数) のほうは、 case when 変数 is null then null when 変数 = '' then null else convert(datetime,変数) end としたらうまくいくのではないかと思います。 datetime型の変数がNot Null指定でテーブルを作っているとダメですが。
ここでLINQについて質問しても回答は出ないのでは。 C#カテのほうが向いてると思うよｗ LINQは本当に便利。取得だけならSQLなど一行も書く必要ないし、オブジェクトに詰める手間もいらない。 キモは、Group化してまとめたボディ部を、Selectで別の型に変えるところでしょう。 public List<MemberTypes> GetMemberTypes(){ 　using (var dc = new DataContext()){ 　　return dc.MemTypeBinds 　　　.GroupBy(mt=>mt.Member) 　　　.Select(g=>new MemberTypes{ 　　　　member　= g.Key, 　　　　types　= g.Select(mtg=>mtg.Type).ToList() 　　　}).ToList(); 　} } 逆の種別->メンバー（複数）変換も書いてみたｗｗ public List<TypeMembers> GetTypeMembers() { 　using (var dc = new DcHealth()) { 　　return dc.MemTypeBinds 　　　.GroupBy(mt => mt.Type) 　　　.Select(g => new TypeMembers { 　　　　type　= g.Key, 　　　　members= g.Select(mtg => mtg.Member).ToList() 　　　}).ToList(); 　} } 面白いｗｗｗ
Accessのクエリーに相当するものはSQL Serverでは ビュー、ストアドプロシージャ、テーブル値関数に なります。 ビューに関して Accessでいうところの アクションクエリーは作成できません。 パラメータクエリーも作成できません。 Order By句にはTop句が必要で、 SELECT TOP (100) PERCENT とすると並べ替えは保証 されません。PERCENTを削除すれば並べ替えされますが 100の数字をあらがじめ予想される最大レコード数に する必要があります。 SELECT TOP (5000) ・・・・・ ORDER BY ・・・・・ Where句、Group By句は使用できます。 ビューを元にして、別のビューを作成できます。 ストアドプロシージャに関して いろいろできます。クロス集計もできます。 TOP句も必要ありません。ビュー、テーブル値関数を 元にして作成することもできます。 ストアドを元にして、別のストアドは作成できません。 Accessのフォームでレコードソースを パラメータ付きストアドプロシージャにした場合 レコードの編集ができないことがあります。 ビューの利点は他の方が述べている以外に 他のデータベースのテーブルを参照するとき、一旦 ビューで受けておくと、自分のテーブルのように 扱うことができます。
テーブルから別のテーブルへだったら INSERT INTO table1 SELECT cast(aaa as char), bbb, ccc,・・・ FROM table2 WHERE ～～～ こんな感じでできるんじゃないかな～
Access2007 → SQLServer2008 で出来ないものが 後発のSQLServer2012なら、なおさら無理というものでは？ >状況 >この動作は仕様です。 ↑これは、哀しいですねぇ。 なお、Access2013からは、 『アップサイジング ウィザードを使用すると、Access データベース テーブルを新規または既存の Microsoft SQL Server データベースにスケール アップできます。この機能は Access 2013 で削除されました。』 です。 他にも、ひどいと思う変更が幾つか。あんまりだ！ Office 2013 での変更点 http://technet.microsoft.com/ja-jp/library/cc178954%28v=office.15%29
#1 です。 最初のIF の条件に合った場合の処理と 合わなかった場合の処理を明確に区別しましょう。 それぞれを BEGIN END でくくります。 そしてそれらの間に ELSE を記述します。 つまり、以下のように記述します。 IF (@@FETCH_STATUS = 0) BEGIN IF (@column_new_value$19 = 1) update ・・・ ELSE IF (@column_new_value$19 = 2) update ・・・ END ELSE BEGIN IF (@column_new_value$19 = 1) insert ・・・ ELSE IF (@column_new_value$19 = 2) insert ・・・ END いかがでしょう? 元のソースがどうなっているか判りませんが、 ツールも100% では無いと言うことでしょう。
SQL Server は同一マシン上にいくつもインストールすることができる。 SQL Server は DB を管理するサービス (DBMS) なので、同一マシンに複数インストールすれば、同一マシンで複数の DBMS が稼動することになる。 1つめの DBMS で管理されている DB-A という DB があったとして、さらに 2つ目の DBMS にも DB-A という DB があったとしても、1つ目の DBMS で管理している DB-A と 2つ目の DBMS で管理している DB-A は別物である。 これは Windows のフォルダーで考えればわかりやすい。 1つのマシン上には複数のドライブ (C とか D とか) をマウントできる。 各ドライブには当然ながらフォルダーがあるが、C:\hoge と D:\hoge という 2つの同じ名前のフォルダーはドライブが違うので別物である。 で、本題。 同一マシン上に複数の DBMS をインストールする場合、それぞれの DBMS のインスタンスに名前をつけて区別する。 ただし 1つの DBMS しか稼動させない場合は名前をつける必要がない。これを 「既定のインスタンス」 と呼ぶ。 既定のインスタンスが稼動しているマシンに 2つ目の DBMS をインストールする場合、すでに稼動している既定のインスタンスと区別するために何か名前をつける必要がある。これが 「名前付きインスタンス」 である。 ただし DBMS を 1つしか稼動させない場合でも、何が何でも既定のインスタンスにしなくてはならないわけじゃなく、名前をつけてやってもかまわない。 例外として、SQL Server の無償版である Express Edition は、通常は名前付きインスタンスとしてインストールされる。 名前付きインスタンスを指定せずにインストールした場合は、既定の名前付きインスタンスである SQLExpress が使用される。
JPN\x64\SQLEXPRADV_x64_JPN.exe をダウンロードすれは間違い無いです。 これには全ての機能が入っています。 インストールの時に選択してください。 リンク先をちゃんと読めば違いが書いてありますよ。 単に DBだけが必要で他の機能は不要なったら JPN\x64\SQLEXPRWT_x64_JPN.exe でも良いかもしれません。
間違ってはいません。 しかし浮動小数点データは概数であるため、データ型の範囲に含まれるすべての値を正確に表せるわけではありません。 SQLServer 2008 などの概数型は IEEE754 仕様に従っています。 概数型では、多くの場合、指定されたとおり正確な値が格納されません。正確な値にきわめて近い概数が格納されます。多くのアプリケーションでは指定した値と格納される概数のわずかな差は問題にはなりません。ただし、その差が問題になる場合もあります。float 型と real 型にはこのような概数の性質があるので、財務アプリケーション、丸めが行われる演算、等価性のチェックなど、正確な数値動作が必要な場合には、これらのデータ型を使用しないでください。 代わりに、int 型、decimal 型、money 型、smallmoney 型を使用することをお勧めします。 実際にはどういうことなのか、多少極端ですが、例を上げてみましょう。 いま、ここで新しいCPUを構想していて、4ビットで 0.00～4.00 までの実数を表現するものを考えているとします。 この例題で、4 ビットのうちの上位2ビットを 1の位、下位2ビットを小数点以下の位にすると仮定した場合、小数点以下は2ビットしかありませんから、2進数の 00 を 0.00、2進数の 01 を 0.025、2進数の 10 を 0.05、2進数の 11 を 0.075 と表現する合計4つのみとなります。そして、1の位は 0、1、2、3 です。 この範囲で表現できる数値では正確な4は表現できませんが、概数として表せば、3.75 が一番4に近い数値となるわけです。 実際にはもう少しビット数が多いわけですが、おおむねこのような仕組みで実数が表現されています。
土地テーブルと家屋テーブルは、同一所有者ＩＤで同一取得日で複数のレコードがあってもおかしくない はずだけれども、テーブルの項目がないので、ないと仮定しましょう。 （あったら以下のSQLではうまく結果はでません。） select a.所有者ID,a.所有者名 as 名前,b.土地取得日,b.面積,c.家屋取得日,c.延床面積 from 所有者テーブル a, (select b2.所有者ID,b2.取得日 as 土地取得日,b2.面積, ROW_NUMBER() OVER(PARTITION BY b2.所有者ID ORDER BY b2.取得日 DESC) as No from 土地テーブル b2) b full outer join (select c2.所有者ID,c2.取得日 as 家屋取得日,c2.延床面積, ROW_NUMBER() OVER(PARTITION BY c2.所有者ID ORDER BY c2.取得日 DESC) as No from 家屋テーブル c2) c on b.所有者ID = c.所有者ID and b.No = c.No where a.所有者ID = case when b.所有者ID is null then c.所有者ID else b.所有者ID end という感じでできるはずです（未検証）
インストールはうまくいきましたか？ あと、システム用件は満たしていますか？ WindowsXPの場合、 SP1とSP3がセットされている事が条件とのことです。
アプリケーションからはどのような接続方式なのでしょう？ VBとかのアプリケーションであれば何もせずに移行できる場合もあります。 面倒そうなのは、 ・システムテーブルを直接操作している　→　方法が少し変わった ・DBCCコマンドを使用している　→　T-SQLに変わった （互換性レベルを90以上にする場合） ・外部結合演算子を使っている　→　OUTER JOINに変更する必要がある ・ORDER BYでテーブル名にプレフィックスを付けていたりする　→　エラーになる これに該当しなければ、そのまま動くかもしれません。
クエリA側にダミーの項目を1つ増やすのであれば以下の様にすればよいと思います。 クエリA select 　　A.Col1 　　,A.Col2 　　,A.Col3 from A クエリB select 　　B.Col1 　　,B.Col2 　　,B.Col3 　　,B.Col4 from B としてUNIONするとこうなります。 select 　　A.Col1 　,A.Col2 　,A.Col3 　,'' AS Col4 from A union all select 　　B.Col1 　,B.Col2 　,B.Col3 　,B.Col4 from B
select TOP A,B,C From test WHERE ・・・ Order by A,B,C でTOP行をとっているとして select TOP A,B,C From test WHERE ・・・ Order by A desc,B desc,C desc ※desc は逆順指定。 で最終行がTOPにくるはずなので、この２件を取得すればいい。 １回のSelect文にしたいなら、 select * from (select TOP A,B,C From test WHERE ・・・ Order by A,B,C) union select * from (select TOP A,B,C From test WHERE ・・・ Order by A desc,B desc,C desc) order by A,B,C で、TOP、最後の順に取れると思いますが。 注：TOPを使っているselect文をunionしようと思うと副問い合わせにしないといけないみたい。。。
＞SET @GetRand = CAST(RAND()*10 AS numeric(1,0)) RAND()*10の値が9.5以上だと破たんする（＝丸められて10になる。）ので、floorするとか。
こんな感じでどうでしょうか。 select C1, C2 from T_TABLE order by case when C2 = 'XY' then 1 when C2 = 'XZ' then 2 when C2 = 'XX' then 3 else 4 end, C1; SQL Serverの環境がないので動作確認はしていません。
select * from table where (A = 'inputed A ' or 'inputed A ' is null ) and (B = 'inputed B ' or 'inputed B ' is null ) and (C = 'inputed C ' or 'inputed C ' is null ) ただし、SQL Serverは null と　''は別扱いだったと思うので、 入力された結果が、''なら、is null は　= ''　としてください。 'inputed A '、'inputed B '、'inputed C 'は入力された文字列を直接編集してもいいし、 ホスト変数にしてパラメタ渡しにしてもいいです。
エラーとなる理由は、スタンバイ解除後の、フォームのクリックイベント時に実行され保存した変数等が、クリックイベント終了時に全て無くなるからです。この現象をスコープから外れる等と言います。 参考url : http://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97 ちなみに、何らかの処理中にスタンバイ等になりネットワークが切断されてしまった場合は、そこでエラーとし、アプリケーションを強制終了し、再度、最初から実行させるのが一般的です。 ※そうしないと、データベースの整合性が崩れてしまう可能性があるため。
私の知る限りですが、すでにあるカラムにIDENTITY属性は付加できません。
> DBCopyTool.exe これは使ったことが無いのでわかりません。 > また当初の希望内容を実現するため、他の方法があれば　 DTS（Data Transformation Services）を使う、ではダメですか？ 直接接続がダメでも、Textなり、MDBなりにデータ変換するツール（双方向）。 参考ＵＲＬ：MicrosoftさんのWebページ [SQL Server 2008 R2 における SQL Server 2000 DTS のサポート]
参考URLに以下記載がありますので、2012でアタッチ可能です。 コピーまたはデタッチした SQL Server データベースはアタッチできます。 フルテキスト カタログ ファイルを含む SQL Server 2005 データベースを SQL Server 2012 サーバー インスタンスにアタッチする場合、カタログ ファイルは SQL Server 2005 と同様に他のデータベース ファイルと一緒に以前の場所からアタッチされます。 詳細については、「SQL Server 2005 からのフルテキスト検索のアップグレード」を参照してください。 ファイルをコピーして、アタッチする場合は問題は無いと思います。 HDDをくっつけてとなると、多少問題があります。 ディレクトリやファイルのWindowsアクセス権限が旧サーバー（OS）を引き継いでしまっており、 新しいサーバー（OS）のアクセス権限を付与してあげる必要があります。 権限を付与してあげれば、アタッチできるようになります。 蛇足となりますが、 ちなみに、SQL ServerのStandard Editionは、Windows Server OSにしかインストールできないので、Windows 7や8などのクライアントOSにはインストールエラーになるので注意してください。
alter table Test_table alter column name nchar(20)
SQL Server 2008 Expressを既定のインスタンスとして作成すると、インスタンス名がSQLEXPRESSとる仕様になっています。 検証していないので不確かですが、 SQL Server 2008 Expressを名前付きインスタンスを選択し、名前に「MSSQLServer」を入力しインストール すると希望されているサーバー名のみの接続が可能になるかもしれません。 ちなみに、SQL Serverはインスタンス名無しではインストールできません。 普段サーバー名だけで接続できているのは、裏側で既定のインスタンス名である「MSSQLServer」を自動保管しているのです。 例えばtestサーバーに、製品版の既定のインスタンスをインストールしたとします。 Management Studioで、接続先に「test」と入れて接続を試みると、 裏側で、「test\MSSQLServer」と解釈しているのです。 インスタンス名が「MSSQLServer」以外の場合は、ユーザーが指定する必要があるのです。 ですので、Expressの場合、あえて名前付きインスタンスを選択し、「MSSQLServer」でインストールすると結果的に、上記動作にのっとり、サーバー名だけで接続できるようになるかもしれません。
select cast( DeviceTime as date ) as 日時, DeviceID as 端末番号, max(DeviceValue) as 計測最大値 from テーブル名 group by cast( DeviceTime as date ), DeviceID order by 日時,端末番号
えーと、たぶんSQL Server Compact Edition 3.5は、ASP.NETに対応していなかったと思います。 対応したのはFramewok 4のASP.NETからかな？ 3.5CEはLINQのデータソースとして選択できるけど使えないと思います。 あと、SQLServer CE（3.5、4とも）は、Visual Studioと別製品。WebMatrixなんかだったらインスコされるけど、Visual Studioだけだと入らないよ。 インストーラがあるので、そちらからダウンロードしてインストールしてみてください。
「受付日をステータスが一番小さな管理番号 でグループ化し、表示することはできますでしょうか？」 　管理番号でグループ化した時点で、最小のステータスは抽出できますが、受付日はどのデータが抽出されるかは不定です。 　なので、一旦ステータスと受付日を連結して、一つの項目（抽出用）にしてしまい、その最小値を抜き出してはどうでしょう？ SELECT 管理番号, Min(ステータス & 受付日) AS 抽出用 FROM ステータステーブル GROUP BY 管理番号 　こうすれば、以下のデータが抽出できるので、これを一旦テーブルに出力し、あとは、「抽出用」の項目の先頭２桁と残りの受付日に分割すれば、良いのではないでしょうか？ 管理番号抽出用 502035302012/09/25 502036102012/09/28 502037102012/09/29
ユーザー定義のストアドプロシージャ、ストアドファンクションで可変長引数は困難な気がします。 1引数を文字列で渡して、ストアド側で動的にSQLを組み立て実行するようなものならできるかもしれませんが。
Ｅｘｃｅｌには型というものがかなりあいまいです。同列でも行によって違っていたりしますよね。見た目は同じでも内部的にはダメという事です。これを治すには式などで同じ型に治すなど必要ですが、つまり参照列の隣にもう一列作成し、そこを変換式にする方法です。 まあほとんど手作業の部分もあると思いますが、excelでは型管理は出来ませんので、最初からＡｃｃｅｓｓとかにしておく方がよいです。 それともＳＱＬ側のテーブルをすべてVarCharにしておいてテキストとして取り込むかですが、これでも結局ＳＱＬ側で数値変換ＳＱＬを作る必要はあります。
Selectが メモリを大量に消費しているので ２個同時に実行したら実メモリが不足して仮想メモリを使ってしまうので遅くなるとか tempdbを大量に消費するので、消費したtempdbの中のオブジェクトを開放するまで次の処理 （サブクエリ等のおのおのの処理）が待ち状態になっているとか。 SQL Server2000の管理ツールとかがどんな内容を見ることをできたか覚えていませんので 調べる方法をアドバイスできませんが。 ためしにtempdbのサイズを大きくしてみるとか。 ・・・自動拡張する設定（ができたかどうかは覚えていませんが）になっていて、 自動拡張を何回も行っているなら、それも遅くなる原因になります。 参考：tempdb http://msdn.microsoft.com/ja-jp/library/ms190768.aspx この記載の中にある 「・・・以下のものを保持するために使用されます。 （中略） ・スプールまたは並べ替えのために中間結果を格納するための作業テーブルなど、SQL Server データベース エンジンが作成する内部オブジェクト。」 というので使っていそうです。 ## あてずっぽうですので、あまり期待しないで確認してみてください。
確かインストールしてから変更していなければ、 SERVERPROPERTY ( 'servername' )と同じところを見ていたと思うので、 nvarchar(128) http://msdn.microsoft.com/ja-jp/library/ms174396(v=sql.90).aspx より。 心配なら、 nvarchar　とのみ設定しておけば？ http://msdn.microsoft.com/ja-jp/library/ms187944.aspx より なお、SQL Server2000 と仕様が変わっていた項目だった記憶があります。
こんばんは、はじめまして。 うーん…それだけだと何とも言えませんので、 とりあえずＳＱＬ文を全文載せてみてはいかがでしょうか。 挿入する値の順番が誤っているとか、 そんなことはありませんよね？
エラーメッセージそのものだけど、 インサートしようとしているデータに外部キー違反があるため、インサートできなかったってこと。 ・インサートをあきらめるか、 ・別の値をつけてインサートするか、 ・キーの設定を変えるか
とりあえず、あいまいなところをなくしてみては？ UPDATE T1 SET T1.[CustName]=T2.[CustName] FROM [Tab] T1 INNER JOIN [Tab] T2 ON T1.[Cd]=T2.[Cd] WHERE T1.[Sys]='S2' AND T2.[Sys]='S1' ※テストしていません。ＳＱＬ２００５用のコードを参考にしました。
SQL SERVER 2008 R2、 PostgreSQL 9.1(cygwin）で試したところではrow_number()のover句でのオーダー順で出力されました。 実行計画をみても、WINDOWSソートの後はシーケンス処理のみということで今の実装上ではover句の指定順になると思われます。 なお、SELECT文の最後にORDER BYでROW_NUMBER関数の値を指定したところ、SQL SERVER 2008 R2では無視（最適化）され、PostgreSQLでは実行されるようです。 ただし、SQLの規格としてはおそらくover句順を保証してはいないと思います。
>string 変数にどんどんと長いクエリを書いてしまいがちです SQL文の中に改行コードを含めてもかまわないので、 適当なところ（項目名の次とか、命令の次とか）に改行コードをプログラムで入れても問題ないので 私はプログラムでstring 変数中にクエリを書いている処理の最中にところどころで、 string 変数中に改行コードを入れることをしていますが。 C#は使わないので例えばVBとかでは dim sqlstr as string sqlstr = "Select * from tableA" & vbcr &vblf sqlstr = sqlstr & "where tableA.A1 = '" & wkstr1 & "'" & vbcr &vblf sqlstr = sqlstr & "order by " & wkstr2 & wkstr3 & wkstr4 といった具合。 ## whereの中はホスト変数にしたほうがいいけど・・・ま、サンプルということで。
主キー項目でないなら update テーブル名 set コード = '0' + コード
ライセンスについてここで質問しても何の保証もない。 質問をするならマイクロソフトかマイクロソフトのパートナー企業にすべき。 SQL Server に関するご相談窓口 http://www.microsoft.com/ja-jp/sqlserver/2008/r2/howtobuy/inquiry.aspx
主キーが無いのでは？ AccessでODBC接続のリンクテーブルは 主キーがないと更新可能になりません。
SELECT … FROM Ａ Right Outer Join Ｂ Ｂ on Ｂ.c =Convert(varchar(10),Ａ.d) varchar(10),は、 Ｂ.cの型にあわせる。 ただし、 今までは暗黙の型変換で、数値に変換されていたから条件が成立していたケースで条件が成立しない 場合がでてくるかもしれません。 例） Ｂ.cが' 1'で、Ａ.dが1のとき、 数値に変換されると、どちらも1ですが、 文字に変換すると、 Ｂ.cが' 1'で、Ａ.dが'1 'になって等しくならないかも。 というようなことがおきたら、 on trim(Ｂ.c) = trim(Convert(varchar(10),Ａ.d)) trim()を利用してください。
補足ありがとうございます。 ということは >001　　AAA　　DDD があって >NULL　 AAA　　DDD もあるというのは間違っていますよね。 ですので、以下のデータと結果を正として考えます。 --データ 001　　AAA　　BBB 001　　AAA　　CCC 001　　AAA　　DDD 002　　AAA　　BBB 002　　AAA　　CCC NULL　 AAA　　EEE --DDDをEEEに変えました NULL　 AAA　　BBB NULL　 AAA　　CCC --結果 001　　AAA　　BBB 001　　AAA　　CCC 001　　AAA　　DDD 002　　AAA　　BBB 002　　AAA　　CCC NULL　 AAA　　EEE 以下のSQLでどうでしょうか。 select 種類,キー1,キー2 from ( 　select 種類,キー1,キー2,count(*) over(partition by キー1,キー2) cnt 　from ( 　　select 種類,キー1,キー2 from Table1 　　union select 種類,キー1,キー2 from Table2 　　union select 種類,キー1,キー2 from Table3 　) ) where 種類 is not null or cnt = 1 order by 種類,キー1,キー2; 全角スペースでインデントしているので、実行時には削除するか半角スペースに置き換えるなどしてください。
>作業に漏れはないか？ 新旧でホスト名が変わるとありますが、クライアント側の接続ホスト名の変更は必要ないですか。 >システムデータベースのバックアップ・復元は必要でしょうか？ 事件が起きる可能性があるのでやらない方が無難です。 >トランザクションログのバックアップ・復元は必要でしょうか？ 移行の間システムを停止しておかないと、データーの整合性が取れなくなるので、基本的には不要です。 >インデックス・View・ストアドプロシジャも復元できますでしょうか？ 棚卸も兼ねて、構築環境を作られる事を推奨します。 >その他漏れや注意点などありますでしょうか？ 単にリプレスと言っても新サーバーが問題なく動く保証は全くありません。その意味で数日を掛けて確実にリプレスする事を推奨します。 私の行った方法は、新サーバーに新しい環境を構築し、データベースに関してはプログラムを作って、毎晩旧から新にテーブをコピーする、クライアント側は新サーバー用接続のプログラムを別に用意し、利用者に動作確認を依頼する。全部署で問題無いとの回答をもらった時点で、夜間のシステム利用を一時停止してもらい、その間にテーブルをコピーし旧サーバーを停止、その後新サーバでの業務を開始してもらう。
SQL Serverには先頭のゼロを取る関数はないので、プログラムで対応された方が良いと考えます。 >「こういうことはデータベースではできないよ」 基本的には、関数で提供されている範囲の加工しか出来ないので、複雑な事はほとんどできません。 >「こういうことはデータベースでないとできないよ」 データベースでできる事はプログラムで全て出来ます。
SELECT ID,MAX(列) AS 最大値 FROM (SELECT ID,列1 AS 列 FROM テーブル UNION ALL SELECT ID,列2 AS 列 FROM テーブル UNION ALL SELECT ID,列3 AS 列 FROM テーブル UNION ALL SELECT ID,列4 AS 列 FROM テーブル UNION ALL SELECT ID,列5 AS 列 FROM テーブル) AS TBL GROUP BY ID ORDER BY 1 でどうでしょうか。
ANo.1のお礼に記載の質問について。 RAID1化されているHDDは、通常のOS上の操作では1台のHDDにしか見えません。なので片方が壊れてもそのまま動き続けられるんですよ。RAIDのシステムが自動的に裏で2台に書いているので。
>ただ、データの同期（という表現が正しいのかわかりませんが・・）をとる >ということにおいては、どちらも同じということでよろしいでしょうか？ ミラーリングと言う本来の２重化の意味では同じですが、目的が異なりますので全く同じとは言いにくいです。 >また、トラブル発生時の復旧作業においては、どちらの方が良いのでしょうか？ トラブル対策の対象が異なりますので、どちらが良いか悪いかは一概には言えません。一方が停止して他方が生きている場合はSQL　Serverの場合は接続して処理中のプログラムは異常となってしまう危険は有ると思われます。（実際に実験したわけではないので正確にはわかりませんが、接続中のサーバーに異常が出た場合の完璧な対応は無理と考えます）一方、RAIDのミラーリングはプログラムには何の影響も与えません。
こんにちは。 ネットワークドライブへのアクセス権限が不足していると思います。 xp_cmdshellストアドプロシージャーについては、 SQL Serverのサービスアカウントの権限で動作します。 参考URLの説明の部分に、 「xp_cmdshell で起動した Windows のプロセスには、 　SQL Server サービス アカウントと同じセキュリティ権限が与えられます。」 との記載があります。 SQL Serverが動作するサーバー以外のファイルサーバーや、 ネットワークドライブにアクセスしたい場合、 サービスアカウントに対して、 ファイルサーバーやネットワークドライブ側での権限設定が必要になります。
ちょっと環境がないので動作確認まではできませんが… insert into A　(columna, columnb, columnc) (select columna, 1, columnc from B) でどうでしょうか。 サブクエリのselect句で、型の違う列（この場合columnb) の部分に１を取得する方法で可能かと思うのですが…。 insert select などで検索するとわかりやすいサイトが出てくると思います。
そのケースにのみに限って言えばコストは同じです。これは実行プランを表示してみればわかります。 通常はIN句を使うのは条件の値が外部にある場合や可変な場合、一致するものがない場合でも使用できるといった理由からです。 そうした場合は値の数や外部テーブルのインデックスの有無などでパフォーマンスやクエリのコストは変わってきます。
条件分岐を使わないように書くと '金額' + REPLICATE('0', @len-LEN(@ix)) + CONVERT(varchar, @ix) こんなかんじでしょうか。 @lenは文字として出力したい数字部分の桁数です。 記載いただいている例であれば2を設定します。
はい。PKは 主キー(primary key)の略として一般的に用いられていますから，その理解でよいと思います。
サーバ上にmdbファイルを置いて クライアント上のAccessからネットワーク経由で共有されたサーバ上のmdbファイルを開く というaccessで時々やっているのを見かける方法をイメージして考えていませんか？ SQL Serverは普通、こんなことはしません。（理由は後述） 1.サーバ機上で、SQL Serverを常時動かしておきます。 (当然、データファイルもこのSQL Serverからアクセスします) 2.クライアントとサーバの通信は、TCP/IPを利用します。 （後述のODBCやADOがTCP/IPの通信をします。） 3.クライアントからは、ODBCやADOその他の方法で、SQL言語を使って、SQL Serverとアクセスします。 4.ODBCやADOは、AccessやEXCEL、ExcelのVBAやVB.2008、C#その他の開発ソフトから利用できます。 ということで、 >・それぞれの端末からサーバーが共有できるが、端末同士で互いに繋がることは出来ない。 それぞれの端末からサーバーが共有できる必要はありません。 ただし、SQL Serverと接続するためのポートがウイルス対策ソフトなどでブロックされていないこと が必要です。 >このような場合、まずはSQLserverをサーバーにインストールするのでしょうか？ まず、サーバ上にSQL Serverをインストールします。 >そもそもNTFSにインストールって…？ NTFSだろうが他のファイルシステムだろうが、ファイル共有するわけではないので関係ないです。 >それとも端末のSQLserver2008があれば、データ保存先でサーバーを選択して、 >他のPCから同じデータを操作できるものなのでしょうか？ 端末のSQLserver2008で、データファイルをネットワークドライブ（サーバー）上のファイルを 指定できなくはないと思いますが、ネットワーク経由にすると異常に遅いのと、 利用前に、SQLServerを起動して、利用後にSQLServerを停止しないとダメで、 停止していないと排他がかかって他の端末から利用できない。 ということ、使用前使用後で数分ずつかかり、なおかつ処理が遅いという、使い物にならない結果が 待っています。。。こんなことはしないことをお薦めします。 ## という説明でイメージくらいはつかんでいただけたかと。。。
＞特に指定していなくても、No（PK）の順になるのかと思っていました。 下記のリンクに「ORDER BY 句が指定されていない限り、結果セットとして返される行の順序は保証されません。」と書いてあるので実際、保証されていないのだと思います。 http://msdn.microsoft.com/ja-jp/library/ms188385.aspx で、実際にどういう順番で返ってくるのかはインデックスの種類（クラスタかどうかなど）や設定状況によって変わってくるのでケースバイケースだと思います。
確かに「なぜ」なのかは不明ですが、情報が足りないのかも知れません。（SQLServer、Excelのバージョンやデータの中身等） 現状、質問から読み取れる内容でやってみた画像を添付しておきます。 ちなみに、SQLServer2008、Excel2003です。 画像中の「B列」が数値と文字データが混在する列です。当方では「'」がないデータはDoubleと認識しますが、「'」を付けたデータではVarCharと認識されました。
こんにちわ。 Windows認証方式ということで、前提として、問題のWin7PCのWindowsログインユーザーがSQLServer2005 Express が稼働しているPCに適切な権限のグループ（Administrator等）に登録されているかどうかご確認されましたでしょうか？ 切り分けとして、一時的にデータベースの認証方式をSQLServer認証との混合方式にして接続が可能であれば、Windows認証の問題と言えるのではないでしょうか。 それでWindows認証の問題となった場合にWin7PCとSQLServer2005 Express が稼働しているPCとのユーーザー登録状況を記載されると問題の有無が判断できる情報になるかと思います。
参照URLに自習書があります。参考にしてみてください。 ディストリビュータとサブスクライバを同一サーバーで実行するのは 普通やりません。そういう設定ができるかどうかは知りませんが... この場合はパブリッシャとディストリビュータを同一サーバーで実行するのが普通です。 >また、Server1は更新用アプリが使用、Server２は参照用アプリが使用などといったことはできるのでしょうか？ これができなかったら、レプリケーションする意味がありません。当然できます。
懐かしいですね、SQL Server 7。 ちょっとメニューがどうだったか覚えていないのですが、バックアップをファイル単位（データまたはトランザクション）でできるのであれば、トランザクションファイルだけをバックアップすれば、トランザクションログの使用領域は小さくなります。その上でトランザクションファイルの圧縮をすれば、ファイルとしての実体は小さくなります。この手順は現在のバージョンでも変わりありません。 あとは復旧モデルを「完全」以外にする、別のバージョン（たとえば無償の2008 Expressなど）に復元してみるなどが考えられます。 サーバーの設定の影響もあるかもしれないので、可能であれば、サーバーAで同じ作業をして小さくなるのを確認してからフルバックアップしたものを復元した方が確実かと思います。 あと、試したことはないのですが、LDF（トランザクションファイル）は実データではないので、一度デタッチしてLDFを削除し、同名のLDF（新規のデータベースを作って同名のLDFを作成、ファイルの新規作成で0バイトのテキストファイルをリネームして～.ldfで保存など）を作ってアタッチすることもできると聞いたことがあります。以前SQL Server 2008でそれを試したらうまくいかず、さらに元のLDFを削除してしまったためにどうにもならなくなった思い出があるので、試すのであれば削除ではなく別の場所に退避しておくことをお勧めします。
ANo1です。 なんか、sysobjects と procedures とをごっちゃにしてました。 SELECT * FROM sys.procedures WHERE schema_id NOT IN (schema_id('sys'), schema_id('INFORMATION_SCHEMA')) ORDER BY name の結果なんかはどうでしょう？ sp_creatediagram、sp_alterdiagram、sp_dropdiagram そのたデータベースダイアグラム関連のストアドプロシジャが まざるようですが。 where句に AND (name NOT LIKE 'sp_%diagram%') とつけたら使えそう（但し、ユーザプロシジャが同じ系統の名前になっているとダメですが。）
あのー。サーバーアカウントはサーバーでしか認識しません。多分ローカルのPcアカウントでPCに入っているのです。それはPC名\ユーザー名。 サーバー名でローカルPCに入るにはドメインを立てるしかありません。 ドメインにPC を参加させ、ドメインにユーザー登録をして、そのアカウントでPCに入る。同じユーザー名にしても、サーバー名がつくので違うユーザーです。そのユーザをSQLに登録すればwindows 認証で入れます。
こんな感じでしょうか？ この場合は、内部ではなく外部結合にして都道府県テーブルを 別名で３つ開けるという形になると思います。 SELECT Customer.* 　　 , Pref1.PrefName as PrefName1 　　 , Pref2.PrefName as PrefName2 　　 , Pref3.PrefName as PrefName3 　FROM Customer 　LEFT OUTER JOIN Pref Pref1 　　ON Customer.CustomerPref1 = Pref1.PrefId 　LEFT OUTER JOIN Pref Pref2 　　ON Customer.CustomerPref2 = Pref2.PrefId 　LEFT OUTER JOIN Pref Pref3 　　ON Customer.CustomerPref3 = Pref3.PrefId WHERE CustomerId = 123
SELECT F_No FROM (SELECT DISTINCT F_No,F_Kaisu FROM テーブル名 WHERE F_Memo IS NOT NULL)AS T GROUP BY F_No HAVING COUNT(*)<>MAX(F_Kaisu) ORDER BY 1 です。
SELECT 支給割合,CASE WHEN 進捗='完了' THEN ISNULL(粗利,0) *支給割合 ELSE NULL END AS 支給分 FROM (SELECT CASE WHEN 種別='A' THEN 0.5 ELSE 0.3 END AS 支給割合,進捗,粗利 FROM dbo.取引マスタ)AS T です。
BEGIN TRANSACTIONを実行しない場合は、自動コミットされます。
#3 です。#4 さんとほとんど同じですが、その後気付いたのが MAX を使う方法でした。 SELECT NAME, ICHI, MAX(CASE WHEN ITEM = 'D2' THEN DATA ELSE NULL END) AS DATA_D2, MAX(CASE WHEN ITEM = 'D3' THEN DATA ELSE NULL END) AS DATA_D3 FROM TEST a WHERE NAME = 'A' GROUP BY NAME, ICHI ;
・@@IDENTITYは直前のIDENTITY列の値です。INSERT INTOする場合に使う物ではありません。 ・SET IDENTITY_INSERTはリストア時など，明示的にIDENTITY列に値を入れたい場合に使います。 というわけで，このクエリは， INSERT INTO members (seibetu, name) VALUES ('男', 'すずき') のみでよくなります。 # SET IDENTITY_INSERTは不要。
> １．トランザクション開始 > ２．テーブルAをUPDATE > ３．色々な処理(省略) > ４．テーブルＡのUPDATE前の情報を参照 同一トランザクションでUPDATEしてから更新前の情報を取得しようとすること自体無理があるように思えるのですが。 SELECT UPDLOCK でデータ取得してから更新処理を行うのが妥当ではないですか。
select s1 from テーブル名 where code in ( 0, 1) group by s1 having count( distinct code ) > 1 でどうでしょう。
A1, B1, C1の型は何ですか。 こちらで試した結果から，A1の型がINT型になっているのではないでしょうか。 ---- TEST ---- DECLARE @table1 TABLE ( A1 DECIMAL, B1 DECIMAL, C1 DECIMAL ) DECLARE @table2 TABLE ( A1 INT, B1 DECIMAL, C1 DECIMAL ) DECLARE @table3 TABLE ( A1 DECIMAL, B1 INT, C1 DECIMAL ) DECLARE @table4 TABLE ( A1 DECIMAL, B1 DECIMAL, C1 INT ) DECLARE @table5 TABLE ( A1 INT, B1 INT, C1 DECIMAL ) DECLARE @table6 TABLE ( A1 INT, B1 DECIMAL, C1 INT ) DECLARE @table7 TABLE ( A1 DECIMAL, B1 INT, C1 INT ) INSERT @table1 VALUES ( 20, 10, 50 ) INSERT @table2 VALUES ( 20, 10, 50 ) INSERT @table3 VALUES ( 20, 10, 50 ) INSERT @table4 VALUES ( 20, 10, 50 ) INSERT @table5 VALUES ( 20, 10, 50 ) INSERT @table6 VALUES ( 20, 10, 50 ) INSERT @table7 VALUES ( 20, 10, 50 ) select 1, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table1 UNION ALL select 2, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table2 UNION ALL select 3, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table3 UNION ALL select 4, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table4 UNION ALL select 5, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table5 UNION ALL select 6, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table6 UNION ALL select 7, 3 / ((1 / (A1 + 1) + 1 / (B1 + 1)) + 1 / (C1 + 1)) as HARMEAN from @table7 (列名なし)HARMEAN 118.97101449275362318 227.14516129032258064 344.62500000000000000 421.65625000000000000 5153.00000000000000000 633.00000000000000000 763.00000000000000001
はい，近年の開発言語としてオブジェクト指向プログラミング言語は一般的ですから，SQL Serverなどのデータベース製品もオブジェクト指向プログラミング言語で開発されていると思います。
・Accessの場合 SELECT IIF(data1,1,0)+IIF(data2,1,0)+IIF(data3,1,0)+IIF(data4,1,0) AS 個数 FROM TABLE ・SQL Serverの場合 SELECT CASE WHEN data1 THEN 1 ELSE 0 END+CASE WHEN data2 THEN 1 ELSE 0 END+... AS 個数 FROM TABLE もしかしたら、単純に SELECT data1+data2+data3+data4 AS 個数 FROM TABLE でもOKの場合もある。
UPDATE テーブルＡ SET Point2=Point WHERE SEQ=1 AND Point!=99 UPDATE テーブルＡ SET Point=ROUND(Point2,0) WHERE SEQ=1 AND Point=99 AND Point2!=99.0 の２個のSQLで出来ます。
SQL Server2003 ならisql かosqlを使ってバッチ処理化しますが、 （SQL Server2005以降はsqlcmd） 今は、結果をCSV保存するってどうやっているのでしょうか？ SQLを実行するだけでは、CSV出力はできないはずで、どんな方法を使っているのかな という点です。 ※現在の質問内容では、 例えば、batファイル作ってその中で isqlで、CSV形式で出力するSQLを実行してリダイレクトでファイルに書き込むという方法が 使えますけど、どこをどう説明すれば分かってもらえるか不明なんです。
関係ないかもしれませんが、 BEGIN TRY 　　★ 　　BEGIN TRY 　　　　▲ 　　END TRY 　　BEGIN CATCH 　　END CATCH CATCH ↑ここにBEGINが必要では？ END CATCH というのは置いておいて、 本当に、 ★の位置だとテーブルのドロップはCATCH できるのですが ▲の位置だとテーブルのドロップはCATCH できないようですが、 となっているのでしょうか？ BEGIN TRY 　　★ 　　BEGIN TRY 　　　　▲ 　　END TRY 　　BEGIN CATCH 　　　　※１ 　　END CATCH BEGIN CATCH ※２ END CATCH となっていたら、▲でテーブルがdropされていてエラーになったら、※２が実行されていると 思われるのですが。 ★と▲両方に別のテーブルを使ったselect文を入れてみてそれぞれのテーブルがdropされた状態で 試してみられては、と思います。 理由 ▲で使用しているテーブルがないときに、 　　BEGIN TRY 　　　　▲ 　　END TRY 　　BEGIN CATCH 　　　　※１ 　　END CATCH がコンパイルエラーになるので、※２のほうのcatchが処理される。 と思いますが。 参考； http://msdn.microsoft.com/ja-jp/library/ms175976.aspx の ---引用--- TRY ブロック内の下位の実行レベル (たとえば、sp_executesql またはユーザー定義のストアド プロシージャを実行しているとき) でのコンパイル中またはステートメントレベルの再コンパイル中にエラーが発生した場合、そのエラーは TRY...CATCH 構造よりも下位のレベルで発生し、関連する CATCH ブロックによって処理されます。 次の例は、SELECT ステートメントによって生成されたオブジェクト名解決エラーが TRY…CATCH 構造でキャッチされず、同じ SELECT ステートメントをストアド プロシージャ内で実行した場合には CATCH ブロックでキャッチされることを示しています。 （以下例文が載っていますが省略） ---引用ここまで--- ・・・マニュアルベースで実際には試していないですが。
insert into テーブルB(会員NO,SEQ,Rank) select a.会員ＮＯ,'7','1' from テーブルＡ as a where SEQ = '1' and Point <> '99' ん？単純に、こういうこと？？？ ただし、 ・一発処理。（定期実行なんぞ考慮してないです。データを用意する目的で、全部データがそろってる状態～で最初に一発だけ流すようなもんです。 ・重複なんぞ考慮してない。（だからこその一発処理。ではあるけど。ついでに言うと、テーブルＢで会員Noでプライマリとってあったりしたら入らないけどね。うん。（まぁ、クエリ実行後のテーブルBを見た限りは、大丈夫か。うん。 定期処理にしたりするのなら、not existsとかでも使ってやる必要があるかと思います。 まぁ、 select a.会員ＮＯ,'7','1' from テーブルＡ as a where SEQ = '1' and Point <> '99' とりあえず、コレだけで実行してみてください。
テストのために以下の項目を持つ「テーブル:日付テスト」を作成し、実証してみました。 　1.[インデックス] ⇒数値型 　2.[日付] ⇒日付型 データには 2012-03-01 00:00:00.000 ～ 2012-05-01 00:00:00.000 までの日付の値を持つデータを追加しました。 質問されている３０日前までのデータを抽出するという条件を満たす条件としては (本日=2012/04/23)として、範囲は 2012-03-24 00:00:00.000 ～ 2012-04-23 23:59:59.999 までとなります。 ですが、実際に重要なのは日付のみであり、時間(hh:mm:ss)は必要ありません。 そこでまずは「項目:[日付]」を「YYYYMMDD」の数値型に変更する事を考えます。 その際の記述としては 　CAST(CONVERT(VARCHAR,[日付],112) as BIGINT) となります。上記の記載でどのように値を変更しているかというと、 １．CONVERT(VARCHAR,[日付],112)で 　　日付型(例:2012-03-01 00:00:00.000)を文字列型(例:20120301)に変換しています。 ２．さらに大小比較を正確に行うために文字列型を数値型(BIGINT)に変換するために 　　CASTを行っています。 　　CAST(CONVERT(VARCHAR,[日付],112) as BIGINT) 　　これで「文字列:20120301」を「数値型:20120301」とすることができます。 次に変換した数値型の日付に対して 2012/03/24<=CAST(CONVERT(VARCHAR,[日付],112) as BIGINT)<=2012/04/23 とすれば、2012/03/24ならば何時であっても抽出範囲に入り、また、2012/04/23ならば何時であっても抽出範囲に入ります。 よって、次に本日日付を「数値型:YYYYMMDD」に変換する事と ３０日前の日付を「数値型:YYYYMMDD」に変換し、その条件をWHERE文に組み込めば完成です。 まずは本日日付を「数値型:YYYYMMDD」にする方法としては 　CAST(CONVERT(VARCHAR,getdate(),112) as BIGINT) となります。 上記の記載は[日付]を「日付取得関数:getdate()」に変更しただけです。 よって、これで「数値型:20120423」となります。 最後に30日前の日付を「数値型:YYYYMMDD」にする方法としては 　CAST(CONVERT(VARCHAR,DATEADD(day ,-30 , getdate()),112) as BIGINT) となります。 こ部分に関しては質問者様が記載されている 　dateadd(d,-30, getdate()) を組み込んだだけですのでご理解いただけると思います。 以上の構文をクエリに組み込みSELECT文を作成すると以下のようになります。 SELECT 　　[インデックス] 　,[日付] 　,CAST(CONVERT(VARCHAR,[日付],112) as BIGINT) FROM　[dbo].[日付テスト] WHERE　CAST(CONVERT(VARCHAR,[日付],112) as BIGINT)>= 　　　 CAST(CONVERT(VARCHAR,DATEADD(day ,-30 , getdate()),112) as BIGINT) 　　AND　CAST(CONVERT(VARCHAR,[日付],112) as BIGINT)<= 　　　　 CAST(CONVERT(VARCHAR,getdate(),112) as BIGINT) 一応検証を取りましたので問題ないと思います。 なお、先頭の空白は見やすくするために全角スペースにしています。 クエリとして使用する際はお手数ですが、半角スペースに変更してください。
#23:59:59.000 だとミリ秒部分で漏れる可能性が。。。 getdate を 文字列型に変換し(cast または convert)、日付部分だけを切り出して(substring)、'23:59:59.999' を連結したらいいんじゃないでしょうか。 ～ AND M_DATE < 翌日の 00:00:00.000 の方が好ましい気がしますが。
http://keicode.com/db/mssql-how-to-check-file-exist.php 非公開ストアドプロシージャという理由で使用を控えたいという理由なら、SQL CLR経由でSystem.IO.File.ExistsメソッドやSystem.IO.Directory.Existsメソッドが使えると思います。
ロックを考慮しなければ一般的に INSERT INTO SELECT の方が高速です。 一件ずつキー重複などを判断しなければならないような場合だとカーソルで回す必要があるでしょう。
質問の趣旨から外れますが・・ データベースの規模は書いてないので判らないのですが、 access を多少超える程度、利用者が3人程度であることを考えれば SQL Server 2008 Express Edition で充分では? (Microsoft のサイトから 無料ダウンロード) SQL Server 2008 R2 standard を利用するためには 64bit のサーバーOS も必要になりますので、 弱小企業(謙遜?)にとっては大きな出費になるのでは?
マイクロソフトのサイトに原因と回避策がありますが、試されましたか？ http://support.microsoft.com/kb/197463/ja 機械翻訳は意味が分かり辛いので英語版のほうが理解し易いと思います。
CREATE DATABASE で本体とログファイルを指定してデータベース毎に作る事は出来ます。 それ以外は多分出来ないと思います。
EXISTS 句は、副問い合わせが行を返した場合 TRUE そうでない場合 FALSE と評価されます。 例示いただいた副問い合わせは TRUE を返すので DELETE されます。 詳細については、ＳＱＬの入門書を参考にしてください。
スタート、ファイル名を指定して実行でREGEDITでレジストリエディタを起動して、 編集,検索でsql server 2008を探して全て消して、c:\program Files\Microsoft SQl Server以下を全て消してインストールしてみて下さい。ただし、レジストリは消し間違えると問題が出ますので注意が必要です。
http://engineer-memo.com/blogs/engineer-memo/archive/2009/11/07/tempdb.aspx にもありますが、tempdbは初期サイズから必要に応じて拡張され、再起動時に初期設定値に再度初期化されます。 起動されている最中には縮小されませんから、処理量のピーク時にデータファイルのサイズを確認して、初期サイズを再設定することが考えられます。 ただし、本当にtempdbの拡張がパフォーマンスのボトルネックになっているかは別問題です。tempdbへのアクセスそのものがボトルネックになっているならtempdbをデータベースファイルと違うストレージに分散配置するなどして競合を減らすなども考えられます。 そもそも、データベースファイルやログファイルの配置やSQLの記述が問題になっている可能性もあります。 バージョンは古くなりますが「インサイドMicrosoft SQL Server 2005 クエリチューニング&最適化編」などの書籍も参考にしてみてはどうでしょうか。
処理件数を非表示にする方法 ⇒SELECT文の前に「set nocount on」を記載すると件数は表示されません。 SELECT文の発行ごとにSELECT結果がグリッドに表示されるのを非表示にする方法 ⇒デバッグのためには表示された方が良いと思いますが、 　とりあえず…SELECT文の前に「SET NOEXEC ON」を記載するとデバッグだけ実施され、 　グリッドは表示されません。 例であげると以下のとおりです。 SET NOCOUNT ON SET NOEXEC NO SELECT * FROM DB.dbo.TableName go
システム開発会社は何と言ってるのでしょうか？ 多分ですが ＞１．サーバ ＞・ＯＳ：Windows Server 2008 ＞・DB：SQL Server 2008 Express Edition の環境に対しクライアント側が低すぎて対応できていないと思われます。 「Windows2000Server」から「Windows Server 2008」に一気に上げたのが原因でしょう。 下げてみては如何？
質問者さんはスルーされていますが、#1さんのSQLも十分スマートだと思いますが・・・。 #1さんは EXISTS 句の中身だけ書かれている様だったので、それ以外を補完してみました。 ------------------------------------ SELECT * FROM テーブル T1 WHERE NOT EXISTS (SELECT 1 FROM テーブル T2 WHERE T1.コード = T2.コード AND T1.区分 = T2.区分 AND ( T1.有効期間開始日 < T2.有効期間開始日 OR T1.有効期間開始日 = T2.有効期間開始日 AND T1.有効期間終了日 < T2.有効期間終了日)); ------------------------------------
SELECT DISTINCT コード FROM テーブル WHERE コード NOT IN(SELECT コード FROM テーブル WHERE 区分 IN('A01','D01')) ORDER BY 1 です。
DROP INDEX IDX_レセプト1 ON dbo.レセプト DROP INDEX IDX_レセプト2 ON dbo.レセプト GO CREATE NONCLUSTERED INDEX IDX_レセプト1 ON dbo.レセプト(保険者番号,診療年月) GO を試してみてください。
最初の方はleft　join前にme01=1をはじいているので、マッチしないテーブルはmeisho側がnullとなって選択されます。 後の方はleft　joinの後でme01=1をはじいているので、せっかくshohin側のみに有る行が選択されてもme01がNULLとなっているので、この部分ははじかれてしまいます。
>GOTO 異常終了処理 でcatchブロックの外へ飛ばしてからエラーメッセージを取得できるのかな？ http://msdn.microsoft.com/ja-jp/library/ms179296.aspx をみると、 「 ・・・ エラー関数 ・・・ ERROR_MESSAGE() はエラー メッセージのテキストの全文を返します。 ・・・ TRY...CATCH 構造の CATCH ブロックのスコープ内であれば、←ここ！ どこからでもこれらの関数を使用してエラー情報を取得できます。 ・・・ 」 とあります。 gotoで飛ばすとCATCH ブロックのスコープ外になりませんか？ 一般にはgotoを使わず、以下のようにすると思います。 ・・・ UPDATE処理 　↓ 　エラー発生(3) COMMIT CATCH ログ出力（エラーメッセージ） ロールバック END ※エラー発生(3)までのエラーがおきなければ、COMMITされ、CATCH～ENDは実行されません。 あと、ＤＢとの接続が切られるようなエラーのときは、Catch以下を実行せずに切断されてしまうようです。（ハードエラーでＤＢが落ちたときとかかな） 詳細は、上記で参照しているサイトをみてください。 だいたいの例文はあると思います。
Windows PowerShellのインストール媒体は 注： の下からいけるリンクから手に入れてください 結論言ってしまうと http://www.microsoft.com/downloads/ja-jp/details.aspx?FamilyID=30125a46-b97c-4704-aa10-605e809d5933 ですが。
where句はselect句より先に評価されるためです。 SELECT 入金額 from ( SELECT CASE WHEN 入金テーブル.通貨 = 'ドル' THEN 入金テーブル.額 * 80 (為替レート1ドル80円の場合) 　　ELSE 入金テーブル.額　END As 入金額 FROM 入金テーブル ) WHERE 入金額 > 100000
SELECT 営業日,営業日フラグ ,(SELECT COUNT(*) FROM テーブル名 C WHERE C.営業日<=T.営業日 AND C.営業日フラグ=1) AS 営業経過日数 FROM テーブル名 T ORDER BY 1 です。
sys.tablesで確認できますが、そういう意味ではないですか?
頑張ってロールバックしているんでしょうね。 Update文が何行あるのかわかりませんが、適宜Commit入れておくことはできなかったんでしょうか？ 責任を負えませんが、データのバックアップがきちんと用意できている等 ＤＢが壊れることも厭わないなら、「サービスを停止する」とか。
私の場合はまっさらな環境から、 ・SQL Server 2008 R2 Developer Edition ・Visual Studio 2010 の順番でインストールして正常にインストールできました。 可能ならマシンを初期状態に戻して、この順番で作業を行ってみてください。
SQLEXPRADV_x64_JPN.exeは64BitOS用でSQLEXPRADV_x86_JPN.exeは32BitOS用ですので、 SQLEXPRADV_x86_JPN.exeとなります。 尚、Express　Editionは評価用では無く無償版です。
＞具体的に対応するSQL Server製品バージョンは何になりますでしょうか？ ＞・ 64ビット版Microsoft SQL Server 2008 R2 ＞・ 32ビット版Microsoft SQL Server 2008 。。。 ＞参照済みURL ＞SharePoint Server 2010 システム要件 ＞http://technet.microsoft.com/ja-jp/library/cc262485.aspx#section4 この参照URLに答えがあると思うのですが、ほしい情報は何でしょうか？ 64 ビット版の Microsoft SQL Server 2008 R2。 64 ビット版の Microsoft SQL Server 2008 Service Pack 1 (SP1) 64 ビット版の Microsoft SQL Server 2005 Service Pack 3 (SP3) 参照URLに上記のようにちゃんと書かれていると思うのですが。。。 SQL Server 2008 R2か、 SQL Server 2008ならSP1以降 SQL Server 2005ならSP3以降 この3パターンのいずれかということになります。（他に更新プログラムが必要とも書かれています） 32ビットはサポートしていないということになります。 こちらのWebサイトのほうが要件のみが簡易的に記載されているかな。 http://sharepoint.microsoft.com/ja-jp/product/Pages/systemrequirements.aspx
select a.id from a natural join b where flag = 1 and a.id not in (select id from a where flag <> 1); で，削除対象のIDであるBとGが抽出されるので，これを， delete from a where a.id in (……); に組み込めば良いのではないでしょうか。 私の手元にあるDBソフトは同一テーブルを２重にネストしてdelete対象にできないので，別途viewを作る必要がありそうなのですが。
ちょっとまわりくどいですが CASE NUMERIC = '' WHEN THEN 0 ELSE CONVERT(NUMERIC,'1') END と空白NULLチェックすればコケはしないです。 ただし、文字の比較なら思った結果は得られません。 No1の方の指摘どおりになるでしょう それよりはゼロフィルした値と比較したほうが楽ではないでしょうか？ SUBSTRING('0000000000' + 【対象カラム】 , LEN(【対象カラム】) , 10) > SUBSTRING('0000000000' + NUMERIC , LEN(NUMERIC) , 10); パフォーマンス無視なので、レコード数が少ないならこれでも大丈夫ですが、
？？？ Windows 7 32bit の PC に SQL Server 2008 R2 Developer 32bit版と一緒にインストールした SQL Server Management Studio (32bit) からネットワーク越しに SQL Server 2008 R2 64bit版を管理してもいいかってこと？ 大丈夫ですよ。
いつも言っているのですがSQLは論理の組み立てが 大切です。 1.テーブルAからテーブルBに結合するレコード数を 　数える。レコード数が0のものが抽出対象になる。 2.上記クエリと結合するテーブルBのデータが求める 　結果になる。 1のクエリ SELECT A.グループ FROM テーブルA AS A LEFT JOIN テーブルB AS B ON A.社員番号 = B.社員番号 GROUP BY A.グループ HAVING COUNT(B.社員番号) = 0 2のクエリ SELECT A.* FROM テーブルA AS A INNER JOIN (SELECT A.グループ FROM テーブルA AS A LEFT JOIN テーブルB AS B ON A.社員番号 = B.社員番号 GROUP BY A.グループ HAVING COUNT(B.社員番号) = 0) AS B ON A.グループ=B.グループ サブクエリの()内は1と全く同じです。 闇雲にSQL構文を覚えるより、理論の構築を 心がけましょう。SQLのSはStructureで、 構造を意味します。論理構造が大切です。
以下で調査可能ですよ。 sys.objectsでテーブルのみ抽出。 ※type='U' sys.objectsとsys.columnsをJOIN ※object_idが一致 sys.typesとsys.columnsをJOINしデータ型の名称を取得 ※system_type_idが一致 >Not Null制約や、 sys.columns.is_nullable >カラムのバイト数、 文字型の場合、sys.columns.max_length 数値型(decimal)の場合、sys.columns.precisionとsys.columns.scale（少数部） >PKかどうか sys.indexesとsys.objectsをジョインし、索引がPKかどうか判定 sys.indexes.is_primary_key sys.columnsとsys.index_columnsをJOINし、索引列を特定 ※sys.columnsとobject_idが一致 ※sys.columnsとcolumn_idが一致 PK列を判定 これらの情報から私はテーブル定義書を逆生成してますよ。
あるかもしれないし、ないかもしれない。（ということは 「ある」 ってことか） その DB を利用しているアプリケーション側がどんな使い方してるかわからんけど、SELECT * ～ってしてるのか、SELECT xx, yy, zz みたいにカラム名で指定してるのかで取得した表のカラムの順番が変わるだろうし、それそカラム名で参照してれば問題ないだろうけどカラムのインデックス番号で参照してれば問題あるだろうと思われる。
アドバイスになるのか、わからないですが．．． メンテナンスを考えて、どうすべきか？ってことが必要かと思います。 各マスタを1つにまとめた場合(※テーブルの項目に種別フィールドで判別するようにする。) の場合は、後でマスタをメンテする場合に、種別フィールドに割り当ててあるコード（かな？）が 画面等ですぐにわかれば良いのですが、そうなっていない場合、 操作説明書なりドキュメントを引っ張り出してきて、探さないとわからないという設計は良くないと思います。 個人的には、マスタを別々に分けた方が良いと考えています。（メンテナンスはしやすいので）
その本は持っていませんが、少なくともSQL ServerのSQLでの文字列連結は「&」ではなく「+」だと思います。
多分ですが、SQL Serverはデータベース毎にユーザーが設定されており、ログインＩＤに対しそのデータベースのユーザーが設定されていないため発生していると推測されます。 Microsoft　SQL　Server　Management　Studioの「オブジェクトエクスプローラ」「セキュリティ」「ログイン」の該当ログインをダブルクリックし、「ユーザー」マッピングで該当データベースがマップされているか確認下さい。
個人的には　PHPオンリーでも可能です メールを送るなら　メールの使えるサーバが必要な程度 条件で検索して　メールフォームから応募は このへんならシンプルに作成できます 求人登録は　認証など必要ないのでしょうか ID認証と　掲載記事の認証など 管理件数はMAXどのくらいを考えているのでしょうか
UPDATE 顧客テーブル SET 担当者 = '中村' WHERE ID IN (SELECT TOP 2 ID FROM 顧客テーブル WHERE 担当者 IS NULL ORDER BY ID)
http://msdn.microsoft.com/ja-jp/library/ms189524.aspx 「CREATE ASSEMBLY」実行段階でデータベース内のオブジェクトとして格納されます。 ですから、データベースをバックアップしてリカバリすれば使用は出来ます。 ただ、ソースやDLLを保存しておかないと他のデータベースに格納できませんね。
> win7（PRO　64bit)にSQL2008はインストール可能か？ こちらを参照するのが確実だと思います。 http://www.microsoft.com/japan/sqlserver/2008/prodinfo/sysreqs/default.mspx > クライアントPC（XP)でMSSMSを起動し、サーバー（win7)のDBへの接続は可能か？ 認証設定は必要でしょうが可能だと思います。
こんにちは。 テーブル定義だけコピーするなら・・・、 create table data_B select * from data_A where 1 = 0 まぁ、常套手段です。
＞リンクを見てみましたが、さっぱりわかりませんでした。 ＞知らない用語が次々にオンパレードであったため、 この辺の話は、このサイトの対話形式の話にでてきます。 http://www.atmarkit.co.jp/fdb/rensai/drk08/drk08_3.html http://www.atmarkit.co.jp/fdb/rensai/sqlsvr08rev/sqlsvr08rev01_03.html No1さんが指摘したサイトと同じところですね。SQLServerのカテゴリーで投稿しているので、 ＞SQLでいうと が「SQLserver」「SQL」どちらを指しているのかわかりませんが、まあ、No1さんの指摘で間に合ってしまうのでしょう。 分かりやすいたとえだと、一人のユーザーが１つのクライアントツール（Webアプリでもいいし、Windowsクライアントでもいい）から２つの検索条件で、２つのクエリーを順番に検索ボタンを押して、検索したとします。 片方は、単独で１分もかからずに結果を表示する物と、もう片方が１０分以上かからもの。これを１０分物を検索して、から１分物を検索したとします。この場合、検索結果を表示してからではなく、待たずにボタンが押せる状態だとして。 さて、一般の方なら、順番に押したから、順番にかえってくるだろう、と思うのか、いや、１分しかかからない方が先に結果が表示されてしまうと思うのか？ どちらが正解でしょうか。 答えは、どちらも正解です（テレビ番組的なひっかけですね）。 それは、DBMSの構築や、設定の問題で、設計側の要望でどうにでもなり、それぞれに意味があります。 この辺の話と、プログラミングのマルチスレッドテクニックとちょっと違う事になりますが、 http://docs.oracle.com/cd/E22054_01/html/821-2495/bkaig.html CPUが一個であった場合、当然、シリアルに処理だけを考えるだけ良かったわけです。しかし、上記のように、一人のユーザーが幾つものジョブを投げてくる場合や、マルチーユーザーで一人が幾つ物ジョブを投げてくる場合、 順番に処理するだけでいいのか？　と言う疑問が浮いてきますよね。その場合、先に実行していいものが在るわけです。それを実行してから、他の処理をする。なんて事があってもいいのでは？　て、考えるわけです。 当然、これは、DB構築設計者が許可すれば、と言う前提条件が付きます。 では、順番でなければ、どのように順番を決めるかということですが、それは、ジョブに関連性があるのか？　と言うだけのキューで後は、実行順番になるわけです。では、今までと違うのでは？　そう、CPUが一個であると、CPUが同時実行される計算の数は、CPUによって決まっているので、いくらアプリ側で、同時に又は、順番を決めても、どうにもならないことなのです。 （初期のInetlのペンティアムだと４つぐらいでした。 http://ja.wikipedia.org/wiki/Core%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3 などを参考に（あくまで参考文献です） それまでのIntelのCPUはシスクプロッセサーでしたね（実行した順番に処理されるだけ） ） とすれば、CPU側のやり方で、マルチスレッドと言う、同時に実行してくれる仕組みでプログラミングしてやらないと、いくらアプリ側で順番を決めても、並列処理も、できなくなります。 で、整理すると、DB側でジョブがスケジューリングされます。CPU側でジョブ（実効命令）がスケジューリングされます。 この２つのスケジューリングによって、もし仮に、エンドユーザーが投げかけたSQL文に依存関係があっても、並列に処理され、設計どおりに順番に検索結果が返ってきます。 それを踏まえて、これを読むと http://support.microsoft.com/kb/899556/ja http://msdn.microsoft.com/ja-jp/library/ms345185.aspx あ、そいうことね。と言う事がわかります。Oracle側（RDBMS）の解説書を読むとその辺が良く分かるかと思います。 http://docs.oracle.com/cd/E16338_01/server.112/b56301/manproc001.htm http://search.yahoo.co.jp/search?p=Oracle+%E5%85%B1%E6%9C%89%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC&aq=-1&oq=&ei=UTF-8&fr=ie8sc&n=10&x=wrt そこにも専門用語「ディスパッチャ」なんて意味不明な物がでてきますが、 http://search.yahoo.co.jp/search?b=1&n=10&ei=UTF-8&fr=ie8sc&p=Oracle+%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81%E3%83%A3%E3%81%A8%E3%81%AF なんて調べればいいわけですね。 これらは、クライアントからキューがあるたびに１つのプロセス（タスクマネージャーで見るプロセス）を起動します。それを共有サーバーと呼んでいます。 何がいいたいかと言えば、１万人のユーザーが同時にキューを投げれば、１万個のプロセスが起動するということです（実際には、他の設定により、そうはならないがMAX）。 それぞれのプロセスで３、４つのCPU（ コアおよびスレッド）を、あますことなく、使ってやるようにマルチスレッドと言うプログラミング技術でコーディングしてやることで、それぞれのプロセスの実行時間が短くなります。 その結果をDB側のエンジン（プログラム）で整理して、クライアントに返すわけです。 で、最初のリンクに戻るわけですが、DBのパフォーマンスアップとか、正確性、整合性を考えると、CPUとかのアーキティクチャーを理解なしでは、とうてい考えられない。それはプログラミングの観点から見ましょう。と言うことです。
バッチファイルを起動した時点ではSQL　Serverがまだインストールされていないので、sqlcmdへのパスが環境変数には設定されていない環境でsqlcmdを実行している為と推測します。 sqlcmdの先頭にディレクトリーも付けてフルパスで実行すれば動くと思います。
SELECT LEFT(列名,LEN(列名)-4) FROM テーブル名 で最後の４文字を取れます。
select t1.KAINo , (select count(*) from テーブルA t2 where t1.KAINo = t2.KAINo and t2.SEQ <= t1.SEQ) from テーブルA t1 KAINo SEQ　 0001 　　 1 0001 　　 2 0001 　　 3 0001 　　 5 0002 1 0002 5 上の順にt1で取得されるとして、 (select count(*) from ・・・)は、それぞれ 1 2 3 4 1 2 となります。 件数多いとちょっと遅いので要注意ですが。
あまり難しいことはせず、SQL文は単純なものが望ましいです。 ちなみに以下のSQL文はデータが存在しない月は0(ゼロ)として 取り扱っていますので必要に応じて修正して下さい。 SELECT [当月], [前月], ([当月] - [前月]) AS [差分] FROM ( SELECT ISNULL([当月],0) AS [当月], ISNULL([前月],0) AS [前月] FROM ( SELECT SUM([当月]) AS [当月], SUM([前月]) AS [前月] FROM ( SELECT [単価] AS [当月], 0 AS [前月] FROM [テーブルA] WHERE [年月] = '2011/02/01' UNION ALL SELECT 0 AS [当月], [単価] AS [前月] FROM [テーブルA] WHERE [年月] = DATEADD(month ,-1 , CAST('2011/02/01' AS datetime)) ) AS T0 ) AS T1 ) AS T2
多分現地のSQL2008は文字長指定が短いのではないでしょか。 SQLに「WHERE DATALENGTH(RTRIM(会員NO))=8」を付加してあげればエラーにならないと思います。
バックアップはふつうテープストリーマを使って定期計画にしたがって行いますが、レストア方法、パックアップ媒体の保管についても十分検討のうえ決めます。案外、レストア時を考慮しない差分バックアップだけ長期にわたってとり続ける素人くさい管理者もいます。 ホットスワップの仕方、レイドシステム異常時の緊急対応方法、手当てが遅れてハードディスク障害を招いた場合の全面復旧方法、サーバーシステムのメーカー保守契約の更新やリース期間終了後のシステム以降、製造中止予定部品の予備調達も対策をこうじていないとなりません。 パフォーマンスチューニングは原因別対策をあらかじめ用意し、必要なら原因特定のための調査分析方法も学ばなくてはなりません。 運用時は毎日システムログ、データベースアクセスログ、ウィルスチェックログ等を確認し異常に気づいたら早急な対応を行う必要があります。またシステム構成要素の保全情報収集活動も欠かせません。業務日誌を記録し、いつ何の作業を行ったか（行わなかったか）トレースできるようにします。作業漏れや設定間違いがないことを記録するには手順書を作り従うこととエビデンスとして設定画面のスクリーンショット作成や設定ファイルのバックアップ等も必須です。このほかに関係部署からのクレームに対する対応の記録もふつうは作成することになります。 その他には、ソフトウェアのセキュリティパッチ適用可否を判断するための試験環境の構築・保持、試験手順書の作成・改訂、試験実施、適用可否報告書の作成もあげられます。場合によってはデータベースシステムのバグ修正やデータ修正、特権ユーザの追加・削除の立ち会い、パスワードの定期更新と関係者への通知、職場によっては修正指示内容に沿った修正作業実施が加わります。
すみません、動作確認していなかったので、間違いがあるようです。 まず、質問のSQL文の場合ATT.AttRecは最大値ですが、StaffCodeとSecCodeでグループ化しているので、StaffCodeとSecCodeが同じ場合のAttRecの最大値となってしまいます。 そこで最初のSELECTでは、テーブルの内容をそのまま表示するようにして、ATT.AttRecが最大である物のみ選択してあげれば解決します。 私の回答の場合条件が一致した全てのAttRecの最大値のみと比較しているので、答えは１件のみになってしますと思います、今回のSQLも動作確認はしていないので、まだミスが有るかはしれませんが、一応回答します。６行目に最初のテーブルとの一致条件を追加しました。 SELECT ATT.AttRec, STAFF.StaffCode, SEC.SecCode FROM PJK0001.dbo.ATT ATT, PJK0001.dbo.SEC SEC, PJK0001.dbo.STAFF STAFF WHERE ATT.AttStaffRec = STAFF.StaffRec AND ATT.AttSecRec = SEC.SecRec AND ATT.AttRec=(SELECT MAX(ATT2.AttRec) FROM PJK0001.dbo.ATT ATT2, PJK0001.dbo.SEC SEC2, PJK0001.dbo.STAFF STAFF2 WHERE ATT2.AttStaffRec = STAFF2.StaffRec AND ATT2.AttSecRec = SEC2.SecRec AND ATT.AttStaffRec = ATT2.AttStaffRec AND ATT.AttSecRec =　ATT2.AttSecRec )
今、検証できる環境がありませんが、そもそもリンクサーバー上のテーブルに対して生じる更新イベントをリンク先で拾えるものなのでしょうか？ 私の感覚で、リンク元でイベントを拾って、それを他サーバーのテーブルにINSERTするのなら可能に思えますが。
> (1)データの追加・削除を繰り返し、ＤＢ領域が不足すると自動 > 拡張が行われる。 これはその通りです。 > (2)自動拡張されたＤＢは、ファイルが断片化している。また、 > ＤＢをしばらく使うと、ＤＢ領域内でデータがまばらに入った > 状態になり、パフォーマンスが劣化する。 一般的に削除や更新が行われるとそうです。 > (3)SHRINKFILEを実行することで、まばらになったデータを > ＤＢ内の１箇所に集めて、無駄な領域を開放する。 ここは注意が必要です。 http://msdn.microsoft.com/ja-jp/library/ms190488.aspx によれば、 「圧縮操作では、データベース内のインデックスの断片化状態は 保持されず、一般に、断片化の程度が大きくなります。この理由 からも、データベースを繰り返し圧縮することはお勧めできませ ん。」 とあります。 インデックスの再作成などを行わないと、パフォーマンスが逆に 劣化する可能性もあります。 また、「DBCC SHRINKFILE」を実行するとテーブル単位にロック がかかる可能性がありますし、かからないとしてもリソースを消 費するので実行タイミングを検討する必要があります。 > (4)さらに、ＤＢの物理ファイルがディスク上で断片化してい > るのを、デフラグで解消する。 デフラグするにはSQLSERVERのサービスを止めないといけません。 基本的にはデータベースを作成するタイミング(CREATE DATABASE) でファイルグループを分けて十分な容量を確保しておき、テーブ ル、インデックスを作成するタイミングで明示的にファイルグル ープを指定するほうがいいと思います。
>(1)ＳＳＤとＨＤＤのどちらにSQLSERVER2008 R8をインストールすべきでしょうか？ SSDとHDDの比較の意味では、どちらが正しいかはわかりません。 ハードの故障を想定した場合は、次の事が言えます。 OSの入っているハードが故障してしまった場合は、完全に使えなくなります。 よって基本的にはOSの入っているハードにSQL　Serverをインストールする事をお勧めします。 データベースの登録される器はデータベース本体と、更新ログの２種類です、また通常はバックアップとしてデータベース本体のバックアップと更新ログのバックアップを取ります。 ハードが壊れた場合、最低でもデータベース本体（業務システム用のデータベース）が壊れていないハードに居れば復元は可能です。 データベース本体のハードが壊れた場合はデータベース本体のバックアップと最後に本体をバックアップした以降にバックアップした更新ログのバックアップ全てと更にクラッシュ直前までのログが更新ログに有り、３種類が残っていれば復元は可能ですが、クラッシュ後に更新ログのバックアップが必要ですので 、SQLServerが生きている必要があります、よって、次のようにされる事が良いと考えます。 ◎OSの入っているハードに業務システム用データベース本体以外を作成する、つまり、業務システム用データベース本体（SQL　Server自身が使うデータベースと更新ログはOS側）のみ別ハードにする、です。 >通常だと「Ｃ」は、ＨＤＤを指しているイメージなのですが、間違っていますか？ CはHDDで有るとは決まっていないです、SSDでも可能です。
「table」はSQLの予約語です。そのため初期設定などで、「table」をそのままSQL文に使用することは出来ません。これは他のRDBも同様です。 SQL SERVERでは[]で括ることで、予約語をオブジェクト名に出来ますが、おすすめは出来ません。 なお、ANSI/ISOの標準規格では「"（ダブルクォーテーション）」で括ることで、同様にエラーを回避できます。SQL SERVERでも初期設定でANSI/ISOと同様に「"」で括るモードにすることは出来ますが、それでも予約語である以上何らかの対応は必要です。 > 会社ではsqlserver2005を利用しているので > 2008からは[]でくくる必要になったのでしょうか そんなことはないはずです。
2008用も有りますよ。
>ところで、全部“秒数”なのですが、ミリ秒やマイクロ秒などで ミリ秒まで計れますが、秒以下は全て切り捨てで表示しました。どちらにしても、簡単なSELECTだけの結果なので、念のため。 尚、７種類のRDBMSを扱った中では、SQL　Serverが一番扱いやすく、問題も少ないです。 ちなみに、MONOによるlinuxクライアントでもSQL　Serverが何も追加インストール無で、いきなり動きました。
2000と2005は同時にインストールする事が出来るので、どちらも入っている可能性があります。 サービスにSQL　Server（インスタンス名）があると思いますが、インスタンス名が異なる物が２個有れば、どちらもインストールされていると考えられます。 ただし、最新はSQL　Server2008R2ですので、最新に切り替えた方が良いと思います。
SELECT REPLACE(REPLACE(REPLACE( (SELECT my_column AS A_Z FROM my_table FOR XML PATH('')) ,'</A_Z><A_Z>',','),'<A_Z>',''),'</A_Z>','') の方が良いかも。
SELECT 大連番,小連番 FROM テーブル T1 WHERE NOT EXISTS(SELECT 'A' FROM テーブル T2 GROUP BY 大連番 HAVING T1.大連番=T2.大連番 AND MAX(T2.小連番)=T1.小連番) ではどうでしょうか。
方法は変更するので心苦しいのですが、ADOを使用して接続したほうが良いように思います。 　　　　Dim StrDBConect As String　　　　　　　　'DB接続文字列 　　　　Dim AdoConnect As New ADODB.Connection　 'ADO接続 　　　　Dim AdoCommand As New ADODB.Command　　　'ADOストアド実行用 　　　　Dim AdoRecordset As New ADODB.Recordset　'ADOレコードセット実行用 　　　　Dim StrSQL As String　　　　　　　　　　 'クエリ文挿入用 　　　　StrDBConect = "" 　　　　StrDBConect = StrDBConect & "Provider=SQLOLEDB;" 　　　　StrDBConect = StrDBConect & "Data Source=データベースサーバ名;" 　　　　StrDBConect = StrDBConect & "Initial Catalog=Northwind;" 　　　　StrDBConect = StrDBConect & "Persist Security Info=True;" 　　　　StrDBConect = StrDBConect & "User ID=SQL Server ログインユーザＩＤ;" 　　　　StrDBConect = StrDBConect & "Password=SQL Server ログインパスワード;" 　　　　 　　　　'データベースに接続 　　　　AdoConnect.ConnectionString = StrDBConect 　　　　AdoConnect.Open() 　　　　'コマンドを実行する接続先を指定 　　　　AdoCommand.ActiveConnection = AdoConnect 　　　　'SQL文を作成する 　　　　StrSQL = "" 　　　　StrSQL = StrSQL & "SELECT FirstName FROM Employees;" 　　　　 　　　　'パラメータを？マークで指定する 　　　　AdoCommand.CommandText = StrSQL 　　　　AdoRecordset = AdoCommand.Execute 　　　　Do Until AdoRecordset.EOF 　　　　　　msgbox(AdoRecordset("FirstName").Value) 　　　　　　AdoRecordset.MoveNext() 　　　　Loop 　　　　AdoRecordset.Close() 　　　　AdoConnect.Close() 　　　　AdoRecordset = Nothing 　　　　AdoCommand = Nothing 　　　　AdoConnect = Nothing ちなみに上記の方法でプログラミングを行う場合、 参照定義に「Microsoft ActiveX Data Objects 2.x Library」を追加する必要があります。 ※ 内容を見やすくするため、ソースの前には全角スペースを入れています。 複写される場合は半角スペースに置換してください。
確かVistaの場合コンピュータ名と同じユーザーは設定出来なかったと思います。 正しいユーザーとパスワードを今一度確認下さい。
こんにちは。 公式では、1.0と書いていますね。 こちらからどうぞ・・・。 http://www.microsoft.com/downloads/ja-jp/details.aspx?FamilyID=30125a46-b97c-4704-aa10-605e809d5933
すみません訂正です。 create table 会議室予約 ( id int identity primary key, 会議室ID varchar(20), start_time datetime, end_time datetime ) go create index idx_会議室 on 会議室予約 ( 会議室ID, start_time, end_time ) go create function chk_会議室予約() returns int begin declare @i int select @i = sum(t.CNT) from ( select count(*) CNT from 会議室予約 y where exists ( select 1 from 会議室予約 y2 where y.id <> y2.id and y.会議室ID = y2.会議室ID and y.start_time > y2.start_time and y.start_time < y2.end_time ) union all select count(*) from 会議室予約 y where exists ( select 1 from 会議室予約 y2 where y.id <> y2.id and y.会議室ID = y2.会議室ID and y.end_time < y2.start_time and y.start_time < y2.end_time ) union all select count(*) from 会議室予約 y where exists ( select 1 from 会議室予約 y2 where y.id <> y2.id and y.会議室ID = y2.会議室ID and y2.start_time > y.start_time and y2.start_time < y.end_time ) union all select count(*) from 会議室予約 y where exists ( select 1 from 会議室予約 y2 where y.id <> y2.id and y.会議室ID = y2.会議室ID and y2.end_time > y.start_time and y2.start_time < y.end_time ) ) t return @i end; go 制約の作成は変わりません。
環境が無いので不明ですが、以下のような理論で 実行すればよいのでは？ (1)売り上げだけのクエリを作る。 (2)支払い方法だけのクエリを作る。 (3)上記を結合して、支払い方法別の集計をとる。 SELECT MAX(A.ダミー) AS 架空, SUM(CASE B.区分 WHEN 1 THEN A.データ ELSE 0 END) AS 現金, SUM(CASE B.区分 WHEN 2 THEN A.データ ELSE 0 END) AS カード FROM (SELECT 1 AS ダミー,伝票番号,データ FROM テーブル WHERE 分類=1) AS A INNER JOIN (SELECT 伝票番号,区分 FROM テーブル WHERE 分類=2) AS B ON A.伝票番号=B.伝票番号 GROUP BY A.ダミー SQLを考える時は先ず理論を組み立てから実施しないと 何時までも使えるようになりませんよ。
SQL Serverも教育機関向けライセンスプログラムがあるみたいですね。 http://www.microsoft.com/ja-jp/education/license/ap/application.aspx より。 アカデミックパックならば、 http://www.microsoft.com/ja-jp/education/license/ap/faq.aspx より Q. アカデミックパックを譲渡するのは可能ですか？ A. 譲渡先がアカデミック対象ユーザーに該当していれば、譲渡可能です。 とあるので、そちらが、アカデミック対象ユーザーに該当していなければ 譲り受けることができないですね。 ⇒譲り受けることができないなら、通常バージョンに変更することはできず、 　新規購入するしかないでしょうね（必要なら。） 　使用に関しても同様。 譲り受けることができたとして、 ライセンスについては、永続ライセンス（取得後に卒業などで取得する資格を失ってからも使える） らしいのでその後の費用は有償サポートを除けばいらないのかな。 教育機関向けライセンスプログラムはアカデミックパックだけではなく、 スクールアグリーメントみたいに非永続ライセンスのものもあります。 ものによって内容もまちまちです。ものを特定しないとどうこう言えません。 ＭＳのカストマーインフォメーションセンターにでも聞いてみれば？ （購入前の質問しか受け付けていないですけど、質問の答えしだいでは購入することになる 　かもしれないからここへ質問して問題ないはずですよ。） URLは以下です。 http://support.microsoft.com/contactus/?ln=ja
オラクル等の個別のSQLシステムのことではなく、たぶんリレーショナル型のデータベースのことを指しているのだと思いますよ。　 テーブルを動的に連結・生成して必要な情報を得る、という方法を発明した人はノーベル賞をもらったと聞いたことがあります。 特にテーブルを切る時に用いられる「正規化」は、個人的にも「大発見」といってよいと思います。
デフォルト設定でインストールしている場合は、記載のような動きになることはありません。 まずは、サーバの設定状況の確認が必要です。 SQL Server構成マネージャで、両方のサーバーのインスタンス名を確認してください。 さらに、SQL Browserの起動有無も確認してください。 SQL Serverのサーバ名のみを指定した場合、 自動的にインスタンス名MSSQLSERVERが自動補完され、 MSSQLSERVERインスタンスに接続します。 次に、インスタンス名を指定した場合はSQL Browserが名前解決をします。 しかし、現在説明ただいている状況になるパターンが想像できません。 インスタンス名とポートの組み合わせの確認でしょうか。 //変更したくないとおっしゃられている以上、変更前と同じ接続文字列（サーバー名\インスタンス名も含めて）を使用しようとしているって認識であってますよね？
SET NOCOUNT {ON|OFF} でその制御ができますが これをサーバ単位で設定することが可能です。 user options オプション http://msdn.microsoft.com/ja-jp/library/ms176031.aspx の512の箇所ですね。
こちらにもとうこうなさっているようですが http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1273901952 マルチポストはいただけません。（画像は貼り付けしてないし） 親切に回答がされているのに無視するのですか。 SQL Serverなら select *,cast( substring([変化履歴],1,CHARINDEX('/',[変化履歴])-1) as int ) bunsi, cast( substring([変化履歴],CHARINDEX('/',[変化履歴])+1,len([変化履歴])-CHARINDEX('/',[変化履歴])+1) as int ) bunbo from from テーブル で分数を分母、分子に切り分けられます。 select t.[実験管理番号],t.[バージョン],t.bunbo,sum(t.bunsi) as shukei from ( SELECT [実験管理番号],[バージョン],cast( substring([変化履歴],1,CHARINDEX('/',[変化履歴])-1) as int ) bunsi, cast( substring([変化履歴],CHARINDEX('/',[変化履歴])+1,len([変化履歴])-CHARINDEX('/',[変化履歴])+1) as int ) bunbo from from テーブル ) as t group by t.[実験管理番号],t.[バージョン],t.bunbo having t.bunbo <> sum(t.bunsi) でいけるかもしれません。
>最初に投稿されたコメント の定義がはっきりしないので（投稿日が日付だけなのであれば投稿順が分かりませんし）、 コメント番号の一番小さいものを最初のコメントとして考えました。 select a.エントリ番号,b.コメント番号,b.元コメント番号,b.コメント内容 from ( select ta.エントリ番号,min(tb.コメント番号) as 最初のコメント番号 from ブログエントリ ta inner join コメント tb on (ta.エントリ番号 = tb.エントリ番号) group by ta.エントリ番号) a inner join コメント b on (b.コメント番号 = a.最初のコメント番号 or b.元コメント番号 = a.最初のコメント番号) order by b.コメント番号; こんな感じでしょうか。
>not inを使っても「B_売上」にまったくない取引先は抽出されません。 どういうSQLを書いているのかが分かりませんので何とも言えませんが、 not in でも抽出できると思いますよ。 もしくは not exists を使って select 取引先 from A_取引先 where not exists ( select * from B_売上 where A_取引先.取引先ID = B_売上.取引先ID); こんな感じもいいと思います。
ツール→オプション→クエリ結果→結果をグリッドに表示の 「結果のコピーまは保存時に列のヘッダーを含める」 にチェックを入れれば可能
SQL Serverのバージョンによってはダメかもしれませんが。 select count(distinct 科目) as 科目種類 from テーブル; でも。
> 1.identityが設定されている値の変更 SQLServerでは基本的に想定していないと思います。 そもそも、identityは自動で採番したい時に使用する機能なので、それを更新したい場面が想像できません。MySQLのauto_incrementの項目では挿入時の値指定や更新ができますが、その場合主キーの重複エラーの可能性が出てきます。 > 2.データの自動更新 普通は更新トリガーを使うのではないのでしょうか。
デフォルトでは自動拡張になっています。テーブルを格納するデータファイルも自動拡張になっています。 データファイルの最大サイズを制限することや、データファイルサイズの監視は出来ます http://social.msdn.microsoft.com/Forums/ja/sqlserverja/thread/e48d0178-960a-4c03-ae3f-540ba7dc5dab 個別のテーブルについては、「sp_spaceused」と「sp_send_dbmail」を使って監視可能ですが、「sp_send_dbmail」はExpressEditionではサポートされないので、その場合は工夫が必要です。 「sp_spaceused」 http://msdn.microsoft.com/ja-jp/library/ms188776.aspx 「sp_send_dbmail」 http://msdn.microsoft.com/ja-jp/library/ms190307.aspx
＞副問い合わせ同士のキーが複数になるどうしたらいいのでしょうか。 ＞すみません。よろしくお願いします。 where と同様、join～on に対しても and で複数条件をつなげる事ができます。 select * from (select cal1,cal2,cal3 from tbl1,tbl2 where cal1>100) aaa right join (select cal1,cal2,cal3 from tbl1,tbl2 where cal1<=100) bbb on aaa.cal1 = bbb.cal1 and aaa.cal2 = bbb.cal2 and aaa.cal3 = bbb.cal3 where aaa.cal1 = tbl3.cal1 ※未検証です
もちろん、メモリは積めるだけ積んだほうが、安心です。 ----- ちょっときついですが、ご質問の内容は 「Excel で処理をしていますが、メモリ不足になり処理が止まってしまいます」 と同等なご質問ではないかと思うのです。 どんな処理をしているのか、単一の SQL なりプロシジャーなりを動かすだけで足りなくなるのか、物凄いアクセスが集中したときにメモリが足りなくなるのかなど、もう少し状況をご説明いただければと思うのですが・・・・・・・。クエリが集中してメモリが足りないのと、SQL のオプティマイズの問題でクエリが異常にメモリを消費しているのでは状況が違いますし、後者であれば SQL 文を最適化しない限りメモリを増やしても解決できないこともありますし・・・・・・・・・。
select * from [テーブル] where [金額1] is not null or [金額2] is not null or [金額3] is not null or [金額4] is not null
＞Replace関数だと一度に一つしか削除できないようなので何か方法がないかと ＞思案しております。 Replace関数を入れ子にすればよろしいかと。 Replace(Replace(Replace(Replace(Replace(商品名, '.', ''), ',', ''), '-', ''), ' ', ''), '/', '') もちろん、関数を作ればカッコイイですけど。 ORACLE なら既に REGEXP_REPLACE なんて関数があります。
>更新時は下記の記述でうまくいったのですが 本当にうまくいきましたか？ テーブルに２行データを入れてそのうちの１行のみ更新してみてください。 ２行とも更新日が今日の日付になるはずです。 ・・・これはだめですよね。 create TRIGGER trgSHOHIN ON TBL_SHOHIN FOR INSERT, UPDATE AS BEGIN UPDATE TBL_SHOHIN SET SAKUSEI_DATE = GETDATE() where SHOHIN_NAME in (select SHOHIN_NAME from inserted) and SHOHIN_NAME not in (select SHOHIN_NAME from deleted) UPDATE TBL_SHOHIN SET KOSHIN_DATE = GETDATE() where SHOHIN_NAME in (select SHOHIN_NAME from inserted) and SHOHIN_NAME in (select SHOHIN_NAME from deleted) END RETURN とでもすれば、作成時は、作成日のみ、更新時は、更新日のみ今日の日付にします。 inserted/deletedに関する参考サイト） http://msdn.microsoft.com/ja-jp/library/ms191300(v=SQL.90).aspx ## 個人的には、作成時は、作成日と更新日をセットするほうがいいと思っていますが ## ・・・仕様の問題 ## また、SHOHIN_NAMEをプライマリキーとする考え方ですが、 ## よくないと思います。連番でもなんでもいいから、SHOHIN_CDをつくったほうがベター ## ・・・これも仕様の問題
http://msdn.microsoft.com/ja-jp/library/ms187887.aspx あらかじめ、インサートする対象のフィールドにデフォルト値で空文字列を設定します。この状態でBULK INSERTを実行すれば空文字列が設定されます。
SQL Server 2008 R2のExpressとStandard版の違いを示したページです。 http://www.atmarkit.co.jp/fwin2k/tutor/sqlexplmt/sqlexplmt_02.html 使用できるCPU数というところはこちらを http://rokuz.com/?p=618 2008 と 2008 R2ではデータベース容量が結構違うので用途によってはR2にしたほうがいいかもしれません。 Express 版でも SQL Server の最低限の機能は満たしています。 後、Webアプリケーションを作成したいならMicrosoft Web Platform Installer 3.0をダウンロードしてASP.NETで作る方がいいかもしれません。
こちらが参考になるでしょうか。 http://social.msdn.microsoft.com/Forums/da-DK/transactsql/thread/c79bb2e1-8a74-4bd2-88a1-ce2ffa9f2a4d Google翻訳： http://translate.google.co.jp/translate?hl=ja&sl=en&u=http://social.msdn.microsoft.com/Forums/da-DK/transactsql/thread/c79bb2e1-8a74-4bd2-88a1-ce2ffa9f2a4d&ei=SVF7To23PMOOmQW_voCyAQ&sa=X&oi=translate&ct=result&resnum=2&sqi=2&ved=0CC0Q7gEwAQ&prev=/search%3Fq%3DGet%2Bconnecting%2Bclient%2BPC%2527s%2BIP%2Baddress%26hl%3Dja%26rls%3Dig%26biw%3D1024%26bih%3D600%26site%3Dwebhp%26prmd%3Dimvns
>「'対象テーブル名'」には変数がいれられないので、どうしようかと悩んでいます。 declare @tblname varchar(100) set @tblname = '対象テーブル名' DECLARE CURS_test CURSOR FOR 　 SELECT name FROM dbo.syscolumns 　 WHERE id IN 　 (SELECT id FROM dbo.sysobjects WHERE name = @tblname) 　 ORDER BY id, colid; >カラム名をカンマで繋げてひとつの変数に格納する方法がわかりませんでした。 declare @colnm varchar(100) declare @colnmconcat varchar(100) set @colnmconcat = '' fetch next CURS_test into @colnm While @@fetch_status = 0 begin if @colnmconcat = '' begin set @colnmconcat = @colnm end else begin set @colnmconcat = @colnmconcat + ',' + @colnm end fetch next CURS_test into @colnm end こういった感じでどうでしょう？（未検証ですが。）
このSQLでは >dbo_TblAには以下のようなデータが2行入っています。（重複している） >SYAINCD XXXXX >StartDT 2011/1/1 >EndDT 2011/12/31 >YuukouDT 2011/1/2 のデータが2レコードのみ存在する場合は2件のレコードが返されると思います。 dbo_TblAのStartDTに2011/1/2以降のデータまたはYuukouDTに2011/1/3以降のデータが 1レコードのみ存在した場合SQLの結果がはじめて1レコードになります。(もちろんSYAINCD='XXXXX') 条件文を (H.StartDT)=( SELECT MAX( K.StartDT) FROM dbo_TblA K, dbo_TblA L WHERE K.SYAINCD = H.SYAINCD AND L.SYAINCD = K.SYAINCD AND L.StartDT = K.StartDT AND L.YuukouDT = K.YuukouDT AND L.StartDT <= '2011/04/20') と (H.YuukouDT)=( SELECT MAX(H_ED.YuukouDT) FROM dbo_TblA H_ED WHERE H.SYAINCD = H_ED.SYAINCD AND H.StartDT = H_ED.StartDT AND H_ED.YuukouDT <= '2011/04/20') にわけて考えればわかりやすいと思います。 何を抽出するSQLかわかりませんがこんな奇怪なSQLは書かないように努力しましょう。
ExecuteNonQueryメソッドを使えばUPDATE、DELETEの対象件数が戻り値になります。
環境がないのでAcc2000でしか確認できていませんが、 MSysObjectsというテーブルの中のデータベースというフィールドに記載されていると思います。 表示方法は、 http://www.tsware.jp/tips/tips_126.htm
SQLは基本一緒です。最も重要なことはWindows上でしか動かないこと。 特徴としては、 ・UNDO、REDOともにトランザクションログとして管理する。 ・DBのブロックサイズが8KB固定で領域管理は8ブロック（64KB）を1エクステントとして管理 ・UPDATE文にFROM句があるなどの拡張構文あり。 ・バッチという概念がある（いまゆるバッチ処理ではなく一連のSQLの処理単位）。 ・サーバーのメモリをSQLSERVERが最大限使用することが基本。
直接テーブルに書き込むこともできますが、安全を 考えて、新しいテーブルにデータをすべて書き出す ことにしました。 質問のテーブル名を「Tポータルサイト」とします。 準備として「Tポータルサイト」と同じ構造の 空のテーブルを一つ用意をしておいてください。 名前を「T書き込み用」とします。 そのとき、フィールドの数を適当に増やして置いて ください。見た目は同じでも空白や改行コードが 入っていると違うデータとして判断します。どちらかと 言えば、目いっぱい設定しておくほうがいいかもしれません。 たとえば、yahoo!　というポータル名がたくさん存在 するならばそれだけ一目では分かりにくいデータ が紛れ込んでいる可能性もあります。 なお、フィールド名は先頭の「ポータル名」だけは 固定で、あとはどのようなフィールド名でも かまわないようになっています。「ポータル名」 も実際に合わせて変更してください。 もし、実行後、データの抽出数が予定より 多い場合は、たとえば、 SELECT * FROM Tポータルサイト WHERE (((Tポータルサイト.ポータルサイト名)="yahoo!")); のように、特定のポータルサイト名を指定して確認、修正も できます。 では、以下のコードを実行してみてください。 一応、DAOで記述しています。 なお、参照設定で Microsoft Scripting Runtime にチェックを入れてください。DAOのチェックの確認も。 Sub testポータル() Dim db As DAO.Database Dim rs1 As DAO.Recordset Dim rs2 As DAO.Recordset Dim rs3 As DAO.Recordset Dim strSQL As String Dim dic As Object Dim v As Variant Dim k As Variant Dim i As Long Dim j As Long 'テーブルのポータルサイト名の名寄せのSQL文 strSQL = "SELECT ポータルサイト名 FROM Tポータルサイト GROUP BY ポータルサイト名;" Set db = CurrentDb Set rs1 = db.OpenRecordset("Tポータルサイト") Set rs2 = db.OpenRecordset(strSQL) Set rs3 = db.OpenRecordset("T書き込み用", dbOpenDynaset) Set dic = CreateObject("Scripting.Dictionary") If rs2.RecordCount > 0 Then rs2.MoveFirst Do Until rs2.EOF If rs1.RecordCount > 0 Then rs1.MoveFirst Do Until rs1.EOF For i = 0 To rs1.Fields.Count - 1 v = rs1.Fields(i).Value If rs2!ポータルサイト名 = rs1!ポータルサイト名 Then '配列へデータ格納 If Not IsNull(rs1.Fields(i)) Then If Not dic.Exists(v) Then dic.Add v, v End If End If End If Next i rs1.MoveNext Loop End If 'テーブルへデータの書き込み k = dic.Keys rs3.AddNew For j = 0 To dic.Count - 1 rs3.Fields(j) = k(j) Next j rs3.Update dic.RemoveAll rs2.MoveNext Loop End If Set dic = Nothing rs1.Close: Set rs1 = Nothing rs2.Close: Set rs2 = Nothing rs3.Close: Set rs3 = Nothing db.Close: Set db = Nothing End Sub
あっさりと以下の方法ではどうですか。 (1) 標準モジュールに以下のコードを貼り付け保存します。 DAOを使っているので参照設定で、 Microsoft DAO xx Object Libraryにチェックを入れてください。 AADoがチェック済みならばADOより上に設定しておいてください。 Function funcDate(ByVal ddd As Date) As Date Dim db As Database Dim rs As Recordset Dim i As Long Dim Maxnum As Date Dim Minnum As Date Dim num As Long Set db = CurrentDb Set rs = db.OpenRecordset("Tカレンダ") Maxnum = DMax("年月日", "Tカレンダ") Minnum = DMin("年月日", "Tカレンダ") num = DateDiff("d", Minnum, Maxnum) For i = 1 To num - 1 If rs.RecordCount > 0 Then rs.MoveFirst Do Until rs.EOF If rs!年月日 = ddd - i Then If rs!売上金 > 0 Then funcDate = rs!年月日 Exit For End If End If rs.MoveNext Loop End If Next i rs.Close: Set rs = Nothing db.Close: Set db = Nothing End Function (2) 以下のSQLを新しいクエリのSQLビューに貼り付け 保存します。 SELECT t1.年月日, t1.売上金, funcDate(t1.年月日) AS 前営業日, t2.売上金 AS 前営業日売上金 FROM Tカレンダ AS t1 LEFT JOIN Tカレンダ AS t2 ON t2.年月日=funcDate(t1.年月日) ORDER BY t1.年月日; 一番ふるい日付の前日はレコードがないので、 0:00:00になり、前営業日売上金はNullになります。 以下のようにすれば体裁整いますが、 あまり意味がないかもしれません。 SELECT t1.年月日, t1.売上金, IIf(IsNull(前営業日売上金),Null,funcDate(t1.年月日)) AS 前営業日, t2.売上金 AS 前営業日売上金 FROM Tカレンダ AS t1 LEFT JOIN Tカレンダ AS t2 ON t2.年月日=funcDate(t1.年月日) ORDER BY t1.年月日;
「>=」、左辺値が右辺値以上。 「=<」、このような演算子はありません。「<=」の誤りです。 オフィシャルなマニュアルは http://www.postgresql.jp/document/9.0/html/ にありますが、 http://books.shoeisha.co.jp/book/b81869.html あたりを購入して勉強することをお勧めします。
SQL だけで全てこなすことが正しいとは限らないのですが・・・・・・。 速度など全く気にしないのであれば select top 1 id, name from ( 　　select id, name, 50 as tID from TA where id=XXXX 　　union 　　select id, name, 100 as tID from TB where id=XXXX 　) tmpTbl 　order by tID こんな感じで行けるかとは思います。要は両方から検索して結合、その際に Table A には tID=50、Table B には tID=100 を当てておき、tID でソートして先頭1行を取得する、というものです。一応ですが、SQL Server/ MS Access 限定の SQL です。 実際のところ、同一 ID のデータは絶対に A か B のどちらかにしか無いということであれば、2つの検索結果を結合しても1行以下しか返ってこないことになるので、from 句の中のサブクエリだけでいいことになります。
#1 です。状況説明、ありがとうございます。 しかし・・・・・・・。やはり ODBC のデータソース作成の際、デフォルトデータベースが、DB1になっていなかったのでは・・・・・くらいしか思いつきませんでした。ごめんなさい！(>_<)。
名称でグルーピングして、区分が2,3,4のレコード件数が0のものを取得する。 select 名称 from テーブル group by 名称 having count(case when 区分 in (2,3,4) then 1 else null end) = 0; もしくはnot existsを使って select distinct 名称 from テーブル a where not exists (select * from テーブル b where a.名称 = b.名称 and b.区分 in (2,3,4)) and 区分 not in (2,3,4) --なくても結果は同じです ; とかでも。
SQLAzureMW http://sqlazuremw.codeplex.com/ を使用すれば、SQL Server 2008 R2からSQL Server 2005へ移行できます。 移行したいSQL Server 2008 R2がインストールされたローカル上で、 本ツールを使用し、ローカルもしくはNW上のSQL Server 2005に DBをコピーします。 コピーが完了すれば、そのファイルを使用すればオフライン環境の SQL Server 2005にも持っていけます。
ああ、単純な記述ミスでした。 No=Case when @no is null then No else @no end ＊↑でなぜ条件をみたすのかは理解できているでしょうか？ 　あと、Case文の文法は自分で調べましたか？ 　というのはちょっと気になります。 　
サブクエリで取得するのが簡単なのではないでしょうか。 こんなイメージです。 select 　年月,ID,体重 as 今月体重 ,(select 体重 from テーブルA b where b.ID = a.ID and b.年月 = a.年月の1か月前) as 前月体重 from テーブルA a where a.年月 = 2011年02月; 年月のデータ型が分かりませんし、SQL Serverでの日付関連の処理に詳しくないので >a.年月の1か月前 この部分はご自身でうまく処理してください。
ANo1です。 大変失礼しました。 >「@@error」でエラー番号は取得できますが、 >同じような感じでメッセージは取得できないでしょうか？ ですが、この機能はなかったです。 Try Catchができるようになって、SQL Server2005からできるようになったという話でした。 （ということでTry Catch内でないと不可。） ・・・昔のソースを確認したところ、@@errorのコードに応じてプログラム内で固定のメッセージを 　出力していました。（忘れていました。） ## 大昔に、SQL Server2000で、これで取れるのでは・・・ダメじゃない。 ## とやった間違いをまたやってしまいました。 ということで、ANo1では望んでおられることはできませんので削除扱いしてください。
・SQL Server の基本的な操作等については、マイクロソフトのサイトに「自習書」がありますので、 　そちらを参考にされたら良いかと思います。(参照URL) ・データベースさえできてしまえば、データの出し入れは Oracle とほとんど変わりないと思います。 ここで，疑問点ですが、 ・SQL Server はOracleと別にサーバーを構築するということですか? 　または、Accessの様に各PCにインストールする想定ですか? もし、Access の様に 各PCにインストールするのであれば、SQL Server Express Edition を使用します。 ご存じとは思いますが、Developer Edition は開発または教育用のみで、業務では使用できません。 SQL Server Express Edition はマイクロソフトのサイトから無料でダウンロードできたと思います。 VB2005 にも添付されているかもしれません。
それだけの情報だとよくわかりません。１つのテーブルから取得するのか、データとは文字列なのか他のテーブルの項目とJOINしたいのかなど詳細がわからないと答えようがないと思います。 ■完全一致 select * from （テーブル名） 　　where （項目A） = '（検索したい文字列）' or （項目B） = '（検索したい文字列）' ■部分一致 select * from （テーブル名） 　　where （項目A） like '%（検索したい文字列）%' or （項目B） like '%（検索したい文字列）%' これではダメでしょうか？
full joinとcase式を使って、 select case when a.コード is null then substring(b.コード,1,4) else a.コード end as コード ,isnull(sum(数量),0) as 数量 from テーブルA as a full join テーブルB as b on (a.コード = b.コード) group by case when a.コード is null then substring(b.コード,1,4) else a.コード end order by コード; でどうでしょうか。 SQLServerの環境が無いので動作確認はしていません。
No1です。 リピートは ＞対象期間内で購入があり、且つその設定日付以前にも同じ商品の購入があった場合 でしたね。 --- FROM 注文テーブル t LEFT JOIN (SELECT 顧客コード FROM 注文テーブル WHERE 購入日<#2011/02/28#) k ON t.顧客コード = k.顧客コード → FROM 注文テーブル t LEFT JOIN (SELECT 顧客コード,商品NO FROM 注文テーブル WHERE 購入日<#2011/02/28# GROUP BY 顧客コード,商品NO) k ON t.顧客コード = k.顧客コード and t.商品NO = k.商品NO
下記でどうでしょう (1)集約は商品NOのみ（購入日は通常日か割引日として表示） --- SELECT switch(t.購入日 < w.開始日 or t.購入日 > w.終了日,'通常日',true ,'割引日') as 日付 ,t.商品NO ,sum(switch(t.購入日 < w.開始日 or t.購入日 > w.終了日,t.購入数,true ,0)) as 通常購入 ,sum(switch(t.購入日 < w.開始日 or t.購入日 > w.終了日,0,true ,t.購入数)) as 割引購入 ,sum(switch(t.購入日 < w.開始日 or t.購入日 > w.終了日,t.購入金額,true ,0)) as 通常購入金額 ,sum(switch(t.購入日 < w.開始日 or t.購入日 > w.終了日,0,true ,t.購入金額)) as 割引購入金額 FROM T_注文 t INNER JOIN T_期間限定割引 w ON t.商品NO = w.商品NO WHERE t.商品NO = '9998' and t.購入日 between #2010/06/01# and #2011/05/31# GROUP BY t.商品NO,switch(t.購入日 < w.開始日 or t.購入日 > w.終了日,'通常日',true ,'割引日') --- (2)2011/01/01以前に購入のある人をリピートそうでない人を初めてに振り分け --- SELECT t.商品NO , t.年代 , sum(switch(t.顧客種別='通常' and k.顧客コード is not null, 1 , true ,0)) as リピート , sum(switch(t.顧客種別='通常' and k.顧客コード is not null, 0 , true ,1)) as 初めて , sum(switch(t.顧客種別='新規' , 1 , true ,0)) as 新規 , sum(switch(t.顧客種別='フリー', 1 , true ,0)) as フリー FROM T_注文 t LEFT JOIN (SELECT 顧客コード FROM T_注文 WHERE 購入日<#2011/01/01#) k ON t.顧客コード = k.顧客コード WHERE t.購入日=#2011/05/01# and t.商品NO = '9999' GROUP BY t.商品NO, t.年代
SQL Server は、2005 以降から DTS を一新した新しい ツール 『SQL ServerIntegration Services（SSIS）』 が導入されました。 http://msdn.microsoft.com/ja-jp/library/cc707786.aspx 古いDTSパッケージは、SSIS に移行することが推奨されます。 移行方法などは DTS SSIS あたりをキーワードに検索すれば、 けっこう情報が出てきます。 # Microsoft ご謹製の "移行(変換)ツール" は、過度な期待は # 危険です。『うまく変換できたら儲け』くらいの気持ちで、全部 # 作り変えるくらいの覚悟で挑んだほうが良いでしょう。
リンクテーブルを作り直す。 ＤＡＯで動的に接続先を変更することも可能らしい。 http://billyboy.blog81.fc2.com/blog-entry-104.html
はじめまして 現行Sqlserver2000とSQLSERVER2008って違うマシンですか？ 違うマシンならファイアーウォールをまず確認された方がよいかも。 サーバーOSが分からないので何ともですが、 「受信の規則」でポート1433が開放されているか確認してみてください。
高速化のアドバイスだけ。 (1) > AND u.保管河岸コード =isnull(@保管河岸コード,u.保管河岸コード) AND (@保管河岸コード IS NULL OR u.保管河岸コード = @保管河岸コード) と書いたほうがよい。 @保管河岸コードがNULLのときは、u.保管河岸コードを参照しなくてすむ。 また、列を右辺に書くとインデックス検索にならない可能性がある。 (2) WHERE 条件1 AND 条件2 AND 条件3 ... のように複数の条件を指定するときは、以下の優先順位で指定する プライマリーキーによる検索 インデックス付の列による検索 絞込みがきつい条件 逆に言うと、WHERE で頻繁に使用する列にインデックスを付ける
SELECT Max( cast( SUBSTRING(TestId,4,10) as INT )) AS MAX_pti_patient_id FROM patient_info WHERE TestCd1 = 1 and TestFlg = 1 を試してください。
[退職日]は文字列ですか？ だったらISDATE関数を使ったらどうでしょう？ http://technet.microsoft.com/ja-jp/library/ms187347.aspx
select 氏名 ,sum(case when 科目 = '国語' then 得点 else null end) as 国語 ,sum(case when 科目 = '英語' then 得点 else null end) as 英語 from 得点データ group by 氏名; でいいのでは？ 2005以降ならpivotを使ってもいいのかもしれません。 自分では全く使ったことが無いというかSQLServerの環境自体が無いので書き方は分かりませんが。
追記　前の回答で「標準的なクエリ」というのは取り消します。 （簡単だと思ったら、ＤＢＭＳごとにだいぶ異なるようです） SQL Server 2005 では下のように、結合が使用できるようです。 （試してはいませんが・・・） -- テーブルを結合して更新する update a set a.visit_point = b.visit_point from a_table a, b_table b where a.member_no = b.member_no -- 相関サブクエリを使った例 update a_table a set visit_point = (select b.visit_point from b_table b where a.member_no = b.member_no) where exists (select null from b_table b where a.member_no = b.member_no) -- 更新する値が複数ある場合は set (col1, col2) = (select table1.col1, table2.col2 from table1 ...) のようにする。
そのテーブルに主キーのように一意性のある列がなく、すべての列を見渡しても全く同じ値が入っているレコードが複数あるってことでしょうか。 Management Studio のツールでは、一意の区別がつかない場合は全ての列の値を使って更新対象レコードを一意に識別しようとしますが、それでも更新対象レコードの区別がつかない場合はエラーになります。 素直に [新しいクエリ] で SQL を書いたほうが良いかと。 まぁ何かのテストデーターなのかもしれませんが、すべての列を見比べても全く同じ内容のレコードが複数必要な場面ってあるんでしょうかね。。。
windowsならADO,ADO.NET経由で対応するプログラミング言語からアクセスできます。 あと、Perl,Ruby,Pythonからでも。 Unix/LinuxからだとUNIXODBC経由からアクセスできます。 http://fujishinko.exblog.jp/8157571/ あとはJavaでJDBC経由でしょうか。これが一番汎用性があると思います。
データベースごとに select * from sys.database_files を実行すればそのデータベースで使用しているファイルが表示されます。 それらのファイルを除外したファイルは現在使用されていないファイルです。
＞　＜データベース名＞．＜テーブル名＞．＜列名＞ ではなく以下です。 <データベース名>.<スキーマ名>.<Table名>.<列名> スキーマ名が抜けてます。スキーマ名はデフォルトだとdboです。 ※自データベース内かつデフォルトだと<データベース名>.<スキーマ名>が省略可能。 あと、SQLを発行しているユーザ（ログイン）は異なるデータベースを参照可能ですか？ 権限がないと参照できませんのでログインのプロパティからサーバロールとユーザマッピングを調べてください。
あ、ごめんなさい。 ANo1のものです。 ミスしてます。 ANo1では、 yotei_id　　jishi_day　　ninzu　　shiten　　shain_yotei_id　　shain_nam 5　　　　　　2011/7/5　　3　　　　支店B　　　　Null　　　　　　Null ができてしまいます。 >insert into #TMP >select a.yotei_id,a.jishi_day,a.ninzu,a.shiten,b.shain_yotei_id,b.shain_nam >from tbl_yotei a,tbl_shain_yotei b where a.yotei_id = b.yotei_id > >を実行する。（shain_yotei_idとshain_namがNULLでないレコードが格納される） まではいいのですが、 >select max(ninzu) from tbl_yotei >の値を取得する。 ここは、 select yotei_id,ninzu from tbl_yotei をカーソルで取得して、１件ずつ処理する必要があります。 > >while等を使って1から上で取得したmax(ninzu)まで以下のＳＱＬを繰り返す。 >insert into #TMP >select a.yotei_id,a.jishi_day,a.ninzu,a.shiten,NULL,NULL >from tbl_yotei a >where (select count(*) from #temp b where b.yotei_id = a.yotei_id) < 繰り返しの値 これは、上で取得したレコード毎に繰り返し処理します。 ということで、 (元質問に書かれているのと同様に) DECLARE c_yotei cursor FOR SELECT yotei_id,ninzu FROM tbl_yotei OPEN c_yotei FETCH NEXT FROM c_yotei INTO @yotei_id, @ninzu WHILE @@FETCH_STATUS = 0 BEGIN set @i = 1 while @i > @ninzu insert into #TMP select a.yotei_id,a.jishi_day,a.ninzu,a.shiten,NULL,NULL from tbl_yotei a where a.yotei_id = @wk_yotei_ID and (select count(*) from #temp b where b.yotei_id = @wk_yotei_ID) < @i set @i = @i + 1 end FETCH NEXT FROM c_yotei INTO @yotei_id, @ninzu end ということで。 （すいませんでした。）
>SELECT REPLACE(col1,' ','') as col1 From table1 where col1 like '%システムズ%' SELECT句とWHERE句は別物です。以下のようにWHERE句でREPLACEを指定してください。 ※SQLの解釈上、WHERE句が先に解釈されて対象データを特定しSELECT句の指示に従いデータを抽出します。 SELECT REPLACE(col1,' ','') as col1 From table1 where REPLACE(col1,' ','') like '%システムズ%' create table table1 ( col1 varchar(100) ); insert into table1 values('NTTデ　ー　タ'); insert into table1 values('NTTデ　－　タ　シ　ス　テ　ム　ズ'); insert into table1 values('NTTデ　ー　タ　ク　オ　リ　テ　ィ'); insert into table1 values('日立製作所'); insert into table1 values('IBM'); SELECT REPLACE(col1,' ','') as col1 From table1 where col1 like '%システムズ%'; col1 ------------------ (0 行処理されました) SELECT REPLACE(col1,' ','') as col1 From table1 where REPLACE(col1,' ','') like '%システムズ%'; col1 ------------------ NTTデ－タシステムズ (1 行処理されました) >できれば全角・半角両方を含む文字のデータでも検索できるようにしたいです SQL Serverの設定は「全角半角を区別する」になってますか？ 区別しない設定なら、そのままでOKです。 区別する設定になっているならREPLACEを二度がけすればよいと思います。 where REPLACE(REPLACE(col1,' ',''),'　','') like '%システムズ%'
strSelect &= " inner join (select * from クライアントマスタ union select * from 関連会社マスタ) as CM on TM.ClientNO = CM.ClientNO " これはunionしているから仕方ないですけど、 他のjoinの大半について。 strSelect &= " left outer join (select * from コードマスタ where 識別コード=00002) as CO2 on TM.内容NO = CO2.汎用コード"　 などはなんでleft outer join (select * from ・・・)なんですか？ left outer join コードマスタ as CO2 on TM.内容NO = CO2.汎用コード and 識別コード=00002 としていないから副問い合わせをした結果と結合するので、 インデックスは使えないし、作業用にメモリかディスクは食っているし負荷とレスポンスの大敵と なっていますけど。 なお、 inner join (select * from クライアントマスタ union select * from 関連会社マスタ) as CM on TM.ClientNO = CM.ClientNO も、 inner join クライアントマスタ as CM1 on TM.ClientNO = CM1.ClientNO inner join 関連会社マスタ as CM2 on TM.ClientNO = CM2.ClientNO として、冒頭のSelect句の、 select CM.クライアント名 as クライアント, を select case when CM1.クライアント名 is not null then CM1.クライアント名 else CM2.クライアント名 end as クライアント, とし、末尾のwhere句に and (CM1.クライアント名 is not null or CM2.クライアント名 is not null) としたほうが、私が思っているデータ量なら、はやいと思います。 （select * from クライアントマスタ union select * from 関連会社マスタ 　が数十件程度しか取得しないのならこちらは無視してください。）
テーブルを右クリックして「テーブルを開く(O)」
create procedure [proc_最終単価] as select [商品コード], [単価] as [最終単価] from [仕入データ] as [仕入データ1] where not exists ( select 1 from [仕入データ] as [仕入データ2] where [仕入データ1].[商品コード]=[仕入データ2].[商品コード] and [仕入データ1].[仕入日]<[仕入データ2].[仕入日] ) 【注意点】 ・仕入日はDATETIME（2008ならDATEもあり）にすべき。 ・単価で小数点以下が発生する場合はNUMERICにすること（FLOAT、REALは使わない） ・値引きなどがあるような場合を除いて数量×単価＝金額が常に成り立つなら金額欄を持つ必要は、基本的にない。
SQLServer2005以降ならROW_NUMBERが使えます --- UPDATE Table SET 連番 = ROW_NUMBER() OVER(ORDER BY コード) + 14 FROM Table
こんにちわ。 詳細な条件が不明なのでなんとも言えないですが 「UNION」結合ではどうでしょうか？ 例で言えば IDの1～3の3件、ID昇順 UNION ALL フラグ=2の2件、ID昇順 UNION ALL ID3以降、且つフラグ<>2、ID昇順 というようにやれば抽出できそうですが…
・.NET Framework 3.5 SP1 ・Windows PowerShell 1.0以上 が必須なSQL Server 2008 R2。.NET Frameworkの状態によってはうまくインストールができません。 いったん SQL Server 2008 R2、PowerShell、.NETをアンインストールして再度チャレンジしてみてはどうでしょう？
「管理者権限のあるユーザーでインストールすること」 という注意だけで済む話だと思うんだけど。 インストーラーがわざわざ 「あなたは管理者権限をもっていません。一度ログオフして xxxx または yyyy または zzzz でログインしてから再度インストーラーを実行してください。」 とか言う？ というか Inno Setup って使ったことないけど設定でセットアップ実行中のユーザーが Admin 権限を持っているか確認できるようにできるんじゃないの？ どうしても実現させたいっていうなら、Inno Setup がプログラムのセットアップよりも前に下のような VBScript を実行するとか。 Option Explicit Dim userNameList Dim strComputer strComputer = "." Dim objGroup Set objGroup = GetObject("WinNT://" & strComputer & "/Administrators") Dim objUser For Each objUser In objGroup.Members If objUser.Class = "User" Then userNameList = userNameList & objUser.Name & vbCrLf End If Next WScript.Echo "このコンピューターの管理者権限を持つユーザー一覧:" & vbCrLf & userNameList またはコマンドプロンプトで net localgroup Administrators とさせるとか。 または net localgroup Administrators をVBScript で実行させるとか。 Set objShell = CreateObject("Wscript.Shell") strCommand = "net localgroup Administrators" Set objExec = objShell.Exec(strCommand) Do Until objExec.Status Wscript.Sleep 250 Loop Wscript.Echo objExec.StdOut.ReadAll()
拡張ストアドの xp_cmdshell で可能です。 但し、この拡張ストアドは SQL-Server ユーザーがコマンドラインで実行可能な全ての行為を行なう事ができてしまいます。 それくらい危険極まりないので、デフォルトでは使えないようになっています。 （かつて猛威を振るったワーム型ウイルス Slammer は、確かこの xp_cmdshel を内部で使っていました） 使い方は以下、MSDNを参考に。 xp_cmdshell (Transact-SQL) http://msdn.microsoft.com/ja-jp/library/ms175046.aspx xp_cmdshell オプション http://msdn.microsoft.com/ja-jp/library/ms190693.aspx 企業やプロジェクトによっては、セキュリティの観点から xp_cmdshell の使用を禁止している場合があるかもしれません。 xp_cmdshell 以外にも方法はいくつか考えられます。 ■ストアドからDTSをキックする 自分はやった事無いですが（もしくは忘れてしまいましたが）多分、DTSが使えるのであればファイルの削除も可能でしょう。 ■OLE オブジェクトを使う 例えば、VB（VBA、VBS）などでファイルシステムを扱う場合、 CreateObject("Scripting.FileSystemObject") のように書きます。 これと同じ事をTransact-SQLでは sp_OACreate 'Scripting.FileSystemObject' と表現できます。 つまり、Scripting.FileSystemObjectの DeleteFile メソッドもストアドから実行できる、と言う事です。 こちらの方法は自分もやった事があります 結構ハマり、後々のお守りも大変だった記憶があります。 セキュリティの制限さえ無ければ、xp_cmdshell が一番楽チンです。
大体やりたい事のイメージはつかめます。 ＞wk_hizukeというテーブルには複数のレコードが入っており、そのレコード ＞を一件ずつ読みながら、上記の処理を行ないたいと考えております。 （略） ＞が、妥当と思われる構文を見出すことができずにおる次第です。 その場合は、「カーソル（CURSOR）」を使用します。 ・カーソルをオープンし、それを1行ずつ読み込んでループの中で処理する と言う方法です。 カーソルを定義して、オープンした後、そのカーソルを1行づつ処理します。 カーソルLOOPで1行読み込む事を「フェッチ（FETCH）」と言います。 本家MicrosoftのMSDN - FETCH (Transact-SQL) http://msdn.microsoft.com/ja-jp/library/ms180152.aspx ＠IT：ストアドプロシージャによる繰り返し処理 http://www.atmarkit.co.jp/fnetwork/rensai/sql22/sql1.html ストアドプロシージャの花形“カーソル”を使おう - ＠IT http://www.atmarkit.co.jp/fdb/rensai/tsql11/tsql11_1.html 肝の部分だけ簡潔に書くとこんな感じです。 （sp_hizukesanshutuに必要な変数定義や構文の確かさ等々は省略しています） -- カーソル定義 DECLARE wk_hizuke_cur CURSOR FOR SELECT tokuisakicode FROM wk_hizuke; -- カーソルオープン OPEN wk_hizuke_cur; -- 1行先読み FETCH NEXT FROM wk_hizuke_cur; --↓ ↓ ↓ ↓ ↓ LOOP処理開始（データが存在する間ループする） WHILE @@FETCH_STATUS = 0 BEGIN -- ↓1行読んだ後の処理をここに記述する -- ストアド呼び出し exec sp_hizukesanshutu @tokucd , @hizuke1 output; -- おそらくこの後、output の hizuke1 を使って何か処理するんでしょうね？ -- 更に1行追加で読み込み（データがあれば再度ストアド呼び出しを行なう） FETCH NEXT FROM wk_hizuke_cur; END --↑ ↑ ↑ ↑ ↑ LOOP処理終了 -- カーソルクローズ CLOSE wk_hizuke_cur; --最後のおなじない DEALLOCATE wk_hizuke_cur; この手の処理の王道が、上記のカーソルでLOOPする方法です。 バルク的にガッと一発で処理する方法と言うのも、アレコレいじれば多分可能ですが、output を使って何か処理するのであれば、バルク的な処理はできない、と言う要件ですよね、おそらく。 いずれにせよ、まずは王道を先に身に付けた方がよろしいかと思います。
特定文字を除去した結果何文字短くなったか、で判定できます。
＞次に別々のPCに分けてインストール→ミラーリングする場合 ＞どうなりますか？ 下記URLの「フェールオーバー機能を利用する場合」を参照して下さい。 http://www.microsoft.com/japan/sqlserver/2008/howtobuy/system.mspx サーバライセンスならば、1ライセンス プロセッサライセンスならば、使用するサーバで一番多いプロセッサ数分のライセンス になると思います。 ＞まず、同じPC内でHDDを分けてSQLをインストールする場合 ＞プライマリ用、セカンダリ用、監視用と ＞別々にライセンスが必要ですか？ 現実的に運用環境でこの構成になることはありえません。 ミラーリングにする意味が全く無いからです。 従って、この構成のライセンスを判断する意味はありません。 検証環境で構成するのならライセンスは関係ないですし。 しいて言えば上記のライセンスと同じ判断のような気がしますが、マイクロソフトに確認しないとわからないです。 （確認する場合にも、何でそんな構成なのと突っ込まれる可能性が高い気がしますが） ＞接続ユーザーのCALはプライマリへの接続分で ＞よいのでしょうか？ SQL ServerのCALについては、下記URLの「購入する CAL を選択しよう」を参照して下さい。 http://www.microsoft.com/japan/sqlserver/2008/howtobuy/default.mspx SQL ServerのCALは、サーバ数に関係なくSQL Serverに接続するユーザー又はデバイスに対して1ライセンスとなるはずです。
TABLE2.[TYPE] in ('77','88','99') でいいのでは?
sqlcmdのプロンプトを二つ立ち上げて （トランザクション1） begin tran go select * from テーブル with ( updlock ) where 条件 go （トランザクション2） update テーブル set 項目 = ～ where 条件 go として見てください。トランザクション2は待ちになります。 トランザクション1のselect文の with ( updlock ) を取ると待ちになりません。
> メールアドレスの入力チェック perl5.10以降なら http://www.din.or.jp/~ohzaki/mail_regex.htm ここのあたりの記事も参考に http://blog.livedoor.jp/dankogai/archives/51189905.html
こんにちは。 試してみました。 定義は消えてしまうようですね。(TraceID自体が消えていました) 考えた方法は、トレース定義+トレース開始のスクリプトをストアドプロシージャにして、 そのストアドを自動実行させる方法です。 exec sp_procoption 作成したトレースのストアドプロシージャ名,startup, true; 自動実行を終了させる場合、 exec sp_procoption 作成したトレースのストアドプロシージャ名,startup, false; 自動実行登録されたストアドを調べる際は、 SELECT * FROM sysobjects WHERE xtype IN ('X','P') AND ObjectProperty(id, 'ExecIsStartup') = 1 とかで調べられると思います。 トレースの停止と終了を正しく行わない(インスタンス終了で停止)のためトレースファイルを開くときは権限を与えてあげないと開けませんでした。 よろしければお試しください。
8GB の何をどういう風に送っているのかまったく書かないのですね。 Command オブジェクトを使用しているのならタイムアウト値を無制限にするとか。
row_numberで1からの連番ふれるよ INSERT INTO ATBL(CD, NO, NAME) SELECT CD, row_number() OVER(ORDER BY CD) AS NO, NAME FROM BTBL
SELECT 得意先ID, SUM( CASE MONTH(年月日) WHEN 1 THEN 売上金額 ELSE 0 END ) AS 1月売上, SUM( CASE MONTH(年月日) WHEN 2 THEN 売上金額 ELSE 0 END ) AS 2月売上, SUM( CASE MONTH(年月日) WHEN 3 THEN 売上金額 ELSE 0 END ) AS 3月売上, SUM( CASE MONTH(年月日) WHEN 4 THEN 売上金額 ELSE 0 END ) AS 4月売上, SUM( CASE MONTH(年月日) WHEN 5 THEN 売上金額 ELSE 0 END ) AS 5月売上, SUM( CASE MONTH(年月日) WHEN 6 THEN 売上金額 ELSE 0 END ) AS 6月売上, SUM( CASE MONTH(年月日) WHEN 7 THEN 売上金額 ELSE 0 END ) AS 7月売上, SUM( CASE MONTH(年月日) WHEN 8 THEN 売上金額 ELSE 0 END ) AS 8月売上, SUM( CASE MONTH(年月日) WHEN 9 THEN 売上金額 ELSE 0 END ) AS 9月売上, SUM( CASE MONTH(年月日) WHEN 10 THEN 売上金額 ELSE 0 END ) AS 10月売上, SUM( CASE MONTH(年月日) WHEN 11 THEN 売上金額 ELSE 0 END ) AS 11月売上, SUM( CASE MONTH(年月日) WHEN 12 THEN 売上金額 ELSE 0 END ) AS 12月売上 FROM 売上明細テーブル GROUP BY 得意先ID 年月日DADETIME型であることを想定しています。 年月日が複数年に渡る場合はWHERE条件で絞り込んでください。 売上金額をSQLでカンマ区切り書式の文字列にしたい時はCONVERTを活用します。 http://www.ilovex.co.jp/Division/SRD/archives/2007/08/convert_1.html
>SQLServerのCALの考え方をお教え下さい。 http://www.microsoft.com/japan/sqlserver/2005/howtobuy/sqlserverlicensing.mspx にあるdocの「マルチプレキシング」を参照。 >実利用者分必要orAPのデバイス数分必要 Webシステムだと プラウザの実利用者分必要 or ブラウザのデバイス数分必要 になると思います。 CAL数が多いならプロセッサライセンスがお得。 あと、Windows Server CALも必要です。 安く上げるなら、Windows Server Web Edition + SQL Server Express Editonがお勧め。
>UPDATE文だと思う insertしたいのでは？ それとも、通番などを振った行を予め格納して、それをupdateしたいといった要件でもあるのですか？ insert into A."顧客マスタ"("顧客番号１","顧客番号２","顧客番号２") select substring("顧客番号",1,3) ,substring("顧客番号",4,3) ,substring("顧客番号",7,2) from B."顧客マスタ"
参考までに WITH T( [DATE] ) AS ( SELECT GETDATE() AS [DATE] UNION ALL SELECT [DATE] - 1 FROM T WHERE [DATE] >= GETDATE() - 30 ) SELECT * FROM T;
SQL　Server2008　Expressをインストールする際に混合認証にするか、するとすればsaのパスワードを何にするか入力する画面があったはずです。 混合認証を選んでいるなら、その時に入力したパスワードを指定してください。
「フリーで使えるデータベースを手に入れる」でしょうね。 MySQLやPostgreSQL、Oracleにもトライアルのためのダウンロードがあります。 ただ、インストールや設定のハードルが高いように感じられるなら トライアル版付きの書籍（入門書）を入手するが良いかも。 （ブックオフの105円コーナーあたりで見かけることがあります）
「SELECT 'ABC123' , 'りんご' FROM foo」と書くとfooのレコード数だけの行の（'ABC123' , 'りんご'）というデータを作成してしまいます。 質問の記述ではDISTINCTを用いてそれを再度一行にまとめようとしています。しかし、fooにそもそも一行もデータがないとまとめる段階でデータが存在しないので挿入できないのです。 また、fooのレコード数だけのレコードを作ってまとめるのは無駄な作業で、fooのレコード数が増加していくとパフォーマンスの劣化が見逃せなくなります。 SQLを記述する時は、「とりあえず、動けばいい」ではなく、どんな動作が裏で行われているかを念頭に置いておくようにしてください。 で、ACCESSですが、ACCESSの場合はFROM句を省略出来ません。 その代わりに何でもいいので一行のレコード（しかも一行のみ）のダミーテーブルを作成し、FROM句を構成すればいいのです。（OracleのDUAL表と一緒です） フィールドも一つでバイト型で構いません。とりあえず「0」の値を入力しておけば結構です。テーブル名も「DUAL」とでもつけてください。 そうすれば INSERT INTO foo(商品コード, 商品名) SELECT DISTINCT 'ABC123' , 'りんご' FROM ＤＵＡＬ WHERE NOT EXISTS( SELECT * FROM foo WHERE 商品コード = 'ABC123' ) でいけるはずです。
指摘したことの繰り返しになりますが、ユーザーA，Ｂがいてほぼ同時に作られたSQLを実行した場合、後続のSQLは先行のSQLの終了を待ちません。すなまち、同じMAX値を取得します。 作られたSQLシングルユーザーで間をおいて実行している限りは正常に動くでしょう。しかし、マルチユーザーで負荷が高く鳴った時はエラーを起こす可能性をもっています。潜在的バグですね。
クエリによるトレースファイル作成ならいかがでしょうか？ プロファイラでお好みの設定で実行します。 ファイル-エクスポート-トレース定義のスクリプト　からスクリプトを保存します。 プロファイラは終了してください。 ManagementStudio、クエリアナライザなどで↑で保存したSQL開きます。 「exec @rc = sp_trace_create @TraceID output, 0, N'InsertFileNameHere', @maxfilesize, NULL」 こんな一文がありますので、「InsertFileNameHere」の部分に保存先のパス+ファイル名に変更 実行します。 ☆このとき結果として出力された値は、停止と終了で使用するので控えてください。 これでトレースファイルが作成されていきます。 ファイルの作成数、1ファイルのサイズ上限など設定できますのでお好みに。 ManagementStudio、クエリアナライザは閉じて大丈夫だったと思うのでこれでいけるのではないかと思います。 停止、終了は、 sp_trace_setstatus 2, 0 --2の部分は☆の出力された値、0は停止です。 sp_trace_setstatus 2, 2 --2の部分は☆の出力された値、2は終了です。 この順番でやらないと作成中のファイルが開放されないので気をつけてください。 ちなみに、 sp_trace_setstatus 2, 1 --2の部分は☆の出力された値、1は開始です。
以下の事を補足願います。 １．サービスですでにSQL　Server　Agenntが起動していないか？ ２．ログにエラーメッセージ等がでていないか？ 以上　２点　宜しくお願いします。
>現在メンテナンスしているシステムです。 ウェブベースなんですか。 The underlying connection was closed: Unable to connect to the remote server. で検索してみると、 proxyサーバーがhttpリクエストを拒否している可能性 DNSの解決ができていない可能性 などが示唆されています。 http://nilangshah.wordpress.com/2007/03/01/the-underlying-connection-was-closed-unable-to-connect-to-the-remote-server/
テーブルAとテーブルBで、同一内容のレコードが存在していても全件取得したいなら SELECT * FROM テーブルA union　all SELECT * FROM テーブルB テーブルAとテーブルBで、同一内容のレコードが存在している場合に除外して取得したいなら SELECT * FROM テーブルA union SELECT * FROM テーブルB
こうしたらどうでしょうか。 order by case substring(itemNo,1,1) when 'P' then 1 when 'N' then 2 when 'Q' then 3 else 99 end , itemNo SQLServerの環境がないので動作確認はしていませんが・・・
単純に以下でOKかと思います。 select 品番 from Table where ((販売開始日<='2011/03/01' AND 販売終了日>='2011/03/01' ) OR (販売開始日>='2011/03/01' AND 販売開始日<='2011/03/31' ) OR (販売開始日<='2011/03/01' AND 販売終了日>='2011/03/31' )) ケースとしては以下の５パターン（開始日2011/3/1は検索開始日、終了日2011/3/31は検索終了日と表現を変えてます。） 販売開始日、販売終了日ともに検索開始日より前⇒取得しない 販売開始日、販売終了日ともに検索終了日より後⇒取得しない 販売開始日が検索開始日より前で且つ販売終了日が検索範囲の間⇒取得対象 販売開始日が検索範囲の間で且つ販売終了日が検索終了日より後⇒取得対象 販売開始日、販売終了日ともに検索範囲の間⇒取得対象 後程の保守性等を考慮しても、上記の書き方なら見た目でもわかりやすいと思いますよ。 （目的がすぐにわかる）
機能面では、SQL Serverが上回りますが、クエリはデザイナを使って作成するものだと思っていると、ちょっと苦労するかもしれません。 SQL Serverのクエリデザイナは、あくまで補助的なもので、Accessのものほど高機能ではありません。やはり直接SQL文を書くのが基本です。 なお、おそらく唯一Accessでしかできないクエリ機能は、クロス集計クエリです。これをクエリ(ビュー)で実装することは、SQL Serverではできません。
Floor関数を利用します。 UPDATE 商品マスタ SET 単価 = Floor(単価) Floor関数は、指定した数値以下で最大の整数を返す関数です。 正の数なら単純に切り捨てとなりますが、負の数の場合は注意が必要です。
UPDATE　商品マスタ　SET　単価　=　単価　*　1.05 でいいのでは？ 一部の商品のみであれば後ろにWHERE句をつければ良いと思います。
SELECT 元テーブル.売先コード, 元テーブル.需要家コード, 売先名称テーブル.取引先名称 AS 売先名称, 需要家名称テーブル.取引先名称 AS 需要家名称 FROM 元テーブル LEFT JOIN 取引先テーブル AS 売先テーブル ON 売先テーブル.[売先、需要家コード] = 元テーブル.売先コード LEFT JOIN 取引先名称テーブル AS 売先名称テーブル ON 売先名称テーブル.取引先名刺ID = 売先テーブル.取引先名刺ID LEFT JOIN 取引先テーブル AS 需要家テーブル ON 需要家テーブル.[売先、需要家コード] = 元テーブル.需要家コード LEFT JOIN 取引先名称テーブル AS 需要家名称テーブル ON 需要家名称テーブル.取引先名刺ID = 需要家テーブル.取引先名刺ID; ですね。
以下のSELECT文を参考にしてください。 SELECT 社員一覧.社員コード, カレンダー.日付, 出勤データ.出勤, 出勤データ.退勤 FROM (SELECT DISTINCT 社員コード FROM 出勤データ WHERE 日付 BETWEEN '2011/03/01' AND '2011/03/31') AS 社員一覧 CROSS JOIN カレンダー LEFT JOIN 出勤データ ON 出勤データ.社員コード = 社員一覧.社員コード AND 出勤データ.日付 = カレンダー.日付 WHERE カレンダー.日付 BETWEEN '2011/03/01' AND '2011/03/31';
もう解決してるかもしれませんが。。 Fields("Name")が返すのは値ではなく、Fieldオブジェクトだから、当然そうなります。ToStringではなく、Valueです。 それにしても、これは限りなくレガシーVBなソースですね。
SQL ServerはDDLでもロールバックされます。 一時テーブルでも実テーブルでも同じで、ロールバックすると無くなります。
dbo.[テスト（テスト）] というか、テーブル名を変更するべき
サーバサイドトレースを仕掛ける方法になるでしょう。 http://msdn.microsoft.com/ja-jp/library/ms191443(v=SQL.90).aspx
テーブル（オブジェクト）のリネーム構文は以下の通り。 sp_rename [ @objname = ] 'object_name', [@newname =] 'new_name' Excelでも使用して新旧名称をまとめ、式としてSQL文として生成（複数行可） 列Aに旧名、列Bに新名があるとします。 （一行目ならセルA1に旧名、セルB1に新名） セルC1に式[="sp_rename '" & B1 & "', '" & A1 "'"]を入力 セルC1を必要なだけコピー。 列Cをテキスト保存するなり、コピペなり。 上記をクエリアナライザにコピペして実行するも良し。 OSQL(今はSQLCMDかな）で実行するも良し。
データバースサーバをインタネットに晒すなんて恐ろしすぎます。 ASP.NET WebサービスとWinフォームによる、いわゆるスマートクライアントという手も。
変更方法がここに記載されています。 http://msdn.microsoft.com/ja-jp/library/ms143799(v=SQL.100).aspx ミラーリングとかログ配布とかしてなければ、コンピュータ名を変更して書かれているプロシジャを実行するだけだと思います。 SQL Serverはこれでいいですが、接続するアプリ側のことが書かれていません。 クライアントサーバならば、接続設定を変える必要もあると思いますし、ローカル上にある場合も変更の必要がある場合もありますので注意されたほうがいいでしょう。
参考URLを添付します。 インポートとリンクの方法、両方説明していますので、ご注意ください。 ODBCで接続する場合はODBC設定も忘れずに！
> DAO感覚でIndexしてseekすれば高速検索が簡単にできると甘く考えておりました。 そう美味しい話はあまり、ありません。 DAO感覚でやろうするなら、一捻りしてパススルークエリとワークテーブルを使うやり方があります。 最初のクエリ発行の際にある程度の絞り込みが出来るのが前提ですが、ワークテーブル（INDEX作成済み）の全件削除、パススルーのSQL組み立てとこのパススルークエリのデータをワークテーブルに挿入するクエリの実行。 後は、非接続ですが、高速に扱えます。 更新の場合は、別途ADOでもいいので更新・削除・追加クエリを発行することになります。 ただし、非接続なので、他のユーザーが更新していないか、チェックして更新用のSQLを実行することになりますので、ADOのトランザクション機能を使うのがいいかもしれません。 欠点は最初のパススルークエリでのデータ件数が多いと、ネットワーク負荷・DISK負荷が高いのでレスポンスが悪いのと、ワークテーブルの全件削除と挿入を繰り返すのでローカルのACCESSのファイルが肥大化しやすいことです。
こんにちは。 Bテーブルでループしては？と思いましたがとりあえず書いてみました。 動作確認はしていませんので間違えてる部分があるかもしれません。 気になったところを追記削除しています。 どんなエラーが出るか書いていただけるとより答えやすいです。 以下にコードを記述します。 ALTER PROCEDURE XXX @BunruiCD CHAR(10) AS BEGIN DECLARE @TBL_A_ID CHAR(5) DECLARE TBL_A_DATA CURSOR FOR SELECT A.ID FROM TBL_A WHERE BUNRUI_CD = @BunruiCD --begin(必要ないと思います) OPEN TBL_A_DATA FETCH NEXT FROM TBL_A_DATA --ここで 1つめのデータを入れます INTO @TBL_A_ID --ループ開始 WHILE @@FETCH_STATS = 0 BEGIN IF NOT EXISTS(SELECT * FROM TBL_B WHERE ID = @TBL_A_ID) BEGIN --Bテーブルにデータが存在した場合は削除する DELETE FROM TBL_A WHERE TBL_A_ID = @TBL_A_ID END ELSE BEGIN --特に処理なし（UPDATE等する予定） END FETCH NEXT FROM TBL_A_DATA --次のデータを入れます INTO @TBL_A_ID END CLOSE TBL_A_DATA--終わったらカーソルを閉じます DEALLOCATE TBL_A_DATA--終わったらカーソルを削除します END
UPDATE - INSERT - DELTE の順で処理し UPDATE は INNER JOIN で他は NOT EXISTS を使用する方法はいかがでしょうか。 例えば BEGIN UPDATE TableB SET TableB.Filde1 = TableA.Filde1 ・・・・・・ FROM TableB INNER JOIN TableA ON TableB.ID = TableA.ID END BEGIN INSERT INTO TableB SELECT * FROM TableA WHERE NOT EXISTS(SELECT * FROM TableB WHERE TableA.ID = TableB.ID) END BEGIN DELETE FROM TableB WHERE NOT EXISTS(SELECT * FROM TableA WHERE TableB.ID = TableA.ID) END こんな感じで。 SELECT文で確認してから実行してね！
SQL Serverの場合、insertedとdeletedのデータ有無で判断するのが、一般的です。 両方あれば、UPDATEです。
>アンインストールしてしまうとどのような問題が生じるのでしょうか？ 「SmartPhoto」というのはNECの写真管理ツールだと思いますが、現在使っていないならアンインストールしても問題ないでしょう。 新しく買われたデジカメにはZoomBrowser EX（Win）が付属しているようですから、そちらを使う選択肢もあるでしょう。
MS SQLSERVERは他のDBと比べても内部仕様あまり公開していないんで、通常の人では確たることは言えないと思います。 知っていても契約などで、非公開情報になっている可能性もあります。 Oracleのマニュアルからですが、既定値ではWindows Serverはディスク・キャッシュに結構メモリを配分するようです。 http://otndnld.oracle.co.jp/document/products/oracle10g/102/windows/B25020-03/tuning.htm#658607 レジストリでディスク・キャッシュの仕様最大量を変更出来れば、メモリの負荷も少しは減らせるかもしれません。
処理対象のテーブルは一つですか？ レコード長はどれくらいでしょう？ 現在の件数とこれからの増加の見込みは？ 検索・更新処理は一日のうちどれくらい実行されますか？ 検索・更新の対象になるのは全体の件数のうち何割ぐらいですか？ もし、検索・更新の対象になるのが全体のうち極少数なら、そのフラグ項目にインデックスを張れば検索は速くなります。一方、それなりの割合になるのなら、別なアプローチが必要です。 たとえば、年月単位にデータが蓄積されていくデータの場合、テーブルを年単位でパーティション分割するという手段もあるかもしれません。
再びNo.1です。 いろいろと調べてみましたが、 おそらくそのエラーはプロシージャキャッシュが、 オーバーフローしているんだと思います。 私はプロシージャキャッシュのことをよく分からないので、 一度調査されてみては如何でしょうか。
商品マスタをメインにして売上テーブルを左外部結合すれば、1回のSQLでデータ取得できるはずです。 select 商品マスタ.商品名,Count(商品マスタ.商品名) from 商品マスタ left outer join 売上テーブル where 売上テーブル.商品ID = 商品マスタ.商品ID group by 商品マスタ.商品名 こんな感じのSQL分でお望みの結果が出ると思うのですが・・・SQL Serverの環境がないので検証出来ません。
開発（設計）時に知っておいたほうが良い点として ・更新中のレコードを他のプログラムが参照する時の振る舞いの違い 　（更新前レコードを返すか待たせるか） ・ロックエスカレーション は意識したほうが良いと思いません。 ＃動けば良い・・レベルだと気にする必要はありませんが・・
補足をお願いします。 uchi38さん、pamanatuさんともに開示する情報が少なすぎます。 少なくともクライアントからの接続形態・現象発生時のエラーコード・メッセージ等を記されないと、どんな識者でも検討はつかないと思います。
使用されているフリーソフトが何なのか分からないので、保存したテキストファイル（何とか.sql）の変換方法なら、 perl -p -e "s/\x22//g" 何とか.sql > 出力.sql でダブルクォーテーションはとれます。 ただ、データでダブルクォーテーションで括られていたということは、挿入先は文字列項目では？ その場合は perl -p -e "s/\x22/'/g" 何とか.sql > 出力.sql とすればダブルクォーテーションをシングルクォーテーションに変えてくれます。 windows用のperlについては以下のページを参考に http://pocketstudio.jp/win/activeperl/ ダウンロード元は http://downloads.activestate.com/ActivePerl/releases/5.12.2.1203/の ActivePerl-5.12.2.1203-MSWin32-x86-294165.msiが最新です。
こんばんは ご質問の内容だけならば、データのあるテーブルを Table_1 とすれば、 SELECT 明細ID, MAX(日付) AS 日付 FROM dbo.Table_1 GROUP BY 明細ID で可能です。 そうでなくてTable_1の他のフィールドが必要なら以下のようにします。 方法は2段で、 まず、View_1を上記と同じように設定します。 SELECT 明細ID, MAX(日付) AS 日付 FROM dbo.Table_1 GROUP BY 明細ID 次にView_2を以下のように設定します。 SELECT dbo.Table_1.num, dbo.Table_1.明細ID, dbo.Table_1.日付, dbo.Table_1.データ１ FROM dbo.Table_1 INNER JOIN dbo.View_1 ON dbo.Table_1.明細ID = dbo.View_1.明細ID AND dbo.Table_1.日付 = dbo.View_1.日付 もしかしたら、こちらが参考になるかもしれません。 http://oshiete.goo.ne.jp/qa/6484067.html
DBMSのパフォーマンスチューニングに魔法はありません。 工数、予算の関係上、仕方ない部分もありますが、どう考えても条件が理不尽です。 「以前にオラクルでアナライズにより飛躍的に処理速度が向上した経験があります。」 SQL SERVERにも「UPDATE STATISTICS」という統計情報を更新するコマンドはありますが、現状で「なぜ遅いのか」を突き止めないでむやみに行っても結果がしれていると思います。 まず、何がボトルネックになっているか調べてください。パフォーマンスモニタでCPU（多分マルチCPU、マルチコアだと思いますが）の使用率、WAIT。DISK I-Oの転送量、WAIT。がどうなっているのか、書込み量、読込み量。特定のボリュームにI-Oが偏っていないかなど。 SQLの実行プランは取得されているのでしょうか。場合によってはINDEXを一つ追加するだけで解決する場合もあります。 その上で、パラメータチューニングできるかどうか検討してみてください。 「Dr. K's SQL Serverチューニング研修」 http://www.atmarkit.co.jp/fdb/index/subindex/drk_subindex.html
Manegement Studioで復元実行時にデータベースの上書きオプションがありますが、これをやってもだめでしょうか？
インストールしようとしている端末に別途、SQLServerの別のコンポーネントがインストールされていませんか？ またインストール使用している端末とインストールEXEのbitはあっていますか？ 確か32bit用と64bit用があったと記憶していますが・・・。
実際に不可能ではないですが、 片方のコネクションがトランザクションを開始してしまい、 あるテーブルの行を更新してしまうと、 もう片方のコネクションはコミット待ち状態になります。 本来、コネクションは複数持つべきではありません。 SQLServerの同時接続数にも触れますし、 1つのコネクションを使いまわすのが一般的です。 コネクションは引数等も利用して1つにするように心掛けましょう。
私はSP2を当てたらできました。
　え？　MDB+MDBからADP＋SQL Serverに移行という話じゃなくってですか？ 　ま・・・・いいや。それは無理でしょうね。AccessのODBCテーブルリンクの仕様でしょう。ODBCテーブルリンクはいくつものリンク先に接続できるため、名前がかぶる可能性があるからだと考えられますが、確かに煩わしいですね。本当にかぶったときは自動で連番になるんだからどうでも良さそうなものなのに。 　・・・・ところで、せっかくバックエンドをMS SQL Serverに移行した訳なので、MDB＋ODBCテーブルリンクではなく、ADPを使ってみてはいかがでしょうか。ADP（Access Database Project）というのは、テーブルとクエリー（SQL Serverでは「ビュー」）の２つをSQL Serverが担い、フォーム、レポート、マクロなどはAccessが担当するというもので、MDBのテーブルであるかのようにSQL Serverのテーブルを操作できるのと多数のADPでSQL Serverを共有できるのが特徴です。もちろん若干MDBとは使い勝手が違いますが、データをすでにSQL Serverに移したという事なのでADPは十分検討の対象になると思います。 　ほとんど回答になっていませんが、それでは。
納入先テーブル（NOUNYU_ID,納入先)で「NOUNYU_ID」が主キーなのに、「納入先」だけ挿入しようとしているから、「NOUNYU_ID」にNULLを挿入しようとしてエラーになっているのでは。 そもそも、「納入先」が部品テーブルにあって納入先テーブルにないデータを挿入しようとしているように見えますが、その際の「NOUNYU_ID」の符番ルールはどうなっているのでしょうか。
ORACLEのPL/SQLのNULLステートメントのイメージですね。 T-SQLにはなかったと思います。
select count(*) from tbl where flag=1; select num,point from tbl where flag=1; の二つのSQLを実行するのでは駄目なのですか？ Flag列にINDEXを作成すればそんなに遅くはならない気がするのですが。
bcpを使用しないでT-SQL(つまりsqlcmdやManagementStudio)から、SQL文でCSVを 作成するということでしょうか？ bcpが使えるならbcpでCSV出力可能です。 SQLだけでやるなら以下のように連結して出力します。 select col1 + ',' + col2 + ',' + col3 from tname; もう少し前提条件をしぼってもらえればピンポイントでアドバイスできるかと思います。
ここらへんの事でしょうかね。 [ディスク使用量の概要レポート] http://msdn.microsoft.com/ja-jp/library/cc280506.aspx
「xp_cmdshell」で検索してみてください。 後、「SQL CLR」を使用しても可能かもしれません。 ただ、どちらの方式もセキュリティ的には危険性を伴う可能性があります。
bcpにこだわらなくてもいいのではないでしょうか。 vbscriptを使って Option Explicit Dim cn Dim rs Dim exl Dim Book Set exl = CreateObject("Excel.Application") exl.visible = True if exl is nothing then msgbox("excel 起動エラー") WScript.Quit 1 else exl.Workbooks.Open "C:\users\xxx\book1.xls" end if 'ADOオブジェクトを作成します Set cn = CreateObject("ADODB.Connection") cn.Open "Driver={SQL Server};server=(local);database=pubs;user id=xx;password=xx;" if cn is nothing then msgbox("SQL Server 接続エラー") exl.quit set exl = Nothing WScript.Quit 1 end if set rs = cn.execute("select ～") exl.sheets("Sheet1").cells(1,1).copyfromrecordset rs exl.Workbooks("db1.xls").Save exl.quit Set exl = Nothing rs.close cn.Close Set rs = Nothing Set cn = Nothing という内容のファイル(仮にado.vbs)を作成して Cscript /nologo ado.vbs というコマンドを実行すればどうでしょう。
str関数は固定長で右揃えした文字列を出力する関数っぽいですね。 http://technet.microsoft.com/ja-jp/library/ms174140%28SQL.90%29.aspx 整数を文字列に変換するなら、素直に cast(XX as varchar)の方がTrimもいらない様だし安心かと。 あと、"_table"の部分がテーブル単位で固定であるなら ストアド内で書きこむのではなく、トリガーとか、計算列とか、 場合によってはビューの使用も考慮していいんじゃないかという気がします。
#6です。 気になったの書き込みます。 参照側で考えていましたが、更新側のロック範囲は適正でしょうか？ 不必要に広い範囲に排他ロックを掛けていないでしょうか。 例えば更新が select xx from yy where zz>aa for browse のようになっていると広範囲にロックが確保され要注意です。 また、更新がバッチであれば、途中コミットして排他時間を短くするなりの対策が考えられます。 とにかく参照処理も更新処理も出来るだけ範囲を小さくされることをお勧めします。
SQLを考える時には理論を考えないと いけません。それと、質問が曖昧です。 >この中で一番新しい（＝若い）日付の 日付は二つあるんですよね？ 配送日なのか到着日なのかハッキリ しません。配送日が早くても、到着日が 遅い場合もあるのでは？ 「新しい」と言いますが、２行目は一番 古いですよ。 ここでは「古い配送日」と仮定します。 (1)テーブルＢから依頼No毎に、一番 　日付の古い（小さい）ものを抽出する。 (2)上記クエリとテーブルBを依頼Noと 　最も古い日付と結合させ、依頼Noと 　枝番を抽出する。 (3)上記のクエリと依頼No、枝番が一致 　するデータを抽出する。 これを表わすと以下のようになる。 SELECT A.* FROM テーブルＢ A INNER JOIN (SELECT B.依頼No,B.枝番 FROM テーブルＢ B INNER JOIN (SELECT D.依頼No,MIN(D.配送日) 過去日 FROM テーブルＢ D GROUP BY D.依頼No) C ON B.依頼No=C.依頼No AND B.配送日=C.過去日) E ON A.依頼No=E.依頼No AND A.枝番=E.枝番 ちょっと分かり難いので説明します。 ２番目のサブクエリ"(SELECT D.依頼No～) C" この部分が(1)にあたります。このカッコの 内側は依頼No毎に最過去日を取っています。 １番目のサブクエリ"(SELECT B.依頼No～) E" ここは最初のクエリ（Cというエイリアス）と 依頼No、日付が一致するクエリで(2)にあたり ます。 最も外側の"SELECT A.*～"が目的の結果を 得るためのものです。 外国語なんでね、日本人の考えと逆順になる ところがイヤですね。
not exists を使って select 依頼no発送日,到着日 from table名 a where not exists(select * from table名 b where a.依頼No. = b.依頼No and a.発送日 > b.発送日); 分析関数が使えるなら select 依頼no,発送日,到着日 from (select 依頼no,発送日,到着日,row_number() over(partition by 依頼no order by 発送日) rnum from table名) where rnum = 1; とかでしょうか。
これではどうでしょうか。 update テーブル set 会員種別 = case substring(会員No,1,1) when '1' then '0001' when '2' then '0002' --when ・・・もっと必要であれば end;
インポート定義を使えばインポートできる はずですが。 テキストインポートウィザードの下にある設定を 選択し、フィールドの区切り記号をカンマ、 文字列の引用符を「"」とすればうまくいくと 思います。
メッセージからするとSQL Serverのインストール状態がおかしいと言っているので、2008のアンインストールがうまく行っていないのではないでしょうか?。 「sqlboot.dll」がおかしい(必要なエントリが無い)らしいので削除してみてはいかがでしょうか?。 これがどこにあるかにもよります。ProgramFilesの下であれば2008のアンインストールがうまく行っていないと思います(これの場合は大変です)。Windows\System32の下であればリネームしてから2005をインストールしてみるのも1つの方法です。 と言うことで、出来れば2008を再インストールしてからきれいに(もしクライアント等関連ありそうなもの全て)アンインストールするのが良いと思います。 Windowsに詳しい方であれば2008をアンインストールした後、2005に失敗するのであれば、レジストリから2008に関係する項目をきれいさっぱり削除(サービス等の登録にも目配りして)してからWindowsを再起動してから2005インストールすればOKですが。 それからもう一つ(藁にすがる感じですが)、 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session ManagerにPendingFileRenameOperationsがあれば削除して2005をインストールをやってみてください。 これは前回のペンディングのインストール情報の削除です。エラーメッセージからするとこれではなさそうですが。 参考まで。
　直感的に「名前付きパイプ」は怪しい気がします。出来ればTCP/IPでユーザ名/パスワードによる接続には出来ないでしょうか。 　あとはWindows7のWidnowsファイアーウォールは通っていますか。参照のようにTCP1433とUDP1434に穴を空けていますか。一時的に全て通してしまうのが手っ取り早いと思います。 参考まで。
ExcelをAccessにリンクしてリンクテーブル とします。Accessのバージョンによっては Excelは読み取りのみになりますが、この場合は 読み取りでいいのでそのままリンクします。 リンク方法は外部ファイルのテーブルをリンクする場合 と同じですが、ExcelのSheet名がテーブル名 になり、フィールド名はExcelで設定している たとえば、A1、A2などにID、商品名などと 設定しているとそれをフィールド名として 設定できます。 ファイルから「外部データの取り込み」を 選択し、「テーブルのリンク」を選択し、 ファイルの種類をExcelに変更し、フォルダに 移動してExcelファイルを選択するとウィザードが 起動されます。 次に、クエリを作成します。たとえば、Excel とAccessにID、商品名があるとして、 先に更新クエリを実行します。 UPDATE Tdata INNER JOIN Sheet1 ON Tdata.ID=Sheet1.ID SET Tdata.商品名=Sheet1.商品名 WHERE Tdata.ID=Sheet1.ID; 続いて、追加クエリを実行します。 INSERT INTO Tdata SELECT * FROM Sheet1 WHERE ID NOT IN (SELECT ID FROM Tdata); このような方法はどうでしょう。なお、 フィールドが他にある場合はクエリの デザインビュー、あるいはSQL文の中で 追加してください。 なお、 実行時エラー「ファイルの共有ロック数が制限を超えています」 というエラーが出れば以下。 http://support.microsoft.com/kb/209940/
すみません、sqlserverでしたね、それでは select * from 棚卸履歴テーブル where 棚卸日 >= convert(varchar(4),getdate(),121) + '-4-1'; か select * from 棚卸履歴テーブル where 棚卸日 >= convert(varchar(4), case when month(getdate())<=3 then year(getdate()) - 1 else year(getdate()) end,121) + '-4-1'; を試してください。
SQLServerの場合char,text,varchar型はデフォルトではcp932≒sjis nの付くnchar,nvarchar,ntext型はutfのようですね。
　SQL Serverのロック機構は、トランザクション境界内で実行されます。 　http://technet.microsoft.com/ja-jp/library/ms186690%28SQL.90%29.aspx（２００５の記事ですが、２００８でも基本的に同じです。） 　 　さて、トランザクション制御は、セッション制御と絡み合いますが、事故によりセッションが切断された場合は、トランザクションはロールバックされます。この処理は、 　http://technet.microsoft.com/ja-jp/library/ms175523%28SQL.90%29.aspx（同じく２００５の記事です。が、２００８でも、基本的に同じです。） 　に記述があります。 　二つを合わせると、アプリケーションが落ちた場合やネットワークが切断された場合は、トランザクションがロールバックされることにより、ロックも解除されると解釈できますが、どうでしょうか？ 　実際、挙動もこれであっていると思います。
エディション別の機能比較は、 http://technet.microsoft.com/ja-jp/library/cc645993.aspx を参照してください。 Express Editionでの制約として、今回のケースで問題になりそうなのは、 データベース使用可能HDD容量：10GB データベース使用可能メモリ：1GB だと思います。 容量は、サイジング値から判断すると問題無いように思います。 メモリがネックになる可能性はあります。 使用用途にもよりますが、データ量が増えてきたときに問題になるかもしれません。 APのつくりに左右されますので、 評価環境にて評価をした方が良いかと思います。
ここのあたりを参考にしてください。 http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub05_130_030.html 注意点は ・参照設定でADOを有効にしておく必要がある。 ・ADODB.CONNECTION、ADODB.RECORDSETを宣言する際にnewを付加しておく。 ぐらいかな。
sysobjects http://msdn.microsoft.com/ja-jp/library/ms177596.aspx sys.objects http://msdn.microsoft.com/ja-jp/library/ms190324%28SQL.90%29.aspx
SQL Server 2000と2008は共存可能です。 導入する顧客管理ソフトアプリが動くかどうかは別として……。 導入した顧客管理ソフトがインスタンス名を指定できるようになっている、もしくはカスタマイズできるのであれば大丈夫です。
書かれている内容から問題の原因を特定するのは難しいです。 評価環境 　ノートPCを使用 　OS不明(32bitか64bitか不明) 　SQL Server 2005 Express 　この環境でも、クラサバ？ 　(DBサーバのノートPCに、別のPCに乗ってるアプリからアクセス？) 本番環境 　サーバー機(コア何個？) 　Windows Server 2008(32bitか64bitか不明。Windows Updateかけて最新？) 　SQL Server 2008 パフォーマンス値 　メモリ、ネットワークは殆ど使用していない 　CPUも25%程度(この25%は何を見て、25%と判断？) ってな状況ですと、物理I/Oはどうなのか気になります。 また、「ノートPCよりレスポンスが3倍ほどかかるようになりました」では、 1秒が3秒になったのか、 10秒が30秒になったのか、 2分が6分になったのかでも話が変わってきます。 が、まずはインデックスの再構築、統計情報の更新などを試されるといいかと思います。 参考情報として、URLを一つ載せておきます。
何回もどうもすいません。忘れてました VAR/60.00 などでもよいです。（暗黙の変換が効きます。）
こんばんは。 受注番号の集計がネックですね・・・。 相殺されているレコードでも、プラス側の個数が2以上で、マイナス側の個数がプラスよりも少なければ生きなので、完全に相殺されている受注番号だけ除かないといけません・・・。 同じ日付で同じグループ（野菜か果物か）の受注番号は1つとして数えますが、商品コードによってグループが変わる場合は別々に数えないといけません・・・。 手順としては、完全に相殺されているレコードを除外する。 不完全に相殺されている場合はプラス側からマイナス側の個数、金額を引いて生きとする。 グループ分けをする。 これに伴い、同一グループの同一受注番号を数えないようにフラグを立ててサマリーする。 まぁ、口で言うのは簡単なんですが、一筋縄ではいきませんねぇ・・・。 テーブルの件数はどれぐらいですか？ 自己結合するので、レスポンスも心配です。 これ主キーはないんですか？
いや、ごく普通のSQLのWHERE句の作成方法でしょう。 但し、テキストボックスの値を直接SQL文に展開するとSQLインジェクションと言う不正アクセスの原因になるので、そこは考え直した方がいいです。 SQLの実行速度はSQL文の書き方に依存するようでは、まともなDBエンジンとは言えないのですが、そう言うことがあるのは事実です。
こんにちは。 普通にインポートじゃ駄目なん？
GUI操作時に【スクリプト】をおすと、その操作に対するSQL文が表示されます。 それを実行すればGUIと同じことが出来ます。 そのSQL文をファイルにしてあげて、sqlcmdで実行すればコマンドラインから実行できます。 さらに、そのコマンドをバッチファイルに書いてあげればバッチ化できます。 sqlcmdはこの辺りを見て勉強してください。 http://msdn.microsoft.com/ja-jp/library/ms170207.aspx
[C:\Program Files\Microsoft SQL erver\MSSQL10.MSSQLSERVER\MSSQL\DATA\MSDBLog.ldf] にアクセスしたが15秒経過してもアクセスが完了しないってことです。 CドライブのI/O負荷が高いか、もうじき壊れるのでしょう。 可能なら別のハードディスクに「MSDBLog.ldf」を移動することを検討してください。
結合キーを揃えて集計したものと 担当者テーブルを結合させます select 担当.tanto_id as 担当者ID ,担当.tanto_name as 担当者名 ,isnull(売上.売上合計,0) as 売上合計　--null処理 from table_tanto as 担当 left outer join ( select tanto_id,sum(kingaku) as 売上合計　--集計 from table_uriage_meisai where date between '2010/11/01' and '2010/11/30'　--範囲指定 group by tanto_id　--集計 ) as 売上 on 担当.tanto_id = 売上.tanto_id コピペして見やすいようにタブを入れて見て下さい。
オンラインREDOログが一杯になったらコピーされるのがアーカイブREDOログです。 オンラインREDOログは、そのままサイクリックに再利用されます。 Oracleとは切り離された単独のファイルですからエクスプローラー上から操作しても問題はありません。※内部的にはリカバリのために必要なファイルとして記録されていますが、あくまでリカバリ時に必要なものなので通常運用では参照されません。 ただしリカバリには必要なファイルです。 データベースの変更情報が全て記載されたファイルなので、ファイルに抜けがあると、それ以降を戻すことができなくなります。 ちなみにどういう運用をしていますか？ オンラインバックアップを取得しているのであれば、それ以前のアーカイブREDOログは 削除可能です。バックアップ以後の変更情報を当てていけば最新状態に戻すことが可能です。 逆にバックアップを適切に取っておらず、戻すことが出来ないアーカイブREDOログを延々と溜め込んでいるなら無駄ですし、いざという時に復旧できないので危険です。 少なくともファイルのリストをメモしておき移動して保存しておいてください。 その上で、バックアップ・リカバリ計画を確認してください。 もし、ないのであれば、ちゃんと計画をして取るようにしてください。 壊れた時に復旧できなくて困るよりは、今、きちんと確認しておいた方が良いですよ。
T-SQLの表示で、コマンドがどうなっているか確認してください。 http://msdn.microsoft.com/ja-jp/library/ms190488.aspx 手元で確認したところ、「解放された領域はオペレーティングシステム に返す」を指定するとTRUNCATEONLYになるようです。 これだとファイルのデータが入っている末尾を切り捨てるだけなので、状況によっては ファイルサイズは小さくなりません。データが後ろの方に存在しそのデータが消されない場合とか。これはあり得るケースです。 確実なのは、NOTRUNCATEをやってからTRUNCATEONLYをすればファイルは小さくなるかと思います。
デフォルトは自動起動です。 Windows版のORACLEもそうです。 と言うか、Windowsのサービスとして登録されるタイプのRDBMSは殆どそうですね。 手動起動にするなら、コンパネのサービスで SQL Server の関連サービスの「スタートアップの種類」を「手動」にしてください。 再起動しただけではDBが立ち上がらなくなります。 Management Studio からでも設定できるかもしれませんが、今、手元に SQL Server がないのでわかりません。
テーブルの設計が悪くないですかね？ フルテキストテーブルを作成しておいて 一時テーブルの内容を、実行の都度insert & delete するしかないでしょうね
nvercharのようにユニコードに対応しているデータ型に、正しくユニコード文字を 格納したい場合には、 INSERT INTO TestTable VALUES(N'test') のように、値の前に「N」プレフィックスをつけなければなりません。 これは、SQL ServerでもOracleでも同じ仕様です。
「新しいクエリ」で、テーブルに結びついてないクエリエディタを開いて、 そこで実行してください。
たしか、SQL Server 2000 のクライアントをインストールすれば MSDE の操作もできたと思います。 また、フリーではありませんが、 SQL Server 2000 Developer Edition というのがあります。 これだと、XP にもインストールが可能です。 いまさら、売っていないとは思いますが、1万円しなかったと思います。
backup database コマンド中にこのような演算はできなさそうですね。 そこで、変数を定義してそちらでファイル名を設定し、backup database の disk = の右辺には変数名を指定してください。 加えて、DATEPART の戻り値は int なので cast する必要があります。
BCPには列名を出力するオプションはありません。 「BCP　列名」で検索すると同様の質問、回答をがすぐに出てきます。 別途列名を取得したCSVをコマンドプロンプトで結合するような 対応が多いようです。
ご質問の内容はここで解決できる回答が出せる内容では無いように思います。 SQLServerの入門書を読まれることを、お勧め致します。 おそらく、自分のPC 内ではSQLServer へWindows認証で接続されていると 思われます。 LANを介して接続するには、この認証を解決しなくてはなりません。 この認証を説明するには数ページを要します。(図解も必要) Windows認証、SQLServer認証 などで検索してみて下さい。
書き忘れました。 テーブルに主キーが設定されていないと Access側からレコードの更新はできません。
他のDBを参照するには、同じサーバ内であれば DB名.スキーマ名.テーブル名とすれば可能です。 例えば　SELECT * FROM DB2.dbo.TBL1 他のサーバの場合はリンクサーバの設定をして サーバ名.DB名.スキーマ名.テーブル名とすれば可能です。 例えば　SELECT * FROM SERVER2.DB3.dbo.TBL1 質問の例だと以下のようなSQL文になりますかね？(DBAから行う場合) UPDATE TBL1 SET TBL1.会員番号 = TBL2.会員番号 FROM TBL1 INNER JOIN DBB.dbo.TBL1 AS TBL2 ON TBL1.会員名 = TBL2.会員名 WHERE TBL1.会員番号 IS NULL
SELECT * FROM ( select [ID1],[ID2],[ID3],[date], (select COUNT(*) from @tb1 t2 where [txt] is null and t1.ID1=t2.ID1) as cnt, ROW_NUMBER() OVER (PARTITION BY ID1 ORDER BY [date]) as rowno from @tb1 t1 WHERE [txt] is null ) t3 WHERE t3.rowno=1
　考え方としては、テーブルの設計書を見ただけで、それが何を表している項目なのかが解るのが理想です。（もちろん、備考欄・コメント欄に意味を書くのは無しと言うことで） 　その上で、そのテーブルを利用してＳＱＬを書く立場になれば、項目名は出来るだけ短い方がありがたいですよね。なにせ、ＳＱＬ書くたびに毎度毎度その名前を書く羽目になるわけですから。 　短すぎず、長すぎず・・・・この間で、苦悩するのが名前付けの作業です=^・。・^= 　今回の場合、得意先の住所か、会員の住所かはテーブル名を見れば一目瞭然です。ですから、S_TOKUI_ADDのTOKUIは、長すぎの部類と思います。でも、ADDだけだと、動詞に取られかねません。S_ADDRESS当たりが無難なラインかと思います。C_TOKUI_TELのTOKUIも同じく長すぎの部類かな。TELだけで、まぁ誤解されるような用例もないですから、これはC_TELでも良いように思います。 　多分、ＳＱＬを書く時には、テーブル名のエイリアスをつけて、TOKUI.S_ADDRESSの様に使うことが多いです。これが、TOKUI.S_TOKUI_ADDだと、得意先の意味がダブってますよね。やっぱり、タイプの無駄でしょう。
どのように書いたらこのエラーが出たのかを書かないと 原因はわからないでしょう importが正しくできていないようなメッセージに見えますが…
クラスマスタの登録IDクラスが試験項目マスタの登録ID(4桁)+試験項目マスタの更新カラム名(2桁)である前提で、 declare 　cursor c1 is 　select 試験項目マスタ.登録ID 　　　　,substr(クラスマスタ.登録IDクラス,5,2) 更新カラム 　from 試験項目マスタ 　　inner join クラスマスタ 　　on 試験項目マスタ.登録ID = substr(クラスマスタ.登録IDクラス,1,4) 　order by 試験項目マスタ.登録ID 　; 　 　w_sql varchar2(4000); begin 　for r1 in c1 loop 　　w_sql := 'update 試験項目マスタ '; 　　w_sql := w_sql := 'set ' || r1.更新カラム ||' = ''○'''; 　　w_sql := w_sql := 'where 試験項目マスタ.登録ID = ' || r1.登録ID; 　　execute immediate w_sql; 　end loop; 　commit; end; / とかでどうですか？ update文を登録ID毎に実行したい気もしますが、とりあえずイメージだけでも。
SQL Server 2005 EXPRESS Developer EditionというものはＭＳのホームページには存在しませんよ。 SQL Server 2005 EXPRESS EditionとSQL Server 2005Developer Editionの２つは存在しますね。 >>Developer Editionは開発・テスト用途と言う事ですが、本番環境との違いとは何ですか？ 文字通り、開発とテストには使ってよいけど、本番環境、つまりは実際の業務では使ってはいけないって意味ですね。 ”開発とテスト”環境と"本番"環境に差があるのは、おわかりだと思います。「テスト環境だよ」といいながら、日々の売上業務にDeveloper Editionを使ってはいけないってことですね。 本番で使うなら、WorkgroupかStandardかEnterpriseのエディションの中から、適切なものを選んで買ってくださいってことですね。 紳士協定的なものと私は思っていますが、なんらかのチェックをＭＳが行っているかもしれませんので、違反が判明したら、大変なことになるかもしれませんね。
誕生年、名前、年齢が同一で住所がことなる場合はどのレコードを取得するのでしょうか？ たとえば、 誕生年|名前|年齢|住所|・・・ S34 |山田|24|大阪 S34 |山田|24|大阪 S34 |山田|24|大阪 S34 |山田|24|東京 というデータの場合は大阪と東京のどちらを取得するかの条件は決まっていますか？ そんなデータは存在しないというならば、row_number関数を使って select 誕生年,名前,年齢,住所 from ( 　select 誕生年,名前,年齢,住所 　　　　 ,row_number() over(partition by 誕生年,名前,年齢 order by 住所) row_num 　from テーブルA ) where row_num = 1; とかでもいいかと思います。
No.1です。 >もしかして、条件EmployeeID=Employees.EmployeeIDで、相関副問い合わせのときのように、１つのEmployeeIDが副問い合わせの中に渡されて、その度ごとに副問い合わせが実行されるのでしょうか？ はい。SELECT句の副問い合わせは、抽出されたレコードの分だけSELECTが実行されます。 スカラー副問い合わせ というものですね。
思いつくことを列挙してみました。的外れかもしれませんが、許してください ・実行権限がない（SQLサーバーのジョブはユーザーは誰で動作するのでしょうか？） ・SQLサーバーにexeの実行権限がない（スクリプトだけしか実行できないとか） ・SQLサーバーの処理機能（Shell)に偽EXE(Bat_To_Exe_Converterで作成したexe）を実行する能力がない。（VisualStudioで本物のEXEを作って実行できるか試せばわかる） ・相対パスになっていてパスがちゃんと読めない（exeの指定は絶対パスで書いてありますか？） ・実行した結果を格納する権限（大抵はファイルを書き出す権利）がない
勘違いな回答でしたらごめんなさい。 単純にSP_Bを ----------------------------- SELECT TOP 1 　field3 FROM テーブル名 WHERE 　field2 = @パラメータ値 ----------------------------- でどうですかね。
　ご質問の文章だけではなかなかイメージしづらいです。 　そのアクセスソフトのバックアップはとられてませんか（データ自体は古くても構いません）。 　もしあるようでしたら、今問題のソフトを一旦コピーするか別のフォルダーに退避させ、バックアップソフトをセットして下さい。 　次にそのバックアップ部分はデータが古いので、「テーブル」の中身を全て削除して、問題のアクセスのテーブルの中身をセットすれば問題解決と思います。 　ただこの私が言ってる意味がわからなければ、アクセスに詳しい人に聞くか、再度お尋ねください。ただし、バックアップがあることが前提です。 　
できるSQLServer運用という本を少し読んで、SQLSEVERの導入・運用を経験し、SQL文をたくさん書くってことで、私はがんばりました。
これはManagement Studioからではなく，T-SQLによる設定方法とみなしてよいでしょうか。 T-SQLでは，GRANTを使います。たぶん，他のDBにおけるSQLでも同じでしょう。 MSDN: GRANT (オブジェクトの権限の許可) (Transact-SQL) http://msdn.microsoft.com/ja-jp/library/ms188371(SQL.100).aspx
> SQLServerへの接続の場合、dbOpenTableは使用できないのでしょうか？ > dbOpenTableが使用できないとなると、IndexやSeekも使用できないということでしょうか？ はい、その通りです。
accessだから遅く、sqlserverだから速いという 単純なものではありません。やはり、エンジンを 置くPCの性能がカギで、これが遅いのでは期待は できないとしたものです。聞けば同じマシンで代替 するとのことなので、あまり期待しない方がよい と思います。accessのイヤな所は挿入/削除を 繰り返すと、デッドスペースが増加するだけでなく、 インデックスも最適な状態からかけ離れていくこと です。従って、度々最適化する必要があります。 DBの設計方針が分からないので何とも言えませんが、 抽出条件に使う可能性が高い項目にはインデックスを 置くとか、マスタを持つコード項目はリレーションを 張ることで速度が改善されます。特に昔の遅いDBでは リレーションの設計は最大のポイントでした。 SQLの組み方が拙いため遅い可能性もありますが、 accessやsqlserverはスマートな方で、影響は少ない でしょう。例えば、a=1 or a=2 より a in (1,2)の 方がaの参照が１回なので、若干高速です。(気休め程度) 尚、sqlserverには一時テーブルと言うのがあり、 対象レコードを減らしておいて処理することができます。 これは便利な機能で、大いに助かるところです。 尚、ODBC接続したテーブルにDLookupなどDxxx関数を 使うと、極端に遅くなることがあります。これらの 関数を多用している場合は注意が必要です。
> 自分で調べたところ、SQLServer2005ではUNPIVOTを使えるということで まず、サンプルにある通りのテーブルを作って、 サンプル通りのSQLを実行してみてください。
64Bit版しか提供がないのはWindows2008R2です。 SQL Server2008は32bit版、64bit版両方存在します。 2008のExpress版をダウンロードすればよいと思います。
sp_help_job内でコールされている「sp_get_composite_job_info」が「INSERT EXEC文」を使用しているため、このエラーが表示されます。 したがって、 ・エラーは出ても、トラップしなければ、結果は受け取れているのではないですか？ 　それならば割り切ってそのまま使うのも手です。 ・お勧めはしませんが、sp_helptextを使えばソースを見られますから、sp_get_composite_job_infoのソースを元にオリジナルのストアドを作成して、その処理の中でワークテーブルにセットしてしまうということもできなくはないです。 　（条件指定をしないなら、基本的にはsp_help_jobとsp_get_composite_job_infoの実行結果は同じはずです） 　もちろん、システムストアドプロシージャはバージョンやサービスパックなどにより、予告なしに変更されることがありますので、そのリスクはとらなくてはなりません。
Windows Installer Cleanup ユーティリティを保存してあるので特に。。。 とだけ回答してもしょうがないので、完全無保証ですが手助けを。 http://web.archive.org/web/20050329041601/http://support.microsoft.com/kb/290301 URL からもわかるとおり Microsoft ではない第三者のサイトですので完全に無保証です。 ご自分でリスクを背負ってダウンロードしてください。
「XXとYYが何件あるかカウントをして」というのがイメージつかめませんが、 こういうこと？ Select A.*,B.BCnt from A inner join ( Select B4,Count(*) BCnt from B Group by B4 ) C on A.A4=B.B4 これでA3とBCntを比較すればいいんじゃないでしょうか？ ＊意味合いが違うのであれば、結果としての表がどういうものが必要なのかを提示するといいと思います。
こんにちは。 ＞詳細については、イベントログまたは他の適切なエラーログを参照してください。 イベントログにエラーの詳細が出てると思いますが。 これだけではなんとも・・・。
回避策と言っても、インデックスを張るのをあきらめるしかないと思います。 インデックス付きビューの作成 http://msdn.microsoft.com/ja-jp/library/ms191432.aspx >?ビューが参照しているのはベース テーブルのみで、他のビューを参照していない必要があります。
こちらをどうぞ。 http://support.microsoft.com/kb/280106/ja
こんにちは。 SQLServerは別のPCにあるのでしょうか？ 2005はデフォルトでネットワーク接続を許可していません。 スタンドアロンではOKですが・・・。 セキュリティ構成ツールから、TCP/IP接続を有効にしてください。 ポート1443（デフォルト）の解放と、別マシンのホスト名が解決できるように設定してください。
まずリンクサーバの登録をします。Managment Studioからサーバオブジェクトを展開しリンクサーバを右クリックし新しいリンクサーバをクリック。画面の指示に従って登録してください。 SQL文の例 SELECT AA.*, BB.社員名 FROM 別のマシンのインスタンス名.別のマシンのデータベース名.dbo.社員マスター AS BB INNER JOIN dbo.テーブルa AS AA ON BB.社員コード = AA.社員コード VPNを構築していれば遠方のSQLサーバともおなじ要領で結合することができます。
> 物理名を英語表記にしておかないと > パフォーマンスが低下するなどの弊害があるのでしょうか？ パフォーマンスがどうかという話なら関係ないと思います。 只、歴史的には日本語は幾多のトラブルを起こしています。 ＤＢ自体あるいはフロントエンドのバージョンアップの際に、 全角文字の片方のバイトが制御文字だった場合とか 全角英数字が勝手に半角に変換されてしまうとか 半角カナが勝手に全角に変換されてしまうとか 全角の波線がうまく処理されないとか。 現在チャンと動いていても将来まで保証されるものではありません。
以下で参考になりますか？ SELECT a.日付, b.* FROM ( SELECT '2010/07/01' 日付 UNION ALL SELECT '2010/07/02' UNION ALL SELECT '2010/07/03' UNION ALL SELECT '2010/07/04' UNION ALL ・・・ SELECT '2010/07/31') AS a LEFT OUTER JOIN 結合対象テーブル AS b ON b.日付=a.日付 ちなみにSQL Server 2008では以下の書き方も可能です。 SELECT a.日付, b.* FROM ( VALUES ('2010/07/01'),('2010/07/02'),('2010/07/03'), ('2010/07/04'),・・・,('2010/07/31')) AS a(日付) LEFT OUTER JOIN 結合対象テーブル AS b ON b.日付=a.日付
dim i as long For i = 0 To rs.Fields.Count - 1 Cells(1, i) = rs.Fields(i).Name Next cells(2,1).copyfromrecordset rs レコードセットオブジェクトがｒｓとして 上記のコードで1行目にカラム名が表示され,2行目以降にデータが表示されます。
こんにちは。 データベースはSQLServer プログラムはVB2010 なので、逆にXAMPPは不要かと思います・・・。 （PHPやPerlで開発するなら便利ですが） あと必要なのはWebサーバーだけなので、Apache入れるかIIS使うかですね。 ＞XAMPP　+　SQLServerで使用すれば良い、という事で合ってますよね。 まぁ間違ってはないですけでど・・・。 XAMPPは要らんと思います。 （入れたからって損ではないですが） SQLServerインストール。 VB2010の開発環境は既にある（はず）。 ApacheまたはIISを起動させれば、お望みの事になるかと・・・。
CATCHブロックの中は空でいいですよ（CONTINUEはOracleでは？） 以下ご参考までに。 件数のことを考えると、エラーになる理由が分かっているならば、本当はカーソルを使わずにエラーにならないものだけをINSERTするような処理を書いた方がよいですけどね。 DECLARE @TBL TABLE (ID int PRIMARY KEY,VAL char(1)) DECLARE @ID int,@VAL char(1) DECLARE C CURSOR FAST_FORWARD LOCAL FOR SELECT 1 ID,'A' VAL UNION ALL SELECT 2 ID,'B' VAL UNION ALL SELECT 3 ID,'C' VAL UNION ALL SELECT 3 ID,'D' VAL UNION ALL SELECT 4 ID,'E' VAL UNION ALL SELECT 5 ID,'F' VAL OPEN C FETCH NEXT FROM C INTO @ID,@VAL WHILE (@@FETCH_STATUS=0) BEGIN 　BEGIN TRY 　　INSERT INTO @TBL VALUES (@ID,@VAL) 　END TRY 　BEGIN CATCH 　END CATCH 　FETCH NEXT FROM C INTO @ID,@VAL END CLOSE C DEALLOCATE C SELECT * FROM @TBL ID　VAL -------- 1　A 2　B 3　C 4　E 5　F
> ANSI_PADDING へえー！ 知らなかった。 文字列を厳密に比較するときは、 WHERE colA COLLATE JAPANESE_BIN LIKE '1234 ' みたいに書かないといけないのかな？
意味がよく分かりませんが、以下のSQLでどうでしょう SELECT A.* FROM 社員台帳 AS A INNER JOIN 年度辞書 AS B ON A.年度=B.年度
SELECT 商品マスタ.商品名 FROM 商品マスタ WHERE 商品マスタ.子コード in( SELECT 対応テーブル.子コード FROM 対応テーブル,商品マスタ WHERE 対応テーブル.親コード = 商品マスタ.商品コード AND 対応テーブル.親コード = 1000,1002,1004 )
EXCELでデータベース（のように使うってことですよね）はあんまり 聞いたことないですが・・・。 メリットとしては導入コストの削減、メンテナンスを手で可能 （SQLサーバーなどのツールを使わずにってこと） デメリットとしては、管理データの件数が増えていった再の検索速度の低下 セキュリティの問題（この辺りはＰＣの設定の問題もあるので、EXCELに限りませんが・・） >飲食店の顧客データベースを作成する際 >一般的にどのように行っているのか これは、もうピンキリじゃないですか？ 飲食店というのも幅が広いすぎですよね？ チェーン店なのか、店と事務所が別なのか、１店舗で１人だけなのか 店の規模や、かけれるお金などによりさまざまなシステムがあると思いますよ。 小さい店舗なら、EXCELだけで、管理とかありそうですし。 規模が大きい店舗（チェーン店、全国展開しているもの）とかなら、 ORACLEやwebシステムでMySqlとかも考えられます。
SQL Server Management Studio Express は製品版より機能が制限されています。 SQL Server 2005 の各エディションがサポートする機能 http://msdn.microsoft.com/ja-jp/library/ms143761.aspx には載っていないけど SqlServer Management Studio ExpressではSqlServerログが見られない？ http://lsahf.spaces.live.com/blog/cns!AC381CDFEFAFE4B9!217.entry だそうです。 Developer Edition版のManagent StudioならSQL Server ExpressのSqlServerログは見えるのでは？
SELECT 生年月日, dateadd(d,1,substring(convert(varchar,getdate(),111),1,5)+substring(convert(varchar,生年月日,111),6,5)) AS 契約開始日 FROM 給与台帳 その他にも色々と表現する方法はあると思いますので １例としてご参考にして頂ければと思います。
SQL文を実行するときには、まずコンパイルして、実行プランを立て、それから実行するというステップがあるという点をご理解ください。 私の理解ではその時点でTEST_TABLEが存在しないかぎり、CREATE～INSERT～ALTER～UPDATEはエラーにならないはずです。 ただし、"既にTEST_TABLE(ALTER前）がある状態"で４行一緒に実行すると、 列名 'TEST_FIELD3' は無効です。 と返されますので、それと混同されているのではないかなと推測します。 （CREATE TABLE文は既にテーブルが存在していても、コンパイル時にはエラーにはならず、実行時にエラーになるため。 一方、UPDATE文は後述の通り、コンパイル時にエラーになります） CREATE～INSERTが成功したあとで、ALTER～UPDATEが失敗するのは、実行に失敗しているのではなく、コンパイルに失敗しているということです。 （「実行して失敗し、ロールバックされた」わけではありません） 既にそのテーブルが存在する場合、SQL Serverはコンパイル時にテーブルのカラムをチェックします。 この時点のテーブルにはTEST_FIELD3はありませんので、コンパイルエラーになります。 一方、実行時にそのテーブルが存在しない場合は、遅延解決と言ってコンパイル時にはカラムがチェックされません。 （実行時に条件がそろっていなければエラーとなります） 従って、CREATE～INSERT～ALTER～UPDATEと一気に実行すると、チェックすべきテーブルがまだ存在していないため、エラーにはなりません。 もう一つ注意すべきなのは、キャッシュの存在です。 一度「UPDATE TEST_TABLE SET TEST_FIELD3 = 3」が成功すると、このクエリはプランキャッシュというところにキャッシュされ、必要に応じて再利用されます。 その状態でテーブルをDROPし、CREATE～INSERTを行い、ALTER～UPDATEを行うと、キャッシュされた情報を参照してTEST_FIELD3は存在すると判断され、コンパイルが通りますので、今度はエラーになりません。 ご参考までに。
#2です。 >Set Cmd = New ADODB.Command >Cmd.CommandText = ”CREATE VIEW ビュー AS SELECT * FROM テーブル WHERE 日付='2010/07/09'” >Cmd.Execute もちろん、権限があればできます。 しかし、そのリクエストをした人にもう一度確認することをお勧めします。 私もVB内で10行以上のクエリを組み立てて実行しているのを見てげっそりすることはありますので、 「長いクエリはビューで管理したい」というリクエストは理解できます。 ただ、本当に「パラメータまで含めて一切をビューにし、すべてWHERE文の一切ないSELECT * FROM ビューだけにしたい」 というリクエストをしたとすれば、その人はシステムのことを理解していないので、説明すべきだと思います。 ・同時に複数のユーザ・複数の処理でビューを参照できなくなるので、ユーザ数×処理数だけ同じようなビューが必要 ・ビュー定義の一部だけを再作成することはできないので、再作成には常に全部を実行する必要がある。処理はわかりやすくならない
確認したいのですが ・レコードサイズは平均何バイトぐらいですか？ ・主キーはクラスターインデックスですか？
VB6と違い、コントロールに「デフォルトプロパティ」は存在しません。 テキストボックスならtextbox1.textまできちんと記述しないといけません。 textbox1だけなら「テキストボックスオブジェクト」になるので、それを文字列には代入できないわけです。
Order by にたいして、インデックスは有効です。 TOP は関係ないと思います。 インデックスを作成してみてはいかがでしょうか？
この問題には定義が一つなく、「何々付いての問題」のお題できまりますね。つまりカテゴリーですね。 例えば「データベース管理システム」はDBMS(RDBMS)の事でしょうかね。それともDBを管理する管理ツール＆リソースツールのお話でしょうかね。 それで答えが少し違います。 「（２）データベースシステム」とは前述のDBMSとはあきらに違う事がわかりますが、（１）の続きとして出ているのしょうか?　それとも違うカテゴリーでていうのでしょうか? ＞どれも正解のように思えるんですが いいえ、（１）がDBMSであれば、正しくない物を消去するとCしか残らないですね。 a=DBの構築機能、b=DBの活用方法、c=DBを管理するソフト又は、ファイヤーウォール及びOS、d=運用 となる。質問では「役割」となっているので、Cしか残らないかも。だが１つの機能なので、役割と言っていいのか? MSのM=マネジメント　を意味する所からいえば、DBを管理する事柄と言えば、不正アクセスの防止も役割の一つか。 これは、SEと言う職種の、「構築、運用、管理」と言う３つのカテゴリーで分けての設問であれば、この質問の回答は楽に導き出せます。実際の意味とちょっと違うかも。 SEといっても、この３つ全部やっている方もいれば、大きい会社だとかなり分業されています。募集も、この３つに分散されています。 この問題はSE及びシステム営業の何かの試験問題でしょう。 （２）も消去していくと、a,cですね。aは、RDBMSを使用して構築する場合、先に検索結果がどのようなものが必要が最初に考える必要があります。後からでは思うような検索が出ないからと言って、再構築は不可能に近いです。 その場合、例えば株価の予測をする場合、何を項目とするのか、何をキーとするのか、何によって変動するのか（更新される項目）、当初から分析手法を明確にしていないと決まらないからです。 ｃは、必ずしもそうとは言えませんが、項目を追加だけですむ場合もあります（設計によります）。 以上。これに正解があるとしたら、DBMSを知っているか、知っていないかの基準は結構いいかんげんなものとなってしまう。
SQLプロファイラ http://www.atmarkit.co.jp/fwin2k/tutor/sql02/sql02_04.html
insert ～;select scope_identity(); 3,4を同時に行う http://social.msdn.microsoft.com/Forums/ja-JP/sqlserverja/thread/55e7d50e-ecfb-47ec-9671-8a55801a97c8
多少余計なものも拾うかもしれませんが、 select * from sys.sql_modules where definition like '%union%' が手っ取り早いです。
　とりあえず、 　http://www-06.ibm.com/systems/jp/i/seminar/dwhouse/dwhouse8.shtml 　このあたりを読んでください。 　必要十分なだけのことが書いてありますから=^・。・^= 　ちなみに、http://www.google.co.jp で、「データウェアハウス　分析手法」と入れて検索しただけ。まぁ、トップにこんなわかりやすい文書が出てくるのも珍しいですが（苦笑）。 　蛇足ですけど、調べる方法を探して調べるのも学習のうちですよ。というか、回答内容より本当はそっちの方が大事だと思うんですけどね。（もう一つ付け加えると、質問サイトで質問するというのは学習する時の調べ方としては、あまりよろしい方法ではありません。先生に答えを聞いているのと同じレベルですから。）
商品番号と数量がくっついていて、正確な数字がわかりませんが、以下として回答します。 select * from 出庫記録 商品番号 数量 日付 ---------- ----------- -------- PRT145 4 20090610 DP255 2 20090610 DP266 3 20090611 PRT255 2 20090611 (4 行処理されました) 回答は以下です。 SELECT MAX(数量) FROM 出庫記録 ----------- 4 (1 行処理されました) SELECT AVG(数量) FROM 出庫記録 WHERE 日付='20090610' ----------- 3 (1 行処理されました) SELECT COUNT(*) FROM 出庫記録 ----------- 4 (1 行処理されました) SELECT SUM(数量) FROM 出庫記録 WHERE 日付='20090611' ----------- 5 (1 行処理されました) ＞a=1 は間違いです。
SQLにおける不等号は数学で出てくるものと同じで、示された値を含みません。 ですので、「年齢 > 20」は年齢が20より大きい場合(21以上)、「年齢 < 20」は年齢が20より小さい場合(19以下)となります。 ちなみに含めたい場合は後ろに「=」を付けます。「<=」「>=」 ですので、(2)の答えは2行になるはずですね。
ミラーリング構成やログ配布もありじゃないかと思いますが、 簡単にやりたいなら、バッチファイル＆sqlcmdでバックアップ→コピー→リストアとするか、時間差でエージェントタスクを設定するという方法でいいのでは。
SQLにはそのような機能はありません。 どのような言語を使用しているのかはわかりませんが、入力のテキストボックスが２つあるのであれば、SQLの作成の前の時点で２つの内容が同一かチェックし、同じでなければエラーとするロジックを組む必要があります。 SQLはあくまで、データを操作するための言語ですので、入力文字のチェックは画面を作成している言語の方で行うのが一般的です。
クエリプランを確認してみましょう。 TOP句を切って先頭何行かを取るだけでも時間がかかるのは、全部並べ替えてみなければ対象が分からないからです。 従って、 1) TOP句のみ　　　IndexScan/TableScan＋Top 2) ORDER句のみ　　IndexScan/TableScan＋Sort 3) TOP句＋ORDER句 IndexScan/TableScan＋Top N Sort となり、3は2と同じくらいになるはずです。 （クラスタインデックスでORDER句を切ったときは例外で、ソート不要のためその場合は1と同じになります） したがって、質問者さんの環境で2と3はどうプランされるかを確認されるのがいいと思います。 なお、TOP 100 PERCENTはSQL Server 2005以降では無視されますので、1と同じ結果になります。
http://support.microsoft.com/kb/918992/ja などがsaで不明エラーで出る要因の一つですが 細かいことはSQLServerのエラーログを詳細に解析しないとなんとも…というところですね。 アプリケーション作成ということですが、WGEを使っていらっしゃるということで、お仕事でしょうか? 会社のDBメンテナンス部門に連絡したり 会社でMSとサポート契約を結ばれていないか確認してみるのも一つの手ですよ。 何の回答にもなっていませんが、根を詰めないようにしてくださいね。
下に書いた者ですが、DATETIME型ってミリ秒までもってるらしいです！ DELETE FROM テーブル WHERE update > 20100601000000000 /*2010年06月01日00時00分00秒000ミリ*/ こうなるのかな
質問の意味が、「あるテーブルのデータについて、対象フィールドにシングルコーテーションが含まれていたら、そのデータを削除する」ならば、 DELETE FROM あるテーブル WHERE 対象フィールド LIKE '%''%'
＃１です。訂正します。 SELECT t1.* FROM table_uri_meisai t1, 　(select tokuisaki_id, max(uriage_date) saisin 　FROM table_uri_meisai 　WHERE syohin_id = 1 　GROUP BY tokuisaki_id) t2 WHERE t1.tokuisaki_id = t2.tokuisaki_id AND t1.syohin_id = 1 AND t1.uriage_date = t2.saisin ORDER BY t1.meisai_id 商品ID=１以外も欲しいなら、 SELECT t1.* FROM table_uri_meisai t1, 　(select tokuisaki_id, syohin_id, max(uriage_date) saisin 　FROM table_uri_meisai 　GROUP BY tokuisaki_id, syohin_id) t2 WHERE t1.tokuisaki_id = t2.tokuisaki_id AND t1.syohin_id = t2.syohin_id AND t1.uriage_date = t2.saisin ORDER BY t1.meisai_id (ORDER BY は適宜修正のこと）
#1です。 スナップショットというのは「ある特定の瞬間のデータベースの読み取り専用コピー」です。 したがって、別に行単位のリストアが可能になるわけではありません。 （一日一回スナップショットを取っておけば、リストアの手間が省けるだけです） 質問者さんのいう機能はOracleのフラッシュバック機能でしょう。 SQL Server 2008からCDC(変更データキャプチャ)は追加されていますが、Enterpriseのみでフラッシュバックほどの機能ではありません。
普通に２回重ねればOKです。 select * from テーブル名 where 列名 like '%''%'
曜日の算出を行うにはDATEPARTを使います。 DATEPART(dw,GETDATE()) これにより日曜日から土曜日までが1～7の数字で返ります。 それぞれの曜日の数字が返ってきたときに、何日動かせばその週の月曜日になるかを考えてください。 日 1　－6日 月 2　　0日（そのまま採用） 火 3　－1日 水 4　－2日 木 5　－3日 金 6　－4日 土 7　－5日 よく見てみると、日曜日以外は返ってきた数字を2から引けば動かすべき日数になることがわかります。 （日曜日だけは特別です） したがって、 CASE WHEN DATEPART(dw,GETDATE())=1 THEN DATEADD(d,-6,GETDATE()) ELSE DATEADD(d,2-DATEPART(dw,GETDATE()),GETDATE()) END これでその週の月曜日が求まりますが、GETDATE()というのは時刻もついているので、検索対象のフィールドに時刻まで入っていないなら、このままでは月曜日の取引が全部拾われないことになります。 時刻部分を落とす最もシンプルな方法は一旦年月日の文字型にしてから日付型に戻すことです。 CONVERT(datetime,CONVERT(varchar,日付,111)) 上記をまとめると BETWEEN CONVERT(datetime,CONVERT(varchar, CASE WHEN DATEPART(dw,GETDATE())=1 THEN DATEADD(d,-6,GETDATE()) ELSE DATEADD(d,2-DATEPART(dw,GETDATE()),GETDATE()) END,111)) AND DATEADD(d,6,CONVERT(datetime,CONVERT(varchar, CASE WHEN DATEPART(dw,GETDATE())=1 THEN DATEADD(d,-6,GETDATE()) ELSE DATEADD(d,2-DATEPART(dw,GETDATE()),GETDATE()) END,111))) となります。 逆にもし検索対象のフィールドが時刻も含まれているならば、6日足して日曜日を求めるのではなく、7日足して月曜日を求めて、日付>=週初の月曜日(時刻なし) AND 日付<次の月曜日(時刻なし)としてください。
1.後者ですね。三者間で定期的にpingしています 2.データベースの負荷分散ですか？データベースミラーリングは負荷分散ではなく冗長化です。 　ミラーリング中はミラーサーバ側は更新はおろか直接参照することもできません。
うーん、想像力が欠如していました。 確かにあの質問の後なら、このクエリを実行しようとしますよね。。 BCPの場合、このような複数ステートメントのクエリはストアドプロシージャにして実行するのが一般的です。 （SET variable文や値を返さないSELECT文が含まれると、そのメッセージが出ます） しかし、そうも言ってられないので、ちょっと裏技っぽくなってしまいますが、対応策をご紹介します。 クエリ部分の先頭に「SET FMTONLY OFF;SET NOCOUNT ON;」と足してください。 余談ですが、複数ステートメントを並べて実行する場合は、各ステートメントの末尾にセミコロンを書くようにしましょう。 （SQL Serverはコマンド末尾のセミコロンはなくてもいけますが、Oracleなどと同じく推奨されています）
例えば10代の人の人数はこんな感じで求まります。 SUM(CASE WHEN 年齢 BETWEEN 10 AND 19 THEN 1 ELSE 0 END) これを20代、30代、と横並びにすればできるでしょう。
http://technet.microsoft.com/ja-jp/library/ms186973.aspx >1 回の DELETE または UPDATE 操作によって起動される連鎖参照動作は、循環参照を含まないツリー形式になっている必要があります。DELETE または UPDATE 操作によって生じる一連の連鎖参照動作の影響を複数回受けるテーブルがあってはいけません。 上記に反することから、このケースはCASCADEできないと考えられます。 したがって、外部参照制約だけで表現することはできません。仕様だから仕方がありません。 代替案としては、参照元のテーブルAには通常の外部参照制約だけを掛け（ON DELETE NO ACTION)、削除されたときの動きはINSTEAD OFトリガで実装することになると思います。 テーブルのデザインで回避したいというならば、テーブルBにテーブルAを参照する複数のキー項目を持たせないようにするしかありません。 （マッピングIDでも持たせて２行で収録するとかです）
「在庫データの(例えば)入庫数が、受払データのどれにあたるのか」といったことを、結合によって一覧表示したい、ということでしょうか？ もしそうなら、ちょっと無理な気がしますが… 在庫と受払を紐付けるものが、日付と品番のみ。 でも在庫の日付って、受払の日付とは違うものですよね。 在庫側6/1のデータは、受払の6/2～6/4のデータ… 例えば6月中に入出庫したデータは、在庫の6/1のデータに加算される、とか省略されている仕様があるのでは？ もしそうなら、 在庫.年月の年と受払.日付の年 と 在庫.年月の月と受払.日付の月 と 在庫.品番と受払.品番 を結合してあげれば、なんとなく出来そうな気もします。 当方SQLServerがないため、Accessでのクエリになりますが、ご参考まで。 SELECT 　　　　Q_在庫.年月 AS 在庫_年月 　　　　, Q_在庫.品番 AS 在庫_品番 　　　　, Q_在庫.入庫数 AS 在庫_入庫数 　　　　, Q_在庫.出庫数 AS 在庫_出庫数 　　　　, Q_受払.伝票No AS 受払_伝票No 　　　　, Q_受払.日付 AS 受払_日付 　　　　, Q_受払.入出庫区分 AS 受払_入出庫区分 　　　　, Q_受払.数量 AS 受払_数量 FROM 　　　　(SELECT Year([年月]) AS 年, Month([年月]) AS 月, 在庫データ.年月, 在庫データ.品番, 在庫データ.入庫数, 在庫データ.出庫数 FROM 在庫データ) Q_在庫 　　　　LEFT JOIN 　　　　(SELECT 受払データ.伝票No, Year([日付]) AS 年, Month([日付]) AS 月, 受払データ.日付, 受払データ.品番, 受払データ.入出庫区分, 受払データ.数量 FROM 受払データ)Q_受払 　　　　ON 　　　　(Q_在庫.品番 = Q_受払.品番) AND (Q_在庫.月 = Q_受払.月) AND (Q_在庫.年 = Q_受払.年) ORDER BY 　　　　Q_在庫.年月 　　　　, Q_受払.伝票No; 結果 在庫_年月 | 在庫_品番 | 在庫_入庫数 | 在庫_出庫数 | 受払_伝票No | 受払_日付 | 受払_入出庫区分 | 受払_数量 -----------+-----------+-------------+-------------+-------------+------------+-----------------+----------- 2010/06/01 | A | 3 | 1 | 1 | 2010/06/02 | 入庫 | 1 2010/06/01 | A | 3 | 1 | 2 | 2010/06/03 | 入庫 | 2 2010/06/01 | A | 3 | 1 | 3 | 2010/06/04 | 出庫 | 1 2010/07/01 | A | 0 | 1 | 4 | 2010/07/02 | 出庫 | 1
サンプルのSQL文がいけてるかどうかのコメントは差し控えます。 SELECT CONVERT(varchar, CASE WHEN DATEPART(dw,DATEADD(d,DAY(DATEADD(m,-1,GETDATE()))*-1,DATEADD(m,-1,GETDATE())))>=6 THEN DATEADD(d,13-DATEPART(dw,DATEADD(d,DAY(DATEADD(m,-1,GETDATE()))*-1,DATEADD(m,-1,GETDATE()))), DATEADD(d,DAY(DATEADD(m,-1,GETDATE()))*-1,DATEADD(m,-1,GETDATE()))) ELSE DATEADD(d,6-DATEPART(dw,DATEADD(d,DAY(DATEADD(m,-1,GETDATE()))*-1,DATEADD(m,-1,GETDATE()))), DATEADD(d,DAY(DATEADD(m,-1,GETDATE()))*-1,DATEADD(m,-1,GETDATE()))) END,112) 一発で出したいニーズはあるのでしょうが、同じことを何度も書くことになるので、以下はご参考までに。 やっているのは同じことです（前々月末日を求めて、それより後の最初の金曜日を算出） DECLARE @NOW datetime DECLARE @PREVEOM datetime DECLARE @DP int SET @NOW=GETDATE() SET @PREVEOM=DATEADD(d,DAY(DATEADD(m,-1,@NOW))*-1,DATEADD(m,-1,@NOW)) SET @DP=DATEPART(dw,@PREVEOM) SELECT CONVERT(varchar, DATEADD(d,6-@DP+CASE WHEN @DP>=6 THEN 7 ELSE 0 END,@PREVEOM),112)
DATANAMEではなく、DATENAMEですよね。 ・書かれているコードは変数がバラバラです（@I、@CUNT、@COUNT) ・ループ内のIF文はDATEADD(DD,-1,GETDATE())と固定で切られているので、無限ループになる可能性大です。 ・DATENAMEで返ってくる文字列は「SET DATEFORMAT」に依存します。 　「金曜」ではなく「金曜日」となることもあり得ますので、この方法でのチェックは汎用的ではありません。 そもそもループ処理で算出するというアプローチが非効率です。 DATENAMEではなく、DATEPARTを使う方法を紹介しておきます。 （なお、GETDATE()を直接使うと、デバッグが大変ですよ） DECLARE @EDATE datetime DECLARE @NOW datetime SET @NOW=GETDATE() SET @EDATE=CONVERT(varchar, CASE WHEN DATEPART(dw,@NOW)>=6 THEN DATEADD(d,6-DATEPART(dw,@NOW),@NOW) ELSE DATEADD(d,-1-DATEPART(dw,@NOW),@NOW) END,112)
先頭に一行 SET NOCOUNT ON と追加して実行してみてください。
(1) 期間の日付って「売上日付」ですか？ これがNULLになるのは構造上変じゃないかと思いつつ、「売上日付がNULLなら期間指定が何であれ常に集計対象にしてよい」ということでいいですか？ それでいいなら、 WHERE 売上日付 between '2010/03/01' and '2010/06/30' OR 売上日付 IS NULL にしてみてください。 (2) 通常生年月日に時刻までは記録されないので、シンプルに以下の通りでいいでしょう。 UPDATE 顧客マスタ SET 年齢=ISNULL(DATEDIFF(yy,生年月日,GETDATE())+ CASE WHEN DATEADD(yy,DATEDIFF(yy,生年月日,GETDATE()),生年月日)>GETDATE() THEN -1 ELSE 0 END,0)
はじめまして。 当方も同じようなことを考えております。 現在使用中なのがAccess2000であり、それで作成されたｍｄｂが多数あることからどうしようかと思っている最中です。 Office自体を2000から2010へ変更予定となっている為、ベータ版を使用して検証を行っていますが、やはり動かないものがあります。 参照のみのユーザーが多数いることもあり、Access2010を全員にインストールするコストを考えると、配付可能になったRuntimeを使用できないかと検証してみました。 結果ですが、Runtimeのみインストールを行ってAccess2000のmdbは使用できました。 ベータ版で使用不可の物も動いています。 メニューが表示されないということですが、AutoExecは設定されていますでしょうか？ デザイナー機能が無いため、メニューを自動起動させておかないと動きません。 検討違いでしたら申し訳ございません。
何だか随分混乱があるようですが、書かれたクエリは相関サブクエリになっていません。 相関サブクエリによる更新であれば、以下のようになります。 update 顧客マスタ set 累計金額=(select sum(売上金額) from 売上データ where 売上日付 between '2010/03/01' and '2010/06/30' and 顧客コード=A.顧客コード) from 顧客マスタ as A where exists (select null from 売上データ where 売上日付 between '2010/03/01' and '2010/06/30' 顧客コード=A.顧客コード) でも、私はこのような書き方はしません。 SQL Serverの場合は。相関サブクエリではなく、以下のようにJOIN更新で処理する方が多いと思います。 update 顧客マスタ set 累計金額=B.累計金額 from 顧客マスタ as A inner join (select 顧客コード,sum(売上金額) as 累計金額 from 売上データ where 売上日付 between '2010/03/01' and '2010/06/30' group by 顧客コード) as B on A.顧客コード=B.顧客コード
ロックされてコピー不可能なファイル名が分かるのであれば、参考URLで紹介されているようなツールを使用し、まずはどのプロセスによってロックされているのかをご確認下さい。
エラー処理などは入れておりません。 置換対象のDBは、実行する場所に依存しております。 実行は読み出し例： ---------------------------------------------------- EXEC 全置換 '検索文字列','置換文字列' ---------------------------------------------------- このコードは全角スペースを利用しています。 「全角スペース1個」→「半角スペース2個」に置き換えて利用してください。 CREATE PROCEDURE 全置換 ( 　　@検索文字　 AS NVARCHAR(MAX), 　　@置換文字　 AS NVARCHAR(MAX) ) AS BEGIN 　　DECLARE @tbl SYSNAME 　　DECLARE @col SYSNAME 　　DECLARE cur CURSOR FOR 　　　　SELECT A.name AS TBL,B.name AS COL 　　　　FROM　 SYS.TABLES A 　　　　　　　 INNER JOIN Sys.Columns B ON A.object_id　= B.object_id 　　　　ORDER BY A.name, B.column_id 　　OPEN cur 　　FETCH cur INTO @tbl,@col 　　WHILE @@FETCH_STATUS=0 　　BEGIN 　　　　DECLARE @prm NVARCHAR(MAX) 　　　　SET @prm　　= '@find NVARCHAR(MAX), @rep NVARCHAR(MAX)' 　　　　DECLARE @sql NVARCHAR(MAX) 　　　　SET @sql = 'UPDATE ' + @tbl + ' SET ' 　　　　SET @sql = @sql + '[' + @col + '] = REPLACE([' + @col + '], @find, @rep) ' 　　　　SET @sql = @sql + 'WHERE [' + @col + '] LIKE ''%'' + @find + ''%''' 　　　　EXECUTE sp_executesql @sql, @prm, @find=@検索文字, @rep=@置換文字 　　　　FETCH cur INTO @tbl,@col 　　END 　　CLOSE cur 　　DEALLOCATE cur END
検索すると http://www.pcreview.co.uk/forums/thread-1303421.php http://www.ehow.com/how_5552829_create-sdf-files.html 有償のものはあるようですが、、、 http://www.gui-innovations.com/html/remotesqlce.html http://www.flyhoward.com/SDF_Viewer.aspx
DATEDIFFは片端ですから、dateAは含まれないということですかね。 計算でも見づらくはなりますが、できることはできますよ。 期間内最初の土曜、日曜をそれぞれ求めて、残りの期間を7で割って回数を求めます。 SELECT dateA, dateB, DATEDIFF(d,dateA,dateB) -CASE WHEN DATEADD(d,7-DATEPART(dw,DATEADD(d,1,dateA)),DATEADD(d,1,dateA))>dateB THEN 0 ELSE DATEDIFF(d,DATEADD(d,7-DATEPART(dw,DATEADD(d,1,dateA)),DATEADD(d,1,dateA)),dateB)/7+1 END -CASE WHEN DATEADD(d,8-DATEPART(dw,dateA),dateA)>dateB THEN 0 ELSE DATEDIFF(d,DATEADD(d,8-DATEPART(dw,dateA),dateA),dateB)/7+1 END FROM T_TEST
VS2008が出た時には「SQL Server 2008のコンポーネントを使っているので、2008はインストールしないと動かない」と言われていたことがあるように記憶していますが、現在は必要なコンポーネントだけインストールする方法が多いようですね。 http://www.microsoft.com/downloads/details.aspx?displaylang=ja&FamilyID=c6c3e9ef-ba29-4a43-8d69-a2bed18fe73c ・Microsoft SQL Server 2008 管理オブジェクト ・Microsoft SQL Server 2008 Native Client ・Microsoft SQL Server システム CLR 型
データベース 　-DB名 　-セキュリティ 　-ユーザ　でプロパティを表示し、「セキュリティ保護可能なリソース」で操作してください。 http://technet.microsoft.com/ja-jp/library/ms188515%28SQL.105%29.aspx
おそらく再コンパイルに時間がかかっているのでしょう。 プランがキャッシュされると２回目からは再利用されますからね。 SQL Server 2000ということなので、ソリューションは限られそうですが、URLに挙げたものなどを参考にしてみてください。
SQL Server 2005のSSMSでは行数に制限がなかったので、2008で困った人は結構いるようですね。 SQL文を学ぶに越したことはないものの、ちょっとした作業にはGUIは便利であることは私も否定しません。 ツール=>オプション=>SQL Serverオブジェクトエクスプローラ=>コマンド ここに「上位<n>行の選択コマンドの値」「上位<n>行の編集コマンドの値」という設定があります。 それぞれをゼロにすると、件数制限は外せます。 ただ、「100万件のテーブルでこれをやるとどうなるか」を考えると、件数制限ができるようになった理由もご理解いただけるでしょう。一応「改善」の１つだと私は思います。
（１）なぜデータベースに認証が必要か 　ユーザー認証によって、ユーザーに必要な権限設定を行い、想定していないデータの削除や追加、控除、参照を防ぐためです。 （２）なぜ「会社側からはSQLサーバを使用して欲しいと言われてい」るのか。 　ACCESSはあくまで個人ユースで使われることを念頭に置かれていて、複数ユーザーが同時にアクセスする場合、最悪データベースの破損の危険があります。 　会社側としては今後の発展性を考えてSQL SERVERを希望しているのでしょう。 参考書として 「ＳＱＬ　Ｓｅｒｖｅｒ　２００５でいってみよう」より　開発編 「ＳＱＬ　Ｓｅｒｖｅｒ　２００５でいってみよう」より　運用管理編 あたりから勉強してみてください。
このあたりを見てみましょう。 Express 基本操作 http://msdn.microsoft.com/ja-jp/sqlserver/cc720684.aspx これはデフォルトで作成されるインスタンスです。 SQL Server Expressをインストールすると作成されます。 >自分のコンピュータ名\sqlexpless >意味が分からなかったので削除は諦め、新しくサーバを作ろうと「新規サーバの登録」から、適当に名前をつけてテストボタンを押したんですが、画像のようなエラーが出てきました。 これは、あくまで接続先を登録するだけです。 適当に入れた接続先が存在しないのでエラーになっただけです。 >見ても解決できなかったので諦めて、最初もともとあったサーバを使って新しくデータベースを作成しようとすると今度は、 >CREATE DATABASE 権限が拒否された >とのエラーが発生します。もう何もできなくなってしまいました。 権限のあるユーザで作業してください。 これも自習書を見てください。
SQL Serverが当該ファイルを使用中なのでは。 SQL Serverを停止してみるとか。VWDのDatabase Explorerならアタッチ方式でなく接続方式を使えないか試してみるとか。
sp_spaceusedとか。 定義を参照して、希望する結果を出力するようなクエリを組み立ててみては。
テーブルsysobjectsを検索してCSV化したいテーブル名を出力するSQLを実行して、その結果を使ってbcpを起動するバッチを作るとか。
DELETE FROM DB2.dbo.table1 INSERT INTO DB2.dbo.table1 SELECT * FROM DB1.dbo.table1 膨大な行数であれば、DB2.dbo.table1のインデックスを一時的に削除するとよい。
こんにちは DB2はバージョンによっても関数の仕様が違ってくるので、かなりわかりにくいですね・・・。 （何故DB2なのか・・・、マニュアル少ないし・・・） とりあえずTMSPCカラムの型が整数値なら、CHARで変換できます。 DECIMALでフォーマット指定なら、バージョンを教えてください。
うーん…それってプログラムに問題があるような気がするのですが。 プログラム側で接続を開放しそこねていて、多重接続しているとか...。 そういう状態になったときにsysprocessesテーブルなどで接続数を確認してみてもいいかもしれません。
私の場合は、以下のようにCASEを使って処理しています。 select * from TBL where case when @para1 is not null then @para1 else koumoku1 end = koumoku1 and case when @para2 is not null then @para2 else koumoku2 end = koumoku2 and case when @para3 is not null then @para3 else koumoku3 end = koumoku3 簡潔になると思いますが、如何でしょうか？
SQL ServerのmsdbはMicrosoft System Databaseの略のはずですけどねぇ。。
ＢテーブルのSELECT文で ltrim関数で、左空白文字を外し、concat関数で左一桁に「0」を 文字連結させる。 SELECT concat('0', ltrim(ＮＯ)) from Ｂ ・・・
再帰CTEの話をすると混乱するかもしれませんので、とりあえず以下を。 ただ、クエリを見る限り、Accessっぽいのが気になります。 SELECT CASE WHEN d5.ChildID IS NOT NULL THEN d5.ChildID WHEN d4.ChildID IS NOT NULL THEN d4.ChildID WHEN d3.ChildID IS NOT NULL THEN d3.ChildID WHEN d2.ChildID IS NOT NULL THEN d2.ChildID WHEN d1.ChildID IS NOT NULL THEN d1.ChildID END, CASE WHEN d5.ChildID IS NOT NULL THEN d4.ChildID WHEN d4.ChildID IS NOT NULL THEN d3.ChildID WHEN d3.ChildID IS NOT NULL THEN d2.ChildID WHEN d2.ChildID IS NOT NULL THEN d1.ChildID END, CASE WHEN d5.ChildID IS NOT NULL THEN d3.ChildID WHEN d4.ChildID IS NOT NULL THEN d2.ChildID WHEN d3.ChildID IS NOT NULL THEN d1.ChildID END, CASE WHEN d5.ChildID IS NOT NULL THEN d2.ChildID WHEN d4.ChildID IS NOT NULL THEN d1.ChildID END, CASE WHEN d5.ChildID IS NOT NULL THEN d1.ChildID END, COALESCE(d1.ChildName,d2.ChildName,d3.ChildName,d4.ChildName,d5.ChildName) FROM Department d1 LEFT OUTER JOIN Department d2 ON d2.ChildID=d1.ParentID LEFT OUTER JOIN Department d3 ON d3.ChildID=d2.ParentID LEFT OUTER JOIN Department d4 ON d4.ChildID=d3.ParentID LEFT OUTER JOIN Department d5 ON d5.ChildID=d4.ParentID
とくに特別な処理は必要ないはずです。 リストアは正常に行われたと書かれていますが、中身が見られないならば、それは正常に行われていないということかもしれません。 ・sys.databasesのstate_descの内容がONLINEになっているか ・use データベース名 ・そもそもsysadmin権限のあるユーザでリストアしたか ・バックアップファイルが正常か あたりを確認してみるしかなさそうです。
ですか・・・。 じゃあWhileで発行するのをやめたらどうですか？ BEGIN TRAN update table set A=1,B=2 where id=1; update table set A=2,B=3 where id=5; update table set A=9,B=99 where id=7; update table set A=5,B=10 where id=15; update table set A=1,B=10 where id=75; COMMIT まとめて実行・・・。
名前付きパイプを使用して接続するようにしてみてください。 詳細は下記。
あるテーブル「テーブル１」に数量1,金額1,数量2,金額2,....,数量10,金額10まで項目があるとして、 それらの数量a×金額aの合計を求めたいとすれば、こんな感じになります。 DECLARE @sql varchar(MAX) DECLARE @i int SET @i=1 WHILE (@i<=10) BEGIN SET @sql = ISNULL(@sql+'+','')+'数量'+CONVERT(varchar,@i)+'*金額'+CONVERT(varchar,@i) SET @i=@i+1 END SET @sql='SELECT '+@sql+' FROM テーブル1' EXEC (@sql) まあ、もしこのようなテーブルが本当にあるとしたら、全く正規化されていないテーブルってことですけど。
SELECT A.* FROM TBL A INNER JOIN (SELECT Max(登録日) AS 最新日 FROM TBL WEHERE 登録日<=CONVERT(SMALLDATETIME,'2008/12/08')) B ON A.登録日=B.最新日 こんな感じでしょうか
http://www.microsoft.com/downloads/details.aspx?FamilyId=ae7387c3-348c-4faa-8ae5-949fdfbe59c4&displaylang=ja http://blogs.technet.com/sqlpm-j/archive/2009/05/19/sql-server-windows-7-rc-windows-server-2008-r2-rc.aspx SP3を適用すれば良いようです。SP3のインストール対象OSにWin7があります。
ダウンロードの画面に以下の記述がありますので、ご自分の環境にあったものを選択してください。 注 : SQL Server 2008 Express には、32 ビット版と 64 ビット版があります。SQLEXPR32_x86 は、32 ビット オペレーティング システム用の SQL Server 2008 Express のインストールだけに使用できる小型のパッケージです。SQLEXPR_x86 は、同じ製品ですが、32 ビットと 64 ビット (WoW) の両方のオペレーティング システムへのインストールをサポートしています。SQLEXPR_x64 は、ネイティブの 64 ビット SQL Server 2008 Express であり、64 ビットのオペレーティング システムへのインストールだけをサポートしています。これらのパッケージに、それ以外の違いはありません。 http://www.microsoft.com/downloads/details.aspx?displaylang=ja&FamilyID=58ce885d-508b-45c8-9fd3-118edd8e6fff
誤字がかなり多いので一旦整理しますね ---テーブル情報--- ・FoodList NO Food 1 りんご 2 みかん 3 ぶどう ・MyList NO first second 1 2 3 2 1 2 3 2 1 --------------- 正しくは以下の通りです。 -------------------------------- SELECT MyList.No, FoodList.Food As firstFood, FoodList_2.Food As secondFood FROM MyList INNER JOIN FoodList ON MyList.first = FoodList.No INNER JOIN FoodList As FoodList_2 ON MyList.second = FoodList_2.No -------------------------------- スレ主の2件目クエリーの結合順序が逆になっているのが原因ですね。
テーブル名をTABLEA,　ビュー名をVIEWAとすれば、こんな感じです。 CREATE VIEW VIEWA AS SELECT MainNo, MAX(CASE WHEN SubNo=1 THEN SubNo END) SubNo1, MAX(CASE WHEN SubNo=1 THEN Name END) Name1, MAX(CASE WHEN SubNo=2 THEN SubNo END) SubNo2, MAX(CASE WHEN SubNo=2 THEN Name END) Name2, MAX(CASE WHEN SubNo=3 THEN SubNo END) SubNo3, MAX(CASE WHEN SubNo=3 THEN Name END) Name3, MAX(CASE WHEN SubNo=4 THEN SubNo END) SubNo4, MAX(CASE WHEN SubNo=4 THEN Name END) Name4, MAX(CASE WHEN SubNo=5 THEN SubNo END) SubNo5, MAX(CASE WHEN SubNo=5 THEN Name END) Name5 FROM TABLEA GROUP BY MainNo
データ量にもよるとは思いますが、、、 ・貸し出し表テーブルの件数が膨大ではない ・集計は年月で絞っての日毎リスト 程度であれば、一時テーブルでもよいと思います。 一時テーブルの利点としては、カレンダテーブルのような物が必要ないということです。 欠点は、内部のループでカレンダを自力で作成するため、集計スパンが広いと、ＤＢに負荷がかかります。 カレンダテーブルの利点としては、集計の範囲が広くてもループ処理を必要なく、集計が行えます。 欠点は、カレンダがマスタとなるので、メンテナンスを求められます。 どちらがよいかは、システムの業務フローや状態から判断するものだと思うので、ご自身でお考えください。 ストアドサンプルを載せます。 見やすくするために、[全角スペース]を利用しています。 [全角スペース]を[半角スペース2個に置換]してお使いください。 --------------------------------------- ↓プロシージャ呼出はこれ（2010年04月） EXEC PRC_月別貸出リスト '201004' --------------------------------------- ↓プロシージャ(初回はクリエイト) CREATE PROCEDURE PRC_月別貸出リスト --ALTER PROCEDURE PRC_月別貸出リスト ( 　@s年月 AS VARCHAR(6) ) AS BEGIN 　-- 結果返却用の一時テーブル定義 　CREATE TABLE #TMP 　( 　　日付　　　　　DATETIME, 　　ID　　　　　　INT, 　　貸出日　　　　DATETIME, 　　返却予定日　　DATETIME, 　　貸し出した物　VARCHAR(50) 　); 　DECLARE @d対象日　DATETIME; 　DECLARE @i日　　　INT; 　-- 引数年月の初日を設定 　SET @d対象日　= @s年月　+ '01'; 　-- 一回目のループを通すために、0日とする 　SET @i日　= 0; 　-- 翌月までループする 　WHILE @i日 < DAY(@d対象日) 　BEGIN 　　-- 抽出結果を一時テーブルに格納していく 　　INSERT INTO #TMP 　　SELECT 　　　　@d対象日, 　　　　T.ID, 　　　　T.貸し出し日, 　　　　T.返却予定日, 　　　　T.貸し出した物 　　FROM 　　　　貸し出し表　T 　　WHERE 　　　　@d対象日 BETWEEN T.貸し出し日 AND T.返却予定日; 　　-- 処理を行った日付を記憶 　　SET @i日　　　= DAY(@d対象日); 　　-- 次のループのために、対象日をインクリメント 　　SET @d対象日　= DATEADD(DAY, 1, @d対象日); 　END; 　-- 抽出結果のアウトプット 　SELECT * FROM #TMP 　ORDER BY 日付, ID END
テーブルの列の拡張プロパティに次の値を設定するとAccessでテーブルを開くとチェックマークで表示されるようになります。 名前　→　MS_DisplayControl　値　→　106 名前　→　MS_Format　値　→　Yes/No 拡張プロパティの表示はマネージメントスタジオでテーブル名をダブルクリック－列をダブルクリック－ 列名をダブルクリックで拡張プロパティを選択します。または下記のクエリーを実行してください。 EXEC sys.sp_addextendedproperty @name=N'MS_DisplayControl', @value=N'106' ,@level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'テーブル名', @level2type=N'COLUMN', @level2name=N'フィールド名' GO EXEC sys.sp_addextendedproperty @name=N'MS_Format', @value=N'Yes/No' ,@level0type=N'SCHEMA', @level0name=N'dbo', @level1type=N'TABLE', @level1name=N'テーブル名', @level2type=N'COLUMN', @level2name=N'フィールド名' GO テーブル名とフィールド名は書き換えてください
今使ってる端末にSQLServerが入っていないので確認はしていないのですが・・・ 型をあわせてあげる必要があると思います。 質問内容の記述ではdbTimeNowは文字列として扱われてしまいます。 T-SQLのCAST文を使って、 "Select * FROM tblA WHERE tbltime < CAST('" & dbTimeNow & "' AS datetime)" というように変換してみてください。
詳しい情報が欲しければ，リンクを辿ってMSDNまで行けばあります。 MSDN: SQL Server 2008 の各エディションがサポートする機能 http://msdn.microsoft.com/ja-jp/library/cc645993.aspx など。 SQL Server 2005の時は，MSDEからの乗り替えという問題があったり， 初のExpress Editionということもあって，色々情報を提供する必要があったのだと思います。 元々，SQL ServerのExpress Editionでは色々制約は確かにあるものの， Workgroupと比べて大きく機能が削減されているわけではありません。 # 運用面からはいくらか不安になるかもしれませんが……。 なので，特別専用情報を提供していないだけだと思います。 ちなみに，Tech・EDをはじめとした各種技術カンファレンスでは， SQL Server 2005は「旧バージョン」として扱われ，移行対象の技術にすらなっています。 SITE: Microsoft Tech&middot;Ed Japan 2009 ホーム http://www.microsoft.com/japan/teched/2009/default.mspx のセッションT4-302 SQL Server 旧バージョンからの移行 http://www.microsoft.com/japan/teched/2009/session/tech_abstract.aspx?T4-302
昔、以下のSQLを作ったことがあります。2005では問題なかったです。 私の用はこれで足りたので必要に応じて修正してみてください。 SELECT b.name as "Table名", a.name as "カラム名", c.name as "データ型", a.column_id as "カラム順", a.max_length as "データ長", a.precision, a.scale , case when a.is_nullable =0 then 'Null不可' else 'NUll可' end as "NULL", case when a.is_identity =0 then '×' else '○' end as "オートナンバー", case when a.default_object_id = 0 then '×' else d.definition end as 'デフォルト値', case when f.index_column_id is not null AND e.is_primary_key = 1 then 'PK' else '×' end as 'PK' FROM sys.columns as a Left outer JOIN sys.objects as b ON a.object_id = b.object_id Left outer JOIN sys.types as c ON a.system_type_id = c.system_type_id Left outer JOIN sys.default_constraints as d ON a.default_object_id = d.object_id Left outer JOIN sys.indexes as e ON a.object_id = e.object_id AND e.is_primary_key = 1 Left outer JOIN sys.index_columns as f ON a.object_id = f.object_id AND a.column_id = f.column_id WHERE b.type = 'U' AND c.name != 'sysname' ORDER BY b.name,a.column_id
test.udl とか適当な名前でからのファイルを作ります。 このファイルをダブルクリックすると「データリンクプロパティ」が立ち上がりますので ここでDBを選択してパラメータを設定し、接続テストを行います。 この後test.udlをエディターで見てみると接続文字列が分かります。 簡単ですのでお試しを
担当部署を中間ファクトテーブルとしてもメジャーに登録し、それを経由して多対多のリレーションを張れば実現可能です。 試した限りではできますよ。 http://technet.microsoft.com/ja-jp/library/ms170463(SQL.90).aspx まあ、無理を承知でやる以上、どう見えるかは十分確認してから設定してみてください。
「スナップショット分離レベルは１となっています」と書いてありますが、SSISからSNAPSHOTで処理するように書いているというわけではなさそうですね。READ COMMITTEDであれば、キーが不足していてテーブルスキャンがかかればロックの競合は発生しうると思います。NOWAIT指定があれば処理は止まらずエラーが返るので、更新処理も含めてここには書かれていない部分もロック待ちに影響している可能性を考えてしまいます。
こういう質問のときは、 ・どうやって更新しようとしたのか（手打ち？クエリ？） ・エラーメッセージが出たのかでないのか など、も書かれるようにした方がいいと思います。 回答者の推理力にも限界がありますから、的外れな回答になることもあります。 今回一番確認してほしいのは「tbl_01には主キーがあるのか」です。 ODBCでSQL Serverを参照するときは、AccessとSQL Serverをつなぐプロバイダというものを介することになりますが、データに主キーがないとうまく更新処理の対象を受け渡せないためです。 なので、そういう場合はよく「参照はできるけど、更新はできない」ということになり得ます。
通常は「トランザクションログをバックアップする」→「ログファイルを圧縮する」の手順ですが、 書き方から察するにログファイルの中身はもういらないということでいいですか？ その場合は、トランザクションログをバックアップしないで切捨ててもいいでしょう（SQL Server 2005まではこのオプションは使えます）。 BACKUP LOG [データベース名] WITH TRUNCATE_ONLY そのあと、SSMSのメニューから圧縮を選んでログを100MBに圧縮します（DBCC SHRINKFILE)。 ちなみに時間外にやった方がいいと思います。 なお、以後そうならないように１日１回はトランザクションログのバックアップを実行することをお勧めします。
キャッシュなどを疑う以前に私などはインスタンス(SQL Server Express2008)とテーブル(TB01)だけでデータベースに言及されていないことが気になります。 「新しいデータベースを作っても中のテーブルが見えない」となるとさらに？です。 そもそもODBCはどのデータベースを向いているのでしょうか？ 質問者さんの削除したテーブルは本当にAccessから見ているテーブルと同一のものですか？
どこまで理解されているか不明のため、質問だけに答えます。 >FileStreamデータ型はEXE形式のファイルを格納することも可能でしょうか？ EXE形式のファイルでもバイナリであることに変わりはないので格納できます。 >また、ファイルをテーブルに格納したあとに、実ファイルをHDDから削除しても問題ないですか？ 実ファイルの「場所だけ」を記録するわけではないので、問題ありません。
まあ、確かにSQLインジェクションかもしれません。 こんな感じでクエリアナライザで全部実行してみると、中身はわかります。ある８文字の間に0から11までの数字がはさんであります。 SELECT convert(varchar,0x6461726b3063306465) その8文字でググると、確かにそういう名前のハッカー集団は存在するようです。ただし、私はその道には詳しくないので、何をどうしようとしていたのかはわかりません。
SQL Serverには以下の方法があります。 ・クラスタ ・ミラーリング ・レプリケーション クラスタは共有ディスクを使用するので、拠点間の距離により制限されます。あとMSCSが必要になります。同一DBを別のサーバで共有するイメージです。アクティブ/スタンバイですけどね。 http://msdn.microsoft.com/ja-jp/library/ms189134.aspx ミラーリングは別サーバの別DBに変更情報をコピーするイメージです。 こちらもアクティブ/スタンバイですが、スタンバイ側は読み取り専用で参照することも可能です。 http://technet.microsoft.com/ja-jp/library/cc917680.aspx レプリケーションは別サーバの別DBの個別オブジェクトの変更をコピーするイメージです。 http://msdn.microsoft.com/ja-jp/library/ms151198.aspx この場合はデータベースミラーリングが当てはまると思います。
>時刻部分だけ取り出して、それに時分秒を分ける「:」をつけて変換し計算するという方法 この内容的にはシンプルな質問に回答がつかないのは、つまり他に方法がないということです。 毎回それをやるのがいやならばスカラー関数を作ってはどうですか。
SqlParameterクラスを使います。 MSDN: SqlParameter クラス (System.Data.SqlClient) http://msdn.microsoft.com/ja-jp/library/system.data.sqlclient.sqlparameter.aspx 詳しい方法に関しては，マイクロソフト サポートオンラインの記事 MSKB: [HOWTO] パラメータ化されたストアド プロシージャを ADO.NET と Visual C# .NET を使って呼び出す方法 http://support.microsoft.com/kb/310070/ja を参照してください。
ご存じのとおり、プロファイラは今をトレースするものです。 その時にトレースをかけていない限り、実行していたSQL文を割り出すことはできないです。 定期的にリソースを監視する仕組みを予め用意していない限り、過去のイベントの手がかりはSQL Serverのログしかありません。ログにそれが記録されていたとしても、おそらくそれが発生したプロセスIDがわかる程度で、それ以外の手がかりを得られることは多くないです。 したがって、その「イベントログに記録されたものがどのシステムからのもので、一時的なものなのかどうか」は今となっては特定できない可能性が高く、再発を待つしかないと思います。 その再発に備えて、発生時刻やログから何か得られればその手がかりをもとに、定期的にトレースを掛けることで、再発時にそのプロセスを実行していた端末は何か、SQL文は何かを割り出せる可能性は高くなるでしょう。
inner joinであれば、どちらも違いはありません。 outer joinであれば、まったく違うものになります。 outer joinの場合、on句の結合条件で偽となる行も、nullとして結果が返されます。また、where句の抽出条件で偽となる行は、最終的な結果としては返されません。
どうやってSELECTしているのかわからないのですが、クエリ画面でSELECT文投げているのではなく、SSMSの機能を使ってクエリを実行しているならば、念のため以下のリンクもチェックしてみてください。 http://support.microsoft.com/kb/915849/ja
Viewの中で変換してください CONVERT(int,フィールド)
SQL Server 2000ではおそらくテーブルを参照しているViewなりストアドなりを全部ALTERしてやるほかないと思います。 （sp_refreshsqlmoduleを実行すればいいのですが、SQL Server 2005 SP2で追加されたものなので）
SQL Server 2008のSSMS/SSMSEから、ALTERですまないテーブル構造の変更はデフォルトでは許可されない設定になりました。 オプションのデザイナ－テーブルおよびデータベース デザイナに 「テーブルの再作成を必要とする変更を保存できないようにする」というのがありますので、そのチェックを外してください。 http://msdn.microsoft.com/ja-jp/library/ms188490.aspx
ORDER BY 単価 * (フラグ + 1)
