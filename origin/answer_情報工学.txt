>>実際にJava を使って何かしよう　と思ってもなにも浮かばないので、どうしようかなぁ　と悩んでいます。 プログラム言語を学んで、教科書とか市販の入門書にあるようなプログラムを作った後、「これを作りたい！！」って目的が無いとか、仕事とか、ボランティア仲間から「これお願いね、よろしく！」「こんなソフトが欲しいなあ！」なんて、他人からの要望・依頼が無いなら、そんな感じになりますね。 >>将来は一応エンジニアを目指していますが、まだどうなるかわからないので、システム開発系の書籍は読んでおりません。 ソフト開発って、「好き！」って要素がないと、続かない気がしています。 若いのに、「どうなるかわからないから、プログラムしない」っていうなら、エンジニアの仕事、開発の仕事がが好きじゃないってことでしょう。 もしかすると、他の仕事を選んだほうがいいかもしれませんね。 >>次の1ステップとして、何をすべきでしょうか？ 私が若いころは、パソコン関連の技術発展が著しいころで、最新ハード、最新ソフトの話が、書店にずらり並んだマイコン雑誌に毎月掲載されていて、それらを追いかけるのが楽しかった時代でした。 今になって考えると、その当時においても、知らないことが多かったから、少しでも知識を増やしたかったのかもしれませんね。 あるいは、就職して、否応なく仕事でプログラミングをするしかない状況に自分を置いてみて、その環境の中で何か探してみるとかね。 現在の世の中、何をやるにしても、システムというかプログラムが必要です。 そして、プログラムがあれば、人間が５時間かかるようなエクセル仕事も１秒で終わらせることが可能になったりします。 江戸末期、黒船が日本にきたとき、日本の技術は、彼らから遙かに後れていて、植民地になる可能性がありました。 でも、日本人は頑張って、欧米に追いつけ、追い越せと努力しました。 現在、ソフト開発において、欧米と日本では、その当時のような差がついています。 今後、もっと欧米と日本とのソフト開発力の差が大きくなれば、日本は江戸末期のようになるかもしれません。 日本が植民地にならないために！って目標を持って、がんばるのもいいかもしれません。
一般的には、 あるコマンド.exe 第1引数 第2引数 とか、空白で引数を区切ります。 例えば、MS-DOSのコマンドだと、 dir /w /s c:\Windows dirコマンドに第1引数「/w」、第2引数「/s」、第3引数「c:\Windows」が渡され、第1第2引数はスラッシュが付いていることからオプションとして解釈され、第3引数のWindowsフォルダの内容が表示されるとか。 -- あと、 ×コマンドプロント ○コマンドプロンプト プロンプト(とそれに続くカーソル)は、ユーザーからの入力を待ってますよって表示、文字です。
>最小積和形と最小和積形 この最小の意味（定義）はなんでしょうか？ 積和標準形や和積標準形を簡約かすることですか？ であれば、与えられた真理値表をカルノー図に書き換えて 関脇位と和積形を求めればいいでしょう。 積和形：Z=1となる積項を拾い出し和をとる。 　Z=Z=A~B+BC+^B~C 和積形：Z=0となる和項を拾い出し変数を反転させてから積をとる。 　Z=(A+B+~C)(~B+C)
人間の脳の働きに例えると、ディープラーニングは成長期の子供が大人に教えられなくても自然に言葉の意味を覚えたり、おもちゃで遊んだりする過程に例えられます。 認知型は教育を受けた成人の脳の働きに相当し、膨大な学習データから対象を認識したり解析して応答する能力に優れますが、新しい知識やルールを自ら学習する能力は低いと考えられます。 多変量解析はパターンやルールを学習する過程での脳の働きと捉えられます。
★回答　ざっくり 44.1[kHz]　Fs　　サンプリング周波数 1/Fs＝Ts　　　　サンプリング周期 サンプリングビット数　信号振幅瞬時値を　数値　2の16乗　2＾16　とうりのレベルで数化 ようするに方眼紙に　信号波形の　ボーグラフを作る工程とおんなじ ★量子化→縦軸のマス目　信号振幅瞬時値を　数値　2の16乗　2＾16　とうりのレベルで数化 ★標本化→横軸のマス目　時間　1/Fs＝Ts　　　サンプリング周期 0～20[kHz]の信号としているのは　標本化定理をみたす範囲に　帯域制限してるだけ 標本化定理　サンプリング定理 1/Fs＝Ts　の場合　信号が　1/2×Fs　までの帯域ならOKと言うこと 詳しくは　このへんがいいんじゃねーかな　学生向き http://laputa.cs.shinshu-u.ac.jp/~yizawa/InfSys1/basic/chap1/index.htm java動画つきだぜ↑　らくちんよ　どうよ http://www.ic.is.tohoku.ac.jp/~swk/lecture/yaruodsp/node21.html ここも　簡単↑ここなら　ばかでもわかる　すごい親切
>このDはAに向かってくるベクトルのことかAから向かうベクトルのどちらでしょうか？ Aを通る光線の進行方向の単位方向ベクトルがDです。 なので平行光線の方向ベクトルを単位ベクトル化したものは、Dベクトルに平行で一致します。
微分なので、0.1→０です。 数値計算のお約束としてΔｘ→０の微分をする時は f(x+Δx)-f(x)≦ε　として、εが十分小さな値になるように設定します。 ですので、エクセルですからせめて0.000001ぐらいまでは計算させてほしいところです。
(1) どちらでもよい。 私はイーサネットと言う。 ちなみにgoogle検索では イーサネット約 790,000 件 （0.49 秒） イーサーネット約 338,000 件 （0.44 秒） (2) http://mbsupport.dip.jp/bk/2003/sub/916.htm クラスプライベート IP アドレスサブネットマスク接続数 A10.0.0.0～10.255.255.255255.0.0.016.777.216個 B172.16.0.0～172.31.255.255255.255.0.065.536個 C192.168.0.0～192.168.255.255255.255.255.0256個
　オオ～！、ほんとだ。シナリオ通りに進んでる(^^;)。最後の一幕を除いては・・・。 　ちょっと前になりますが、年金情報紛失事件ってのがありましたよね？。「個人情報の流出」や「コンピュータ情報の改ざん」ですらなく、たんなる「紛失」です。それを思うと、少なくとも日本にはテクノクラートなんているの？、と思いたくはなってしまう(^^;)。 　スノーデンさんが逃げ出したのは「国家安全保障局」でしたっけ？。あういう処が天下を取ればテクノクラートによる情報管理社会となるかも知れませんが、これからでしょう。もっと原始的な手段でそれを半分実現してる国は、お隣に2つほどありますが。 　もう一つ。その予測が出された時は、サンバーパンクもかなり流行ってました。極論すれば、映画JMみたいな未来のイメージだったと思います。
　波形がどれだけ似てるかを判定するソフトの決定版は、たぶんないです。というのは「似てる」という人間的な判定基準が、そもそもアイマイだからです。問題状況に応じてケースバイケースに処理されるのが実情でしょう。 　という訳で以下、一般的な話です。 　例えば質問文にあげられている波形の例は、かなり明確な周期性を持っています（フリーハンドで適当に描くと、そうなりますよね？(^^)）。こういう場合は、フーリエ変換を行って（FFTすると良くいわれます）、振幅スペクトルを調べます。そうするとスペクトル分布と卓越周波数が概ね等しければ、超概ね似た波形というファジーな(^^;)判断ができます。 ※フーリエ変換のフリープログラムは、けっこうたくさん転がっています(^^)。 　もう一つ良く使われるのは、相互相関係数です。これは対象波形をg(t)，基準波形をf(t)としたとき、 　　A＝∫g(t)・f(t) dt 　　B＝(∫g(t)・g(t) dt)^(1/2) 　　C＝(∫f(t)・f(t) dt)^(1/2) 　　Cor＝A/B/C で計算します。 　相互相関係数Corは必ず　-1≦Cor≦+1　の値を取り、f(t)とg(t)の形が完全に相似なら±1です。-1の場合は、f(t)とg(t)の正負が逆転した相似です。通常は0.5≦|Cor|なら「けっこう似ている」というファジーな判断をします。 ※相互相関プログラムは、ちょっとお高い波形解析ソフトには必ず付いていますが、じつはExcelの数式を使えば、A，B，Cの値はすぐ出せます(^^)。
ハードで実現する場合は，FPGAで行う場合シフトレジスタにためて，加算して，係数を掛ける格好になると思います. 100個の和になるので，そのまま加算する場合は桁上がりに注意が必要です.係数を掛けてから加算した方が良いかもしれません.添付のURLに4段の場合のVDHLが書かれていました.参考までに. 前の方もおっしゃっていましたが，100個の移動平均であれば，100個分の時間を待つ必要がありますので，その処理を入れておく必要があると思います.ご注意ください.
>単位ステップのラプラス変換は表より1/s >exp(-at)のラプラス変換は、1/(s+a) ここまでは良さそう。 このあと…？ 波形出力 (t > 0) は、 　vout (t) = 単位ステップ + 2*{ e^(-at) - 単位ステップ } らしく見える。 これのラプラス変換 F(s) は、 　F(s) = -(1/s) + { 2/(s+a) } 　= (s-a)/{ s(s+a) } だろう。 >よって伝達関数H(s)は … F(s)/(1/s) = (s-a)/(s+a) なのかナ？ 　　
対称性から、ある1つのノードと他の任意のノードとの距離を求める方法がわかれば解ける。 まず、N次元の任意のノードを表現する方法を考えると、すべてのノードはハイパーキューブの頂点にあるため、N次のベクトル (a_1, a_2, ..., a_N) と表せる。ただし、a_n = 0, 1。 次に、任意のノードに繋がっているノード（距離が1のノード）を求める方法を考える。 例えば、要素すべてが 0 のノード (0, 0, ..., 0) （以下、原点ノードと呼ぶ）と繋がっているノードは、(1, 0, ..., 0), (0, 1, ..., 0), ..., (0, 0, ..., 1) のN個である。 ここで、対称性から、あるノードと繋がっているノードは、ベクトルの要素の1つが 0 と 1 が反転したものであるという法則があることがわかる。 さらに、ノード間の距離は最短距離を使うため、原点ノードとその他の任意のノードとの距離は、そのノードの要素の中の 1 の数の合計である。（例えば、原点ノードと (1, 0, 0, 1, 0) との距離は 2） 任意のノードとの距離を求める方法がわかったので、後は単純な組み合わせの問題。
AIもプログラムですから、原則はNo1さんのご指摘のとおりに同じ結果になります。 ただしそれは「同じようなAI」ではなく、「初期値、構造、実績」などまったく同じであり、AIどうしは独立（接続なし）で、「ビッグデータの入力手順も同じ」「ほかに割り込みや並行する計算が一切無い」状態でなければなりません。言い換えると、一台のAIをリセットしてからビッグデータを与えて計算を実施し、次に全てリセットしてまた計算する、こういう作業を繰り返すことと同じ動作になりますので、結果は同じになります。 ディープラーニングは、ニューラルネットワークを用いて様々な情報を経験値として蓄積しながら回答を導出する機械学習法で、AI全てに備わっているわけではなく、AIを実現するための一手法です。通常、AIは並行処理しており、複数のユーザが使用しています。最初はまったく同じであっても異なる入力（計算）がいくつか入り込めば、経験情報はAIごとに異なってきますので、おのずと学習結果は異なってきます。 現実的には、２台の同じシステムのAIがあったとしても、セットアップや受入れテスト、試行などですでに学習状態が異なってしまっています。 それがAIの個性となりますので、同じデータを学習させても、結果は変ってきます。（もちろん、同じ結果になることもあります） つぎに、ビッグデータですが、一般に大きなデータでは統計結果が収束する傾向にありますので、異なったAIを用いても結果は同じということは十分ありえます。
「Small Talk」の本を探して読まれてみては。
まず、儲かるとすれば、すでに投資信託を運用している金融機関が採用済みと思われます。（ファンドの目論見書にて運用方針なども顧客に説明済みで） 次に、情報を得られる人数が少ないほど、その精度は上がるでしょうが、それがわかっている人間ほどどうでもいい情報を無料で全世界に公開し、本当に重要な情報は「利害関係者内」でしか共有しないでしょう。 そのような、情報が上がってきたトップ層での情報からは抜け落ちる・省略して構わないと見逃される情報の中に、現場に一番近い人間が「本当は重要なのに」と思っている情報があり、それが顧客でも確認し得る、という可能性に賭けるしかないと思います。
「単回帰分析」と「母集団の平均の推定」
キャッシュはメモリより読み書きが高速です。（そうでないとキャッシュを使う意味がない） しかし、ライトバッファを持たないライトスルー方式では、書き込みの速さはメモリの速さと同じになります。 一方、ライトバック方式では、必要に迫られるまでメモリへの書き込みを行わず、メモリへの書き込みはバスの空き時間を利用したりして、可能な限りキャッシュの速度で書き込みができるようにします。（そうでないとライトバックを使う意味がない） これに対し、読み込みの速さは、2方式で違いはありません。どちらもキャッシュからの読み込みでよい場合はキャッシュから高速に読み、メモリからの読み込みが必要な場合はメモリから低速で読むためです。 したがって、ライトバック方式が速くなるのは、書き込みが多い場合に限られます。(ただし、ファイルのコピーのような、大量に連続した書き込みを除く) この条件を満たすのは、AとCです。
こういっちゃなんですが、「プログラミング」は一定の「センス」 がないと読み書きできないものです。 言えばいきなり「英語のお笑い」を聞くようなもので、英語を 普段から聞きなれている人は笑えるけど、英語をテキストでしか 読んでない人は全然笑えない・・・というのに似ています。 要は「普段からプログラムを書きなれているか」どうかを見たい わけで、逆に言えば今更あがいても「間に合わない」んです。 ということで、「普段からプログラムは書きなれている」なら 何もせず放置で全く問題なし、「普段プログラムは書いてない」 なら、今更頑張っても無駄ですから、やっぱり放置で正解です。
＞時系列信号に含まれるある成分(周期性あり)の特徴を時間領域で抽出できないか まず「特徴」の意味を明確に定義することが必要です。それによって、アルゴリズムはおのずと決まってきます。 あるいは、「特徴でない」ものを定義して、それを除くような処理でもよいです。 話を読むと、雑音の中から盗聴音を拾い出す、スパイ映画に出てくるような処理の気がしますが、 その場合は、適応化平滑化法、最大エントロピー法、が使われることが多いです。
>解答は 010111 のようですが、なぜ出力Qの初期状態が、右から0,0,1であるのに、 Aから初めに0 0 が出力されないのでしょうか？ 各FFのデータが001ですから 各FFの最初の入力値は110になります。 そうすると出力データが110になりますから 各FFの次の入力値は011になります。 そうすると出力データは011となり Aの出力は00にはならないはずです。 2段目の入力がXORであることを忘れていませんか？
T[s]=1/Δf+T[G]　ではないのですか？ 6.4MHｚでは128が余分に考慮されてしまうということです。
▲この係数は振動を表すような値？を示していると考えていますがいまいち 納得できません． ↓ 伝達関数の係数は振動（周波数）を表すような値？を示していると考えていますがいまいち 納得できません． ★回答　工学的ざっくり回答　なんの方法で求めても意味は以下だろ システム関数→伝達関数→デジタルの伝達関数→Ｈ（Ｚ）　；Ｚ＝exp（ｊω）　　　　Ｚ＝e＾ｊω H(Z)の絶対値が周波数振幅特性　信号は正弦波の合成として正弦波の大きさを表現してるだけ H(Z)のatan（虚数部分H（ｚ）/実数部分H（ｚ）） atan（Im（H（ｚ））/Re（H（ｚ））） が周波数位相特性　信号は正弦波の合成として正弦波のずれ位相おくれを表現してるだけ http://okwave.jp/qa/q9080187.html ▲自己回帰移動平均モデルでは高い次数のARモデルを低い次数で表現可能とあったのですが ★回表現可能とはかぎらない　最終的に目的精度の問題となる たとえば直感的に説明 H(z)　MAモデル　は H(z)＝a ＋ bｚ^[-1] + ｃz^[-2] + dz^[-3]・・・有限個でおしまい・・・・・　が一般の形　 係数は　a b c d と名前をつけただけ 工学的だ　有限でおしまい　メモリーは有限　適当に打ち切る　有限インパルス応答ならOKよ H(z)/H(ｚ）の形式（ARMAモデル）に出来るとはかぎらない この割り算を計算すれば割り切れません H(z)＝a ＋ bｚ^[-1] + ｃz^[-2] + dz^[-3]・・・無限個になる場合もあるだろ 。。。。。工学的　ざっくり　回答。。。おわり。。。。。。。。。。。。。。。。
添削してみました。 spがスタックに最後に積んだ要素を指すようにしました。初期値はNULLです。 main関数も修正しました。コメントで示しました。 #include <stdio.h> #include <ctype.h> #include <stdlib.h> typedef struct cell_{ double vall; struct cell_ *next; }cell; cell *sp = NULL; int empty(void){ return sp==NULL; } void push(double x){ cell *newnode; newnode = (cell*)malloc(sizeof(cell)); newnode->vall = x; newnode->next = sp; sp = newnode; } double pop(void){ int i; double num; cell *nextnode; if (empty()) exit(1); num = sp->vall; nextnode = sp->next; free(sp); sp = nextnode; return num; } double print(void){ return sp->vall; } int main(){ double a, b; double i; char c; char *ends; while ((c = getchar()) != EOF){ if (isspace(c)) continue;// 空白を無視しないと Irregular Character 扱いになる if (isdigit(c)){ a = c-'0'; push(a); } else{ switch (c){ case '+': a = pop(); b = pop(); i = a + b; push(i); break; case '-': a = pop(); b = pop(); i = b - a;// aとbが逆　先に積んだほうが後から出てくる push(i); break; case '*': a = pop(); b = pop(); i = a * b; push(i); break; case '/': a = pop(); b = pop(); i = b / a;// aとbが逆　後で積んだほう（先に取り出したほう）が除数になる push(i); break; // c==EOFのときはwhileの判定ではじかれている default: printf("Irregular character is found. Try again\n"); while ((c = getchar()) != EOF && c != '\n'){} break; } // 全部処理してから結果を表示する a = print(); printf("%f\n", a); } } return 0; }
samples'は何を示しているのでしょうか？ グラフの縦軸が’samples’になっています。→grpdelay(samples) になっています grpdelay(samples) 　→ 　縦軸　データー列　　　単位が時間 samples　　　　→　　　　　　横軸　データー列　　複素周波数の値の列 でしょ
たとえば以下よ 音響工学研究室において　実用ディジタル信号処理講座 http://www.sound.sie.dendai.ac.jp/index-j.html http://www.sound.sie.dendai.ac.jp/index-j.html ニューラルネットワーク(Neural Network) http://www.sound.sie.dendai.ac.jp/dsp/Text/PDF/Chap05.html LMSアルゴリズムもある ｍａｔｌａｂのプログラムが記述されてる 検索キーワード；　適応フィルタの作り方　 分野；デジタル信号処理
定義どおりに考えればよい。 精度=(検索結果のうち、条件に適合する件数)/(検索された情報の件数)=10/40=0.25 再現率=(検索結果のうち、条件に適合する件数)/(全情報中に存在する、条件に適合する情報の件数)=10/20=0.5 参考 http://ameblo.jp/bakanata2/entry-11772045116.html
スキャナで取り込んだときと プリントアウトする時とで多少倍率が変ったり、 機械のクセが出たりする可能性がありますので、 一度、やってみて求めるサイズより大きいか小さいかで 微調整が必要だと思います。 昔のスキャナだったりすると、縦横倍率が100％と９９％程度に違うというものもありました。 ＞1/144サイズから1/100にするなら一旦144で割ってから100を掛けるという計算になるのでしょうが倍率の%表記になると数学がずっと苦手な自分には計算方法が出てきません。 100％が１／１です。 1/144を1/100にするのは 144倍して1/100にするので、0.694倍つまり69.4％です。
>大学で、符号化理論を学びました。インタネットなどの通信路の安全を高めるための学問でしょうか。 どちらかというと、効率化を高める理論だと思うのですが？ >通信路の符号化とセキュリティでは、理論的、分野的に違った分野でしょうか？ または、重なる部分もあるのでしょうか？ 符号化の意味次第ですが、 符号化が上位概念とも言えます。 信号を垂れ流しにするのか 圧縮するために符号化するのかというのがまずあって、 符号化して通信路に流した場合に、 どのように暗号化するのかということになります。 符号化自体が解読が容易な暗号化と言えなくもないです、 暗号化自体はそれとは別に 隠語を使うことも暗号ですし、隠語を使うということは符号化と呼べなくも無いです。
★ヒント　回答　説明 wN[n]　を時間域の関数とすれば　（なんの窓でもよし） 255 ΣwN[n]×exp(-n×jωT) n＝0 ω＝2πF ωのとる値を　0～ｍ　　　たとえば　　ｍ＝255個の　　刻み値 離散値をとっていくとすればDFT　と一致 連続ならZ変換 フーリエ変換 でもとめたのと一致 計算した結果は個々で確認 ΣwN[n]×exp(-n×jωT)の　絶対値振幅グラフで確認　　すればよい　 https://en.wikipedia.org/wiki/Window_function#Windowing https://ja.wikipedia.org/wiki/%E7%AA%93%E9%96%A2%E6%95%B0#.E3.83.8F.E3.83.9F.E3.83.B3.E3.82.B0.E7.AA.93 ざっくり　添付　図の感じになる　ハニングだとこんな感じ
★ざっくり　回答 ｈ（ｋ）×ｈ（ｋ）　に　離散フーリエ変換をする 掛算の　　離散フーリエ変換　　は　畳み込み和の式になる パワー（エネルギー）は同じと証明される 式を整理すると　　パーシバルの定理　離散版となる ※式は　テキストでは　数式は嫌い　　めんどいので略 高速フーリエ変換　科学技術出版社 144ページにでとる http://www.kagaku.co.jp/1-20-01_fouhenkan.htm この道の原点みたいな教科書↑これよ
こりゃ、「数学」あたりで訊かんとろくなレスつきませんヨ (このレスを含め … ) 。 >ｆ：Ａ→Ｂとする。このとき、次の（ｆ、Ａ、Ｂ）は全射・単射・全単射・どれでもない・のうちどれか？また、関数でない 場合は関数でないと答えよ 　　↓　字引き 全射 (Surjection) : B のどの要素も、f 対応する A の要素をもつ。 単射 (Injection) : B のどの要素も、「高々一つ」の f 対応する A の要素をもつ。 全単射 (Bijection) : 全射かつ単射、つまり「一対一」対応。 どれでもない : 上記三つに該当せず。 関数でない : (意味不明 … ) 。 　　↓　判定案 (1) log(x), [-1,1], [0,∞)　→　単射 ∵ 0∈B だけが 1∈A と f 対応。他の B 要素は A からの対応なし。 (2) e^x, (0,1), (-e,e)　→　単射 ∵ (1,e)∈B だけが (0,1)∈A と f 対応。他の B 要素は A からの対応なし。 (1) x^2, [-1,1], (-∞,∞)　→　どれでもない (… ヨね) (1) √(x), [0,2], [0,1]　→　単射 ∵ [0,1]∈B だけが [0,1]∈A と f 対応。他の B 要素は A からの対応なし。 　　
サンプリングした際のグラフの描き方 振幅スペクトルが　X(Ω)={1, |Ω|<ΩB，0, |Ω|>=ΩB　 ↑不明 Ω　は時計　ｗｗｗｗ Ω　じゃなくて　　ω　角周波数では？ ω＝2πｆ ★回答　グラフの描き方　振幅スペクトル　グラフ　一般的やり方の　一例ヒント ある連続信号　x(t)の離散信号の計算 ●連続系の式は　フーリエ変換で求める ★時間関数　　変換　　周波数関数 x(ｔ)　　⇔　　X(ω) ●離散系の式は　離散フーリエ変換で求める ※時間連続系の式にグラフ描画点を代入して計算しても同じ　周波数が連続グラフで出るだけ ★離散時間関数　　変換　　離散周波数関数 たとえば　もとめた離散系の式を以下とすれば 時間域時系列　　　　　複素周波数列 x(n×Tｓ)　　⇔　　X(（ｎ×ωs/225）) ｎ；グラフ描画点　ｎ＝　1　　2　　　3・・・・・256 上記は　1～256　個の点をωｓまで描画する例 ω；　グラフ描画点　ω＝　ωｓ/255　　2ωｓ/256・・・・・ｎωs/256 Ｔｓ；サンプリング周期　サンプリング周波数の逆数　1/ｆｓ＝Ｔｓ ωｓ；　ωｓ＝1/Ｔｓ×2π ω＝2πｆ S=ｊω exp（ｊωT）＝exp（S×T）＝Z　　←実際にはZ＝exp（ｊωT）の関数式で求まるので ωにグラフ描画点を代入にて計算するだけ ざっくり言えば　Zはｚ変換のZと一致する式となる Z変換は　時間数列式⇔複素周波数連続の式 振幅スペクトルは絶対値　｜X(（ｎ×ωs/225）)　｜　を描画すればいいだけ ｎ；グラフ描画点　ｎ＝　1　　2　　　3・・・・・256 上記例　グラフはfs×1/2　までを繰り返す　fs　までとなる 　　　　　グラフはωｓ×1/2　までを繰り返す　ωｓ　までとなる X(ω)の位相は　　atan（虚数部分X(ω)/実数部分X(ω)））　です ω；　グラフ描画点　ω＝　　ωｓ/256　　2ωｓ/256・・・・・ｎωs/256 ※後は計算範囲（時間差サンプル数と描画周波数）を決め　お好みの範囲で描画すればいいだけ ・・おしまい・・・・・・・ 参考 振幅スペクトルと位相スペクトルのグラフ作成 http://okwave.jp/qa/q9069692.html
　配列を使った問題でしょう？ 　（Ｘ，Ｙ）の。 ＸもＹも１～１０の自然数。それ以下でもそれ以上も動けない。それぞれの座標の値の加算と減算で良いと思いますが。 　ＸもＹも１０になれば終了。ＩＦ　Ｘ＝１０　ＡＮＤ　Ｙ＝１０　ということでは？ 　コマの動きでＸとＹの値の計算だけの問題。その値に合わせて画面に表示させるとか別のルーチンで作れば良いでしょうね。 　プロっぽくするには指定入力のキー以外は再入力を求めるメッセージとか出す。除算０エラーに成らないように成りそうな計算式にはチェックする条件式をいれてね。変数が０になったらどうするかとか。 　プログラムで分からない時には、実際に物を紙などで作って、それぞれの変数をどうしたら良いか、書きだし見たり、作成中に変数を表示させて確認するプログラムを入れ込むとかすると良いよ。 　フローチャートももう一度考えて見よう。そこで考えを整理して、プログラミングですよ。 　
例えば分散のことです。 2次までの掛け算で得られるものなので、分散の平方根である標準偏差や共分散、相関係数などが2次の仲間ということになります。 3次の代表は尖度 (skewness)、4次は歪度 (kurtosis)となります。高次の統計量についてはリンク先に書かれています。
一周期2秒間のサンプリングデータは8個（2s*4Hz)なので、N=8になるかと思います。
★ざっくり　回答　一例　ヒント 例 $B$2＝各周波数πあたりの描画周波数の個数　　とすりゃ　3列でOK　　行数は描画周波数の個数で決定 0は計算しない←めんどいのではぶいた 描画周波数範囲÷描画点数＝描画周波数　←きざみ値 A4↓から入れる例 描画点ω=2π×描画周波数　振幅値 0　　　　=A4*1*PI()/$B$2　=(1/$B$1)*ABS(SIN(B4*$B$1/2)/SIN(B4/2)) =+A4+1=A5*1*PI()/$B$2　　　　=(1/$B$1)*ABS(SIN(B5*$B$1/2)/SIN(B5/2)) =+A5+1=A6*1*PI()/$B$2　　　　=(1/$B$1)*ABS(SIN(B6*$B$1/2)/SIN(B6/2)) =+A6+1=A7*1*PI()/$B$2　　　　=(1/$B$1)*ABS(SIN(B7*$B$1/2)/SIN(B7/2)) くりかえし 赤のグラフとなる 位相も同じ要領でやるだけ
>>薄々感じているんですが日本のインターネット人口減っていってませんか？ インターネット人口が何を指しているのか明確ではありませんね。 ただ、パソコンを使ってネット接続している方が減少しているってことはいえるでしょう。 ちょっと前は、会社の新人がパソコンに詳しくて、上司である４０～５０代のおじさんは、パソコンが使えない（エクセルダメ、メールダメ・・）っていう「パソコン音痴」なんてことがよく言われていたものです。 でも、最近では、新入社員はスマホは使えても、パソコン使えず、エクセルもメールも駄目っていうのが話題になっていますね。 そして、かつてのおじさん世代がパソコンの使い方を新人に教えているというのが話題になっています。 また、日本人のＩＴ能力が世界的に見て低いっていう統計も出ていました。 この原因は、自分専用のＰＣが無い、あるいは自宅にＰＣが無い家庭が多いからだそうです。 最近では、貧乏を売りにしているアイドル女性も増えているといいます。 １０数年前なら、「そんな貧乏な家庭ってないだろう？作り話では？」と思えたような貧乏話も、最近では「貧困家庭が増えたから、そんな極貧家庭もあるだろうなあ」と感じています。 だから、「ＰＣが買えない経済状態の家庭が増えている」その結果として、「ＰＣでインターネットを使っている人口が減っている」ということになっているのでしょう。 それに「経済状況としてＰＣは楽に買えるけど、自分の用途ではＰＣは要らない！」という人たちも増えているように思えます。 ちなみに、最近のＷｅｂ開発では、「モバイルファースト」という言葉をよく目にします。 Ｗｅｂサイトを作成するとき、以前はＰＣユーザの画面サイズを意識したホームページを最初に作って、そのあとにスマホや携帯向けの画面を作成しました。 今は、最初にスマホ向けの画面を作成し、その後でＰＣ向けのホームページを作ることが増えているそうです。
　人工知能は初期のprologとか、Lispなどは、あらかじめ入力して置いた命令やデータを分岐処理で実行出来るだけのもので、知能と呼ぶのにふさわしいものではなかったように思います。 　昨今の人工知能ブームは情報処理能力の拡大で柔軟性が増しただけのもので、本当の人工知能と呼べるものではないと思います。本当の人工知能を使って回路設計をさせると、未知の物理理論を見つけ出して回路設計するので、人間に理解出来ない複雑な回路設計になり、無駄が多いのに、性能が高いという結果になるそうです。 　何でも人工知能で設計させると、性能は良くても、人間に理解出来ない機械ばかりになって、文明が混乱する事態になりませんかね。 　たとえば、パソコンが人工知能で動いていると、毎回同じ動作を繰り返していたら、先を読んで、電源を入れた途端に、繰り返し動作を全て実行してしまうような、賢過ぎるコンピュータになる公算が大きいです。 　何かやろうとしてキイ入力していると、先を読んで目的の処理を実行してしまうなど、何でも見抜いてしまう恐ろしいコンピュータになる可能性もあります。 　こういうコンピュータを相手にしていると、自分はわからないが、コンピュータはみんな知っている感じがするという強迫観念に苦しめられる結果にもなりかねず、実際に、そうなる可能性もあるわけで、人間にも先読みが出来る人が少なくありませんから、コンピュータが先読みを始めたら、厄介な事態になるように思います。 　チェスや将棋でもコンピュータに勝てなくなった人間が、日常生活でもコンピュータに先を読まれてしまったら、面白くない世の中になると思いますよ。
問ア セル(F5)の計算式 =sum(c5:e5)/3 問イ セル(G5)の計算式 =if(f5>=85,"A",if(f5>=75,"B","C")) 問ウ セル(D14)の計算式 =countif(g$5:g$10,c14) 　　↓　列下方へコピー貼りつけ 問エ セル(D15)の計算式 問オ セル(D16)の計算式 　　　
なんちゅーか、基本中の基本で説明したくてもできないほど なんですが。この程度ができないと先行き暗いです・・・。 >2. D列の『参加人数』は次の式で求める >『(男子＋女子)＋2』 問題の書き写し間違いですよね。 『(男子＋女子)×2』ですよね。 ＞問1 セルD5に設定する式 =(B5+C5)*2 ＞問2 セルＥ5に設定する式 =IF(B5>=3,"○","") う～ん・・・簡単すぎて解説のしようが無いです。
　まず専門学校の実態です。専門学校のシラバスのコース分けは、各校で勝手にやってますから、以下のコース名は一般的な話と思って下さい。 　専門学校はビジネススクールです。実際にプログラムを行う製造に直接関わる工程を、下流工程と言います。それに対して設計・企画・業務管理などの管理業務の比重が大きいところが上流工程です。それらに対応して概ねコースは、プログラマー（通称PG），プロジェクトマネージャー（通称PM），ITアーキテクト（通称IA？）に分かれます。 　プログラマー（PG）は現場要員です。単にプログラムを書く技術を身につけたいなら、ここです。ここを出た人は、企業での即戦力になり得ます。逆に大学の情報系を出た人は、プログラムが下手くそだったりします。手を動かした量で能力が決まるからです。ここはそういうところです。 　プロジェクトマネージャー（PM）は、主に業務の工程管理を行います。どんな仕事にも納期があり、IT業界はほとんど人件費で成り立っている世界なので、PMは重要になります。顧客要求のヒアリング、現場意見を吸い上げて顧客への提案・プレゼンもやります。大きな専門学校なら、ヒアリング・提案・プレゼン方法も教えてくれます。 　ITアーキテクト（IA？）という職種は、じつは正式にはありません。PGとPMは正式な資格なので、認定試験があります。ITアーキテクトは、PGとPM両方の素養を持った人材です。現在のソフト開発においては、OSとデータベース・エンジンと開発言語の選択と組み合わせで、工期に大きな違いが出るからです。もちろんその選択は、業務目的（顧客要求）にも適ったものでもなければなりません。 　PG，PM，IAを総称して、一般にはSE（システムエンジニア）と言われますが、これも正式な職種名ではなく、巷に流布しているあだ名です。ちなみに上記は昼間コースです。夜学なら、さらに低レベルでしょう（←怒られそうだが）。 　あなたの目的に適うものは、ありましたか？。 　次に必要な基礎知識ですが、例えばよく目にする業務ソフトに、経理・構造解析・電磁場解析などがあります。ではPG，PM，IAは、これら専門分野の知識があるのかというと、通常は全くありません。それでもそれなりの物が開発されるて来るのも、また事実です。なので極端に言うと、物理も数学も不要です。プログラミング技術さえあれば、開発は可能なんです。もっとも専門知識があるに越した事はないので、自分のような専門分野からの転職組もいます。ただし次のような事は、当然ながらあります。 　開発中のソフトの「取り扱い説明書」や「マニュアル」を上手く書ける能力というのは、ひそかに大事です。いかにわかりやすい文章を書けるかという、国語そのもでなく国語力が試されます。また普通の作文より論理性を求められるので、数学そのもでなく数学力も試されます。 　で、人工知能なんですが、人工知能の工学的定義すらないのが現状ですからね(^^;)。大学のその手の研究室で勝手に定義して、もしくはアヤフヤなままやられてると思います。#4さんの仰るS式やλ計算も、もともとはチャーチ，チューリング，ゲーデル，コーエン辺りから出てきた話で、今では計算理論としてまとめられてますので、やはり大学の、それも数学科辺りというのが普通です（情報系でも教えてるかも知れないが）。 　次の本は、恐らく世界初のプログラミング学に関する成書（教科書）です。恐ろしくお高い本ですが、たぶん大学の図書館にはあると思うので、斜め読みしてみて方向性を検討してみるのはどうですか？。 　　・コンピュータプログラミングの概念・技法・モデル，ピーター・ヴァン・ロイ、セイフ・ヘリディ，翔泳社，2007年．
＞2. D列の『参加人数』は次の式で求める ＞『(男子＋女子)＋2』 (男子 + 女子) × 2 であるように見えます。 ＞問1 セルD5に設定する式 =(B5+C5)*2 ＞問2 セルＥ5に設定する式 =IF(B3>=3,"○","") ＞問3 セルB10に設定する式 =SUM(B5:B9) ＞問4 セルB11に設定する式 =ROUND(B10/5,0) ＞問5 セルB13に設定する式 =MIN(B5:B9)
No,1です。 ご希望の意味、その一例を示します。 (1)の群 ・ABSTRACT：概要 ・ACT：行動 ・AID：助力 ・ALL：すべて ・AWARD：賞 ・BAT：：バット ・BATCH：一組、一束（バッチ処理、リアルタイム処理などコンピュータ分野で良く使われる） ・BALL：ボール ・BILL：：勘定書…（Billing Machine：会計機） ・BLACK：黒 ・CAR：：自動車 ・CASH：現金 ・CAT：猫 ・CATCH：捕獲 ・CHILD：子供 ・CHILL：冷え ・CLASS：階級 ・DASH：突進 ・DART：投げ矢 ・DIRT：不潔物 ・DISH：皿、鉢 ・DRAW：引っ張る、描く（CG用語） ・DRILL：ドリル ・HAIR：髪 ・HALL：ホール（ホテルなどの） ・HALT：停止、休止…アセンブラ言語で使われる ・HATCH：ハッチ（潜水艦などの） ・HILL：丘 ・HIT：一打ち、打撃 ・ILL：病気 ・LAST：最後の、最新の ・LIST：リスト ・PITCH：投球 ・RAW：（行と列）の行 ・SAW：縫う ・SAID：sayの過去形 ・SHALL：I shall～ ・SHIRT：シャツ ・SLIT：裂け目 ・STALL：畜舎 ・STAR：星 ・START：開始 ・TAB：耳おおい（帽子の） ・TALL：背の高い ・THIRD：サード（三塁） ・TILL：～まで ・WATCH：時計…Tが抜けていました。すみません。 ・WALL：壁 ・WAIT：待つ ・WAR：戦争 ・WAS：be動詞の過去形 ・WASH：洗う ・WHICH：どちら ・WILD：野生の ・WILL：I will be～ ・WISH：望む
12.5Hz程度だと考えられる。理由は、シャノンの定理による。ただし、実際にはノイズや精度の面で、シャノンの定理の4倍がサンプル周波数に使われる場合があるので、3.125Hzの場合も考えられる。 シャノンの定理 https://ja.wikipedia.org/wiki/%E6%A8%99%E6%9C%AC%E5%8C%96%E5%AE%9A%E7%90%86
＞１．次の計算式で合っていますか？ 合っています。 ですが、表記が間違っています。 1KB＝1000B ではなく 1kB＝1000B です。 1MB=1000KB=10^6B ではなく 1MB=1000kB=10^6B です。 10進数を元にした「SI接頭辞」では「キロ」は「小文字のｋ」を使う事になっています。 「大文字のK」を書いたら、情報工学の試験では不正解にされます。 ＞２．MiBはメビバイト、GiBはギビバイトですが、TiBはなんと発音するのですか？ 2進接頭辞の発音 KiBキビバイト MiBメビバイト GiBギビバイト TiBテビバイト PiBペビバイト EiBエクスビバイト ZiBゼビバイト YiBヨビバイト SI接頭辞の発音 kBキロバイト（SI接頭辞では「キロ」は「小文字のｋ」を使用する） MBメガバイト GBギガバイト TBテラバイト PBペタバイト EBエクサバイト ZBザタバイト YBヨタバイト
質問のプログラムでは、名前で入力した文字が逆順にはならないですよ。 アルファベットで入力しても、このプログラムではなりません。 下記のプログラムでは「125」～「140」のように、お名前の文字数「LEN(U$)」から、最初の１文字目までを、１文字ずつ取り出しています「MID$(U$,J,1)」。 FOR J = LEN(U$) TO 1 STEP -1で、逆順にしています。例えば、U$が６文字の場合、「LEN(U$)」の値は「６」、STEP -1なので、１つずつ「６」から「１」まで減って行きます。 そして、そのお名前を１文字ずつ、逆順に表示したのち、すなわち、「NEXT J」のあとに「PRINT "さん ";」を置くことで、お名前を出力したのち、「さん 」が出力されます。 10 INPUT "お名前は？: ", U$ 20 PRINT "こんにちは "; U$ ;" さん" 30 INPUT "丸がいくつ欲しいですか？: "; N 35 S$ = "" 40 FOR I = 1 TO N 50 print "○" 55 NEXT I 70 INPUT "もう一度やりますか（Y/N)？ "; A$ 80 IF LEN(A$) = 0 THEN GOTO 70 90 A$ = LEFT$(A$, 1) 100 IF (A$ = "Y") OR (A$ = "y") THEN GOTO 30 110 PRINT "さようなら " 111 INPUT "挨拶はなん回: "; N2 120 FOR I = 1 TO N2 125 FOR J = LEN(U$) TO 1 STEP -1 130 PRINT MID$(U$,J,1); 135 NEXT J 140 PRINT "さん "; 145 NEXT I 150 PRINT 160 PRINT "さようなら" 170 END 以上でどうでしょうか？
1.なぜデータサイエンティストになりたいか？ 2.なぜデータを分析するのか 3.どんなデータを分析したいのか これが無いとあんまりよい回答は出せない。 回答例 1.最近現れた職業でしかも給料がいいらしいからやりたい 2.データを叩いて事実を発見するのが面白いから 3.例えばDNAを分析して生物学の発展に貢献する 例えば金融データを解析して儲けたい 例えば売上情報を分析して企業の販売活動に貢献する。など まず目的と手段をわけないと行けない。 何がしたいのかという目的があって、データ分析が有効になる。 例えばノーベル賞の山中さんは、IPS細胞にスパコンを使ったと言われているが、 山中さんの専門はあくまで生物学でしょ？ 売上の分析をしたいっていうなら商学部かもしれないしね データサイエンスは手段に過ぎない、 目的は無いけれどデータサイエンスという技法を知りたいなら 情報工学、あるいは理学のどちらかだと思う データの割り当てとかメモリーの構成とか、計算するということに関して言えば 情報工学科か電子工学科に行けばまあ勉強はできると思う あと私は個人でデータサイエンティストみたいなことやってるけど、 基本的にデータサイエンスなんて、目的があったとしても無味乾燥でつまんねーものなんだからどうせなら楽しいことやった方がいいぞ
No.1,No.2です。 >右下の"1"のループ作成では縦方向、横方向の任意のどちらかで十分なのだと解釈しておりました。 これだけでは「簡約化された論理式」として十分ではありません。簡約化の式変形の計算途中の式とは言えると思いますが...。 >縦方向、横方向共にループでくくる理由があれば教えていただきたいです。 カルノー図を使う目的は、ドントケアーの１を含め、出来るだけ大きくかつ少ない数のループですべての1を括ることにあり、これによって簡約化された論理式=「より少ない変数からなる積和形の論理式」が得られます。 なお、 カルノー図を使う和積形の簡約化された論理式を求めるやり方もあり、このやり方だとドントケアーの0を含めすべての0をカルノー図上で、出来るだけ大きくかつ少ない数のループですべての0を括ることにより、和積形の簡約化された論理式が得られます。
　プログラムしようとしている対象が、三角関数や微分積分で無ければ、正直、その当たりは必要ありません。 　まぁ、最低限、四則演算と、出来れば、２進数の扱いと論理演算くらいは知っていると後が楽ですね。 　プログラミングに本当に必要なのは、論理的な思考方法です。これを多分、数学センスと言うのでしょう。 　例えば、三平方の定理を覚えていることは、プログラミングにほとんど役に立ちません。でも、三平方の定理をちゃんと証明できる力量があることは、プログラミングに大きく寄与します。 　 　数学の世界では、厳密に定義された言葉の中で、必要とされる知識（定理等）を説明（証明）しようとします。プログラミングも同じなんです。厳密に定義された言葉（プログラミング言語）の中で、自分がコンピューターにして欲しいことを正確に説明する作業なんです。 　よく言われるプログラミングに数学センスが必要というのは、おそらくこの意味です。 　まぁ、自然界・物理現象を数字で表現するためには、数学は必須です。この分野では、三角関数や微分積分は必須知識になりますね。経済・お金を数字で表現するためにも数学は必要ですね。 　コンピューターで仕事をさせるというは、ある意味、自分の仕事を数字で表現する作業にもなりますから、その意味では、コンピューターにさせようとしている仕事に関わる数学の知識は是非とも欲しいところです。数学のどの分野の知識が必要かは、どんな仕事をコンピュータにさせるかによって異なります。
y[n]-2y[n-1]=x[n]-3x[n-1] y[n]=x[n]-3x[n-1]+2y[n-1] これに ｚ変換の線形性と推移定理を用いることで次を得る。 (1-2z^-1)Y(z)=(1-3z^-1)X(z) 伝達関数H(z)は H(z)=Y(z)/X(z)=(1-3z^-1)/(1-2z^-1) =(3/2)-(1/2)/(1-2z^-1) 収束範囲：|2z^-1|<1 ⇒ |z|>2(原点を中心とする半径2の円の4外側) インパルス応答h[n]は伝達関数H(z)を逆z変換すれば得られる。 逆z変換表より h[n]=(3/2)δ[n]-(1/2)2^nu[n]
基本的にはしておいた方がいいでしょう。 内部生より情報が少ないでしょうから内部生が使用している教科書などは見ておく必要があると思います。 シラバスもネットで検索できるのでそこを参考に何冊か教科書になっているものは見ておいて損はないかと
Wolfram document centerを検索するか(下記URL参照のこと)、以下のようにFullFormの出力を読むか、でしょうね。 p && q || r % // FullForm
>1.信号を整数倍した時の振幅スペクトル，位相スペクトル． 信号の何を整数倍するの？ 振幅それとも周波数 >2.異なる2信号を足した時の振幅スペクトル，位相スペクトル． 何が異なる２信号なの？ 位相、振幅、周波数？ >3.信号を時間軸方向に移動したときの振幅スペクトル，位相スペクトル． 時間軸方向に移動すると、何が変わると思います？
> printf("%s %s %ld\n",a[i].name,a[i].crops,a[i].pct); 「%ld」は符号あり倍精度整数の書式指定です。 「%lu」で表示してみて下さい。
こんにちわ。 プログラムの実行によりどのような出力を得たいのでしょうか？ "Tが文字列中の何番目に出現しているか"という理解で宜しければ以下のように、 str2の先頭アドレスを別にもっておいてアドレスの差で計算できるかと思います。 void sea(const char*str2,int*c){ char *p; char *q = str2; while(*p!='\0'){ p=strchr(str2,*c); printf("%d\n",p-q); str2=p+1; } } -- 0 3 4 20
ネットワークアドレス 173.168.0.0 ブロードキャストアドレス 173.168.1.255 ユーザアドレスについては固定IPアドレスが割り振られている173.168.0.64ということではないでしょうか
　お考えの、DRAM、フラッシュメモリといったものは、コンピュータのメモリとして、直接にアクセスされるものを指しているようですね。以下、メモリと呼ぶことにします。 　メモリはアクセスされるときに、まずアドレスを指定して、続いて読む・書くという動作を行います。 　メモリ（上限）の増え方が2倍則であるのは、アドレス指定と一度に扱えるデータのビット数によるものです。 　例えば、8bitでアドレス指定できる場合、メモリのアドレスは16進で00～FF（10進で255）になります。そのアドレスに対し、8bitのデータを扱えるわけです。最大のメモリを扱いたいなら、データは8bitごとにアクセスするようにすればよいわけです。 　8bitコンピュータ（CPU）の8080ですと、データは8bit、アドレスは16bit扱える設計になっていました。16bit個分（4096個分）の8bit（10進数で16）ですから、65536バイトまで扱えていて、1K＝1024バイト換算で、64Kバイトと呼ばれていました。 　同様に、16bitコンピュータになるとデータ・アドレスのbit数が増え、メモリの上限が16倍の1024Kバイト＝1Mバイトになりました。以降、コンピュータのbit数が増えると、データとアドレス指定のbit数増加に従って、メモリの上限が2倍則的な増え方になっていきました。2進数で直接的に管理するから、2倍則的になるわけですね。 　一方、ハードディスクは外部記憶装置です。コンピュータから直接にアドレス指定はしません。また、ハードディスクのデータを直接扱うのではなく、コンピュータのメモリにいったんデータを転送します。ハードディスクごとに違いますが、例えば1Kバイト単位で区切ってデータを保持します。区切られた領域を「セクタ」と呼びます。 　区切り方、区切られた領域の管理方法は割愛しますが、区切られた各領域である「セクタ」に番号を振って、コンピュータが番号を渡せば、ハードディスクはその番号に割り当てられたディスク内の領域のデータをコンピュータに渡します。 　この方法だと、2進数による束縛を受けません。コンピュータが16bitだとして、4096個のセクタを直接指定するとしても、1セクタを何バイトにするかは自由に決められます。あるいは、セクタ番号を32bitに拡張しておいて、16bitずつ2回に分けてセクタ番号を指定してもよいです。いろいろ自由にできるわけですね。 　このため、ハードディスクにどれだけデータを保持できるかという技術的な限界が、ハードディスク容量の限界になります。金属ディスクの磁気的な密度をどれだけ高められるか、などですね。ですのでコンピュータのbit数はハードディスクに関係しておらず、コンピュータのメモリに現われるような2倍則的な上限にはならないわけです。
とりあえず、問題の意味はわかりますか？ 私は問題の説明があまり良いとは思いませんでした。 変数がアバウトすぎる。 変数と言うだけなら、どんな値も取ることは出来るが、プログラム中でどのように使っているかも場合によるから。 CGIの話をしているから、出題者はユーザー入力に対する結果の話を言いたいのかもしれない。 でも、その変数がユーザー入力の影響を受けるものとは限らないし、問題に書いていない。 だから、前提条件としては問題に含めるべきですね。 まぁ、多分そう言う問題なのだろうから、回答の最初に、 『ここで言う変数をユーザー入力により自由な値を許すものとすると』 と言う下りで回答してやれば良い。 問題に不備があると伝わるし、回答としても正解と言える。
添付画像の画質がボケててよく見えず問題がわからず、解答できません。
　その2ですね。今度は「双対」という意味が分からない？ 　ちゃんと式でも示してあるので、それに従うのが正確でしょう。「Ａ」「Ｂ」「Ｃ」を各々「not」にして、得られる結果を全て「0と1を反転」させればよいのです。 　「ベイチ図」で、「Ａ」（上段）の代わりに「notＡ」（下段）を、「Ｂ」（左2列）の代わりに「notＢ」（右2列）を、「Ｃ」（中央2列）の代わりに「notＣ」（外側2列）を、各々使えばよいのです。 　さらに、この「ベイチ図」の全項目の0と1を反転させます。 　それで、論理式を導き出せばよいのです。 　「ベイチ図」の1の欄は2つだけになりますから、2つの項で表わせますね。 　さらに、問題文の前半から、「ベイチ図」を「Ａ」「Ｂ」「Ｃ」を使って表わした論理式も、「notＡ」「notＢ」「notＣ」を使って表わした論理式も、同じ「ベイチ図」を表わせば等価である、ということが分かれば、単純に「ベイチ図の全項目の0と1を反転させたもの」を「Ａ」「Ｂ」「Ｃ」を使って表わした論理式で良いことが分かります。 　答は「１」ですが、「選択肢から選ぶ」のではなく、ご自分で「ベイチ図から論理式を書いてみる」ことにチャレンジしてみてください。
　No.1です。「補足」に書かれたことについて。 ＞リンク先の資料で(A,B,C)=(1,0,1)が　1の場合は ＞4項(上段)を1項に=A ＞2項(左から２つ目の列)を1項に=BCにより ＞A+BC ＞になることがわかりましたが、 ＞(A,B,C)=(1,0,1)が0の場合がよくわかりませんでした。 ＞ABC'+ABC+AB'C'+A'BC ＞=(C+C')AB+AB'C'+A'BC ＞=AB+AB'C'+A'BC ＞となり正解であろうA+BCにもっていけません。 　やってみましょう。 （１）(A,B,C)=(1,0,1)が　1の場合は、おっしゃるとおり 　上段の４つの「１」は、「=A」 　残る下段左から2番目は、「=BC」で表わされますね。 （２）(A,B,C)=(1,0,1)が　0の場合は、「ベイチ図」から 　左から2列目の上下は、「=BC」 　上段の両端は、「=AC'」で表わされますね。 （３）つまり、(A,B,C)=(1,0,1)が　０でも　1でもよいということは、（１）＋（２）ということで、 　　　A + BC + BC + AC' ということになります。ここで、「BC + BC = BC」だし、「A + AC' = A」ですよね。 　よって、最終的な論理式は、 　　　A + BC ということです。 　つまり、「０でも　1でもよい」ところは、「１」としてベイチ図なり論理式を作ればよい、ということです。これを「0」にしたのでは、「前問5の答」と同じですから、何も変わりません。 （４）念のため、問5の答「z=ABC+AB'C'+ABC'+A'BC」から出発してみましょう。 　(A,B,C)=(1,0,1)が　０でも　1でもよいということは、「AB'C」が「+」(OR)で追加になるということです。 　そうすると、zは 　　ABC+AB'C'+ABC'+A'BC　+AB'C 　＝AB(C+C') + AB'(C+C') +A'BC 　＝AB + AB' +A'BC　　←C+C'=1 なので 　＝A(B+B') +A'BC 　＝A +A'BC　　←B+B'=1 なので 　＝A +ABC +A'BC　　←A +ABC=A なので 　＝A + (A+A')BC 　＝A + BC になります。
　なにしろ数字と言うのは順番に並んでいるのですから表を覚える必要はなく数字の増え方を知るだけで済みます。二進数の増え方は下の桁が1から0に下がるたびに上の桁が変化すると言う仕組みの連結です。
http://www.biwako.shiga-u.ac.jp/sensei/mnaka/ut/binarydigit.html >>２進数の一桁 ２進数。 なので、「０」か「１」で、 一桁。 なので、数字ひとつ分。ということです。
if((fp=fopen("sample.txt","a"))==NULL){ で、アーカイブモードでの追記書き込みとして sample.txt を開いた後、キーボード入力した値を sample.txt に書き込んでいるだけで、ファイル内での位置はどんどん先に進んでいるまま、 i=0; while(i<3){ の前では、sample.txt を "r" (読み出しモード) で開き直していないとともに、ファイル内での位置はキーボード入力の内容を書き込んだ後の「まだ存在しない部分」を指しているままで、 ファイルの先頭から読み書きし直すためには、fseek() 関数で fp を「先頭」に戻すパラメータを指定するか、rewind() 関数で fp を先頭に巻き戻すことが必要です。 一番簡単なのは、sample.txt を書き出し終わったら、一旦 fclose() してしまい、sample.txt を読みだすために fopen() し直すほうがスッキリします。
　全てのプログラミング言語の純粋なリファレンスマニュアルは、結局次の5項目です。 (1)四則演算(＋，－，＊，／) (2)ループ構造（N88では、For Next Loopなど） (3)2値条件分岐（N88では、If then ElseIf Else End If） (4)配列確保 (5)ユーザー定義型（クラス定義など） 　これらがどんな言語でも同一なのは、これらはCPUとコンパイラーの基本機能だからです。CPUとコンパイラーは、実はこれらの事しか出来ません。 　今回の件では、せいぜい(1)～(3)くらいしか使わないんじゃないですか？。であれば(1)～(3)についてCとN88BASICのマニュアルを読み、これらの構文に対応を付ければ、Cのプログラムから逐語的にN88BASICへ移植可能なはずです。 　・・・でもWindowsN88BASICって、あるんですね。どっかで聞いたような気もしましたが・・・。自分が使用してたのはNECのPC98時代に搭載されてた、N88BASICでした。 　当時のOSはDOSでしたが、その時の経験で言うとN88BASICは、N88BASIC用のOS込みのシステムなんですよ（つまりDOSですらない）。使った事がないので憶測ですが、もしかするとWindowsN88BASICもWindowsと言いながら、起動した途端に完全にWindowsから切り離され（真っ黒な画面になったりして(^^;)）、そこで戸惑ってるのかな？、とも思いました。 　もしそうであれば、IT関連の板できく方が早いです。
反省・・・って、技術的に言えば「フィードバック回路」 「フィードバック処理」ってやつで、これ、かなり昔から 「当たり前の処理」として技術やは使ってますよ。 つか、半分「爺さん」に足を突っ込んでる私でも、大学 時代の「人工知能」の卒論で、フィードバックを課題に 選んでたくらいですから、いまさら言わなくてもある意味 「当たり前」の話なんですけどね・・・。
現在は規定が整備されているので、Shift-JISでもEUC-JPでもUTF-8でもメールに使用する事は可能です。 かつては、メール本文に使えるのが7bitのASCII文字だけだったため、Shift-JISを使用すると8bit目が1になる文字が出現するので使えませんでした。 そこで8bit目が0だけで表現できるJISコードをベースにISO-2022-JPが整備され使われるようになりました。 その後多言語でメールが利用されるようになったので、あらゆる文字コードで本文が書かれても大丈夫なように、文字コードの指定方法（宣言方法）等がルールとして整備されています。 文字コードの特徴と言う事であれば、JISコード、Shift-JISは日本語のみ表現できるコード。 EUC-JPはUnix系OSで日本語を扱うために作られた文字コードで、基本的には日本語のみ表現できるモノで利用されている範囲は案外と狭い。 UTF-8(Unicode)は世界中の言語を一つのコード体系で表現することを目的に作られたモノで、一つの文章の中にあらゆる言語を表示できることが特徴ですかね。
#include<stdio.h> #include<stdlib.h> int main (void){ char st[100]; printf("数字列を入力してください。"); scanf("%s",st); printf("%lf %d %ld\n",atof(st),atoi(st),atol(st) ); return(0); }
キミの暗号コードで「110110110001001000」を復号してみよう。瞬時だから、 q_1,q_2,q_3,q_1,??,q_2,?,q_2,???とでもなるのかな。それとも、???。q_1,q_2,…,q_6なんてとてもならない。うまく復号できそうもないと思いませんか。
祭りと聞いて真っ先に思い浮かんだのは 子供の頃に、子供会や町内会で行われた秋の収穫祭ですね 子供みこしや獅子舞が町内を練り歩き ご祝儀を集めて回りました 神社の境内で餅投げが行われて お餅の袋に入っている抽選クジがとても楽しみでした お祭りの日は、夕食も少し豪華だった事を覚えています 子供の頃はお祭りの意味なんて考えた事もありませんでしたが 今思えば、こんな風習も 子供の心を育てる物だったのではないか？　と思いますね
factrical(100)はintでは表現できません。 今のようなアルゴリズムを使うのなら、任意精度の計算が出来るようなライブラリを使用してください。
>53.8(10進数)を2進数(小数9位まで)に変換するには 整数部「53.」と小数部「0.8」に分けてそれぞれを変換します。 整数部 53.=52+1=26*2+1=(13*2+0)*2+1=((6*2+1)*2+0)*2+1 =(((3*2+0)*2+1)*2+0)*2+1 =((((1*2+1)*2+0)*2+1)*2+0)*2+1 =1*2^5+1*2^4+0*2^3+1*2^2+0*2^1+1*2^0 =110101.(2進数) すなわち ２で割った余りを並べたものになります。 2)53 2)26 ... 1(LSB) 2)13 ... 0 2)6 ... 1 2)3 ... 0 2)1 ... 1 ... 1(MSB) MSBからLSBまで並べれば53の２進変換した「110101」が得られます。 小数部 0.8 小数部を２倍して繰り上がる整数部を並べれば小数部の２進変換値がえられる。 0.8*2=1.6=整数部1+小数部0.6　→ .1 ...(※1) 0.6*2=1.2=整数部1+小数部0.2　→ .11 0.2*2=0.4=整数部0+小数部0.4　→ .110 0.4*2=0.8=整数部0+小数部0.8　→ .1100 0.8*2=1.6=整数部1+小数部0.6　→ .11001 ここからの計算は(※1)からの繰り返しなので ２進の桁のパターン「1100」の繰り返しになる。 0.8=0.110011001100 ... (2進数) 小数第９位までで打ち切ると 0.8=0.110011001（2進数） 整数部をあわせると 53.8=110101.+0.110011001=110101.110011001 (2進数) ...(答) >8進数(小数5位まで) 53.8の２進変換した 110101.110011001 を 小数点を中心に３桁で区切って |110|101|.|110|011|001| 区切った３桁の２進数を８進数に変換してならべると8進変換値 65.631(8進法） ... (答) が得られます。 >16進数(小数5位まで) 53.8の２進変換した 110101.11001100110011001100 を 小数点を中心に4桁で区切って 11|0101|.|1100|1100|1100|1100|1100| 先頭に00を補って |0011|0101|.|1100|1100|1100|1100|1100| 区切った4桁の２進数をそれぞれ16進数に変換してならべると16進変換値 35.CCCCC (16進法） ... (答) が得られます。
大学も高等学校と同様に学問を教えます。しかし高校と違って研究機関です。何を勉強をするかより、どんな研究をするかを想定しながら選びましょう。 研究は積み重ねです。独力では、在学中にまともな成果を出すことは難しいです。指導教官の知見、研究室の設備、蓄積された成果物の助けを受けることになるでしょう。 それを踏まえた上で、自分の役に立つ資源が、一番たくさんありそうな大学を選べば良いと思います。例えば下のような要領で。 ・その大学の研究室を洗い出す。 　関心が持てそうな研究室を対象に。 ・次に、それぞれの研究室の指導教官、その業績を調べる。 ・その指導教官が著者に入っている論文をリストアップする。 　とくに筆頭著者、査読付き、最近の論文を重視して。 ・各論文の概要（抄録）を拾い読みする。 　論文のタイトルや著者名で検索して、論文を探す。 　IT系の論文の抄録なら、比較的にネットで見つけやすいはず。 ・指導教官が出願した特許の内容や件数も参考になるでしょう。
nxが初期化されていないからでしょう。
緯度経度でｇｏｏｇｌｅマップを参照するようにしたら普通に出来そうに思います。
　どの程度が「最先端」なのでしょうか。 　とりあえず、現時点での技術はこんな書籍でご確認ください。 http://www.amazon.co.jp/%E8%AA%A4%E3%82%8A%E8%A8%82%E6%AD%A3%E6%8A%80%E8%A1%93%E3%81%AE%E5%9F%BA%E7%A4%8E-%E5%92%8C%E7%94%B0%E5%B1%B1-%E6%AD%A3/dp/4627817312/ref=pd_sim_b_2?ie=UTF8&refRID=10EZW9K220KRQEMAQ48W http://www.amazon.co.jp/%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E7%AC%A6%E5%8F%B7%E5%8C%96%E6%8A%80%E8%A1%93%E3%81%A8%E8%AA%A4%E3%82%8A%E8%A8%82%E6%AD%A3%E3%81%AE%E5%9F%BA%E7%A4%8E%E2%80%95%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E7%AC%A6%E5%8F%B7-%E7%95%B3%E3%81%BF%E8%BE%BC%E3%81%BF%E7%AC%A6%E5%8F%B7-%E3%82%BF%E3%83%BC%E3%83%9C%E7%AC%A6%E5%8F%B7%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B-RF%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%BB%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E8%A5%BF%E6%9D%91/dp/4789846407/ref=pd_sim_b_3?ie=UTF8&refRID=1P934Q69TN7PF5EWHVJW http://www.amazon.co.jp/%E8%AA%A4%E3%82%8A%E8%A8%82%E6%AD%A3%E7%AC%A6%E5%8F%B7%E5%85%A5%E9%96%80-J-%E3%83%A6%E3%82%B9%E3%83%86%E3%82%BB%E3%83%B3/dp/4627817118/ref=pd_sim_b_3?ie=UTF8&refRID=12GQ00FF4Z0HWVBM26R6
やりたいことはこうじゃないの？ int x[2][2] = { { 1, 3 }, { 2, 4 } }; int y[2][1] = { { 3 }, { 2 } }; int xy[2][1]; int i, j, k; for (i = 0; i < 2; i++) { for (j = 0; j < 1; j++) { xy[i][j] = 0; for (k = 0; k < 2; k++) { xy[i][j] += x[i][k] * y[k][j]; } } }
衛星－地上間で光通信って、出来るんでしょうか。天候と言うか大気の擾乱の影響をかなり受けるように思います。特に地上からのリンクも光でやるなら衛星側のシステム構築も大変だろうなぁ・・・。 (1)いきなり衛星光通信の勉強から入っていいものか？ 衛星光通信を使う側なのか、衛星光通信を運用する側なのかによって、知識範囲は大きく異なるでしょうね。使う側からであれば、いきなり衛星光通信から初めて必要に応じて広げていけば構わないと思います。 (2)通信自体のことを基礎から学ぶとして、おすすめの本・サイトはあるか？ 　http://jp.fujitsu.com/group/labs/techinfo/techguide/list/photonic-networks.html など、光通信の概念を紹介するサイトは多数あります。 もしもLLCD・LCRD両計画等の関係者として地上との通信に関わるなんてのであれば、ソフト部分担当かメカ部分担当かという違いでも必要となる知識にかなりの開きがあるでしょう。 ソフト系なら通信プロトコルはもちろん、ファイアウォールや暗号化技術、通信エラーの誤り検出方法なんて通信一般の知識も必須でしょう。それから気象にも多少通じていた方がいいと思います。いきなり標準大気モデルの構築なんて言われても困りますよね。 メカ系なら数学とプログラミングや画像処理といったソフト知識、それから試験評価のための手法や各種測定器の使い方なんかも必要。 自分で理解できるとっつきやすいところから始めて、知識を広げていくと良いでしょう。 (3)衛星光通信を学ぶのにおすすめの本・サイトはあるか？ 確かまだロクに運用されていないですから、専門の本を発売しても読者がいないでしょう(^^; JAXA関連で論文をあたるくらい、しかもほぼ英文論文ではないかと・・・。 単なる光通信だけなら子供の実験でもできます。 　http://www.aichi-c.ed.jp/contents/rika/koutou/buturi/bu6/hikaritusin/hikaritusin.htm など。 以上、ほとんど回答になっておらず、済みません。
KEIS050162 さんの回答で全く正しいのですが、 Cプログラミングを教えている者の老婆心ということで、参考まで。 １．配列の要素数を求めるのは、配列の型を書き換えた場合を考慮して 　　sizeof(第1要素)で割るのが推奨されてます。 ２．pow(x,y) は、実際は e^（y* log x） なる式を使って計算されますので、 　　yが実数である場合以外は勧められません。整数乗は素直にかけ算を使いましょう。 　　powは精度と計算時間で不利です。ただし、この程度の問題では差は出ませんが… ３．データの和と二乗の和を一緒に求めて、 　　分散＝（二乗の和)の平均 ー （平均）の二乗 　　という式でも求められます。 ------------------------ #include <stdio.h> int main(void) { int dat[] = {44, 100, 63, 99, 25, 47, 96, 42, 70, 100, 25, 80, 98, 49, 9, 46, 92, 65, 57, 50, 55, 95, 33, 7, 5, 56, 3, 25, 85, 96}; int i, nm = sizeof(dat) / sizeof(dat[0]); //これが定石 double ave =0.0 , var = 0.0; for ( i = 0; i < nm ; i++ ) { ave = ave+dat[i]; var = var+dat[i]*dat[i]; //二乗は単にかけ算を } ave = ave / nm; var= var/nm - ave*ave; //二乗和の平均ー平均の二乗 printf( "Average = %f Variance =%f\n",ave, var); } 実行結果はもちろんKEIS050162 さんのと同じになります。 Average = 57.233333 Variance =974.645556
a = 0; 　aに０を代入する。 for( i = 0; i < 10; i++ ){ 　iに初期値０を代入。 　iを１づつ加算し、iが初期値０から９（１０未満の整数）になるまで　｛ ｝内を繰り返す。（※） for( k = 1; k < 100; k = k + 2 ){ 　kに初期値１を代入。 　kを２づつ加算し、kが初期値1から99（100未満の整数）になるまで　｛ ｝内を繰り返す。（※） a = a + i; 　ａに１を加える。 } 　kのfor文の折り返し地点 } 　iのfor文の折り返し地点 document.write( a ); 　a を出力する。 （※）補足 for文がネストになっている点のみがポイントです。for文のネストは下記が参考になります。 http://www1.bbiq.jp/takeharu/java37.html
　ご質問の内容が正しいとすると、単純にそのまま計算すればよろしいのでは。 　ピクセル数は 　　　40 × 30 = 1200（ピクセル） 　１ピクセルあたり、24 ビット＝3 バイト　ですから、 　　　1200 × 3 = 3600 （バイト） ということになります。 　ただし、写真が「４０ピクセル×３０ピクセル」ということはあり得ないので、何か条件を取り違えていませんか？
　Excelのグラフを2つ重ねる事は、恐らくできません（少なくとも自分は、やった事がない）。 　pHjump付近という事なので、目盛りを0.01に設定したいのはy軸のほうですか？。もしもそうなら、pHjump付近のデータだけ、基本グラフと別の系列として同じグラフに読ませ、y軸を「第2軸」に設定するという方法はあります。 　「第2軸」の目盛りはデフォルトでグラフの右側に現れので、実質2つのグラフを重ねたのと同じです。 　あと、対数目盛を試すのも、悪くないかもしれません。
たとえば、参照 URL みたいなこと？ 　
離散的な数値を基に算出基に算出しているというところまではわかったのですが ★回答 離散的な数値を基に算出しているのは　デジタルコンピューターで アナログ信号をデジタル処理するためであり　　みなおなじ デジタル信号処理で実現するためである（DSP　マイコン　その他電算機みな同じ） (1)音声に合わられるどのような特徴に着目して分析を行っているのでしょうか。 音声合成が 声門における音源と声道を伝達関数モデルとして表現し 声道における共振特性を表現するディジタルフィルタを構成し インパルス系列や白色雑音で近似した音源波形を入力することによって 音声生成を実現する手法なので 声道をモデル化するため．声道における共振すなわちフォルマントを なるべく簡素に　精度よく　抽出することに着目していると思われる 有益な　回路モデルとして格子型デジタルフィルターなどがある 音声・オーディオ符号化の基本技術を考慮した抽出分析が　一番有効なのでは？ (2)また分析次数はどのような意味を持つのでしょうか。 分析次数は　その精度を上げるには高いほうがよいが その伝達関数の簡素化をするには簡単なほうがいい よって次数は目的の精度の範囲でなるべく小さいほうがいい デジタルフィルタ設計と同じで　メモリーと積和演算回数は DSPハード　ソフトのため少ないほうがいい ・・・・・・・・・・・・以上・・・・・・・・・・・・・・・・・・・ 以上と思われる・・・・・※注意　ただし私は音声分析の専門化ではない ★回答　　詳しくは　以下で見ればよい 近頃は本買わないでもOK　　ただで見れちゃうわけ　　　電子通信学会　知識の森でみれちゃうわけ http://www.ieice-hbkb.org/portal/doc_514.html 2群7編　音声認識と合成 2群8編　音声・オーディオ符号化
シフトしてオーバーフローした場合は、コンピュータ内部においては演算結果が反映されているのでしょうか？ 演算結果が反映されているか？ ★回答　工学的に人為的に製作者により決定される 製作された言語　アプリ　の仕様で決まるのが正解である メーカー　によりちがう 仕様どうり　コンピュータ内部においては演算結果が反映されている ★回答　説明 演算結果を制限するものは　以下であり　ソフトでそれを解消して仕様を決める (1)デジタルコンピューター（マイコン　DSP　その他全部）のレジスターの仕様　メモリー仕様 (2)そのデジタルコンピューター上で走らせるソフト　アプリ 任意多倍長計算が可能なのもあるわけ 商用の数式処理システムとしては Maple や Mathematica　その他が可能 言語はその仕様に有効数字が記載されてる (3)アプリは　言語アプリで作成されるのでその仕様で決まる 言語はその仕様に有効数字が記載されてる アセンブラは　マシン語　に近い仕様がほとんどだ ※注意　ちゃんとマニュアルに書いてあるはずだ ★推定法は以下でOK たとえば　仮数部は 0.5^推定有効bit数-1　を計算させてみると　言語仕様は推定可能 -1が出たらそこが限界だ たとえば49bitで -0.999999999999998000000000000000 たとえば50bitで -0.999999999999999000000000000000 たとえば51bitで -1.000000000000000000000000000000 となる　たとえばエクセルはそうなる
2倍で1ビット左シフトする。 42倍=32倍+8倍+2倍 2倍　(b1　b0　0)2 4倍　(b1　b0　0　0)2 8倍　(b1　b0　0　0　0)2 16倍 32倍　(b1　b0　0　0　0　0　0)2 42倍　(b1　b0　b1　b0　b1　b0　0)2 か。
方向性もなにも、 [ 1*1,1*2,1*3 ... 9*9 を計算して、二次元配列の適当なところに代入する ] ってだけになりますが。 > 結果確認はmainで上記関数を呼び出して結果を表示 ということだから、main関数は int k[9][9] ; /* 9x9の二次元配列 */ /* その他準備 */ kuku_make(k) /* ここで、二次元配列kに9x9の結果が入る */ /* kの内容を出力 */ となります。 ここまではポインタ以前の問題です。 C言語で注意する点は int k[9][9] と宣言したら、 k[9][9]=9*9 ; とは使えない、という点です。
それで、どこがわからないのですか? この問題に必要となるのは次のものです。 ○全体の流れ → 「日付1と日付2の入力,妥当性チェック,結果出力はmainで」とあるのですから ・日付の入力 ・妥当性のチェック→妥当でないときのエラー処理 ・日付の比較( date_comp関数を使う) →結果の出力 というのがmain 関数の構成になります。 ○ ユーザー定義関数の定義、宣言のやり方と、実際の使い方 → 参考書に載っているはずです。復習しましょう。 ○日付の比較 → この部分は「自分で考える」ところです。 日付1 > 日付2 とは、y1,m1,d1,y2,m2,d2 がそれぞれどんな関係にあるときか、 日付1 = 日付2 とは、y1,m1,d1,y2,m2,d2 がそれぞれどんな関係にあるときか、 考えてみましょう。 = の方は簡単にわかると思います。 /* 別解として、 time.h にあるライブラリ関数を使う方法があります */ ○妥当性チェック → ここも、「自分で考える」ところです。 「2014年13月-45日」等という有り得ない日付だったら、なんらかの処理をする、というものです。 カレンダーについての知識が必要です。うるう年のチェックも必要です。
データをスクリプト中に入れましたが、 csvファイルから読み込むことも可能です。 それくらいは、ご存知ですよね。 Rのバイ・プロットは、記号表示となり、 私は好きではありませんが、 下記のようにすれば、できます。 コピペして動作を確認してみて下さい。 # テストデータによる主成分分析 dat <- data.frame( matrix(c( 3,4,1,4,1,4,1,1,2,2,4,2,2, 3,3,3,3,3,3,3,1,3,3,3,3,3, 1,4,5,3,1,1,1,1,1,1,1,1,1, 3,1,3,1,1,2,2,2,4,4,3,4,2, 3,3,3,4,3,3,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,3,3,3,3,3, 4,4,4,4,4,4,3,3,2,2,2,2,2, 4,3,4,3,2,2,2,2,3,3,2,2,2, 3,4,4,4,1,3,3,2,2,2,2,3,3, 3,3,3,3,3,3,4,3,2,2,2,3,3, 3,3,2,4,4,3,2,2,3,2,2,2,2, 3,2,3,3,3,2,3,3,4,3,3,2,3, 4,4,4,4,4,3,3,3,2,2,2,2,2, 3,4,4,4,2,3,3,3,3,3,2,2,3, 3,3,3,3,3,3,3,3,3,3,3,3,3, 3,4,4,3,3,3,3,3,3,3,3,3,3, 3,4,4,4,4,4,3,3,3,3,3,3,4, 3,3,3,3,3,3,3,3,3,3,3,3,3, 3,3,4,3,3,3,2,1,2,2,2,2,2, 3,5,1,5,1,5,1,1,1,1,1,1,1, 3,3,2,2,2,2,2,2,2,2,4,2,4) ,ncol=13,nrow=21,byrow=T) ) names(dat)=c("F","G","H","I","J","K","L","M","N","O","P","Q","R") dat result1 <- prcomp(dat,scale=TRUE) biplot(result1)
　先日、初めてベイズ理論の小話を知ったばかりなので説明はできませんが・・・。 　こういうページでなんとか。 ＞初めてのベイズ学習 ＞http://watanabe-www.math.dis.titech.ac.jp/users/swatanab/Bayestheory.html
vbaの基礎はできているのですか。 要するにプログラムのメインの部分は dim FIB(1000) FIB(1)=1 : FIB(2)=1 for N=2 to 100 : FIB(N)=FIB(N-1)+FIB(N-2) : next N あとは手続的な話だけでしょう。
早稲田大学 https://www.wsl.waseda.jp/syllabus/JAA101.php 大阪大学 https://koan.osaka-u.ac.jp/syllabus_ex/campus 中央大学 http://syllabus.chuo‒u.ac.jp/syllabus/ 千葉大学 http://www.chiba-u.ac.jp/student/syllabus/index.html シラバス・データベース http://www.syllabus-db.com/index.html 最近はシラバスを公開している大学も多いですね。
「式を変形して求めよ」と言われているのでは無いのですから、別の方法で求めればいいのでは。 例えば ・正攻法: カルノー図を書く。 4変数までなら、下手に計算しているより早いかと。 ・ちょっと試験対策的: 　選択肢があるのですから、そこから明らかに非該当のものを消していきます。 　数が減ったら、真理値表を書いて比べます。 　(4)は全ての項でA,B,C全て使っているのですから、X=1の数と項の数が一致するはずです。 　が、実際には一致しないので、明らかに違います。 　(1),(2) はともに ACを含みますが、 AC = ABC + A(notB)C であることを考えれば、A(notB)C=0となるXとは一致しません。 　以下、同様に考えていくと、5だけが残ります。 　あとは、実際に正しいかを、真理値表を書いて検算します。
> UNIX時刻の起点である1970/01/01 00:00:00をTAI(1958/01/01 00:00:00からの秒数)に換算したらいくつなのか 1972/01/01 00:00:00(UTC)は1972/01/01 00:00:10(TAI)です。1958/01/01 00:00:00からの秒数でいえば441,763,210秒です。 UNIX時刻の基点は，単純にはここから2年=730日=63,072,000秒だけさかのぼればいいはずですが，このころのTAIの1秒はUTCでの1.0000000300秒と決められていました。さらに1972/01/01 00:00:00(UTC)になる直前の時点で特別に(TAI秒で)0.107758秒だけUTCを遅らせたという事情がありました。 したがって1970/01/01 00:00:00(旧UTC。1971年末までは旧UTCです)には，1972/01/01 00:00:00(UTC)から63072000*1.00000003+0.107758=63,072,001.999918秒だけさかのぼらねばなりません。 UNIX時刻の基点1970/01/01 00:00:00(旧UTC)は441,763,210-63,072,001.999918=378,691,208.000082秒(TAI)ということになります。 もし，もっと前の時刻までさかのぼりたければ http://ja.wikipedia.org/wiki/%E5%8D%94%E5%AE%9A%E4%B8%96%E7%95%8C%E6%99%82 の旧協定世界時の周波数オフセットとステップ調整という表に周波数オフセットとステップ調整が載っています。この表を使って1961年初までさかのぼれば1961/01/01 00:00:00(旧UTC)は1961/01/01 00:00:01.422818(TAI)=94,694,401.422818秒であることが確認できるでしょう。 周波数オフセットの数値がTAIの1秒がUTCでの何秒に相当するかを示しており，ステップ調整はそれが挿入された時点で旧UTC時刻がジャンプしたことを示しています。
変数 my が double なので、scanf() で対応する書式指定子は "%lf" になります。 scanf("%lf", &my); ※ちなみに、printf() における double に対応する書式指定子は、"%f" です。 そもそも、hiroko() という関数が何をしているか説明できますか？ あと、４人の身長が int なのに、自分の身長だけ double なのはなぜか、説明できますか？
printf("文字列を入力してください："); scanf("%s", str); ch = 'h'; printf("%cは%d個ありました。\n", ch, str_chnum(str, ch)); ch = 'o'; printf("%cは%d個ありました。\n", ch, str_chnum(str, ch)); ch = 'g'; printf("%cは%d個ありました。\n", ch, str_chnum(str, ch)); ch = 'e'; printf("%cは%d個ありました。\n", ch, str_chnum(str, ch)); でいいのではないですか？ 個人的には…str_chnum()の戻り値の型がcharだったり、第２引数の型がintなのがちょっとなぁ…とは思いますが。 # 環境によっては正しく動作しないかも知れない。 # charがsignedになるのか、unsignedになるのか…とか。
16進数587FC0B4を2進数で表して 1011000011111111100000010110100 ということですが、先頭に0が1つ足りないのでは？ 見当違いならごめんなさい。
○CSVファイル、というのは、通常は、Comma Separated Values の名前の通り、「カンマ(,)で区切られたデータ」になっています。 そのfscanfの書式を見ると、 「整数(読み飛ばす) 空白 数値(読み込む) 」となっているファイルを読もうとしています。 どちらが正しいのでしょうか? 空白区切りが正しいのなら「CSV」などと誤った名前を使わないようにしましょう。 カンマ区切りが正しいのなら、fscanfの書式を正しいものにしましょう。 ○ あるいは、もっと他の方法を探しましょう。 「C言語を使わなければならない積極的な理由」が無ければ、他の方法を使った方がはるかに楽です。 例えば、そのままエクセルを使って、 C1: =B1+B1 C2: =C1*(B2-C3) ... とでもやれば済むことです。 で気付いたのですが > w[i] = w[i - 1] *(r[i]-w[i + 1]); この時点で、w[i+1]には何も入っていません。C言語の場合、このような場合に、どんな値になっているか、わかりません。 (デバッグモードでは0に初期化されていることもありますが) 計算式、または計算順番を間違えていませんか? ○ここでは ・質問が解決したら締め切る ・続きの質問を投稿する前に、前の質問は締め切る というルールになっています。過去の質問は適切に処理しましょう。
ファイルから読み込んだ文字列情報を 文字列を区切り文字で分解する関数、strtok関数で分解しましょう。 （#include <string.h>をお忘れなく。） 分解した「文字列の数字」を、atof関数で「少数の数値」に変え、計算しましょう。 計算を終えた数値を　sprintf関数で文字列として繋ぎ合わせましょう。 （この時文末に“改行コード”を入れ忘れずに。\r\nなど。） 繋ぎ合わせた文字列を　fputs関数でファイルへ書き出しましょう。 「実現したい機能」と「Ｃ言語」の２ワードで検索されると ヒントになる関数やサンプルコードに辿りつけます。 関数の動作を確認しながらご自分で実装していかないと、 全てがブラックボックスになり、 CSVの行内文字数が　char s[100];　を超えて誤作動を起こしたりと 些細な想定漏れに対する修正ができず、 せっかく書いたプログラムもあっけなく使い物にならなくなりますので。
csvファイルが実行形式と同じディレクトリにあるかどうか。 ファイル名にディレクトリの指定を付加してみたらどうか。
>>C++にてCSVファイルを読み込み、CSVファイル中のデータを修正するプログラムを作りたいのですが、どのようにすればよいのか分かりません。 やりたいことを可能にするために必要な要素を細分化して、自分に足りない知識・経験を、時間をかけてひとつずつ（１テーマ１週間くらい？）勉強しましょう。 たぶん、作り始めると、さらに抜けていた知識が明らかになり、勉強しなければいけないテーマが増えて「１歩進んで３歩下がる」という状況になるかもしれませんが、我慢して頑張りましょう！
#2, #4です。 失礼しました。とんでもない勘違いをしてました。#4は間違いです。無視してください。 で、m人の顧客の検索がO(n)であるという理由ですが、 m＞nだとして、m人のうちn人だけを検索します。 そのなかに１人でもハッシュテーブルにない顧客がいれば、それをアウトプットすればいい。 もしn人全員がハッシュテーブルに存在したとすれば、残りの顧客(m-n人)はすべて契約更新していないのだから、その中から適当に１人を選んでアウトプットすればいい。 いずれにしても、m人全員を検索する必要はなく、多くともn人の検索で充分なのでオーダーはO(n)になります。
学生さんも社会人も面接で相手が知りたい内容は同じです。 常識的な受け答えはもちろんですが、一番は面接に来た人の気持ちを知りたいのです。 この人はどういう人でどういう考えを持っているのだろうといったところです。 例えば１つを挙げてみても ・プログラム、パソコンのことを学びたい ⇒学んで何をしたいのか。パソコンのこととは何か。（ハードウェア的な部分なのか？ソフトウェア的な部分なのか？（すげぇ雑な分け方ですが） 抽象的な言葉はすぐにわかります。だって頭にイメージがあれば言葉に詰まることはないですから。 若いうちは苦労するところですがもっと具体的なこと（内容）を考えてみては？ プログラムといっても色々な種類のものがありますよ。 ・就職のサポートが良い ⇒すごく良いと思います。ただ、あなたが具体的にサポートの内容を「こうこうこういう部分」がと言えると満点じゃないですかね？ 今はインターネットで簡単に情報も入手できるので、色々調べてみて話の材料をそろえてから何回も話す練習をしたらいいと思いますよ＾＾ 私は今年PG一年目のぺーぺーですが、この業界を目指している人なら応援したく思い偉そうに書き込みました✩ 長文失礼します。
大学により違います。 極端な話、同じ科目名であっても勉強する中身が異なったりすることもありますので、シラバスを参照してください。
そういうときは、JIS規格の用語が参考になるでしょう。規格書から曖昧さを可能な限り排除するため、まず使われる用語の定義から規格化されています。 「JIS検索」でJIS「X 0002」を検索すると、「情報処理用語（算術演算及び論理演算」が見つかります。 http://www.jisc.go.jp/app/JPS/JPSO0020.html 02.10.03　「結果」　演算をおこなって得られるもの。　result まあ、結局No.1さんと同じく「リザルト(result)」でよいと思います、という結論なんですが、その根拠として。
言語の選び方は ・やろうとしていることができるかできないか ・楽にできるかできないか ・自分が得意かそうでないか で総合的に判断します。 企画がまとまっていないなら、言語選択も難しいです。 簡単でもいいから、企画をまとめてください。
X^NOTというのがよくわからないが、Xの排他的論理ではなくて単にXの否定（!X)と仮定して進めます。 まずブール代数の論理和（ここでは２進の加算ではなく論理和の話をしているんでそこ間違えなく）では、 1 + 1 = 1 0 + 0 = 0 だから Aを任意の変数とすると、A + A = Aという式が成立します。よって、A = A + Aという見方もできる。 ということは、!X!Y!Z = !X!Y!Z + !X!Y!Zという式が成り立ちます。 X＾NOT・Y＾NOT・Z＾NOT＋X＾NOT・Y・Z＾NOT＋X・Y＾NOT・Z＾NOT(面倒なんで!X!Y!Z + !XY!Z + X!Y!Zと書き換えます）は、!X!Y!Zはすでに式の中にあるので、もう一項それを追加してもブール代数上は同じ式になります。 !X!Y!Z + !XY!Z + X!Y!Z　 = !X!Y!Z + !XY!Z + X!Y!Z + !X!Y!Z(これが追加項で４項目はどこから来るのという質問の答え） = !X!Z(!Y + Y) + !Y!Z(X + !X) = !X!Z + !Y!Z = !(X+Z) + !(Y+Z) = (X+Z)(Y+Z) というわけで、問題集の中の解答は誤りではありません。
『cvAbsDiff(srcOld2,srcCur2,dst);←ここでエラーがでます。』 srcOld2 や srcCur2 という末尾2のものは、どのように取得されていますか？
カリフォルニア在住です。 アメリカではカタカナで書くとすれば「ステム」、発音としては植物のstem(茎)と同じ読み方です。 子ども達が学校でSTEM Programに入っており、学校ではこのように呼ばれているので間違っていないと思います。 日本での読み方は分かりませんが、NASAを「ナサ」と読むくらいですから、「ステム」と呼ばれているのではないかと想像します。 ご参考まで。
こういう時は、部分木ごとに分割して考えて、あとで全体にまとめていく、というのが常套手段です。 http://ja.wikipedia.org/wiki/AVL%E6%9C%A8 ということなので、高さ4のAVL木は、高さの定義やAVL木に性質を考えると 「高さ3のAVL木と、高さ3あるいは2のAVL木を左右に持つ木」 ということになります # 高さの定義から、左右それぞれの部分木は、高さ3以下、かつ、どちらか一方は必ず3 # AVL木の定義から、左右の差は1以下、つまり、高さ3と、高さ3または2、という組合せしか無い ここでは、左が高さ3だとします。 すると、ノード数が最小となるのは (高さ3のAVL木のうちノード数最小のもの) - ルート － (高さ3のAVL木の最小ノードのものと、高さ2のAVL木の最小ノードのうち、ノード数の少ない方) という構造の木になります。 左の高さ3の木のノードに注目すると (高さ2のAVL木のうちノード数最小のもの) - ルート － (高さ2のAVL木の最小ノードのものと、高さ1のAVL木の最小ノードのうち、ノード数の少ない方) 以下、繰り返していくと、 高さ0: ノード無し(ノード数0) 高さ1: 1ノードのみ(ノード数1) 　に辿りつきます。ここから戻っていくと 高さ2: (高さ1) - ルート - (高さ1または高さ0のうちノードの少ないほう) → (高さ1) - ルート - (高さ0) → ノード - ルート - 無し(ノード数2) だとわかります。以下同様に高さ3、高さ4と戻していけば、求める解の一つです。
>for( i=1;i<8;i++){ > >　putchar('*'); >　putchar('\n'); >} *を表示する前に、 iが1の時は半角スペースを10個出力。 iが2の時は半角スペースを9個出力。 iが3の時は半角スペースを8個出力。 iが4の時は半角スペースを7個出力。 iが5の時は半角スペースを6個出力。 iが6の時は半角スペースを5個出力。 iが7の時は半角スペースを4個出力。 という風に出力してみたらどうなりますかね？ # 規則性があることに気付けばforループ1つ追加で行けますよね？ iが1から始まる。って点に微妙に違和感ありますけどね。 # まぁ規定回数のループが出来れば87からから始まろうとなんでもかまいませんが。 # ただし、コードレビューとかで「なんで87からなの？」という質問に納得の出来る回答が出来れば…ですけどね。 ## 0ベースで考える方が妥当…ってことが多いでしょうな。こういう場合は。
＞情報社会とクラウドをテーマ （レポート用紙に、図を書いても良いならば図を使いましょう） （お近くの図書館に事情を話して、参考になりそうな図書を教えてもらいましょう） ※言うまでもありませんが、引用する時は、引用元を書きましょう。 ・レポート（用紙）に表紙をつける。 表紙に、課題のタイトルの他に、「自分でつけたサブタイトル」を書く。 （この作業は、レポートが全て書きあがってから最後に行ってください。） ・今日の「情報社会の特徴について」（２ページくらい） （下記が、参考にすると良いと思われるサイトです。（高校生の内容ですが）） 社会と情報　 http://www.nhk.or.jp/kokokoza/library/tv/syakaijouhou/ （直接引用する際は、引用元を必ず書いてください。） ・クラウドに関する「分かりやすい説明」で１ページからから１．５ページ。 （具体的には、”クラウドコンピューティング”と”クラウド技術を用いたサービス”） （分かりやすい資料をあつめるために、家電量販店かパソコンショップに行って、事情を話して、広告用パンフレットをもらってきてもＯＫ。） ・「従来のデータの管理」で半ページ。 ・「クラウド」と「従来のデータ管理」の違いで、半ページくらい。 ・クラウド（技術・サービス）による「情報社会の未来・展望」を引用して、半ページから１ページ。 （何かしらの書籍かＷｅｂサイトから引用してください。当然、引用元は必ず書いてください。） ・質問者さんがレポートをまとめている時に感じた事柄（感想・所感）で、半ページくらい。 ・質問者御自身が考える「情報社会におけるクラウドコンピューティング」の未来像を締めくくりとして、１ページくらい。（難しいならば、半ページでも可。） これで、表紙を除いて、約６ページくらいです。 他の生徒さんは、情報社会だけで、3.5ページくらい使いそうですから、クラウド（コンピューティング）や、クラウド以前のデータ管理について記述すれば、良い成績を修められると思いますよ。 以下は、参照されると良いと思われるサイトです。 『情報通信白書 for kids』 http://www.soumu.go.jp/joho_tsusin/kids/ Yahoo キッズ　　ゲームとコンピュータ http://dir.kids.yahoo.co.jp/Computers__Games__and_Online/
他回答にあるのはエクセルのソート機能を使ったものなので、書いても先生を怒らせるだけですよ。 Sub Macro1() Dim i As Long, j As Long, Tmp As Long '型宣言 For i=4 To 1 step -1 For j=1 To i If Cells(1, j)>Cells(1, j+1) Then '右隣のセルと比較し大きいなら入れ替える Tmp=Cells(1, j) Cells(1, j)=Cells(1, j+1) Cells(1, j+1)=Tmp End if Next j Next i End Sub 動作確認くらいはやって下さい。
(double)no1/(double)no2 に修正。 (double)(no1/no2)では、割り算ををintで計算した後、doubleにキャストしています。
　各々、その分野の専門書を読むのが一番です。 　ただ、情報処理技術者試験を受けるための勉強であれば、「基本」「標準」の技術があれば事足ります。 　世の中の技術には、次のような大ざっぱな区分けができ、各々の後者は特別な専門書が必要でしょう。 （１）基本技術と応用技術 （２）標準技術と、製品技術（特定のベンダー、製品の固有の技術） （３）技術進歩によらず共通に適用できる技術と、時代・世代で変わって行く技術 （４）学校で学ぶような広範囲な基本知識・技術と、企業で実務に必要となる専門知識・固有技術 （５）汎用技術と、ある特定の応用システム技術 （６）広く浅い知識と、狭く深い知識 　専門用語なら、ＩＴ用語辞典、ネットワーク用語辞典、データベース用語辞典など、あるいはネット上の用語検索が使えると思います。
>機械が主人を自ら選び できるとしたら、製作者に主人を選ぶ基準をあらかじめ与えられているだけでしょう。 それなら、入力情報（カメラ・マイク・入力用端末）で、ある程度の判定させることは可能かと思います。 >自己修復機能を持ち ナノマシーンの群体にしたうえで、自己生産ライン的な役割を持たせられれば可能かもしれません。 >自ら進化すること AIの学習機能（貯め込むだけの機能）は可能だけど、進化（自ら選択・創造・抹消）となると難しいでしょうね。 偶発的な事故によって進化する可能性は０ではないけど、自ら進化するような機械を作るのは 現行の技術で出来る可能性は０に限りなく近いでしょう。
通常は無理です。というか無理です。 Chrome OSで動くアプリをほかのOSでという逆は出来る場合もあります。 もしあなたがUNIXの知識に長けていて、C/C++が理解出来ているなら、OSのソースコードを取得してiTuneが動くように改造しましょう。 おそらくその技術は売れるかもしれません。
for /l %i in (2,1,8) do @ren textc%i.c textc1-%i.c
単純に「計算式が間違っている」です。 テストパターンとして 6 0.0 0.0 0.0 2.0 2.0 2.0 0.0 0.0 2.0 2.0 0.0 2.0 0.0 2.0 0.0 0.0 2.0 2.0 0.0 2.0 2.0 2.0 0.0 0.0 2.0 2.0 0.0 0.0 0.0 2.0 2.0 2.0 0.0 2.0 0.0 0.0 を使います。 (0.0 0.0) ( 0.0 2.0) (2.0 2.0) これは、サンプルにあった座標と同じ外接円に接する三角形になります。 その座標を入れ替えた全6通りです。全て同じ三角形です。 ということは、サンプルと同じに 1.000 1.000 1.414 になるはずです ですが、実際には違う値になります。 どこに間違いがあるか、探すのは面倒なのでやっていません。 直したら、いろんなパターンを入力して確認してみましょう。 中心(x0,y0) 長さr0 の円上の点(xa,ya) は xa=x0+r0 * cos(Ta) ya=y0+r0 * cos(Ta) で求められます。 x0,y0,r0,Ta,Tb,Tc を乱数で決めれば、A,B,Cの3点の座標が求まります。 その順列全てを並べれば、テストパターンの完成です。 ・全部の順列で答えが(ほぼ)同じ ・その答えが元のx0,y0,r0と(ほぼ)同じ ということで確認することができます。
「答案」の筋書きは？ ・f(t) は 1 Hz と 2 Hz の余弦波の積らしいから、「和積公式」により 3 Hz と 1 Hz の余弦波の和。 　つまり、f(t) は 3 Hz と 1 Hz の「輝線スペクトル」をもつ。 ・f(t) を fs = 5 (or 10) Hz の「インパルス」で標本化したときのスペクトルは？ 　　参考 URL >わかりやすいサンプリング定理(標本化定理) 　などを見て思案くだされ。 　　
現在地(myLatitude,myLongitude)のように目的地のGPS座標をセットすれば良いと思います。 double toLatitude = 目的地の緯度; double toLongitude = 目的地の軽度; もしも現在地と同時に表示したい目的地が特にないならば、 CameraUpdateFactory.newCameraPositionを使用すべきかなと... CameraUpdateFactory.newLatLngBoundsは複数地点を同時に表示したい時に使用します。
>y[n] ＝ x[n] - 2x[n-1] + ax[n-2] を時間シフトし、a=1 とした 　y[n] ＝ x[1] - 2x[0] + x[-1] のシフトを戻し、 　y[n] ＝ x[n] - 2x[n-1] + x[n-2] 　　　　↓　右辺の z 変換 : z=e^(jω) 　[1/z^n] - [2/z^(n-1) ] + [2/z^(n-2) ] 　= [1/z^(n-1)] * { [1/z] - [2] + [z] } (またシフトかヨ) …と整形してみると？ [1/z] - [2] + [z] の項は、 　= [cos(ω) - jsin(ω) ] - 2 + [cos(ω) + jsin(ω) ] 　= 2*[cos(ω) - 1 ] になり、これは零移相。 そして、[1/z^(n-1)] の分は直線移相。 …という蛇足。 ご自身が引用なさった URL と照合してみて。 　　
☆ - 式にて {a1, a2} を選定してオールパスにできる … のですか？ (一見、不可能) 　　
「エラーとなりました。どうしたらエラーがなくなるのか教えてください。」 って 回答してくれる人が全員、質問者の環境と状況そしてエラー内容を熟知してるワケじゃ無いですよ？エラーが出たなら”「○・・・○」というエラーが出て原因が分からず解消できません”という風に具体的なトッカカリを示すようにして下さいね。 質問者さんの流儀に合わせて解答すると「同じサイトに示されたとおりに構築したら正常に動きましたので参考にして下さい」で終わってしまいます 直接的にｈｉｔするかは微妙ですが過去、この手のサンプルを引っ張ってきて最初にぶち当たった壁の備忘録に以下のような文言を記していたので転記しておきます テーマに「AppTheme」なんてモノは無いと何度言えば判る！正しくは「AppBaseTheme」だ 忘れるな！オレ 誤) <style name="AppTheme" parent="android:Theme.Holo.Light" /> 正) <style name="AppBaseTheme" parent="android:Theme.Holo.Light" /> 頑張ってＴｒｉａｌ＆Ｅｒｒｏｒに励んで下さい
　低周波でサンプリングするときには、極端に大きい、または極端に小さいピーク信号をたまたま拾うと誤差が大きくなりますから、サンプリングする前に、サンプリング周期に応じた「信号なまし処理」、つまり一次遅れ、二次遅れなどの「平滑化処理」をするのが普通だと思います。 　どの程度の時定数で「遅れ」処理をするかは、信号の特性やサンプリングした後の取り扱いなどで判断する必要があると思います。けっこう、経験的な要素もあるのではないかと思います。ただし、サンプリング後のデータを相互に比較する場合は、各信号に対して同じ処理をしないといけません。
こんばんわ。 OS情報が不明ですが、こちらでいかがでしょう？ http://blog.ybbo.net/2014/01/14/windows7%E3%81%A7%E3%80%8Cie10%E3%81%8B%E3%82%89ie9%E3%81%AB%E3%80%8D%E3%80%81%E3%80%8Cie11%E3%81%8B%E3%82%89ie10%E3%81%AB%E3%80%8D%E7%B0%A1%E5%8D%98%E3%81%AB%E3%83%80%E3%82%A6%E3%83%B3%E3%82%B0/ ご参考になれば幸いです。
配列として与えられたデータからヒープを作るだけなら 1. 空のヒープを作って 1つずつデータを追加する 2. 配列に対していろいろ処理して最終的にヒープにする のどちらも可能です. やってることがわかりやすいのは 1 だけど 2 の方が速く, n個のデータがあるとき 1 が O(n log n) 時間に対して 2 は O(n) 時間. でいちおう「取り出し」はそれでいいといえばいいです. ただし, 「末端の最も右の値をルートにコピーし、ヒープを再構成する」とはいってもその「末端の最も右」のノードは使わなくなってしまうので, 実務的には「末端の最も右の値とルートの値を交換してからヒープを再構成する」のが普通です. あと, そもそも「取り出す」といったときに「ルートの値をとってくる」だけで「ルートの値を取り除く」までは想定しない可能性があるので, もうちょっと正確な表現をすべきだとは思います. 「削除」ですが, 「削除したい値を削除し、削除した頂点以下のノードを再構成する」は (少なくとも素朴に読む限り) ダメです. TECHSCORE の絵でいうと, 2番の 21 という値を削除するときにその下の 5番と 6番だけをヒープとして作り直してもダメだよね. これも上の「取り出し」と同じように, 当該ノードを「末端の最も右の値」と交換してからヒープを作り直すのが自然かな.
ご質問の主旨に沿って、「解き方」だけをお示しします。 ＞（１）アルファベット26文字×２（大文字と小文字），0～9の数字と30種類程度のよく使う記号 ＞（「，」「．」「：」「！」など）に2進数をひとつずつ割り当てて表すとすると， ＞最低何ビット（何桁）必要か． 文字、記号の種類数を（26X2 + 10 + 30 =92）とします。 必要な２進数のビット数をNとすると、 2^N=92 より、 N=log92 / log2＝6.52 ビット数は整数でなければならないので、ガウスの整数NNを使います。 NN=ceiling (6.52) = 7 すなわち、92種類を表現するに必要な最低ビット数は7ビットになります。 なお、7ビットでは（2^7=128）まで表現可能ですが、このケースでは128-92=36種類空きになります。 ＞（２）同様に，1万種類の漢字を表すためには最低何ビット必要か． 上と同様に、 2^N=10000 より、 N=log10000 / log2＝13.28 ビット数は整数でなければならないので、ガウスの整数NNを使います。 NN=ceiling (13.28) = 14 すなわち、10000種類を表現するに必要な最低ビット数は14ビットになります。 なお、14ビットでは（2^14=16384）まで表現可能ですが、このケースでは6384種類が空きになります。
NANDゲートは入力が変化してから、出力が変わるのに5～15nSの信号の遅延があります、入力と同時に出力が変化するわけではありません ２番のステージで、A=H,B=H,X=L,Y=H　の時　A=L　に変わると15ns後に　X=H (B'=H)　に変わり　B-NANDゲートが その15ns後に　Y=L　に変化し右の３番のチャートと等しくなります {　Y=L　(A'=L)　A=L　の為　A-NAND出力は変化しません　X=H　のまま　} ４番ステージで　A=H　に変わると　A=H,A'=L　の為　A-NAND出力は変化せず　X=H　のままになります ゲートの遅れを加味したタイムチャートを書くと理解が深まります。
CRCはエラ―検出専門。 検出精度が非常に高く、安価にハードウェア化できます。 CRCは再送と組み合わせて使います。
たとえば4000Hzの音を出す時１秒間に4000回のON/OFFを繰り返す必要があります、（計8000回） これをプログラムで組むと、ポートのON,1/8000秒待つ、ポートのOFF,1/8000秒待つ、のループを音を鳴らしている間繰り返すことになります これでは音を出してる間他の仕事が出来ません、TVゲームなら音を出してる間画面が止まることになります これを割り込み処理にすると、メインプログラムで音を出すフラグをセットすれば、後は自動的に音が出るようになり メインプログラムは他の仕事に専念できます、（マルチタスク処理） キースキャン、RS232受信、LEDのダイナミック表示、これらを割り込み処理で行わないと キー入力が遅い２重入力、RS232受信データの取りこぼし、LED表示がちらつく等の弊害がでます パソコンでは、Windows及びサブCPUが処理するのでユーザープログラムが意識するすることはありませんが 組み込みマイコンでは自前で処理しなければなりません。
素直にNexus7(2012)を買うのはいかがでしょう？ SDKだけで認識しますし、価格も1万3千円程度。 中古なら1万円割ります。 互換バッテリーを自分で交換できるので 末長く使えますよ。
fgetsでfilemaneを入力した際、filenameには最後に\nが入っています。 よって、 fgets(filename, 33, stdin); //読み込むテキストファイルを指定 filename[ strlen(filename)-1]='\0'; というふうに潰しておく必要があります。
心配してないで訊いてみりゃいいです。情報系の論理学の要は自動証明。不完全だけれども速い線形入力推論や、のろいけど完全な導出原理など、ま、少なくとも「証明可能」だとか「決定不能」の概念は、学生でも分かってなきゃおかしい。だから、（論理ではなく数学の話だけれども）、不完全性定理や標準的なZF公理系の話程度のことなら案外すらすら教えてくれるんじゃないかな。もし分かんなくても、別に訊いて失礼に当たるわけでもなく、むしろ自発的に勉強しようという学生は大歓迎のはず。適当なひとや教科書を紹介して貰えるかも。
s1=0 s2=0 for i=1 to 10 s1=s1+a(i) next i am=s1/10 for i=1 to 10 s2=s2+(a(i)-am)^2 next i
　振幅変調(AM: amplitude modulation)の話でしょう？足し算じゃなくて掛け算ですよ。AMは搬送波 Ac sin(ωt) に対して、ωよりずっと低周波の成分しか持たない信号f(t)を掛け算する。だから結果の波形のピークは、その瞬間tにおいて sin(ωt)＞0なら Ac f(t) に、sin(ωt)＜0なら-Ac f(t)に概ね対応します。もちろん、谷底は符号が逆になる。 　もしf(t)にバイアス（直流成分）が入っていてf(t)がいつも正の値だ、ということなら、|Ac f(t) sin(ωt)|のピークは概ねf(t)。なので、振幅の外形（envelope）を見れば、概ね Ac f(t)になっている。 　なお「概ね」というのは、ピークや谷底の瞬間にdf/dt=0であれば「ぴったり」なのだけれども、df/dt≠0であればその影響でピークの時刻が少し変わり、ピークtにおいて|sin(ωt)|は1よりほんのちょっと小さくなってる、ということ。 　ところで、 > なんにも変えてない搬送波の振幅Acまで変化するのが納得できません。  と仰る意味はさっぱり分かりません。変調された波形を計測しただけではAcは分からんでしょうに。
そのまま y(3), y(4), ... と計算していけばいつか y(100) にたどりつく... よね?
単に足し算してるだけだから, 形式的な証明はともかく直感的には簡単だよね. 本質的には同じことだし.
> PRINT　INT　（RND*4）+1; こうしてRNDを直接表示してしまったら、後から計算に使ったりはできません (次にRNDを使ったら、新しい乱数が使われるので) 変数や配列に保存しましょう。 > ELSEIF文を用い，IF文およびEND IF文は1回で済ませる。 構造は簡単です。 問題中に日本語で書いてある条件を、プログラミング言語に翻訳するだけです。 もし x=y=z=1 のときは 　　「大当」と表示， そうではなく、もし x=y=z≠1 のときは 　　「当」と表示， そうではなく、もし x, y, z のうち２つだけが一致したときは 　　「惜」と表示， そうではなかったら 　 「残念」 と表示 少し難しいのは、条件の書き方です。 数学と違って、 「x=y=z=1」とは書けません、「A=B」「A<>B」といった「2つの値の比較」しかできません。 なので、 元の式を 「2つの値の比較」 と「『かつ』『または』『ではない』」といった論理演算との組み合わせで表現します。 例えば 「x=y=z=1」 は x=y かつ y=z かつ z=1 です。 「x, y, z のうち２つだけが一致」 は 「xとyが一致で zとは一致しない」または「yとzが一致で xとは一致しない」または「zとxが一致で yとは一致しない」 となります。 これをそのまま書けば、とりあえずはできます。 ここで、IF～ELSEIF～ELSE～END IF の性質を応用します。 このIF～ELSEIFには「上から順番に評価して、最初に条件が一致したものが実行される」という性質があります。 x=y=z≠1 の判定をしている、ということは、上の「 x=y=z=1」ではない、ということです。 このELSEIF で、 x=y=z の判定だけをします。 本来なら、x=y=zの時は x=y=z=1 x=y=z≠1 の2通りの可能性がありますが、=1の場合は、上のIFで一致するので、このELSEIFは実行されません。 つまり「x=y=z」だけ判定すれば、必ず「x=y=z≠1」になっている、ということです。 同様に、それまでの条件を考えれば「二つだけ一致」も判定を省略できます。
>「Pythonの勉強をすること」 ということなので。 常套手段は、次のような流れのものです。 (1) 1行読み込む (2) (1)の行を加工する (3) (2)で加工した文字列を書き出す (4) 以上(1)～(3) をファイル全部に対して繰り返す (1),(3),(4)については、チュートリアルで勉強できます。 http://docs.python.jp/2.7/tutorial/ http://docs.python.jp/3.3/tutorial/ (2)について、今回は特定のパターンでの変換となるので、正規表現を使った置換が便利でしょう。 http://docs.python.jp/2/howto/regex.html http://docs.python.jp/3.3/howto/regex.html > いろいろ調べてもなかなか実現できません。 どんなことをして、どんな風に「実現できません」だったのでしょう? 原因を調査して対策を考える、というのは、プログラミングの基本です。 Pythonの勉強が目的ならば、この解析もきっちりとやりましょう。 例えば、上記の流れでも、(1)～(4)のそれぞれに「うまくいかない場合」が存在します。 (1)が失敗しているのに、(2)を変更しても無意味です。 > 「ほかの言語のほうが書きやすい」 例えば、「パターンマッチによる置換」ができるテキストエディタでできます。 # Windowsのメモ長等の一部の低機能なもの以外なら、大抵のものが該当します 数ファイルだったら、プログラム作っている間に処理が終了します。 例えば、UNIX系に標準のsedコマンドを使えば、1行で書けます。 ファイルが大量にあっても、シェルスクリプトやバッチファイルの繰り返し機能(for 等)を使えば簡単です。 ※ 別解 import os os.system(r"sed 's/ \([0-9]*\):[0-9][0-9]:[0-9]*\.[0-9]*/|\1/' infile > outfile") sedコマンドが使える環境限定
Android の OSがまだTPMに対応していないから。 なぜか・・はGoogleに聞いてください。 AppleはMacOSでもTPM非対応って、実際には対応しているんだけど使い方が違うのでアプリなどから使う目的じゃないので事実上非対応。(OSのプロテクトに使ってる) http://japan.cnet.com/news/tech/20086162/ この状態だからiOSでの対応は考えられない状態でしょうね。
＞0,2,4,6を考えてから+3すればいい… 既にほぼ正解に辿り着いていると思われますが。 (1) RND(1)*4で0～4未満の乱数を取得。 ↓ INTで整数化…[0,1,2,3] ↓ 2を掛ける…[0,2,4,6] ↓ 3を足す…[3,5,7,9] なので、 INT(RND(1)*4)*2+3 (2) あらかじめ、配列変数Xを宣言しておく。 FOR i=1 TO n X(i)=a+((n-1)*r) NEXT i FOR j=1 TO k PRINT X(INT(RND(1)*n)+1) NEXT j 配列Xに所定の数値を格納する処理をn回繰り返し、1からnまでの乱数で、そのうちのいずれかひとつをランダムに選定し表示、という処理をk回繰り返します。 但し、nが1以上の整数であること。 入力者が、0とか0.5とかをINPUTしてしまう恐れがある場合、それはそれで別に判定文を設けて例外処理をします。 また、n=1の時、答えはa一択になるので、それがイヤな場合も、併せて事前処理をしておきます。 （例:IF n<2 THEN 変数をリセットして再度INPUT行へ飛び、入力のやり直しを促す、等）
＃１ですが、まあフローチャートくらいは書いてあげましょう。 前教えてあげた、ランダムの話は覚えていますか？ 今回乱数は使わないです。確率はｎとｒだけで決まるから。 ＦＯＲ～ＮＥＸＴ　は使えるようになりましたか？ まず数学の確率がわからないとつらいので、確率は次のようになります。 （１）　ｎＣｒ・（2/6）^ｒ・（4/6）^(ｎ－ｒ) ちょうどｒ回出るという確率をプログラムで求めろ、ということは。 ｎＣｒ＝ｎ（ｎ－1）（ｎ－2）・・・／ｒ（ｒ－1）（ｒ－1）・・・ を求めろということですね（式１と呼ぶ」）。 （２）は（１）の答え　１～ｒ　を全て足し算します。 今、ＦＯＲ～ＮＥＸＴ　の入れ子構造を習っているのではないですか？ ｉとかｊとかｋとか　←見間違いに注意してください。 （１）フロー 画面クリア 変数初期化 式１の分子を　Ｂ、分母をＣ　とおく（Ａ使う予定だったけどやめました） Ｂ＝1　としておく Ｃ＝1　としておく Ｄ＝1　としておく Ｐ＝２／６　としておく（３の倍数が出る確率） Ｎ　を入力させる Ｒ　を入力させる ＦＯＲ　ｉ＝1　ＴＯ　Ｒ 　Ｘ＝0　としておく 　Ｂ＝Ｂ*（Ｎ－ｉ+1） ※この式によって、分子に　ｎ、（ｎ－1）、（ｎ－2）・・（ｎ－Ｒ＋1）　が順番に掛け算されて行きます 　Ｃ＝Ｃ*ｉ ※この式によって、分母に　１、２、・・ｒ　が順番に掛け算されて行きます 　Ｒ、Ｒ－1、Ｒ－2、・・１　という減る順番でも良かったんですけど、どうせ同じなので式をシンプルにしました ※宿題ならば、ｎＣｒ　を正しく理解しているか、も、ＦＯＲ～ＮＥＸＴの使い方と同時に試されていますよ！ ＮＥＸＴ　ｉ ＩＦを習っているということにして ＦＯＲ　ｉ＝1　ＴＯ　Ｎ 　ＩＦ　ｉ＜＝Ｒ　ＴＨＥＮ　Ｄ＝Ｄ*Ｐ 　ＥＬＳＥ　Ｄ＝Ｄ*（1－Ｐ） ＮＥＸＴ　ｉ ＩＦを習っていなかったら、２段階仕立て ＦＯＲ　ｉ＝1　ＴＯ　Ｒ 　Ｄ＝Ｄ*Ｐ ＮＥＸＴ　ｉ ＦＯＲ　ｉ＝Ｒ+1　ＴＯ　Ｎ 　Ｄ＝Ｄ*（1－Ｐ） ＮＥＸＴ　ｉ ただ、このやり方だとＲ＝Ｎ　のときは答えが狂ってきますから、ＩＦが使えないと結構不便です ＩＦを使わずにＩＦっぽいことをやる裏技 ＦＯＲ　ｉ＝1　ＴＯ　Ｎ 　Ｄ＝Ｄ*（－Ｐ*（ｉ＜＝Ｒ）－（1－Ｐ）*（ｉ＞Ｒ）） ＮＥＸＴ　ｉ 最後 Ｘ＝Ｂ／Ｃ*Ｄ Ｘを表示 （２） （１）の　Ｒ　を入力させる　の後を以下のように変えます Ｅ＝0　としておく ＦＯＲ　ｊ＝1　ＴＯ　Ｒ 　（１）の　ＦＯＲ　ｊ＝1　ＴＯ　Ｒ　から　Ｘ＝Ｂ／Ｃ*Ｄ　まで　そのまま 　Ｅ＝Ｅ＋Ｘ ＮＥＸＴ　ｊ Ｅを表示 以上です。
> 自分で実際にシミュレートできたら楽しいなあ というだけのことであれば、自分で勝手に規則を考えて、実際にシミュレートなされば良い。 　たとえば： 　n行m列に並んだ升目を考えて、ただし、一番上の行は一番下の行につながってる。一番左の列は一番右の列につながっているということにする。（これはドーナツの表面（トーラス）と同じ位相を持つ空間です。）これが「今の状態」だと思うことにします。 　これらの升目は場所を表す。各升目には「何もいない」か「オオカミが居る」か「ヒツジが居る」としましょうか。 　で、オオカミとヒツジの行動のルールを定めます。 　オオカミが居る升目の隣にヒツジが居る升目があるなら、オオカミは隣接するヒツジの居る升目のどれかに移動して、ヒツジを喰ってしまう。そして、ある確率で、オオカミが元居た升目にもう１匹オオカミが生まれる。 　オオカミが居る升目の隣にヒツジが居る升目がないなら、ある確率でオオカミは餓死し、その升目は何もいない状態になる。餓死しない場合、オオカミが居る升目の隣に何もいない升目があるなら、ある確率でオオカミは隣接する何もいない升目のどれかに移動する。さもなくば、オオカミはその場にとどまる。 　ヒツジが居る升目の隣に何もいない升目があるなら、ある確率で、隣接する何もいない升目のどれかにもう１匹ヒツジが生まれる。 　 　てな感じでしょうかね。以上の設定に出てくるいくつかの確率の値を適当に決めておいて、最初にランダムにヒツジとオオカミをばらまき、シミュレーションをやってみる。確率を変えたり、ルールを変えたり、いろいろとお楽しみになれば宜しいかと。 　ほかにも、森林火災（火は燃え広がるけれども、燃えるものがなくなれば消える。火が消えた跡には、しばらくするとまた木が生えてくる）ですとか、回遊する魚をサメが追いかけ回すだとか、いろんなことをイメージしたルールを考えて、試してみることができます。 　ところで、セルラーオートマトンという数学分野（既に出ている回答にあるgame of lifeもセルラーオートマトンの一種です）では、升目の状態が刻々変わって行く、という点については上記のようなシステムと同じなのだけれども、ルールの作り方が全く違う。すなわち、単に、「ある升目（セル）が、それ自身の状態とその周囲にあるセルの状態に応じて、それ自身の状態を変える」という風に考える。確率は使わないし、個々のオオカミやヒツジというものも考えないんです。それでも、多くの升目がどんどんと千変万化する様子を眺めていると、あたかも「ある個体が移動して行ったり、増殖したり、死滅したりしている」ように見えちゃう。面白いものです。 　２次元平面のセルラーオートマトンについて最も興味深い定理は、そもそもセルラーオートマトンというものの発案者であるフォン・ノイマン自身によるもので、一群のセルから成るパターンが、万能チューリングマシン（あらゆる計算ができるコンピュータ）になるようにできる、ということ、および、一群のセルから成るパターンが自己増殖する（つまり、自分の複製を作る。これは生命の最も重要な特徴！）ようにできる、ということ。で、のちにコンウェイが考えたgame of lifeでも、万能チューリングマシンと自己増殖のパターンが作れることが証明されています。
人工知能の中でも、迷惑メールを排除する学習と似た部分や、それが、利用者の増加・利用者による正誤のフィードバックの増加によって加速度的に学習が進化する部分などで、次のサイトで言及されている部分が大変興味深く思いました。 iPhoneアプリ　アキネーター(Akinator）の仕組み | iPhone App Star http://iphone0appli.blog82.fc2.com/blog-entry-120.html
作成しました。 #include<stdio.h> #include<stdlib.h> #define N 255 typedef struct student{ char str[N]; } STUDENT; int main(void){ int i = 0; FILE *fp; STUDENT * st = (STUDENT*)malloc(sizeof(STUDENT)*10); /* ファイルオープンの処理 */ fp = fopen("02student.txt", "r"); /* ファイル入力処理（ポインタ変数st を各領域を参照し，格納） */ /* 標準出力処理（ポインタ変数st から各領域を参照し，値を確認） */ while(fgets(i[st].str, N, fp)&&printf("%s", i++[st].str)); /* ファイルクローズの処理 */ fclose(fp); /* メモリの解放処理 */ free(st); return 0; }
共通の法使用時の同一平文暗号化の問題ですね。 一方の公開鍵を(ea,N)、もう一方の公開鍵を(eb,N)とします。Nは共通とします。 そして二つの暗号文を Ca＝M^ea(mod N) Cb＝M^eb(mod N) とします。 GCD(ea,eb)＝1よりα×ea＋β×eb=1を満たすα,βが存在し、それを求めることができます。 そうすると、二つの暗号文と求めたαとβを使って【mod表示を省略します】 　Ca^α×Cb^β ＝(M^ea)^α×(M^eb)^β ＝M^(α×ea)×M^(β×eb) ＝M^(α×ea＋β×eb) ＝M^1 ＝M を計算することで、Mが求まります。
では次。 これをすべて書いても良いのですよ。ただ１００，１０００となれば無理ですので、 ループにすることにします。 これ、一行毎に文が違います。添字、入れる値。これを変数として放り込みます。 a[i][j] = x; こう書けばすべての行がおなじになるでしょ？ あとはi,j,xをセットするだけ。 xは1からはじめて+1する。 i=0にして、jを0から3までループ x=0; i=0; for(j=0,j<4;j++){ a[i][j] = x; x++; } こうなります。 理解できますか？ その次は i=0;ではなくて0から3までループすることです。 理解できますか？ これでaの配列は終わりです。 では、bを考えてみましょう。 iとjを操作すればどうなりますか？ iは0,1,2,3だったものを3,2,1,0にすればほら、出来た。
８ヶの配列に０と１を４ヶずつ代入し、数回　乱数によって配列の内容を入れ換えます 後は配列のデータを２進数に組み替えて終了
V(a*X) = a^2 * V(X) X, Yが独立のときにV(X+Y) = V(X) + V(Y) などの証明は終わっているものとします。 ave(Xn) = (1/n)*X1 + (1/n)*X2 +・・・+ (1/n)*Xn なので、ave(Xn)の分散は (1/n)^2 * V(X1) + (1/n)^2*V(X2) +...+ (1/n)^2*V(Xn) = (1/n)^2 * σ^2 + (1/n)^2*σ^2 +...+ (1/n)^2*σ^2 =(1/n) * σ^2 = σ^2 / n (X - μ) / σ で標準化できることも、期待値の線形性と、それから導かれる上に示した分散の性質とを使うと理解できると思います。 rand() については、Xそのものなので分散は1になるけれど、randで発生させた乱数の平均を取ったもの、というのをいくつか作ってみれば上に示したものに合っていることがわかると思います。たとえば、rand() 100個組を100組作ってそれぞれの組で平均を取り、出来上がった100個の平均値についてその平均や分散を調べてみると良いと思います。
1バイトで16進数を表すとしたら二桁ですかね。 16進数の一桁(0-F)は4bit(0000-1111)で表せるので1Byte=8bitだから二桁かなと。
　ここ、 　　http://www.atmarkit.co.jp/ait/articles/1005/11/news105.html がたぶん参考になるでしょう。VS（Visual Studio）2010の記事で、2世代ほど古いけど（もうそんなになるのか・・・）、基本部分は変わっていません。 　参考URLの記事によると、VS2010の種類（Editionと言います）は、 　　Visual Studio 2010 Ultimate 　　Visual Studio 2010 Premium 　　Visual Studio 2010 Professional 　　Visual Studio 2010 Express（無償） 　　Visual Studio Test Professional となっています。これらは、Test Professionalを除いて、基本機能はみな一緒です。それで「ノーマルタイプ？」に相当するEditionですが、上記の並びは、上に行くほど上位Editionになり、「ノーマルタイプ？」はPremiumかUltimateに相当します。 　値段で言うと（正規料金で）、Professionalは仕事のツールとしてなら何とか買う気の起きる値段ですが、PremiumとUltimateは仰天するほど高額になります（車一台買えるのじゃないの？・・・のレベルです(^^；)）。こいつらは全くの「非ノーマル」です(^^；)。 　PremiumとUltimateは、Professionalにチーム開発を行う際に利用できるツールなどを、盛りだくさんに追加したもので、企業向け、それも大企業向けのパッケージです。 　Test Professionalは、Applicationのテスト作業専用のツールの集積で、テスト技術者なら欲しがるでしょうが、開発は行えません。 　という訳で、個人または個人開発者向けの最上位Editionは、Professionalになります。普通はこれで十分です。というか、全機能は使いきれませんよ。ちなみに自分の会社は中小企業なので、いつでも絶対にProfessionalです(^^；)。 　一方Expressは、本当に基本機能のみで、実際上、色々と不便極まりないところがあります。VS2005の時代でしたがExpressでは、開発したApplicationのインストールパッケージを作れない事がわかって、大いに鬱陶しかったです。いわゆるクリックワンス・インストールしかサポートしてませんでした。Professionalが入手可能なら、それに越したことはありません。 　VS2013ですが、まだβ版の臭いがします。2012では駄目ですかね？。2013の日本語版の正式リリースはもう少し待つ必要があるでしょう。でも参考URLはもちろん日本語で、VS動作中のキャプチャー画像も多いので、参考になると思います。英語でも日本語でも、やる事はいっしょですから。 　参考URLで「Visual Studio」をキーワードに検索すると、少なくとも.NET以降のVSについては豊富な記事があります。少し古いVSの歴史を知るのは、損にはならないと思います。 　Visual Studioの原型はじつは30年以上前からあるんです。自分はその頃からVisual Studioを使ってた事になりますが、そこで思うのは、Visual Studioだって（開発環境だって）、Excelなんかと同じApplicationだという事です。そしてApplicationは、設計思想さえわかれば使い倒せます。どう動作するか、予想がついたりするんですよ（ヘルプを読まなくても）。その助けになるのは、そのApplicationの開発の歴史です。 　参考URL自体は、良質なサイトだと思います。自分も良く利用します（← いちおうプロです(^^；)）。 それとVisual StudioのオンラインヘルプはVS2010以降、個人評価では劇的に「使いにくくなりました」。VS2008のヘルプをどこかで入手する事を、お奨めします（少なくとも2012とほとんど同じです）。ヘルプ単体なら、どこかで入手可能と思います。
C++はCの上位互換と思ってください。 よって、 C++のコンパイラーでCをコンパイルすることができます。
一個目の　j=? のところは、文字列の長さが必要ですね。 jを０から１つづつ増やしていって文字列の最後までカウントアップさせます。 for( j = 0 ; *( words[i] + j + 1) != '\0' ; j++ ); 二個目の　while( ? ) の部分は　j が０までやればよいのでこうなります。 while( j >= 0 ) ひとつめのfor 文の真ん中の節で　1 足しているのがわかりにくいかもしれませんね。 次の文字がNULLになってるかどうかを判断したくて１足してます。
printf で double の値を表示するとき, むかしは %f を使ってた (%lf は NG) んだね. だから, 「ちょ～古い」処理系だと変なことになるかもしれん. ただ, scanf とのからみでいろいろあって, 今では %lf でも OK になってる.
式中のx(n),y(n),h(p)の説明とインパルス応答の定義式をお書きください。ｈ（ｔ）はδ(t)関数のインパルス応答でしょうか？ 参考URLが参考になると思います。 1.～3.の式にはy(n)がありますが、4.の式はy(n)がありませんが？
Excelに持っていくだけなら、画面に表示される結果をコピー→Excelに貼り付け でもできます。 その後で、Execl上でグラフに加工してください。 また、Windowsのコマンドプロンプトや、Unix/Linuxのコマンドラインシェルから 実行コマンド > 保存ファイル のように > で保存ファイルを指定すると、 画面の代りにファイルに出力されるようになります。 (リダイレクト と言います) これを使って、 ～.csv というファイル名で出力し、ExcelからCSVファイルとして開けば、カンマ区切りが表になります。 以下、上記コピペと同様に加工します。 fprintfは出力先に任意のファイルにできます。 使いかたは、最初に出力先を指定する以外は、printfと同じです。 出力先は FILE * で指定します。 任意のファイルをFILE * と結び付けるには、 fopen 等を使います。 というあたりのことが、C言語の初心者向け参考書の「ファイル操作」とかいう当りに載っているはずです。 これを使って、結果の出力先をファイルにして...以下、リダイレクトによるものと同様です。 ・xls, xlsx ファイルを直接出力する ・Excelを自動操作する ・図を直接画像ファイル等として出力する 等の方法もありますが、これらに比べると高度です。
最適な成分数を決めるのは、それ自体、難しい問題です。 過学習（過剰適合）すると、汎化能力が下がってしまうわけで。 ＞１、成分数を変えてモデルを各成分数毎に複数作成したとして、どの様に比較・評価を行えば良いのか たとえば、成分数を変えながら、半分のデータを使って学習して、別の半分のデータがどれだけ学習結果に当てはまるかを調べるなど。 ＞２、１の様な手段ではなく、より簡単な(toolboxやmatlab内のfunctionを用いて)手法で成分数を決定する手法 matlabのtoolboxでというのは難しいですが、成分数も（人手を介さずに）機械的に求めたいということであれば、赤池情報量規準（ＡＩＣ）とか、最小記述長（ＭＤＬ）とかを考えるのが、よいです。 あるいは、成分数自体をパラメータ（ハイパーパラメータ）としてモデルに組み込んで、それも一緒に推定するか。
　ご自分の書いたノートですから、その時の状況を思い起こすのが一番正確では？　その講義を受講された専門知識をお持ちなのですから。 　おそらく、文脈としては、「認知心理学」、最近でいえば「脳科学」なども含めて、そのメカニズムを解明してシミュレーションするのに、「記号論理学」がツールとして使える、というものではないかと思います。脳の中で起こっていること、認知心理学で取り扱うようなことを、メカニズムとして「記号論理学」で定式化できれば、コンピュータ上でシミュレーションできるということではないでしょうか。 　ごくごく当たり前のことですが。 　ということは、 （１）「認知心理学」で認知や脳のメカニズム解明 　　　↓ （２）記号論理学でそれを定式化 　　　↓ （３）それをコンピュータ上でシミュレーション という流れの中の、（３）の部分のテクニックに関する講義だったのではないでしょうか。 　問題は、脳の中で起こっていること、認知心理学で取り扱うようなことのメカニズムが解明され、それを「記号論理学」で定式化できるかどうか、にかかっているわけです。 　多分、状況は２０年前とそんなに変わっていないのではないでしょうか。
(1)気がつけば。 (2)デスクトップを表示したら同じですよ。 (3)やってるところは少ないと思います。つか、「教えてもらえる」と思ってるところが間違い。大学生でゲーム作ってるのは独学でやってるのが多いですよ。VisualStudioやUnityが多いですけど。気軽に作るならツクール系とかもありますけど。 (4)学歴も資格も関係ないです。面白いゲームを作ったかどうか(センスを感じさせる作品があるかどうか) なんでも教えてもらえると思ってるなら専門学校の方がいいかもね。でも、一握りのセンスある奴とその他大勢の腐った奴だから、どっちに埋もれるかはそのひとによるけど。
ローカル変数 'dright' に値が代入されていません。 本来は、関数で値を求めたいのではないでしょうか。 最初に書いてある関数は、名前が変数名と同じ 'dright' なので呼び出せません。 意図が上の通りなら、関数名を 　float calc_dright(int a, int b) などに変更し、「左回りの計算」の前に 　dright = calc_dright(a, b); を入れると良いでしょう。 それと 　if (a = b) では比較ではなく代入してしまいます。 正しくは 　if (a == b) です。
線形位相システムと線形時不変システムは同じことですか？ ★回答 ちがいます (1)線形時不変システムは ウキペデイアの以下項目で書いてあるとうり LTIシステム理論←ここみる ※ざっくり言えばフーリエ変換とラプラス変換Ｚ変換で表現できるシステム関数で 周波数ドメインにて かけざん　足し算で　話のすむ伝達関数のことですね (2)線形位相システムとは とは群遅延特性が一定値のシステム関数（伝達関数）の場合 そのシステムのことを言います 位相のグラフの傾きが一定のこと リニアーフェーズシステムのこと インパルス応答が対称である ＦＩＲデジタルフィルターシステムでしか実現しにくいわけですね ・・・・・・・・おわり・・・・・・・・・・・・・・・・
　組込みシステム、エンベデッドシステムは、国家試験として行われる「情報処理技術者試験」にも「エンデベッドシステムシペシャリスト」という区分があります。 　　↓ http://www.jitec.ipa.go.jp/1_11seido/es.html 　このスペシャリストのための教育プログラムや参考書もありますので、参考にしてください。 http://www.itec.co.jp/style/es/ http://www.itec.co.jp/recommend/index.html#studyMethod_05 http://www.itec.jp/shop/products/detail.php?product_id=2528
>「ナイキスト周波数は、最少標本化周波数である。」 これはナイキストレート(Nyquist rate) >「ナイキスト周波数は、サンプリング周波数の1/2である。」 こちらがナイキスト周波数(Nyquist frequency) しかし、ナイキスト周波数＝ナイキストレートと書いているところもあるそうです。 詳しくは参考URL
1・・・× これは言えない・・! 強定常ならば弱定常であることは成り立つ・・! 4・・・× 理由：電力スペクトル密度は0も取り得るため、必ず正の実数というわけではない・・! 他の理由はOK・・!
C++等のプログラム言語自体の講義を手とり足とり教えてくれる大学は無いでしょう。 個人で解説本なり参考書等を購入する、参考サイト等で調べて、自分のペースでプログラムの作成コンパイルデバッグ等を繰り返して身に付ける他ないのではと思われます。 データ構造とアルゴリズム等はある程度講習される事もあるかと思いますが、これもC++等と同じくわざわざ聴講生として教わるよりも自分で調べる方が良いのではないでしょうか。 次等を参考にして下さい。 http://okwave.jp/qa/q7398476.html 情報関連の参考書について ######## それから特定のサイト内に情報がありそうな時は、サイト内サーチを使うと便利です。 http://www.atmarkit.co.jp/　==> C++ 入門 OR 初歩 OR 基礎 OR 解説　site:http://www.atmarkit.co.jp/ アルゴリズム OR データ構造 site:atmarkit.co.jp 新しい情報をサーチしたい場合、最終更新日時(googleに更新が確認し収集された日時)を追加すると便利です。 http://www.google.co.jp/advanced_search?hl=ja &as_qdr=, &tbs=qdr: 等の項目がサーチ条件の中に出てきていた場合は、その内容を次の通りに書き換えます。 サーチ条件内に出てきていない時は最後に追加します。 &as_qdr=all ==> &as_qdr=y 　　 (制限なし　==>　一年以内) &tbs=qdr:m ==> &tbs=qdr:m6　　(一月以内　==> ６か月以内) &as_qdr=, &tbs=qdr: の後には次の文字、文字+数値が指定できます。 　y, m, w, d, h, n <==> 年、月、週、日、時間、分　 C++ site:atmarkit.co.jp ==> https://www.google.co.jp/search?hl=ja&as_q=C%2B%2B+site%3Aatmarkit.co.jp&as_epq=&as_oq=&as_eq=&as_nlo=&as_nhi=&lr=&cr=&as_qdr=all&as_sitesearch=&as_occt=any&safe=active&as_filetype=&as_rights= ==> ２年以内の情報のみサーチ https://www.google.co.jp/search?hl=ja&as_q=C%2B%2B+site%3Aatmarkit.co.jp&as_epq=&as_oq=&as_eq=&as_nlo=&as_nhi=&lr=&cr=&as_qdr=y2&as_sitesearch=&as_occt=any&safe=active&as_filetype=&as_rights=
＞Busyについてわかりやすく BUSY とはその単語どおり「忙しい」という意味で、 「今は話しかけないで」(コマンドやデータを送ってよこさないで）くらいの意味である場合が多いです。 守らない場合の挙動は特に示されてないなら、どうなるかわかりません。 制御する側は、コマンドやデータを送る直前に BUSY でない事を調べ、BUSY なら待ちます。 永久に待ってしまうとよくないので、ある程度の時間待っても BUSY のままなら 待つのを止めて「異常です」等の報告を使用者に表示したりします。 タイミングなどは仕様書で示されているはずです。 メカ寄りなインタフェースなら１ドット毎に変化する場合もあるでしょうし、 PCに接続して使うようなもの変化は１行毎かも知れません。 「熱転写プリンタ」だけでは、「インタフェース信号の仕様」は別々のことなので 信号の仕様がどのようなものかは特定できません。 メカ寄りのやたら細かい制御が必要な独自な仕様の場合もあるし、 IEEE1284 のような公的規格(すでにレガシーですが)になってる場合もあるし。
２浪が限度。留年したらダメだよ！ 就職での年齢制限。
どこの情報学部でも、見られる現象ですが、もうすでにプログラミングスキルがある一定水準以上ついていて入ってくる学生と、大学でゼロから教えてもらえると思って全くできない学生とで、最初から成績・スキルの二極化がおきることが本当に多いそうです。 申し訳ないですが、質問者さんは、後者だと考えられます。最悪、落ちこぼれから始まり、落ちこぼれのままの４年間を過ごされることになりかねません。 自分で、本屋へ足を運ばれて、初心者向けの「javascript」のプログラミング本を購入して、独学されることを強くお勧めします。どの本がいいかは、手に取ったりして、確認されるのが一番です。 次に、かなり初歩的な情報工学の学習の総論的内容は、「ＩＴパスポート試験」の中に要約されています。 これは、youtubeで、「ＩＴパスポート」と入力すると、簡単な講義動画やアニメーションを見ることができます。それらを徹底的に見まくってください。 以上に書いたことは、最低限やっておくべきことであり、とても2週間程度では終わりません。情報工学は、本当に大切なのに、普通科の高校教育では、穴だらけです。それにも負けずに、情報工学科に進まられて、充実した大学生活を送れるようになることを、お祈りしています。
　アラン・チューリングに関しては以下のリンク先を参照すれば詳しいです。 　アラン・チューリング：http://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A9%E3%83%B3%E3%83%BB%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0 　コンピュータの基礎理論を構築した天才で、ノイマンがチューリングの計算理論に基づいてコンピュータを設計したのは有名な話です。暗号解読の天才で、人工知能理論の父とも呼ばれています。暗号解読の為にコンピュータが開発される動機を作ったとも言えます。
理科大と学芸大ならまよわず理科大です。知名度で理科大はあまりしられていませんが 実は慶応、早稲田と同レベルです。 優秀な学生もおおいです。基本東大と併願しておちた学生がきます。留年率がたかいの は本当ですが、海外の大学の比ではありません。 サークルはたのしめますし、バイトしている学生もいます。それほどこわがらなくてもよい のではないでしょうか。 昨今はあまり就職率がたかくないので、理科大にはいれたのなら理科大にいったほうが 将来の選択肢がひろいです。超有名企業の技術者もねらえますよ。
　長すぎることはないと思いますよ。 　書き方よりも、「この学校に是非入りたい！」という熱意を伝える内容の方が大切です。 　短い文章で「人を納得させられる理由」が書ければよいのですが、「言葉足らず」ではなかなか伝わりません。言いたいことがキチンと言えるだけの長さが必要です。 　この学校に入ってこんなことがしたい、自分のしたいことを実現するのにはこの学校が最適だ、だから、ものすごくこの学校に入りたい、というあなたの熱い気持ちを、面接できちんと伝えてくださいね。その熱意が伝われば、大丈夫ですよ！
同値関係？？ equivalence relation
文字列の種類が100種類あると、if文の羅列では一回の検索で平均して50回のstrcmp関数を実行する必要があります。良く出現する文字列の検索を前方におけば回数を少なくすることは可能だと思いますが…。 二分検索を行うと最大で7回に抑えることができます。 文字列ポインタと関数ポインタを格納した構造体の配列をqsortで整列させておいて、bsearchで二分検索して一致する文字列があれば対応する関数を実行する感じです。 #include <stdlib.h> #include <string.h> #defineN5 struct s { char*str ; int (*f)(void) ; } ; chars0 [] = "abc" ; chars1 [] = "de" ; chars2 [] = "fghi" ; chars3 [] = "opq" ; chars4 [] = "jklmn" ; intf0 (void) {printf ("f0実行\n") ;return 0 ;} intf1 (void) {printf ("f1実行\n") ;return 0 ;} intf2 (void) {printf ("f2実行\n") ;return 0 ;} intf3 (void) {printf ("f3実行\n") ;return 0 ;} intf4 (void) {printf ("f4実行\n") ;return 0 ;} struct s st [N] = { {s0, f0}, {s1, f1}, {s2, f2}, {s3, f3}, {s4, f4}, } ; intcomp (const void *a, const void *b) { return strcmp (((struct s*) a)->str, ((struct s*) b)->str) ; } intsearch_do (char *mojiretu) { struct ssa,*sp ; intrtn = 0 ; sa.str = mojiretu ; sp = (struct s*) bsearch (&sa, st, N, sizeof (struct s), comp) ; if (sp != NULL) { sp ->f () ; } else { printf ("一致文字列なし\n") ; rtn = 1 ; } return rtn ; } int main(void) { qsort (st, N, sizeof (struct s), comp) ; search_do ("fghi") ; search_do ("fgh") ; return 0; }
本当にそのような問題だとしたら, 問題がおかしい. 「無向グラフ」と「隣接リスト」との関係が文章に書かれていないので, 「どうなるか」といわれても答えようがない.
http://docs.oracle.com/javase/jp/6/api/java/lang/String.html#split%28java.lang.String,%20int%29 で、o を区切りとしたらどうなるか、が 今回のCRLFを区切りにした場合と同様となります。 なお、 /r/n (スラッシュrスラッシュn)では改行文字にはなりません。 バックスラッシュ、または、環境によっては円記号です。 また、テキストエリアの改行がCRLFで正しいかどうかも確認した方がよいでしょう。
xy=a として各式を変形すれば、わかると思います。 別解。 真理値表を書きましょう。 たかだか4通り(x,y)=(0,0),(0,1),(1,0),(1,1)しか無いのですから、簡単です。 左辺と右辺が4つとも同じなら、等価な式です。
真理値表を作れば簡単だよね。 (1)=(4) (2) (3)=(5) の3つに分けることが出来ます。 (4)は吸収則を使えばそのまま(1)になるし，(5)は￢(x(￢x+y))=(￢x)+(x・(￢y))=(￢x)+(￢y)=￢(xy)=1-xy
物理的に、ソケットが同じであれば可能であるが・・・・ マザーボードは、ＤＥＬＬ専用と思われるので、交換してもBIOSが対応しているは、分からん。最悪、CPUが認識不能になる可能性もある。認識出来たとして、対応出来ない場合もある。 まあ、メーカー製マザーボードであれば、CPU交換なんて余計なことなどしない方が無難。どうしても性能向上が必要であれば、買い換えた方がすっきりする。
視聴率が高い番組ほど多くの人が観ていることがわかるからスポンサーは宣伝効果のある高視聴率の番組にCMを流すわけだ。 すると視聴率に合わせて商品も売れたり、売れなかったりするわけ。 しかも今は番組を観ている人の年齢層や性別もわかったりするんだな。 男ばかりが観ている番組に化粧品のCM流しても意味ないでしょ。
排他的論理和（Exclusive OR, XOR, EX-OR）の演算子です。 演算子の記号の説明は参考URLの中に書かれています。 以下の添付図に計算を書きます。 演算は対応するビット同士で行います。
この場合、( Q' )' を Q にしたらダメです。 回路図見ればわかりますが、 Q' は 、信号 Q を not回路で反転させたものではありません。 Q' というのは、ただの端子名です。 安定状態では not Q = Q' になる、というだけです。 not演算に ' ではなく、not を使えば Qｎ＝not( (not S)・Q')＝S＋(not Q') Q'ｎ＝not( (not R)・Q)＝R＋(not Q)　 ということです。 S＝１、R=０、Q＝０、Q’=1の時 S+(not Q')＝1＋0＝１ R+(not Q)＝0＋1＝１ となっても、次の瞬間には S+(not Q')＝1＋０＝１ R+(not Q)＝０＋0＝0 となり、 S+(not Q')＝1＋1＝１ R+(not Q)＝０＋0＝0 で安定します。
「なんですか？」では、どこまで答えていいのかさっぱりわかりません。 国語辞典的に短い日本語での説明が欲しいのであれば、Googleなどで検索してWikipediaでも読んでみてください。詳しい理論を数式レベルで理解したいのであれば、教科書を買って勉強してください。
半角スペース２個を全角スペース１個に変換しています。 import java.applet.*; import java.awt.*; public class **** extends Applet implements Runnable {　　//****はアプレット名 　　Dimension d; 　　Thread kicker = null; 　　Image offs; 　　Graphics grf; 　　public void init() {　　　　//初期処理 　　　d=getSize(); 　　　offs=createImage(d.width, d.height); 　　　grf=offs.getGraphics(); 　　} 　　public void run() {　　　　//ここは触らなくて良い 　　　　Thread.currentThread().setPriority(Thread.NORM_PRIORITY-3); 　　　　while(kicker != null) { 　　　　　　repaint(); 　　　　　　try { 　　　　　　　　Thread.sleep(100);//動作が遅い場合は数字を小さくする（ミリ秒） 　　　　　　} catch(InterruptedException e) {} 　　　　} 　　　　kicker=null; 　　} 　　public void update(Graphics g){　　//ここは触らなくて良い 　　　　paint(g); 　　} 　　public void paint(Graphics g) { 　　　grf.setColor(Color.white); 　　　　　　　　　　　　　　　　　　　　//ここで画面を作る 　　　g.drawImage(offs,0,0,this); 　　} 　　public void start() {　　　　　　　//ここは触らなくて良い 　　　　if(kicker == null) { 　　　　　　kicker = new Thread(this); 　　　　　　kicker.start(); 　　　　} 　　} 　　public void stop() {　　　　　　　//ここは触らなくて良い 　　　　if(kicker != null) { 　　　　　　kicker = null; 　　　　} 　　} }
240を二進数にすると　11110000　です。 0の部分がホスト部になるわけですから　0000　～　1111　の間がホスト部として利用できます。 0000　はネットワークアドレス、1111　はブロードキャストアドレスですから、残りの　0001　～　1110　がノードに割り当てられることになりますので、14ノードにIPアドレスを割り当てられます。 単純に計算するなら 256 － 240 ＝ 16 ネットワークアドレスとブロードキャストアドレスの2つを引いて　14　ノード分。 （上位3オクテットが255ならこれでも計算できる）
ITと言う言葉は広すぎるので、まずはどこを目指すかが大事だと思います。 大雑把にわけると、ITを作り出す人向けの学問と、ITを使う人向けの学問に わかれています。使う人向けの話は勉強しても面白くないかもしれません。 大学で習う情報処理の話ならば、作る人向けには必須の内容だとおもいます。 これは専門学校では習えませんから、将来的に得をするとおもいますよ。 例えばですが、 町を歩いていて面白いソフトや製品に出会ったとします。 友人と会話しながら、ぼんやりと、どんな風に作られているか、次々と内部 の構造や応用している技術等が脳内に想起され、 これならば、別のものにも応用できるとおもい、にやりとする。 弱電と呼ばれる全ての電子機器とそのソフトウェアを自分で作れると確信する。 作り方がわからない最新テクノロジーは一切ない。 ゲームをしていて気になる動きがあると、クリエーターに助言したくなる。 War系のシミュレーションゲームをしていて、知らない最新ジェット戦闘機 があるのでWikiで調べると、ソフトウェアの開発費用が高騰していることを知り、 憤慨して自分にやらせろ、とおもったりする。 色んな技術に感銘を受けて、自分でソフトをお試しで作りにやりとする。 音楽ソフトが高いので買えないと言う友人の言葉を聞き、 その人のために、それを超える製品を作り、その人のためだけにプレゼントする。 音声通話ソフトを使うと電話が無料に誰かに勧められても、 電話のソフトを作っている友人に申し訳ないので使わない。 その代わり、もっと良い音質のソフトを作り、いやみで友人に送りつける。 会社で仕事のやり方で揉めている同僚がいて、コミュニケーション力で取り成す 同僚がいる。ここで仕事自体を自動化するソフトを作り、仕事ごと無くす。 新製品を調査し、採用を検討している人が海外に視察に行っている人がいたら、 その間に競合製品を作り、一緒に評価してもらう。 安い製品ソフトやシステムを探して、購入手続きを準備している人がいたら、 その間に購入したいソフトと同じものを作ってしまう。 およそ、ITと名のつくものでは全てに対して自分で作れると確信している。 またそれをして食べてきたため、業界にも精通している。 後輩にも本質をしっかりと教えることが出来る。 目に付く全ての製品をライバルとして尊敬し、まけずに趣味で作る。 その一部を仕事で披露し、適当なところで満足する。 時代の先行きを技術方式の変更から読み取り、 市場調査やマーケティングをしている人より早く、社会現象について予言をする。 電気や情報を取り扱った全てのテクノロジーを把握し、自らの手で作れると言うことは、 世界がこの様に見えます。 PC一台とインターネットがあれば、資材も要らずに、自分の余暇時間で出来ます。 また自分の作った製品を売るために、ビジネスを学び、マネージメントを学び、 人のものを売るのではなく、自分のものを売るモチベーションで身につけられます。 ここで、努力しても売れないため、何が間違っているのか悩み、 人間としての成長が必要であったり、心の質を高める必要があったり、 文章や歌の上達が必要であったり、色んな足りないものに気がついて身につけます。 これらについて努力が出来るのは、最初の「自分でこれだけ作れる」 と言う喜びがあるため、他に欠点があると勿体無いと思えるからです。 せっかくだから、そうした弱い部分も人並みにして、すごい自分にしちゃおう。 多くの「意味がない」と思えてきた、小中高、大学、大学院での勉強。 これらをソフトウェアでプログラムし、利用できる形にすると、何とも感動的です。 人が作ったものを使うだけだったら、使うたびに落ち込んだでしょう。 なんて、自分はちっぽけなのだろうと。 そうした分岐点に質問者さんはいるのだと思いますよ。 手っ取り早く何かが作れると言う事。 買ったほうが早いと分かっていても、自分の尊厳のためには大事なのです。 学校の勉強に取り組むとして、 「これが分かると何が作れるようになるのか？」 また、 「これを作りたいのだけど、何を学べばいいのか？」 こうした思いを先にして、単に「自分にあっている」だけで捉えないほうが良いかと思います。 情報、電気、ネットワーク、全てが手の内にあると言う感覚を得られるのが、 ITを学ぶ魅力じゃないかとおもいます。 以上、ご参考になれば。
No3です。 演算プログラムを見て計算量評価をしたのかと思ったら違うのですね。 やはり単純に計算量評価が間違っているだけでした。 なんというか、ここまで見事だとあなたのためにならない気がしてくるんですが… お示しのデータをプロットしたものが添付画像です。 青が乗算、赤が剰余算です。 剰余算が遅いというような言い方でしたが、これを見ると剰余算は綺麗に(lg n)^2となっています。 剰余算が遅いのではなく、乗算が速いのです。 これ、プロットすれば一発で分かることなんですよね。 で、参考までに、あなたも名前を挙げたカラツバ法の計算量はO(n^1.585)らしいですね。(こちらのnは桁数) http://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%A9%E3%83%84%E3%83%90%E6%B3%95
大学（高専）の宿題なら、原則解答はありません。 教科書や演習や授業で解答を作るだけの情報が得られるはずです。 なので、自力で宿題の解答は作れるはずですし、作らないと大学生としての実力がつきません。 前半のYの論理式を式にしたがって、論理式をC-MOSゲートに置き換え部分回路を相互に接続して 作ったYのC-MOS回路の全体図を描いて添付しますので参考にしてください。 論理回路図は論理式の変形によって、部分回路が変わり、解答は１通りとは限りません。 回答が正しいかどうかの確認は、真理値表を作成して一致するかで確かめるといいでしょう。 （C-MOS回路図が煩雑になるので、P-MOS、N-MOSのサブストレートは省略してあります。） 後半は自力でやってみてください。 YのC-MOS回路図を求めて添付してくれればチェック致します。
　＞よろしくお願いします。 　ペンフィールドの地図のことかな。 　ホムンクルス、とも呼ばれたりするやつ。
非常に難しい問題ですね。私にはマトンは羊の肉という認識しかありませんｗ
まず興味がわかないものを覚えるのは苦痛だし効率が良くありません。 Androidアプリに興味があるのなら、素直にAndroid開発環境でJavaをやるべきです。 そして自分が作りたいものを作るべきです。 そのためにどうするかだけを四六時中考えてください。 書籍やネットで他の方が書いたコードは非常に参考になります。 それを元に自分なりに改変を加えていくのが一番の上達への近道となります。 一つも習熟した言語が無い段階で、複数の言語を学ぼうとするのは他の方と同じ理由でお勧めしません。 他はボチボチでもいいでしょう。 ただし、Cについて学べる機会があるなら、卒業までにポインタを完璧に身に着けておくことをお勧めします。 Cをしっかり覚えることは、後々、いろんな意味で役に立つことがある…かも知れません。 RubyはJavaを覚えた後なら大丈夫です。簡単なので。
System.out.print((char)('a'+i)); でも System.out.printf("%c",'a'+i); でも可。
今試してみましたが動きますよ？ 恐らく提示されていない、UserForm1の中の何かが間違っています。 以下の2サイトがそのまま参考になると思います。 http://okwave.jp/qa/q4218152.html http://hpcgi1.nifty.com/kenzo30/b_cbbs/cbbs.cgi?mode=al2&namber=20966&no=0&P=R&KLOG=136 ちなみに、 1. VBEの左側：プロジェクトの部分で右クリック 2. 挿入→ユーザーフォーム 　 自動的にUserForm1ができあがると思います。 3. 表示→プロパティウィンドウ 4. プロパティウィンドウが左下に出るはずですので、 　　(オブジェクト名)が UserForm1 になっているか確認。 で、このオブジェクト名が間違っていると「変数がどうたら」といった別のエラーになりますね。
　おそらく「UserForm1.Show」のところがエラーで黄色く染まっているんだと思いますが、そこにエラーはありません。 UserForm1のコードをもう一度点検してください。 エラー箇所はInitilizeのプログラミングの中です。 Private Sub UserForm_Initialize() ・・・・ End Sub この中で途中で「Stop」を追加して1行ずつエラーがないか確認してみてください。
要はWEBサーバーの構築ですよね？ http://www.obenri.com/_webserver/
（1）補完的な事前分布 （２）監督の信念ネットワーク （３）現象を離れて説明 だと思います。 間違っていたらすみません…。 Google 翻訳　http://translate.google.com/?hl=ja
まず、「起動しない」の具体的な意味を書いてください。 プレーンテキストのメールの場合には、単に URL と認識されていないだけ、ということもあります。 (1) 一致していない可能性はあります。 しかし、その際には、ブラウザが起動して、アクセスした後で、文字化けなどが発生することとなります。 通常は、ブラウザの設定や、現在表示しているサイトで使用されているもの等で決めます。 また、OSはあまり関係ありません。 重要なのは、どのコードを使ってエンコードするか、デコードしたものをどのコードとして解釈するか、です。 　WindowsからShift_JISをエンコードしたものを送信して、UNIXサーバーでデコード後Shift_JISとして解釈 　UNIXサーバーからEUCでエンコードしたURLを、WindowsのInterner Explorer で表示 などは、大昔から行われています。 (2) Macも10年以上前からOS X になり、Unicode(UTF-8)が標準になっています。 UNIX/Linuxでも、UTF-8を採用するものが主流になっています。 WindowsではUNICODEですが、Shift_JISもまだまだ多く使われています。 (3) URLエンコードされたURLを貼り付ければ、文字コードによる違いは出ません。
とりあえず、Live起動できるものでHDDにインストールしないでも使えるものから試す。 ってところですかねぇ……。 あとは目的をもう少し明確にすること。 情報収集の仕方を調べること…でしょうか。 >こっちのほうが良い。LinuxはじめたらWinには戻れない。 私的にはまだクライアントとして使うならWindowsの方が使いやすいですけどねぇ。 # Windows8は微妙すぎるのでアレですが。 サーバとして使うならもちろんLinuxですが。 # Debianが1台、CentOSが2台動いてます。 あとは…大きめな本屋などに行って、PC関係の書籍の棚からLinux関係の書籍でも探してみて下さい。 まぁ今だとCentOSかUbuntuあたりになると思いますが。 ディストリビューション比較とかやっているサイトくらいあると思われます。 とりあえず使ってみたい。 というのであれば、VMWareかVirtualBoxで仮想マシン作って触る。って程度でいいかと思いますけどねぇ。
ディストリビューションが不明なので確認は出来ませんが、 下記をご参照ください。 http://itpro.nikkeibp.co.jp/article/COLUMN/20060227/230892/
図中の入力端子と出力端子の記号がよく見えません。 A3,B3がそれぞれ、最上位桁ですか？最下位桁ですか？ それとも A4,B4がそれぞれ、最上位桁ですか？最下位桁ですか？ 出力端子の文字記号（添字数字付き）と各桁の桁上がりの英字記号（添字数字）は何ですか？ 回路図は上から順に、半加算器、全加算器が３つ並べてあるだけで、半加算器のけた上げ出力を下の下位桁けた上げ上げ入力に接続し、各全加算器のけた上げ出力を直ぐ下の下位桁けた上げ上げ入力に接続して構成されています。最上位桁のけた上げ出力はそのまま出力端子として出ています。 各全加算器は半加算器２つとORゲートで構成され、半加算器はXORゲート（和出力用）とANDゲート(けた上げ出力用)で構成されます。 例えば 　A4 A3 A2 A1　...被加数 +)B4 B3 B1 B1　...加数 -------------- 　S4 S3 S2 S1　...和 　C4 C3 C2 C1　...上位桁への桁上げ >回路をトレースして2進数「1101と1110の和」を求めよ A,Bの各桁の記号、下位桁からのけた上げの出力と上位桁へのけた上げ入力の各桁の記号、各桁の和の出力の記号を決めてください。 この場合の 　1 1 0 1 +)1 1 1 0 ------------ 　1 0 1 1 ...和 　1 1 0 0 であれば例えば (+)をXOR,　・をAND, +をORの演算子とすると A1(+)B1=1(+)0=1=S1 A1・B1=1・0=0=C1 (A2(+)B2)(+)C1=(0(+)1)(+)0=1(+)0=1=S2 A2・B2+C1=0・1+0=0+0=0=C2 (A3(+)B3)(+)C2=(1(+)1)(+)0=0(+)0=0=S3 A3・B3+C2=1・1+0=1+0=1=C3 (A4(+)B4)(+)C3=(1(+)1)(+)1=0(+)1=1=S4 A4・B4+C3=1・1+1=1+1=1=C4 となります。
インターネットを利用するときに求められるルールやマナーを教えようということです。 アメリカは知りません
＞メディア（情報・媒体）とは何ですか？ 書いてある通りです。ただし、情報・媒体でなく、情報媒体です。 情報媒体とは、情報を伝えるための媒体（仲介役となるもの）のことです。数とか、視覚・聴覚の別、機能、性能などは一切関係ありません。 メディアの例は、昔なら、新聞、雑誌が代表的なものでした、その後はレコード、音楽やビデオのテープ、ちょっと前はフロッピーディスク、CD、今はDVD、USBメモリなどでしょう。 また、ラジオ、テレビもメディアと呼ばれることがあります。もちろん、インターネットも。 しかし、電話、電報は、メディアとは呼ばないように思います。(なぜかは知りません。) なお、数は関係ないと書きましたが、１：多数のものをマス メディアと呼ぶこともあります。 もうお分かりでしょうが ・実体物（あらゆる商品） ・サービス（接客、マッサージ、教育、医療など） は情報を伝えるための媒体ではありませんね。
戻りの型が　int, this.dataの型は int[][] なんだから 当然です。 どういう動きを想定されていますか やりたいことは return this.data[line][column]; とかではないんですか？
シンプソン法は任意の曲線を分割して、各分割内の曲線を放物線によって近似し、面積を求めるものです。 近似すべき相手が放物線というのであれば近似でなく、厳密解として積分ができるわけです。 もちろん分割には関係ありません。 ∫(α→β)[f(x)]dx=(1/6)(β-α)[f(α)+4f((α+β))+f(β)] が成り立つことを計算で示せばよいでしょう。左辺は解析的積分、右辺はシンプソン法ということがわかりますか。
まず、rp = fopen(IN, "r")にてファイルを読み込みモードでオープンしています。 それが成功するとTRUE、失敗するとFALSEが返ってきます。 !は否定形で、!(rp = fopen(IN, "r"))にてFALSEだった時という意味になります。
間違いはwhile(1)ですね。 それを直せばコンパイルは成功します。 勉強法は、初心者のうちは教科書のプログラムを参考にしつつ、数多くの問題を自力でプログラムして解くことかな。 大学の情報系学科ではスパルタでやらされます。 あとは、エラーは英語表記でも読んで理解すること。 また、配列や動的メモリ確保を行うと「セグメントエラー」を経験します。初心者のみならず上級者にとってもやっかいなエラーです。 ちなみに、total = total + input_number(); は、total += input_number(); のように書けます。
「大学の研究は就職しても役には立たない」と、卒業のとき教授に言われました。 その通りでした。 有名大学であるとか、企業と共同研究やっていてコネがあるとか、そういうのでもなければ就職に有利とかはほとんどありません。 就職しても、大学の研究とは関係無い仕事に就くことも少なくありません。 就職の有利不利を重視するなら、卒業生の就職状況を調べてください。 その2つからは採用0で、他の研究室からはコンスタントに採用されている、ということもあるかもしれません。
>なぜ１なのかが曖昧… くどくどと書けば、 　H[e^(jω) ] = { c + be^(-jω) + ae^(-j2ω) }/{ a + be^(-jω) + ce^(-j2ω) } 　= e^(-j2ω)*{ c + be^(-jω) + ae^(-j2ω) }/{ c + be^(jω) + ae^(j2ω) } 右辺にて、最初の項　e^(-j2ω)　の絶対値は明らかに 1 。 続く分数式、 　{ c + be^(-jω) + ae^(-j2ω) }/{ c + be^(jω) + ae^(j2ω) } では、{a, b, c} が実数なら分子と分母はたがいに共役値。 つまり、分子と分母の「絶対値」は相等しい。 　　　
>最近授業でてきたピアノの楽譜みたいな横線で、1と0の状態を表すものが理解できないです これはタイミングチャートと呼びます。F=A・Bのような論理式の右辺に現れる記号A、Bは入力信号の記号で0や1の値をとります。左辺のFは出力信号の記号で出力の値（0または1）は論理式の右辺の式から決まります。 タイミングチャートは入力信号の記号（A,Bなど）を縦に並べ、一番下に出力信号（Fなど)を並べます。横方向に時間軸をとって、入力信号と出力信号の時間変化を縦方向の振幅（0や1）として描きます。 この際、多くの場合、全ての入力信号（A,Bなど）の全ての組合せ 例えば 2入力A,Bの場合 (A,B)=(0,0),(0,1),(1,0),(1,1) の4通り 3入力の場合 (A,B,C)=(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1), (1,1,0),(1,1,1)　の8通り がある時間帯に現れるようにタイミングチャートを描きます。その際、入力信号の各組み合わせに対応して出力信号Fを論理式(F=A・Bなど)から計算して、タイミングチャートの一番下に0,1の振幅で描きます。 入力信号の縦方向の並び順は自由ですが、通常はアルファベット順に並べます。 また横方向（時間軸方向）には、入力信号の組合せの現れる順は自由ですが、縦方向にみてある時間帯に、全ての入力信号の組み合わせが少なくとも1回は現れるように入力信号を組み合わせを考えて描いていきます。 なお、ゲート回路という簡単な論理式の場合でも、入力信号が３以上、出力信号が２以上となる論理回路存在しますので、論理式も複数出てきて、論理出力も複数（F,G,H,…など）になる場合もあります。その際も、タイミングチャートは縦方向に入力信号の記号を並べたあと、その下に出力信号の記号を並べて時間経過ととともに、全ての入力信号の組み合わせが少なくとも1回は現れるようにタイミングチャートを作ります。 また 更に発展して、ゲート回路ではなく記憶のある論理回路の論理式の場合は、入力信号の組み合わせが現れる時間的な順番が出力信号に影響するようになるので、入力信号の組み合わせも時間的な要素も考えて、現れる順序を考えて、全ての出力が現れるようにタイミングチャートを作らないといけません。授業で、順序回路、フリップ・フロップ、記憶回路が出てくる時には、この点を注意して、先生の講義を聴くといいでしょう。 また、入力信号の全ての組み合わせは、一次元真理値表の左側に縦方向に並べて、書き漏らしのないように、全ての組み合わせを描きます。真理値表も1次元の後には、二次元真理値表やカルノー図などが講義の進度に合わせて出てきます。しっかりと勉強してください。
$result = mysql_query('select * from main_t where keyword[1] ='.$keyword[1]); の部分で$keyword[1]が文字列なら、"で囲まなければいけません。つまり、 $result = mysql_query('select * from main_t where keyword[1] ="'.$keyword[1].'"'); または、 $result = mysql_query("select * from main_t where keyword[1] =\"$keyword[1]\""); とすると正しく反応するのではないでしょうか。
http://www.slideshare.net/masaya0730/ux-16051909 に書いてあるスライドには千葉工業大学の先生と載ってます。 ここなら勉強できる可能性があるのでは？
機械的にやるならスラック変数と人工変数を導入した 2段階シンプレックス法.
>(次第に、ミスし易くなってきたけど…) 　=SUMPRODUCT(G2:G1000,EXP(-$A$2*(F2:F1000)) なのかな？ 　　
ftpで受信する場合は受信完了が検出できないと 処理が難しくなる場合があります。 送信側で最後にリネームすることをお勧めします。 #拡張子を変えるとかすると完了後に見えるようにできます。
当方のような「一般人」は 10 進法しか使いませんので、その路線でも。 >10進法の11を2進法で… 10 進法に慣れておれば、 　11 を 2 で割って、その余り 1 を (2^0) の桁の数字とし、商 5 の 2 進表示勘定へ。 　　　　　　↓ 　商 5 を 2 で割って、その余り 1 を (2^1) の桁の数字とし、商 2 の 2 進表示勘定へ。 　　　　　　↓ 　商 2 を 2 で割って、その余り 0 を (2^2) の桁の数字とし、商 1 の 2 進表示勘定へ。 　　　　　　↓ 　商 1 を 2 で割って、その余り 1 を (2^3) の桁の数字とする。 …で終了。各桁の数字を羅列すると 1011 。 それが答案。 「答案」の験算は、上記勘定の逆算で…。 2 進 1011 = 1*(2^3) + 0*(2^2) + 1*(2^1) + 1*(2^0) 　= 8+2+1 = 11 >2進法の11101を10進法で表しなさい。 「上記勘定の逆算」をなぞれば、できます。 　　　
単純に不特定長の数列に、なんらかの数列が反復されているかを判定するプログラムを作成することは可能です。 基本的に、何らかの規則性があるものであれば、全て作成可能です。 そのようなソフトやソースコードが、 Webに落ちていたり誰かが持っているかというと、答えはNoに近いと思います。 なぜなら、必要性も汎用性も乏しいから。 そう言った場合に解決する方法は、 自作するしかありません。 アルゴリズム的には 反復が含まれると判断できる最低の長さから有限の長さの数列(元の数列とする)で 文字列の先頭からn文字抜き出す。 n+1文字目からn文字抜き出す。 比較する。 nは1から元の数列の長さの半分の整数の範囲でループ 比較して一致したものが反復されている数列 あとは自力でどうぞ。
大学の授業内容についてはOpenCourseWare 或いはオープンコースウエアとして公開されていますのでWikipediaやネットで調べることが出来ます。 他の方が最近次の質問等をされていますので、参考になるかと思われます。 http://sqa.scienceportal.jp/qa6577355.html 大学入学までの物理の勉強 http://sqa.scienceportal.jp/qa6577547.html 大学の授業の導入に向いてるような物理の参考書を教え その他左上の検索窓やネットで "情報工学科" "情報工学科 参考書"　等として調べて下さい。 電磁気学等、数学が必要な科目が多くなり高校で自信があっても全く新たな基礎から理解する必要が出てきますので頑張ってください。 http://okwave.jp/qa/q5653918.html 中学レベルから大学受験までの道のり その他一般的なサイト: http://itpro.nikkeibp.co.jp/index.html http://www.atmarkit.co.jp/ http://www.pdftutorials.com/index.html http://wave.iobb.net/doc/digital/ http://www.ie.u-ryukyu.ac.jp/~wada/lecture.html http://www.aozora.gr.jp/ http://www.gutenberg.org/wiki/Main_Page http://www.gutenberg.org/wiki/Gutenberg:The_Audio_Books_Project
こんにちは どちらがいいでしょうか？という２択一というよりも 受験日がずれてる限り、両方受けて、合格したら理工＞工で選べばいいです ただ日本大学工学部って福島県ですよ http://www.ce.nihon-u.ac.jp/access.html 理工学部は東京の駿河台と千葉の船橋 http://www.cst.nihon-u.ac.jp/campus/access.html 場所が全然違いますけど、その２つのどちらか？という話なんですか？ 日本大学理工学部をメインにするならば 併願校としては 芝浦工大、東京都市大学（現武蔵工大）、東京電機大 これらあたりの大学かと思われます http://www.yozemi.ac.jp/rank/gakubu/index.html ＞パソコンのウイルスを探したりシステムを作ったりする ソフトウェアエンジニア系ということだと思いますが どっちの学部学科でもＯＫです ＞あと、現在日大レベルですが頑張れば来年「農工大」のレベルに上げる可能性ってある＞と思いますか？ ＞塾の先生は「基本無理」といっています。 ＞ご意見お聞かせ下さい。 お子さんを身近に見ていて、成績を知ってる塾の先生が無理っていうなら 無理なんでしょう。赤の他人が、がんばれば行けますよ！と言っても根拠はありません
カリキュラムはどの大学でも公開していると思います。たとえば、情報処理学会のWEBサイトにあるコンピュータサイエンスのモデルカリキュラムと志望校のカリキュラムを比べてみましょう。 チェックポイントは ・情報工学の先生だけで学科が構成されているか、「電子情報」のように寄り合い所帯か ・情報の専門の先生だけか、電子とか通信の先生が紛れ込んでいないか。 などもチェックポイントです。 ・情報科学の中枢に近い専門の先生が多いか、ちょっとずれた専門領域(人工知能、自然言語、そのたコンピュータを道具として使う側の分野)か ・教育体制はしっかりしているか(たとえば、卒論が選択科目なんて言う大学は期待できません ・学生数と専任教員数の比率 電磁気学とか電子工学の基礎科目ばっかりやらされれて情報科学関連の科目が少ないとか、情報工学科なのにハードディスクの真空蒸着が卒論のテーマだとか、ひどいところもありますので。 >ネットだとSEやPGなら文系でもなれるからそれこそ大学行かなくてもなれる たとえば、建築作業員なら、高卒どころか中卒でもなれます。でも、その働く内容も待遇も、大学の建築学科を出て建築会社の正社員になったひとと、日雇いの作業員では全然違う・・というのは理解できますよね。 SEやPGも同様です。とにかく人手が足りないので、未経験者でもドンドン雇いますが、あくまでも使い捨て要員としてです。まともな待遇がほしければ、ちゃんと専門教育を受けるか、独学で実力をつけるか。 確かに、ハードウェアを専門にやってると、博士課程を出ても民間機魚にばんばん就職できたりしていますが。..
通信制で帝京大学理工学部情報科学科があります。 その他、編入学などに関しては下記サイトへお問い合わせが出来ます。 http://www.teikyo-u.ac.jp/faculty/science/sci0600.html
旧東京商船大学の歴史を背負っているので、「情報」を必ず物流と結びつけて研究しているそうです。 いわゆるロジスティックスということになりますが、ほとんど国内では独壇場のようです。 http://www.logistics.or.jp/link.html#C 他がリンク先研究室とか研究科段階なのに、海洋大学のみ大学にリンクですもの。 同程度の偏差値の情報工学に行くのであれば、お買い得かも。 情報系の仕事も、パソコン関係だけに限定されているより、物流が絡むとプロジェクトが巨大になります。郵政民営化とかの時代背景を見ると、これから成長産業かも。
大学でパソコンなんて学べませんよ。どこの情報工学科でも、パソコンの使い方くらいはリテラシーとして教えることもあるでしょうが。 挙げておられる大学の中では理科大は他より難易度が高いでしょう。それから東京電気ではなく東京電機大ですね。理科大も電機大も学部によっては田舎（失礼）です。 同じレベルかどうかわかりませんが、法政、工学院、武蔵工大、東京工科大などもあります。明治も文系でなくて情報系ならそんなに難しくないように思います。
基本的に情報科学は理学部にも分類されることがあるくらいなので、数理的な部分(アルゴリズムなど)を学ぶことが多いです。 また、電気電子や通信、工学といった名前が付いている学科名はは必ずといっていいほど実験がつき物です。つまりハードの部分は必修として習います。どちらの学科に行っても両方を学ぶことはできますので、将来情報系に行きたいのであれば、情報科学系を専攻してハードを学ぶのが一番だと思います。とくに、理学部でなくて、工学、理工学部に属している情報科学科がいいと思います。
情報のことは良く分かりませんが、名前だけでは決められないと思います。 例えば、Ａ大学の情報工学とＢ大学の情報工学では内容がぜんぜん違ったり…何ていうことも良くあります。 また、Ｃ大学の情報工学とＤ大学の情報科学が同じなんていうこともあります。 名前だけでなく、カリキュラムや卒論を詳しく調べた方がいいと思います。
