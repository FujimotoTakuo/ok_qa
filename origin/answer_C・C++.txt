＞"#define WATCH_FUNC"という宣言がみつからないので、#else以下が起動しているようです（どちらも同じコードですが・・・） 「WATCH_FUNC」が未定義なら「#ifndef」は「もし未定義ならば」になるので、#elseより「上」が実行されています。 つまり「OS_ENTER_CRITICAL();の無い方」が実行されてます。 ＞このような値を設定している意味がよくわかりません。 ＞それぞれのレジスタは8bitのレジスタとH8S2368のデータシートには記述されていますが、16bitの値をを代入しているのでしょうか？ レジスタは「バイトサイズ」ですけど「書き込む時はワードサイズで、上位８ビットを特定の値にして書き込みしないと、値がセットされない」ように作られてます。 これは「プログラムが暴走して、メモリを無茶苦茶に書き換えてしまった時」に「不正にレジスタが書き換えられるのを防ぐため」です。 バイトサイズで書き込んだ場合は「書き込み動作が無視される」ようになっていますし、ワードサイズで書き込む時に上位バイトが特定の値以外の時も「書き込み動作が無視される」ようになっています。 読み出す時は「レジスタの中身は書き換えないので、普通にバイトサイズで読み出せば良い」です。 ＞なので、なぜこれでシステムリセットがかかるのかも不思議です。 これでシステムリセットがかかるのは「ウォッチドックタイマーが正常に働いているから」つまり「無限ループに入って、ウォッチドックタイマーをリセットしなくなるので、ウォッチドックタイマーで割り込みが実行され、割り込みルーチンでシステムリセットされるから」です。 つまり、結論は「ちゃんとウォッチドックタイマーが実装されてる。それでもハングアップするとしたら『どこかで割り込み禁止状態のまま無限ループに落ち込んでる』か、『どこかでウォッチドックタイマーを停止したまま無限ループに落ち込んでる』か、『どこかでウォッチドックタイマーをリセットし続けながら無限ループに落ち込んでる』のどれかだろう」という事です。
おっと失礼。こうですね。 #include <stdio.h> #include <math.h> double f(double x) { return x * x - x - 1; } double g(double x) { return 2 * x - 1; } double solve(double x0, double e) { double x; while (1) { x = x0 - f(x0) / g(x0); if (fabs(x - x0) < e) { return x; } x0 = x; } } int main(void) { double x0 = -2, eps = 1e-5; printf("%f\n", solve(x0, eps)); return 0; }
こうしたいのかしら? #include<stdio.h> float wa(void); int main(void) { 　float a; 　a = wa(); 　printf("%f\n",a); 　return 0; } float wa(void) { 　float l = 0, i, m, n, x, b; 　for (i = -2; i <= 0.00005; i++) { 　　x = i; 　　l *= i; 　　m = x*x - x - 1; 　　n = (2 * x) - 1; 　　b = l - (m / n); 　} 　return b; }
で、幾つも問題点があります。このプログラムは、修正してエラーが出ないようにしても、正常に動きません。 問題点１点目。 test[piyo][hoge] = NULL; この行はメモリを壊します。OSが例外を発生してプログラムが停止します。 testの配列は「test[0][0]～test[piyo - 1][hoge - 1]」までしかありません。 １次元目の要素番号に指定できるのは「0」から「piyo - 1」までです。 ２次元目の要素番号に指定できるのは「0」から「hoge - 1」までです。 問題点２点目。 while (fgets(buf, hoge, fp) != NULL) { 「bufのメモリに、何度も読み直し」をしているので、strtokで返って来たポインタを配列に記録しても無意味です。 「２回目のfgetsを行なったら、１回目にfgetsした後のbufの内容が壊れてしまう」という事を理解して下さい。 つまり「fgetsは１行につき、１回しかやってはいけない」のです。 なので「while文で、同じメモリに読み込むfgetsを繰り返す事はできない」です。 問題点３点目。 if ((fp = fopen("testfile.csv", "r")) == NULL) { printf("\aファイルをオープンできません\n"); }else{ 略 } fclose(fp); オープンエラーが出た時、if文の処理が終わると、fpがNULLなのに「fclose(fp)」を実行してしまいます。エラーの時は「後始末だけやって、続きの処理をしない」ようにしないといけません。 問題点４点目。 for (k = 0; k < hoge; k++) { ary[k] = strtok(buf, ","); } strtokの使い方が間違ってます。 以下を参照して下さい。 http://www9.plala.or.jp/sgwr-t/lib/strtok.html 上記を踏まえて、修正して動作するようにしたのが、以下のプログラムです。 #include <stdio.h> #include <stdlib.h> #include <string.h> #define piyo 11 #define hoge 2900 int main(void) { 　　FILE *fp; 　　//１行hoge文字分のバッファを、piyo行分、用意する。 　　//念のため、バッファは「１文字分余計に」確保しておく。 　　char test[piyo][hoge + 1]; 　　//分離したトークンのポインタを覚えておく配列。 　　//piyo行分、１行につきhoge個分。 　　char *ary[piyo][hoge]; 　　int i, k; 　　//aryを初期化する。 　　for (i = 0;i < piyo;i++) { 　　　　for (k = 0;k < hoge;k++) { 　　　　　　ary[i][k] = NULL; 　　　　} 　　} 　　//ファイルを開く 　　if ((fp = fopen("testfile.csv", "r")) == NULL) { 　　　　printf("\aファイルをオープンできません\n"); 　　　　//エラーならretuenして、それ以上処理しない 　　　　return(0); 　　}else{ 　　　　//piyo行分、繰り返す 　　　　for (i = 0;i < piyo;i++) { 　　　　　　//testのi行目のバッファに読み込む。 　　　　　　//１行繰り返すごとに、test[0]の先頭、test[1]の先頭、test[2]の先頭 　　　　　　//のように、読み込むバッファのポインタを変える。 　　　　　　if (fgets(&test[i][0], hoge, fp) == NULL) break; 　　　　　　//末尾の改行を\0（EOS）に書き換えて、改行を削り取る。 　　　　　　strtok(&test[i][0], "\n"); 　　　　　　//列番号kを初期化。 　　　　　　k = 0; 　　　　　　//一回目のstrtokの呼び出し。 　　　　　　ary[i][k] = strtok(&test[i][0], ","); 　　　　　　//strtokがNULLを返すまで繰り返す。 　　　　　　while (ary[i][k] != NULL) { 　　　　　　　　//列番号を１つ増やす。 　　　　　　　　k++; 　　　　　　　　//列番号が限界に達したら諦める。 　　　　　　　　if (k >= hoge) break; 　　　　　　　　//２回目以降のstrtokの呼び出し。 　　　　　　　　ary[i][k] = strtok(NULL, ","); 　　　　　　} 　　　　} 　　　　fclose(fp); 　　　　//結果を表示する。 　　　　for (i = 0;i < piyo;i++) { 　　　　　　for (k = 0;k < hoge;k++) { 　　　　　　　　if (ary[i][k] != NULL) { 　　　　　　　　　　printf("ary[%d][%d]=[%s]\n",i,k,ary[i][k]); 　　　　　　　　} 　　　　　　} 　　　　} 　　} 　　return(0); } で、このプログラムは、結局は http://okwave.jp/qa/q9216423.html の当方の回答と「ほぼ同じ事」をしています。 違うのは「今回のは、１行づつ１１回読み込んで処理するが、前回のは、必要なメモリを動的に確保して、一気に全部読み込んで処理する」という点と「今回のは、改行の扱いをfgets任せにしているが、前回のは、自前で改行を判定して処理する」という点です。
#include <stdio.h> #include <stdlib.h> int main(void) { FILE *fp; char *fname = "./test1/test2/201509/test.csv"; char *buf; long fsize,cp; int rc,lc,cc; char *array[11][1500]; fp = fopen(fname,"rt"); if (fp == NULL) { printf("%sファイルが開けません\n", fname); return 1; } fseek(fp,0L,SEEK_END); fsize = ftell(fp); fseek(fp,0L,SEEK_SET); buf = (char *)malloc(fsize + 1); fsize = fread(buf,1,fsize,fp); if (fsize == 0) { printf("%sファイルを読み込めません\n", fname); free(buf); fclose(fp); return 1; } fclose(fp); for (lc = 0;lc < 11;lc++) { for (cc = 0;cc < 1500;cc++) { array[lc][cc] = NULL; } } buf[fsize] = '\0'; array[0][0] = buf; for (lc = 0,cc = 0,cp = 0;cp < fsize;cp++) { if (buf[cp] == ',') { buf[cp] = '\0'; array[lc][++cc] = &buf[cp+1]; } if (buf[cp] == '\n') { buf[cp] = '\0'; cc = 0; array[++lc][cc] = &buf[cp+1]; if (lc == 11) break; } } for (lc = 0;lc < 11;lc++) { for (cc = 0;cc < 1500;cc++) { if (array[lc][cc] != NULL) { printf("array[%d][%d]=[%s]\n",lc,cc,array[lc][cc]); } } } free(buf); return 0; }
元のcsvファイルはどうなってるの？ testtesttest,testtesttesttest testtesttesttest,～ とか？ > 理想 > [0][0] = [testtesttest] > [0][1] = [testtesttesttest] > 一行が終わりしだい > [1][0] = [testtesttesttest] > と変わっていくようにしたいです。 文字列を格納する -> １次元配列が必要 カンマで区切られた複数の文字列を格納する -> ２次元配列が必要 カンマで区切られた複数の文字列が複数行あるcsvファイルを格納する -> ３次元配列が必要 なのでは？
opendir関数、readdir関数を検索すれば答えが見つかると思います。 もっと言えば「c言語 ファイル一覧」で検索すれば、色々とヒントは出てくると思います。 ＃ここに質問するよりも早く、少ない労力で回答にたどり着けると思いますよ。
たぶん、相対パスにしたいのかと。 パスの先頭にピリオドを追加してみたらどうでしょうか。 "./file/d20151001.csv" ピリオドひとつはカレントディレクトリ、ピリオド二つ（..）なら一改装上のディレクトリを指します。
if (tumochusen[i] < (400 / nhai[i])) { というように比較していますが，これって意図通りなのだろうか？ まず400 / nhai[i]はint/intだから答えはintにしかならない。(切り捨てです。) tumochusen[i]は，rand() % 100を計算してdoubleにしていますが，実質的にはintです。 比較は，doubleとdoubleの比較にすべきなんじゃなかろうか？ 他にはrand()を使うのならsrand()は使わないの？とか，そもそもrand()を使うべきなの？とかありますが，大勢には影響ありません。 もう一点だけ。 平均巡目はsum / SIMULATEでいいのだろうか？これについてはよくわからないので明確な言い方は避けますが，全員が無作為に打牌するわけではないという事実を完全に無視していますよね。それで求めた計算にどれほどの意味があるのだろうか？ 少なくとも，自分からは見えていない牌の集合を考えて，そこから各プレイヤの手牌を推測した上で，ツモる牌の確率分布を考えるといったことまでしないと，計算がかなりずれそうです。実際にどういう計算をすればよいかは聞かないでください。私も答えは持っていません。 ちなみに，あなたが書いたプログラムでも18巡目にならないものだけを取り出して，その平均を取れば9巡目くらいにはすぐなりますよ。
scanf_s("%s", temp); を scanf_s("%s", temp,19); にする。 scanf_sは「%sを指定する場合は、入力バッファのポインタと、入力バッファのサイズを引数に指定する」ことになっています。 この１ヶ月で「まったく同様のエラーで質問している投稿」を３回も見ました。 たぶん、お使いの参考書は「scanf_sの使い方を間違って記載している」のでしょう。 もし宜しければ「このサンプルプログラムが掲載されている書籍の名前、著者、出版社名、ISBNコード、掲載ページ」を教えて頂けませんか？
＞sprintf((char *)str,"%04dZ",pass16); ＞この記述が1行入っただけで暴走してしまうのか大変不思議に思っております。 sprintfの書式指定の"Z"が「長さ修飾子」として機能していると思われます。 sprintf((char *)str,"%04d\x5a",pass16); として下さい。 なお、printf系関数の「書式を書く部分」に sprintf((char *)str,"%04dM1#",pass16); sprintf((char *)str,"%04dZ",pass16); のように「特定の文字、文字列を指定する」のは「書式の修飾子として判断される危険があり、意図した結果にならない場合がある」ので、事故の元です。 こういう「思わぬ事故」を防ぐ為、多少、冗長になってしまうのを承知の上で sprintf((char *)str,"%04d%s",pass16,"M1#"); sprintf((char *)str,"%04d%s",pass16,"Z"); と書くようにしましょう。
エラーメッセージに書いてありますよ。 30行目　FILEが定義されていません。 これはstdio.hをincludeするのが常套手段です。 36行目　NUMBERが定義されていない 突然NUMBERなんて書かれてもコンパイラにはわかりません。どこかに定義がありませんか？
＞fnameに対してどういった動作をしているのでしょうか？ scanf_sは、%sを書式に指定する場合、バッファのポインタの次に「バッファのサイズ」を指定します。 この時、キーボードなどの入力から「指定サイズを超える文字列」が入力された場合、scanf_sは「バッファへの代入を行なわないで呼び出し元に戻る」ようになっています。 つまり「バッファを越える文字列が入れられたら、fnameに何も代入しない」のです。 この時、scanf_sは「代入を行なった項目数」を返すので、scanf_sが「1じゃない値を返した場合」には、fnameには「何も入っていない（というか、メモリのゴミ、不定な値が入っている）」事になります。 もし「入力に成功した」のであれば、scanf_sは「1」を（代入を行なった回数を）返す筈です。 つまり「1以外が返って来た時は、ファイル名のキーボード入力が成功しなかった」のです。 なので「scanf_sが入力に失敗して1じゃない値を返した場合」には「return(0)」を実行しています。 ＞return(0)を返しているのでしょうか？ 違います。「return(0)を実行している」のです。つまり「main関数の処理を終了している」のです。
CF_HDROPとDROPFILES構造体について調べてみてください。
コードを読む限り、コードの間違いは２点で 一つ目 scanf_s("%s",ch) ではなく scanf_s("%s",ch,10) 二つ目 str_char関数の引数は２個なのにmain関数内で呼び出している時の引数が３つになっています。 no = str_char("ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz", ch[0]); ではなく no = str_char("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", ch[0]); が正しいコードだと思います
>前の方のお礼コメントにも書きましたが、func2が呼べるのが謎です。 謎も何も、そのC++処理系がそのようなコードを出力する処理系だというだけの事です。 例えばint CSub::func()が次のようなCソースと同等にコンパイルされ int CSub_func2(CSub *this) { return this->m_nSub1; } CSub::func2()の呼び出しが nRet = pSub->func2();// (*4) ↓ nRet = CSub_func2(pSub); のようなコードと同等ならばpSubの値がCParentのインスタンスだろうがCSubのインスタンスだろうが関係なくCSub::func2()が呼び出されます。
スクロールバーのメッセージ生成の特殊性と、MessageBoxの弊害が組み合わさって起こる現象のようです。 通常のウィンドウをクリックした場合、メッセージは1回(というか一組)しか送信されませんが、スクロールバーの場合はマウスのボタンを押し続けることでメッセージが連続して発生するようになっています。通常の状態であれば、マウスのボタンを離すことでメッセージの生成は止まるですが、MessageBoxを生成することによって別のメッセージループがメッセージ処理を行うことになり、その際にスクロールバーにボタンが離されたことが通知されなくなってしまいます(生成されたメッセージボックスがアクティブウィンドウになり、ボタンを離したメッセージがそちらに送信されるためだと思います)。そのため、スクロールバーのボタンの上にマウスカーソルがある状態だと、スクロールバーがメッセージを送信し続けてしまうようです。
> プロパティを変更し、ビルドしたものを別のPCにいれて検証すると、メッセージが表示されてしまいます。 OpenCVがDLLを欲しがってるんじゃないかしら? static-libraryをリンクしましたか?
> スパナボタン押してみました・・・ > プロパティページが表示されるのですが > そこからどう設定したらいいか分かりません。 > 「構成プロパティ」に全般があるだけです。 んなわけないんだけどなー...
#1の補足を見ました。 ＞これは”1パケットで構成したいデータ長は20msec以内にUARTでESP-WROOM-02に流し込みなさい。” ではなくて、 「パケットを分ける際には間隔を20ms開けなさい。」 ということだと思います。逆に言うと、1パケットにしたいときはデータの送信間隔を20msより小さくしてください。ということになります。 話は変わりますが、送信データ中に￥0(0x00,ゼロ)が含まれていませんか？strlen関数でデータの長さを求めているので、￥0が現れた時点で送信が終わってしまうと思います。
確認済みでしたらごめんなさい。 http://www.kohgakusha.co.jp/support/library_cgame/index.html こちらにあるサンプルは、 書籍のものより新しいかもしれないです。 directx書籍についての情報です。 http://www.pg-naruniha.jpn.org/books/directx.htm http://garicchi.hatenablog.jp/entry/2014/05/24/182340 こんなのもあります。 http://qiita.com/em7dfggbcadd9/items/483c60fa066f10f510d7
WM_INITDIALOGは、 表示される前に来るメッセージなので、 動作としては正しいです。 プログラムの可読性が低くなるかもしれないですが、 最初のセットフォーカスやアクティブだとか、 ダイアログ内のコントロールのメッセージを使うとか、 というやりかたです。 いずれにしても、１回だけ行うためのロジックは、 自作する必要があります。 (フォーカス系でメッセージボックスは問題ありか？) またはメッセージボックスは使わないで、 ダイアログ内のコントロールを、 一時的に変えるってやりかたもあります。 あ。 WM_INITDIALOGで、ユーザー定義のメッセージを自分になげて、 そのなかでやればいいかな？ ま、いろいろ試してみてください。
この話でしょうかね？ https://social.msdn.microsoft.com/Forums/vstudio/ja-JP/3ded9f7e-6b4b-491d-8aac-60b6ecb15d9a/mfc?forum=vcgeneralja GetWindowRectが返すサイズの単位はPixelですが、リソースエディタでの単位はdialogUnitなのです。解像度の異なるディスプレイで表示しても見た目のサイズが変わらないようになっている、ということです。なのでpixel単位でのサイズは変わることになります。 常にPixel単位で同じサイズに表示したい場合は、ダイアログボックスにはしないで、CreateWindow等で通常のウィンドウとして作ることになります。その場合はウィンドウのcallbackも（DlgProcではなく）WndProcとして自分で作る必要があります。
追加のご質問に返信いたします。 >>やり方が間違っているでしょうか？ すみません。具体的な操作まではわからないです。 とりあえずご案内したかったことは、 ソリューションとプロジェクトの関係と、 VSの内部動作についてです。 ひとつのアプリを作成するとき、 exeとdllというように分けて作成することがあります。 このexeやdllはそれぞれがプロジェクトです。 それをひとまとめにするのがソリューションです。 そういうわけでソリューションに表示されても、 プロジェクトに入っていない可能性を、 ご案内したかったのです。 私は過去のバージョンを触ったことありますが、 テキトーにファイル追加しても、 コンパイルは通らなかったので、 ソリューションとプロジェクトを新規に作り直し、 って対応した記憶があります。 解決に直結してなくてごめんなさい。
> ”MSVCP120D.dllがないため、プログラムを開始できません。” DLLファイルのbasenameが'D'で終わっていることから、Debug-modeのDLLでしょう。 Debug-DLLは配布が許されていないのでコピー先に存在しないのも無理からぬこと。 実行モジュールもしくはそれが依存しているライブラリがDebug版であると推測されます。
処理時間が0秒になるのは計測誤差以下の作業しかしていないためです。 たとえば Bsort(data, SIZE); を for(i=0; i<1000; i++) Bsort(data, SIZE); にしてみれば，値が確認できるでしょう。 なお，(double)(t2 - t1) / CLOCKS_PER_SECで出てくる値の単位はmsではなくてsですよ。
unsigned long v; (略) v = (unsigned long)va_arg(args, long); switch (*p) { case 's': outs_sci0((char*)v, c); break; case 'c': outc_sci0((char)v, c); break; case 'd': case 'o': case 'x': outn_sci0(*p, v, c); } を char *vp; int vi; char vc; （略） switch (*p) { case 's': vp = (char *)va_arg(args, char *); outs_sci0(vp, c); break; case 'c': vc = (char)va_arg(args, char); outc_sci0(vc, c); break; case 'd': case 'o': case 'x': vi = (int)va_arg(args, int); outn_sci0(*p, vi, c); } にせんといかんよ。 何故なら mprint_test_sci0("test value %d %d %x %x \n\r",1,1,1,1); ってやると、可変引数の「1,1,1,1」は「16ビットのintが４つ渡される」から。 なお、%d、%o、%xは、今はint（16ビット幅。0～65535）までしか出力できないから char *vp; int vi; long vl; char vc; bool lf; （略） if (*p == '%') { lf = false; p++; if ((*p >= '1') && (*p <= '9')) { c = *p++ - '0'; while ((*p >= '0') && (*p <= '9')) c = c * 10 + (*p++ - '0'); } else if (*p == 'l') { p++; lf = true; } else c = -1; switch (*p) { case 's': vp = (char *)va_arg(args, char *); outs_sci0(vp, c); break; case 'c': vc = (char)va_arg(args, char); outc_sci0(vc, c); break; case 'd': case 'o': case 'x': if (lf) { vl = (long)va_arg(args, long); outn_sci0(*p, vl, c); } else { vi = (int)va_arg(args, int); outn_sci0(*p, vi, c); } } とか、新たに「longバージョンの%ld、%lo、%lx」とか作って、呼び出す際に mprint_test_sci0("test value %d %ld %x %lx \n\r",1,1L,1,1L); とやって「可変引数に渡した数字はlongであることを明記」してやれば、long型も使える筈。 なお、この改造は「デバッグしてない」ので、バグっているかもしれない。 プログラムを直さないで、今のまま使うなら mprint_test_sci0("test value %d %d %x %x \n\r",1L,1L,1L,1L); とか mprint_test_sci0("test value %d %d %x %x \n\r",(long)a,(long)b,(long)(a + 4),(long)(a + b)); とかって感じで「数値の引数は必ずlongで渡す」ってやれば良い。
再頒布可能パッケージはココにあります。
system("cls");//クリア dungeon(pc, mc);//ダンジョンの表示 この２行を、ダンジョン＆ステータスを更新したいつど記述すればよいのでは？１カ所にしか記述できないということはありませんので。 たとえば、上記２行を「○○は倒されてしまった・・・」と表示する直前にも追加してみてはどうでしょうか。
#if 関連を拾ってソース構造を見やすくしてみると、 ------------ #ifdef CONSOLE_DEBUG 　　（ここにcharget()などが記述してある。mprint_tst_sci1()の定義はしていない） #else 　　（ここにmprint_tst_sci1()が記述してある） 　　　#if 1 　　　　　　#ifdef H8TINY_USB 　　　　　　#endif 　　　#endif 　　（ここにouts_sci1()などが記述してある） #endif ------------- ひとつ目の#elseの前にmprint_tst_sci1()の記述がくるようにしてはどうでしょうか。 あと、引用元のコードは、「H8TINY_USB」が定義されているときにシリアルポートに出力するような記述だと思いますので、#ifdef H8TINY_USBの箇所はそのように修正が必要かと思います。
構造体メンバが、構造体の先頭から何バイト目にあるかを得るマクロ「offsetof」を使うと良いと思います。 #include <stddef.h> number = offsetof(a_z,xx); //先頭が0としてのオフセット位置を得る
printf()とは別にprintf2()のような関数をデバッグ用に用意するほうが簡単です。 今あまり時間がないのでとりあえず関係ありそうなサイトを紹介しておきます。 http://www.mm2d.net/main/prog/c/printf-01.html わからないところは補足で質問してください。
whileの中にprogramが変更されるようなコードがないため、最初に-9999を入力した場合以外は無限ループになってしまいます。
共通のヘッダファイルをincludeする。 http://d.hatena.ne.jp/saitodevel01/20110321/1300685958 これを参照してください。
VS2012はプロパティ・マネージャをサポートしてませんでしたっけ? 新規にプロパティ・シートをひとつ作り、そいつにモロモロ設定しておけば、 次回からはプロパティ・シートをプロジェクトにアタッチするだけで モロモロ設定完了です。
このソースだと、 Aのポインタは、NULLで初期化後に、コマンドライン引数１のポインタをセット。 Bのポインタ（格納するメモリーの場所）は、NULLで初期化 Bのポインタをtest()関数に引き渡し　（なのに、test()側では、それをポインタのポインタで受取り） そのNULLの位置は格納場所として確保されていないので"ABCD"をコピーした時点で、セグメントエラー。（コンパイラやOS次第だけど） なので、 A,Bにはバイト数制限はありますか？　 という問いついては、 ・Aは、コマンドライン引数の１つ目を示すargv[1]をポインタを使っていて 　これは、実行時に自動でメモリー確保されているので、 　バイト数制限は、コマンドライン実行時の引数１の文字の長さということになります。 ・Bは、そもそもメモリーが確保されていないので、1バイトさえない、ということになります。 なお、 10行目 test( B ); ↓ test( &B ); １６行目 strcpy(B,"ABCD" ); ↓ *B = malloc(strlen("ABCD")+1); strcpy ( *B , "ABCD"); 　もしくは、１行で *B = strdup("ABCD"); と、メモリーを確保してからコピーするようにすれば、Bにバイト制限はなくなります。
>>その出力結果というのが、いわゆるMS-DOSのコマンドウィンドウなので、そこに表示されているものをコピーアンドペーストする方法がわかりません。 コマンドウインドウが表示されている状態で、 ・ウインドウタイトル部を右クリック-＞編集－＞範囲指定->マウスでウンドウ内を範囲指定 ->タイトル部を右クリック->編集->コピー ->さくらエディタソフトなどのの編集画面に移動して->右クリック->貼り付け ->エディタより印刷 とします。 >>コマンドウィンドウではなく、Visual Studioの「出力」ペインにリダイレクトする設定などがあるのでしょうか。 こっちの出力ウインドウなら、素直にマウスで範囲指定して、右クリック->コピー->エディタソフトの編集画面に貼付け >>これを印刷すると範囲のほとんどが黒色で埋まってしまう形なので、インクがすぐなくなってしまいそうです。 ソフト開発をする場合、参考にしたいドキュメントや、プログラムソースを大量印刷することが多いですよ。 私は、コピー用紙を５００枚*５パック単位で買っていますけど、２、３ヶ月で無くなります。 印刷コストと印刷スピードを考えたら、絶対にレーザプリンターを用意したほうがいいです。 私は、Ａ３対応のモノクロレーザと、インクジェットプリンタを使っています。 インクジェットは、年賀状とか名刺印刷用で、年に数回使うだけです。 レーザーは毎日のように利用しています。 やっぱり、デバッグには、ソース印刷して行うほうが効率的です。 資料は印刷して通勤電車の中などで読む。 （資料やソースは、スマホやタブレットだと読むのがメンドクサイんですよね。やっぱり紙のほうがいい。 ちなみに、マンガを読むのも、ＰＣやスマホの画面じゃあなく、本で読みたい派です）
標準ではないです。 描画処理のプログラミングがしたいなら、先ず、どんな描画処理を行うかを決めて、そのライブラリとヘッダーファイルを自分で用意する必要があります。古典的な３DグラフィックならOpenGLなんてのもありますし、まあ探せば色々あると思います。 取り敢えずHello Wordが出来たようなので、次はもっと一般的なHello World辺から．．．
ポインタを使わない場合、質問文にあるような自動変数だとスタック上にインスタンスが作成されます。スタックサイズが小さい場合でインスタンスのメモリが大きい場合は、スタックがオーバーフローします。newで作成した場合一般的にはヒープ上に作られますから、比較的大きなメモリが使える場合が多いのではないでしょうか。 インスタンス生成とはチョット違いますが、引数で渡すときに、大きな違いが出てきます。値渡しだと、引数で渡される度にコピーコンストラクタが実行されて、スタックを喰い潰していきます。ポインターであれば、コンストラクタは実行されないですし、どんなのサイズの大きいインスタンスでも、ポインタのサイズ分しかスタックを消費しません。
プロジェクトの中に 拡張子 .c または .cpp のついたコードは含まれていますか?
>>わざわざC++でWPFでアプリを作る必要はないのでしょうか？ C++/CLIで開発の仕事を行っていた時期があります。 その当時読んだ資料によると、 ボタンやテキストボックスを表示するWindowsアプリは、Ｃ＋＋よりも、Ｃ＃やＶＢで作るほうがずっと楽。 Ｃ＋＋は、過去のソフト遺産を生かす場合、ハードに近い処理を行う場合に使う限定的用途が多い。 ってことが書かれていたように記憶しています。 >>そこで、WPFでアプリを作る利点を知りたいです。 たぶん、画面の表現力がWinFormよりも高いってことだと思います。 ただ、ユーザとしては、画面にそこまでの高機能な表現力を求めない人も多いでしょうから、開発がやりにくいWPFはあまり広まってない気がします。 >>WPFは簡単にWindowsアプリを作れるとあるのですが、MFCや.NET FrameWorkで作成して も変わらないのでしょうか？ 簡単にアプリが作れるってなれば、言語はＣ＃を選び、.NET Frameworkを使う。GUIはWPFではなく、WinFormを選ぶことになると思います。 当然、これ以外を選ぶと、アプリ作成は手間が増えます。 ただ、ちょっと前から日本では、「プログラマって３Ｋ職でブラックだよね？正社員でもない非正規の派遣が多いから、仕事にしないほうがいいよね」という風潮が広まったと思います。 その結果、プログラマをめざす若い人が減り、プログラム関連の専門書が売れなくなってきました。 書店自体も減少していますが、お店は残っていても、コンピュータ関連の専門書コーナが消えてしまったりしてます。 まあ、「必要な情報はネットで得るから、専門書は買わない！」という人が増えたのも理由のひとつだと思いますが。 まあ、そんなこんなあって、アプリ開発の最新技術を日本語書籍で得るのが、ちょっと難しい状況になっている気がします。 私の場合、アプリ開発に必要な技術情報は、海外の英文サイトから得ることが多くなっていますね。 日本語サイトだけだと、情報が得られない・・・。
ざっくりstrtokで改行も弾いて関数使いまくり','に置き換えました やはり文字列飲み込んで"カウントして切り貼りしなきゃいけないかな #include <stdio.h> #include <string.h> int main(void){ char str[] = "\"100,AAA,002\",\"1,B\nB\"2B,,B3\",\"1CCC,\n,\"2\"3,4\""; char *point = str , mem[10][30] = {{}} , co_1 , co_2; for(co_1 = 0; (point = strtok(point,",\n")) != NULL; co_1++){ if(*(point+(strlen(point)-1)) != '"'){ strcat(strcat(mem[co_1],point),","); co_1--; }else{ strcat(mem[co_1],point); } point = NULL; } for(co_2 = 0; co_2 < co_1; co_2++) printf("%s\n",mem[co_2]); return 0; }
その送信のプログラムは問題無いです。 WriteFileの戻り値は、成功すれば「１」で失敗すれば「０」ですが、これはどうなっていますか？ あと、dwWrittenには実際に送信できたバイト数が入ります、それは６が入っていませんか？ 戻り値が失敗だったり、送信データ数が少なかったら、通信相手や他の問題だと思います。
0x00 は、NULL という「文字」のコードですから、もちろん送れます。 送れないのは、文字列の最後を示すのに NULL を使っている処理系では、「文字列として読み込みをしたら、そりゃNULLで止まる」というだけのことで、バイナリデータとして読み書きするルーチンや関数を用いれば済むことです。
bmpでは正しく動くとなると、ちょっと原因がわからないですね・・・。 Windows10のペイントでpng形式で保存すると、使用はしていないければアルファ情報が含まれていたりするのかもしれないですね(完全に推測です…)。 画像サイズが大きくても問題ないのでしたら、 ひとまずはbmp形式でプログラム進めていったほうが良いかもしれないですね。 原因特定は時間かかりそうですし・・・。
struct.packとstruct.unpackを使います。 http://docs.python.jp/2/library/struct.html サンプルは、「Python struct」で検索すると見つかります。
-o が保存名指定のオプションですから その指定である -o list1210 を残しておけばいいです。
エラーではなく、警告(warning) なので、「本当に意図した書き方なの？大丈夫？」と言いながら、実行ファイルはできているはずですよ。 while(*str = toupper(*str)){ は、「while() の中は条件文にするのが普通で、それなら等値である意味の == で書かないと条件文にならないけど、本当に、toupper() 関数が str ポインターに代入した値そのものを真偽値として条件判断に使っていいの？」という警告内容。 *str++; は、「*str++; って増加させた後、str を使っているところが見当たらないんだけど、本当にいるの？」という警告内容。これは、前の警告の while() の中で使っているのでいいんだけど、それがコンパイラでは気付けないほど凝った技を使っているから。
>print(len(test))これをやった時の結果が"1212"と表示されるので、うまくいったと思ったのですが・・・ その"1212"は1212バイトではなく、testが管理している配列の要素数が1212個ということだと思いますけど。 NumPyでバイト列を扱いたいのでしたら test=np.array([0x88,～略～,0x45], dtype=np.uint8) になるんじゃないでしょうか。 あとPythonのNumPyについては、この質問見て知った位なので詳細な使い方を聞かれても困ります。
利用するライブラリの動作要件をよく確認することをお勧めします。 > 32bit/64bit版でそれぞれ別のlibを使うように指定されています。 この説明の「32bit/64bit版」というのは、 「32bit Windows/64bit Windowsでそれぞれ別のlibを使うように指定されています。」 という意味ですか? それとも 「32bitアプリ/64bitアプリでそれぞれ別のlibを使うように指定されています。」 という意味ですか? Windowsでは、32bitライブラリは32bitアプリからしかリンクできず、 64bitライブラリは64bitアプリからしかリンクできない制約があるため、 Windows用ライブラリは、どちらのアプリからでもリンクしてもらえるよう 32bitライブラリと64bitライブラリの両方を提供しています。 つまり通常は後者の意味で2種類のライブラリを提供します。 一方、アプリは 64bitアプリは64bit Windows上でしか動作できませんが、 32bitアプリは64bit Windows/32bit Windowsどちらでも動作できますから、 両方で同じ動作をすることが求められるアプリは、通常は32bitアプリを作ればいいだけです。 64ビットアプリを作るのは、4GB以上のメモリ空間を使いたい等、64ビットの能力を フルに使いたい時だけです。
回答ではなく"確認"ですけど: STR.ReadLine() は 改行までを読み込んでくれるのでしょうか? であるなら、クライアント側は文字列の末尾に改行をくっつけて送信せんと いつまでたってもReadLine()から抜けてくれませんけど。
>型定義しておいて、他のcppでこの定義を使っているのが不思議な感じがするのです。 ヘッダファイルの基本的な使い方の一つです。 ヘッダファイルの中身が少なすぎるように思いますか？ おそらく、ヘッダファイルを編集することによってビルド時に再コンパイルが必要になるソースファイルの数を抑えることが目的なのでしょう。 ヘッダファイルを一部でも変更すると、そのヘッダファイルをインクルードしている（依存している）ソースファイルは、その変更と全く関係なくても再コンパイルが必要になってしまいます。 これを避けるために、ヘッダファイルの中身から関連性の強いものだけを抜き出して別のファイルに分離する、ということはよく行われます。凝集度を上げるとも言います。
VCなら __FUNCTION__ や __FUNCDNAME__ を使うんじゃないの https://msdn.microsoft.com/ja-jp/library/b0084kay
最大公約数はそもそもどうやって求めるか分かっていますか？ それとも単純にタイプミスでしょうか？ vx&vy ↓ vx%vy なお、return の返値全体を括弧で囲むのは、文法間違いではありませんが、普通はしません。 なので、 return vy == 0 ? vx : gcdf(vy, vx % vy) ;
Formのコンストラクタ内で初期化できない場合があるようですね。 参考URLにある通り、Shownイベントを追加しその中でdrawしてみてはどうでしょうか？
確か、通りがけ順を使うと小さいものから探索するはずです。 小さい方からN番目が求める答えではないでしょうか。
ご賢察のとおりです。 int *p1,*p2; じゃないと、ともにポインタとしての宣言になりません。
Ｑ１）できますよ。ネットで検索してみてください。
はい、プロジェクトからlibファイルを指定できます。
TBM_SETRANGEの説明(英文)が下記URLにあります。 https://msdn.microsoft.com/ja-jp/library/windows/desktop/bb760221(v=vs.85).aspx ここで、 ＞ Because this message takes two 16-bit unsigned integer values, the maximum range that this message can specify is from 0 to 65,535. To specify larger range values, use the TBM_SETRANGEMIN and TBM_SETRANGEMAX messages. という解説がされています。範囲の指定が16ビット値2つになっているので、指定できる範囲が0～65535になる。この範囲を超える値を指定するには、TBM_SETRANGEMINとTBM_SETRANGEMAXを使って最大値・最小値を別々に指定するようです。
動作するものができておめでとうございます。 余計なところとかありますが、おいおい覚えていってください。 質問についてですが、objがどこからも参照されなくなればGCの対象となります。 button1_Click()内でしかobjが参照されていないので、button1_Click()が終了するとGCの対象になります。 しかしbutton1_Click()が終了してすぐに開放されるかというとそういうわけではなく、GCが行われるタイミングで開放されます。 頑張ってください。
Class1にForm1型のプロパティを作成し、そのプロパティにClass1 objを作成した時にthisを渡して保存し、Class1の方でそれを参照しましょう。
char型で扱う文字コードはunicodeですから、sjisコードでの値を用いたところで勝手にunicodeでの値に変換してくれたりはしません。
mbstring.hがない事が原因なのは確かですが そのmbstring.hは、Windows向けのCコンパイラ(Visual C++など)で用意されているmbstring.hの事だと思いますから MacのCコンパイラでは用意されていないんじゃないかと思います。 どこかの誰かが互換ライブラリを提供してくれている可能性までは否定しませんが。
CではNULLは(void*)0と定義されるので、それを整数型をtypedefしたMCIDEVICEIDやDWORD_PTRに代入しようとすると警告されます。 C++にすると、NULLは単なる0と定義されるので、整数型に代入可能になります。 あくまでVisualStudioでの話で、他の環境では定義が異なる可能性はあります。
.Start(); ここの部分をメソッドとして定義し、外側の{から}までをメソッドの本文にする。 { AllocConsole(); //開始============== for(uint i = 0;i < 100;++i) { Console.WriteLine("Hello " + i); } FreeConsole(); //終了============== } そのメソッドをThreadStartの引数にし、そのThreadStartをThreadの引数にします。 その戻り値で.Start()を呼び出す良いかと思います。
> これはParam_p()という配列が呼ばれたら、m_parentParam_pの値をParam_p()という配列に入れなさいという意味でしょうか？ フツーに解釈すれば、m_parentParam_pのポインタ変数の指している先のモノの、Param_p()関数を呼び出してreturnしろって処理です。 「->」はメンバーアクセス演算子です。 メンバー アクセス演算子: . および -> https://msdn.microsoft.com/ja-jp/library/b930c881.aspx > VarA*とアスタリスクが出ている意味が分かりません。 VarAがクラスだか構造体だか分かりませんが、それへのポインタを返す関数Param_p()ってことでは。
こんな感じになるかなと思います。 private void Form1_Move(object sender, EventArgs e) { //動かした時に強制的に高さの位置を調節する。 Rectangle rect = Screen.GetWorkingArea(this); this.Top = rect.Height - this.Height; } private void Form1_Load(object sender, EventArgs e) { //初期位置の設定 Rectangle rect = Screen.GetWorkingArea(this); this.Top = rect.Height - this.Height; this.Left = 0; }
Formの方に、publicなメソッドを定義しその中でmouseClick(...)を呼び出すようにして、Workerクラスからは追加したpublicメソッドを呼び出すと希望に近いものが出来るかもしれません。 但しmouseClick(...)でFormの描画に影響する処理があった場合うまくいかない可能性があります。 その場合は参考URL先を見てみてください。 頑張ってください。
object型で代用するくらいで同等のものはないです。 https://msdn.microsoft.com/ja-jp/library/dd297709.aspx
やりたいことはこんなことかしら? #include <iostream> #include <functional> typedef std::function<void(void)> func_type; class Class2 { func_type mFunc; public: void runFunc() { mFunc(); } void setFunc(func_type func) { mFunc = func; } }; class Class1 { int i = 0; void func() { std::cout << "Hello world #" << i << std::endl; } public: func_type get() { return [this]() { func(); }; } }; int main() { Class2 c2; Class1 c1; c2.setFunc(c1.get()); c2.runFunc(); }
夏のオリンピックは４年ごと（西暦が4で割れる年)で その2年後に冬のオリンピックがあります（冬のオリンピックとしては４年ごと） なので、 ４で割れたら（余り＝０）夏季五輪 ４で割れずに２で割れたら冬季五輪 それ以外はオリンピックなし。になります。
printf("%d x %d" = %d\n", a, b, c) にて真ん中の”Ｘ”が16進コードの演算子%X　と見られているのではないでしょうか？ X　を外してみてください。
あくまでifの中は真か偽かで判断するようにしましょう。 num%2はnumを2で割ったあまりを求めているので、「割り切れたら」が「真」ではありません。 「あまりが0でない」が「真」です。 「割り切れたら」を「真」にしたいなら、条件は「余りが0である」になるので if ((num%2)==0) になります。
Visual Studioの話なら選択後は、Ctrl + K押下、Ctrl + Fだったはず。
freadの仕様をよく確認しましょう。 思い当たる原因がないと書かれていますけど警告が出てるはずです(コンパイルオプションで警告を出力しないとかしてなければですが)。
#1です。 関数counter_functionは int counter_function (Counter * c, int a) こんな感じで定義されているのだから，この関数へのポインタを宣言するときは int (*counter_function)(Counter * c, int a) こんな感じで宣言しますよね。 で，これにキャストするときは int (*)(Counter *, int) をつけてやればよい，と言うのがCの文法です。
> 一つ気になることがあるのですが、一番変更してはいけないidが >一番変更しやすい設計になっているのは割り切って考えればいいんでしょうか？ はい、割りきってしまって良いと思いますよ。 もし何か変更条件を追加したくなった場合には、SetIdに条件を追記すればよいかと。
access関数を使うのが一般的なようです。 1.4 Fortran ライブラリルーチンリファレンス (Sun Studio 12: Fortran ライブラリ・リファレンス) https://docs.oracle.com/cd/E19205-01/820-1201/aetbk/index.html 　　INTEGER*4 access, status 　　status = access ( 'xxx.dat', ' ' ) ! 空白モード 　　if ( status .eq. 0 ) write(*,*) "ファイル存在" 　　if ( status .ne. 0 ) write(*,*) 'ファイルはない', status > Cでの処理が参考になるかも知れません。 PathFileExistsなどのWin32APIなんか使う方法もあると思います。
numerical recipe in cの16章2項がadaptive stepsize control for runge kuttaです。 cのプログラムも載っていますよ。 http://www.aip.de/groups/soe/local/numres/bookcpdf/c16-2.pdf
引数の型などが同一の場合は、コンパイルエラー（曖昧な呼び出し）になります。 同一でない場合は、簡単にいえば必要な型変換が少ないほうが選択されます。
No1です　編集ミスってました WritePrivateProfileString はそれだけでファイルの作成・書き込み・クローズを行いますので （WindowsAPIです） ＞StreamWriter writer = new StreamWriter("Config.ini", true); とか言ったことを自前で行う必要がありません Console.WriteLine との組み合わせで作成されたファイル 上書きしてるのではないでしょうか ReadPrivateProfile の時はファイルが無ければデフォルト値がセットされます(パラメータ） ほとんど必要ないと思いますが 関数の戻り値で正常かを判断する必要はあるかもしれません
.Net 2003の場合の確認方法のようですが、 2005でも同様に確認できないでしょうか？ 参考URLページ最下部に確認方法がまとめられております。 >【BMP のインポートが出来ない】
実行中のファイルは、Windowsによってロックされているため、書き込みを行うことはできません。 また、文字列部分のみを書き換えても、実行ファイルが破損していないかチェックするための値があり、実行時にチェックされるため、ファイルが壊れていると判定されて実行できなくなります。 他の方法を考えましょう。
>これがクラス内では定義できないのは、この関数自体こういった動きをする関数で、プロトタイプ宣言でしかできないという理解で良いでよろしいでしょうか？ プロトタイプ宣言がどこから出てきたのかわかりませんが >// これはでない・・・ >const Complex operator+(const Complex x, const Complex y) >{ > >} はプロトタイプ宣言ではありません。 +演算子関数がそういう仕様だからとしかいいようがないです。 Complex a; Complex b; a + b; // a.operator+(b); とも書けます。
＞ほとんどの入門書ではプログラム終了直前に必ず開いたハンドルを閉じるように書かれているのですが・・・。 後始末を習慣づけるためだと思います。 ただ、「終了直前に閉じる」と書いてるとしたら、良くない本です。「使い終わったら閉じる」というのが正しい考え方です。 １つのプロセスから同時にオープンするファイル数には上限があるので、何十ものファイルを順次読んでいくプログラムの場合、読み終わった段階で閉じないと、そのうち上限に達して開けなくなります。 習慣づけ以外としては、読む人に、「これ以降はこのファイルを使わない」という情報を与えるためです。「変数のスコープはできるだけ狭くすべき」というのと同じですね。 また、プロセス外の共有資源(セマフォなど)をカーネルに依頼して確保したようなケースだと、これはプロセスが終了しても（プロセスの外なので）自動的に解放されないので、明示的に解放が必要なはずです。
添え字の範囲の検査が必要です．作り変えてみました． // 配列の添字 left ～ right の部分を，pivot の値より小さい要素と，大きい要素に分割し pivot の位置を返す関数 int Array::partition(int left, int right) { int ipivot = left + (right - left) / 2; int pivot = array[ipivot]; //基準 Array::swap(&array[left], &array[ipivot]); //基準値を先頭に退避する int j = right; //右からの処理位置 int i = left + 1; //左からの処理位置 while (true){ while (array[j]>pivot){ j--; } while (i <= j && array[i] < pivot){ i++; } if (i >= j) break; this->swap(&array[i], &array[j]); i++; j--; } this->swap(&array[left], &array[j]); //基準値をPartition位置に戻す return j; }
> int num=right-left; 個数はright-left+1だよね。 > int t=0,l=left,r=middle; rはmiddle+1から始まるよね。 > while(l<middle&&r<right){ > while(l<middle){ > while(r<right){ l=middleでもr=rightでも実行させるべきだよね。
(1)は公開されているライブラリを使えばデータにアクセスできると思います。 参考URLはC#向けのライブラリを使った解説となっているようです。 (2) こちらはちょっとわからず申し訳ありません。
MFCにはなかったと思います。 zlibを使うのが手っ取り早いかと。 http://zlib.net/
　８ビットの頃からアセンブラでプログラムを作っていましたが、処理能力が低いパソコンではアセンブラは必須で、アセンブラでソフト開発しなければ処理能力が低過ぎて使いものにならないのが実情です。 　アセンブラでプログラムが作れるだけの技量を持っていれば、ソフト開発中に処理が間に合わない問題が起こったり、プログラムのコード数を減らす必要が生じた時に、アセンブラでコーディングすることで解決出来る例が多いようです。 　今では、アセンブラを使わなくても、高級言語で開発した方が開発速度が早いですが、どうしても処理が間に合わない問題が生じることがあり、その時はアセンブラで補うしかありません。
SendMessage( hwndEdit, EM_GETLINECOUNT, 0, 0) ; で行数を取得して，文字数を調節してやればいいんじゃないの？
DEV-C++を使った事ありませんがエラーメッセージの内容的に書かれたソースコードに問題があるわけではなくコンパイラが異常終了してるようです。 ですのでDEV-C++のインストールが正常に行えてるのかどうかの確認が必要かと思います。 またDEV-C++の開発は2005年2月でストップしているようでサポートOSがWindowsXPでストップしてますので、もしかしたらご使用の環境では正常動作しないのかもしれません。
publicの付け方が間違ってないか？
提示されたソースの部分だけ見ると問題ないように見えます。 ソース全体を見せていただけますか？（特に #include のあたり）
あ、とりあえずようやく1点、決定的におかしいと思うところが現れました。後述します。その前に少し確認させてください。 >Invalidate(FALSE);で画面の再描画を行い、この次にWriteBitmap(); をしているにも関わらず、再描画される前の状態で出力が行われます。 再描画される前の状態、つまり冒頭の「起動時の画面が取得されてしまう」ということに繋がっているということですよね。動時の画面というは「真っ黒画面」でしょうか？ 一応確認ですが、glutSwapBuffersをコメントアウトされているので、WriteBitmap()内のglReadBufferの引数は「GL_BACK」にする必要がありますが、変更済みですか？ ここでGL_FRONTを指定していると、フロントバッファには何も転送されていない状態なので、黒画像が取得されるはずです。 更に確認ですが、Invalidate関数ってMFCの定義済みメソッドという認識で合ってるでしょうか？ MFCは久しく使ってないので。。 >それと、glGetIntegervした後のalignmentParamには4が格納されていました。 そうでしょうね。glGetIntegervは現在の設定を確認する関数ですが、デフォルトで４なので、確認せずとも４なのは分かりきっているんです。 だからglReadPixelsでGL_RGBを指定するなら、最初から１に変更してしまえばOKです。 本題ですが、もしこの通りのような実装にしているなら、仰る通りの挙動になってもおかしくは無いと思いました。 Invalidate関数が決定的な箇所なんですが、Invalidate関数って先ほども確認しましたが、独自ルーチンではなくMFCの関数ですよね？ そして、OpenGLで頂点配列を使って描画している関数が、恐らく他にあるわけですよね？ MFCはほんと久しいので、なんて呼ぶのかとかどういう挙動なのかよく覚えていないので、最近のC#とかJAVA的な考えになってしまうのでうまく伝わるか不安ですが、 Invalide()で、PAINTイベント(MFCなので厳密に言うとWM_PAINTメッセージですかね・・)みたいなのを明示的に発生させ、その結果実行されるPAINT();みたいな関数(OnPaintだったか・・？)内に、頂点配列などを使って描画しているOpenGL関数がある。そしてvertex変数も、そのPAINT();みたいな関数内で使っている。 という認識、まず合ってますか？ もしそうであるならば、質問者は、Invalidate関数を呼ぶことで、そのPAINT()関数内のOpenGL関数が同期的に実行されていると思われているように見受けられますが、そうでは無いです。WM_PAINTメッセージが吹っ飛んでいくだけで、すぐ次のglFlushとかに移動します。 PAINT()が実行されるのは、WM_PAINTメッセージを受け取って処理された時で、いつ実行されるかは分かりません。 Invalidate関数を呼ぶのではなく、そのPaint();みたいな関数を直接呼べませんか？ ただ、その前に、for文でInvalidateを読みまくってますけど、その必要ってありますか？ forループ抜けた後で十分ではないでしょうか？ とりあえず、以上の点を確認ですね。なんか原因が分かってきた感じはします。
C++の言語仕様自体がアップデートされていて、VC++2010からC11に段階的に対応しています。 C11になるとコーディングスタイルがかなり変わるので、C++に関しては追加でC11に対応した本も読んだ方が良いでしょう。 C11以前のコーディングスタイルを勉強するのは無駄にはなりませんが、より効率的なプログラムが書けるようになります。 サンプルプログラム程度であればソースコードは問題ないと思いますが、プロジェクトの設定や操作画面なんかが違っている可能性があります。 VisualStudioも機能が増えているので、新機能等に関しては古い本には説明が無いので、ネットなんかでチェックすると良いと思います。 プログラミング言語の入門としてはVS2010程度の本でも問題ないと思いますが、ある程度使えるようになったならばネットでC11について調べるか、対応した解説本を読むのをお勧めします。 VS2010はC11に対応していな部分も多いので。 https://msdn.microsoft.com/ja-jp/library/hh567368.aspx#corelanguagetable
C#は言語です、例えばJava、Ruby、C言語とかと同じです .NETはフレームワークです RubyでいえばRuby on Railsなどと同じ役割をするものです .NETを使わずにC#でプログラムを作成することも可能です、しかし.NETを使った方が簡単に作成することが可能です
上の句の列の幅を大きく取って、下の句が画面に入らないようにしてはどうでしょうか？ 見映えが悪いなら行の幅と文字の大きさも大きくしてはどうでしょうか？
i++; をwhileループ終了直前(printfの下あたり)に移動してはどうでしょうか？ whileに入った直後にi++してしまっているので、 fscanfする前のデータで平均値計算やprintfしているのかと思われます。
そうですね、基本的にはmallocやnewの解放忘れはメモリリークにつながると思います。 Windows環境であれば、Windows APIを使って確保したメモリ領域やハンドルリークなどもあったりします。 http://keicode.com/iis/iis504.php C++でしたらスマートポインタを使ってメモリリークを防ぐ方法もあります。 http://qiita.com/hmito/items/db3b14917120b285112f
＞通常であればMessageBox（NULL,"本文1\r\n本文2"・・・とすることにより \rは不要 ＞iniファイルに同じように記載しても iniファイルの構造を理解してないのが根本の原因 iniファイルは一行が原則なので改行コードなんてありえません(扱えません） 複数の文字列を読んで自分で改行を悲歌して 変換・表示するといったような方法を取ってください
ダイアログもフォームの一種です。 表示の方法が異なるだけです。 http://dobon.net/vb/dotnet/form/index.html
誰もが最初に触るprintf("")関数の引数は 必ずダブルクォーテーションポインタでしょ "文字リテラル"もどっかに保存されます でも、そんな事にこだわる必要はありません ポインタは住所だから実体はさほど意識しないでも プログラムが動いてる間に存在してればいいのから 読み取り専用ののmallocとfreeを暗黙に行ってます printf("Hello World\n"); 上下のソースは同じで、"%s"はポインタの実体を表現する void *name = "Hello World"; printf("%s\n",name); 環境によって(char *)nameでキャスト ポインタを勉強するには本来の型を知らない住所のみの 小難しいvoidポインタから入る方が近道かもしれません
クラス(インスタンス)をそのままfwrite/freadして使うのは色々難しいと思います。 上記プログラムでいえば、read時にstr用のメモリを割り当てていなかったり、write時もmMap内部のデータを出力できていないのではと思います。 そのような目的でboost::serializationというライブラリもありますのが、これもC/C++に慣れていないと難しいかなと思います。 クラス内の変数1つずつをread/writeする処理を記述する方が簡単かと思います。
https://www.sist.ac.jp/~suganuma/cpp/3-bu/16-sho/16-sho.htm C++とJavaのcinのソースあるので見比べてみると解りやすいかも。
＞int i,N; ＞double u[N]; この段階で「Nは不定（たぶん、0になっている）」ので、配列の要素数も「不定（たぶん0個）」です。 「Nの値を入力し終わってから、配列を動的に確保する」か「配列の要素数を固定で取っておいて、配列の要素数を超えるNが入力されたら、入力エラーにする」ようにしましょう。 ・動的に確保する場合 #include <stdio.h> #include <math.h> #include <stdlib.h> int main(void){ int i,N; double *u; int ransu; printf("Define N : \n");　//得たい乱数の数を設定 scanf("%d",&N); u = (double *)malloc(sizeof(double)*N); if (!u) { printf("Out of memory.\n"); return 1; } for(i = 0; i < N; i++) { ransu = rand() % 101 ;　//０～１００までの乱数を得る u[i] = (double) ransu; printf("%.0f ", u[i]); } printf(" \n"); free(u); return 0; } ・要素数を固定（最大２００個）にする場合 #include <stdio.h> #include <math.h> #include <stdlib.h> int main(void){ int i,N; double u[200]; int ransu; printf("Define N : \n");　//得たい乱数の数を設定 scanf("%d",&N); if ((N < 0) || (N > 200)) { printf("Illigal number.\n"); return 1; } for(i = 0; i < N; i++) { ransu = rand() % 101 ;　//０～１００までの乱数を得る u[i] = (double) ransu; printf("%.0f ", u[i]); } printf(" \n"); return 0; } あと、蛇足だけど「N」みたいな「大文字だけの変数名」や「１文字だけの変数名」は、なるべく使わない方が良い。 （「i」「j」「k」は「歴史的な慣習」なので、使っても良いが、出来るだけ使用は避けるべき）
実行時エラーを出すのなら、手元のVisualC++ 2010 Express、Windows7の環境なら、 #include <stdio.h> #include <stdlib.h> int _tmain(int argc, _TCHAR* argv[]) { 　char *mem; 　mem = (char*)malloc(10); 　mem[0x00000001] = 1; // ここは有効な領域内なので当然ＯＫ 　mem[0x00000010] = 1; // ここは有効な領域外だがセーフ 　mem[0x00000100] = 1; // ここも有効な領域外だがセーフ 　mem[0x00001000] = 1; // ここで実行時にアクセス違反の例外が発生してプログラムが停止する 　mem[0x00010000] = 1; 　mem[0x00100000] = 1; 　mem[0x01000000] = 1; 　mem[0x10000000] = 1; 　return 0; } とか。 > 実行すらできずに落ちる（停止）するにはどうすればいいのか いよいよ意味不明です。 コンパイル、リンク出来て、作成された実効形式(Winなら.exe)は、例外なく(1ステップでもって意味で)実行可能だと思いますが。 テキトーなテキストファイルの拡張子を.exeに変更したファイルなんかは、最近のWindowsでは実行できないようにチェックされてはじかれます。が、これはプログラムの問題で実行できないのと別の話。 Unixでファイルに実行権限が無くて実行できないのも、プログラムがどうこうで実行できないわけではないですし。 そもそも、「落ちる(停止)する」ってのは、何かしら実行された結果では。
ＶＳ２０１５は、ＶＳ２００８やＶＳ２０１３との差異が大きいようです。 そのためか、開発中に、質問者さんのような状況になることが増えていますね。
以下の記事に切り替え方が載っています。(2013 の記事ですが、2015 でも同じです) http://www.atmarkit.co.jp/ait/articles/1502/17/news094.html
そのコンソールアプリを呼び出すDLLでいいのではと。
エラーになったならどんなエラーなのかも書いてあった方がいいです。 ざっと見たところheadをNULLにリセットするコードが見当たらないので、デストラクタのループが終わらなさそうです。 それとaddAllした後だとl1のデストラクタがl2のCellまでdeleteしちゃうので、l2のデストラクタが2重deleteになります。 それ以外はちゃんと動きそうに思えるんですが、実行結果の出力まで到達してないんでしょうか。
refキーワードは不要ではないですか？
イベントハンドラを使う場合は、戻り値は void と決められているので Return で返すことはできません。引数で返すようにする必要があります。例えば、 　delegate string MyDelegate(ref string msg); とするとか。 もっとも、質問のサンプルのパターンなら、最初からイベントハンドラなど使わずに、直接メソッドの参照を渡すようにしたほうが賢い選択では。 MyClass mc = new MyClass(); MyEventClass mec = new MyEventClass(); mec.eventname = mc.myget; msg = mec.Oneventname(); class MyEventClass { 　　public MyDelegate eventname; 　　(以下略)
#include <iostream> #include <wchar.h> int main() { wchar_t c1[20], c2[20], c3[20], c4[20]; swscanf_s(L"a b c d", L"%s %s %s %s", c1, sizeof(c1), c2, sizeof(c2), c3, sizeof(c3), c4, sizeof(c4)); std::wcout << L'|' << c1 << L'|' << c2 << L'|' << c3 << L'|' << c4 << L'|' << std::endl; } 結果: |a|b|c|d| ...何の問題もありません。　なにが/どのように「旨く働きません」か?
＃１です。何度もすみません。 修正プログラムには問題がありました。 例えばRize=4の次にRise=2がきてループが終了するような場合、SUM_AreaにはArea[1]と[2]しか足し込まれず、[3][4]が足し込まれないことになってしまいます。 なお、この問題は、お示しのべた書きプログラムでも同じことが言えると思います。 ＞一定ループ後に合計値を計算したい。 ということですので、ループ内ではSUM_Areaの計算はせずに、ループを抜ける際に、 Aera[1]～[64]の合計をSUM_Areaに格納するようにしたほうが良さそうです。
既に似た様な回答がありますが、VisualStudioの操作系の基本的な外観はVisual C++6とかの頃から大きく変化はしていないので、わかりやすさは変わっていないでしょうか。 個人的にはVS2015は、まだ日本語のサポートも十分でないので、実際使うなら無料のVS2013のCommunityをお勧めして、完成度が上がってきて、人に対して公開したい時などに、インストーラーの作成機能がある有償版に切り替えるのが良い気がします。 ちょっとした定型作業をするようなアプリを作って仕事を効率化したい、とかの需要になると、どれが一番適しているか分かりませんね。 今までそういう目的で使ってきたものですと、以下のもののいすれかが適しているでしょうか ・なでしこ ・PowerShell ・VBA ・C# 基本的には下に行くほど、比較的難しくなりますが、学習教材の充実などを考えると、C#か、簡単さに振り切ったなでしこを触ってみるのが、目的に叶ったプログラミングの勉強としては適しているでしょうかね
Visual Studio 2015 Community ならば普通に日本語が使えますが、2013 にこだわる必要がありますか？ (2013 のCommunity は英語しかなかった記憶が) https://www.visualstudio.com/ja-jp/products/visual-studio-community-vs.aspx なお、Community 版は誰でも使えるわけではない (例えば従業員5人以上の企業で使うのはダメです) ので、利用に際しては必ず利用規約を確認してください。
＞無償版 「Visual Studio Community」にはMFCがありますが、「Visual Studio Express」にありません。
＞printf("z1-z2=%f+%fi \n",z.re,z.im); これを、show(complex x) に置き換えたいということでしょうか？ かなり推定ですみません。こうなるのかもしれません。 （全コード書きました） #include<stdio.h> typedef struct complex{ double re; double im; } complex; complex hikizan(complex z1,complex z2) { complex z; z.re=z1.re-z2.re; z.im=z1.im-z2.im; return z; } complex kakezan(complex z1,complex z2) { complex zz; zz.re=z1.re*z2.re-z1.im*z2.im; zz.im=z1.re*z2.im+z1.im*z2.re; return zz; } void show(complex x) { printf("%f+%fi",x.re,x.im); } int main(void) { complex z1,z2,z,zz; z1.re=1; z1.im=3; z2.re=2; z2.im=2; z=hikizan(z1,z2); zz=kakezan(z1,z2); printf("z1-z2="); show(z); printf("\n"); printf("z1*z2="); show(zz); printf("\n"); } 補足・・・ 実は、大して考えていません。 ですが、printfで、"z1-z2="とか表示しているので そこをあえてわけて 最小限の値をshow(z)等で表示したにすぎないものです。 もしかしたら、考え違いで不正解かもしれません。
このような場合は Sleep(0); を使います。 Sleepに0を指定した場合、自分より実行順位が等しいか又は高いスレッドがあれば、それらに実行権を譲り、無ければ（自分が一番優先度が高ければ）即座に戻って来ます。 つまり「0を渡せば時間待ちしないで、実行権の明け渡しをする」ので、他のスレッドが期待通りに動作します。 マルチスレッドで「他のスレッドが実行されるのを期待（想定、待機）する場合」は「Sleep(0)を実行して明示的に実行権の明け渡し」をしないといけません。
確認したわけじゃないですが OnButton5　で表示ではなくそこではフラグなどをセットして 実際の描画は　WM_PAINT　　で行うようにしてはどうですか
そういえば、さっきのremoveAtはdelete書くの忘れました。 リストからは削除されますが、メモリにはnewしたCellが残りっぱなしです。 ちなみに末尾削除はnextがNULLになるまでループさせれば、削除対象です。 アルゴリズム勉強でしたら、自作はすごく勉強になります。 仕事とかの場合は、stlのlistとかmap使った方がバグらなくて良いですよ。 がんばです。
// 連結リストの index 番目の要素を削除する関数 void List::removeAt(int index) { if (index < 0) return; Cell *p = head; Cell *prev = NULL; for (int i = 0; i < index; ++i) { prev = p; p = p->next; if (!p) {break;} } if (p) { if (prev) { prev->next = p->next; } else { removeFirst(); } } }
試してはいませんが、 SetPriorityClassでREALTIME_PRIORITY_CLASSとしていれば、 システム割込みにすら勝ちそうですね。 https://msdn.microsoft.com/ja-jp/library/cc429350.aspx http://chokuto.ifdef.jp/advanced/function/SetPriorityClass.html ではご健闘を！
http://sayahamitt.net/utf8%E3%81%AAstring%E5%85%A5%E3%82%8C%E3%81%9F%E3%82%89shiftjis%E3%81%AAstring%E5%87%BA%E3%81%A6%E3%81%8F%E3%82%8B%E9%96%A2%E6%95%B0%E4%BD%9C%E3%81%A3%E3%81%9F/ 後は通信時のエンディアン変換ですかね。 ２バイト文字だとエンディアン変換しないとやられるかも。 でもLinux側のCPUもIntelなら大丈夫な気がしますけど。 通信する際はビックエンディアンにしましょうという事なので念の為、 http://wisdom.sakura.ne.jp/system/winapi/winsock/winSock4.html
それは現象が全く変わらなかったという事でしょうか？ 落ちている箇所は Array::~Array() { delete[] array; ←★ cout << "デストラクタが呼ばれました。配列の要素数分のメモリを開放します." << endl; } ★の箇所です。 できたファイルを実行して １０００と入力してもうまく行きますけどね。 治す前は８以上は落ちてましたね。 不思議ですね。
普通です、それどころか更に遅い場合もあります。 WindowsというＯＳは元々実行時間を完全に保証する仕組みではありません。 そういうのはリアルタイムＯＳなどと呼ばれて、組み込み系などであります。 http://www.mnc.co.jp/INtime/MncPresidentPage/hikaku.htm Windowsでできるだけリアルライムにソフトを動かそうとすると、デバイスドライバ等の特権レベルで動作するプログラムをする必要がありますが、それは難しくかなり制約のあるものです。 また特権レベルのモジュールでバグや不具合などが起こると、まずＰＣがフリーズしたり落ちたりします。
セーフモードで起動した状態が最小限の状態思います。 もしくわ、 コントロールパネル -> 管理ツール -> サービス からサービスを停止＆自動起動をoffで不要なプロセスの起動を抑えることはできると思います。 どれが必要なサービスかというのはHW構成によっても変わってくるらしいので、 try&error的な作業になるかもしれません。
色々問題のあるコードですが、最初はそんなものです。 お互いに頑張っていきましょう＾＾ で、こんな感じでどうですか？ //#pragma warning(disable:4996) //#include <iostream> #include<stdio.h> #include <ctype.h> void reverse(char *str) { int i; for (i = 0; i<26; i++) { if (*(str + i) >= 'a' && *(str + i) <= 'z') { //printf("=%c", *(str + i)); *(str+i)=toupper(*(str + i));// //*(str+i) -= 'a' - 'A';//toupper,tolowerを使いたくなければ　 } else if (*(str + i) >= 'A' && *(str + i) <= 'Z') { //printf("==%c", *(str + i)); *(str+i)=tolower(*(str + i)); //*(str+i) += 'a' - 'A'; } } return; } int main(void) { //char *str = "AddsssEEEEwwwJojoHoih";これは絶対ダメ～。 char str[] = "AddsssEEEEwwwJojoHoih";//charの文字列は配列で printf("変換前文字列 %s \n", str); reverse(str); printf("\n変換後文字列 %s \n", str); //std::system("pause"); return 0; }
TVN_SELCHANGEDが通知されるはずです。
MFCのテンプレートを使用されているなら、Visual Studio同様 [Ctrl+Tab] で切り替わりませんか？ 特にコードを書く必要もなかったりします。
http://d.hatena.ne.jp/eel3/20120615/1339768796 ここを参考にしてください。
TList::ClearはTList自身が確保したメモリを開放しますが、Addなどで渡されたポインタについては何も行いません。 だって、渡されるポインタが指すオブジェクトがどのように生成されたのかを知るすべがありませんから。 newで生成されたオブジェクトならdeleteできますが、自動変数のポインタを渡される可能性もありますし、malloc系関数でメモリを確保したり、Windowsからメモリを取得する場合もあります。 また、渡されたポインタはvoid*として扱うので、開放すべきメモリのサイズもわからないし、デストラクタ呼び出しもできません。int*、double*、char*を1つのTListに追加して、それぞれ適切に開放できると思いますか?
floatやdouble等の2進浮動小数点数値は、2のべき乗の有効数値ビット数分の個数の和しか正確に表現できません。 つまり、0.5や、0.125などは正確に表せますが、0.1は2進では無限小数なので有限長のデータでは正確に表現できません。10進数で、1/3が正確に表現できないのと同じ。 10で割らずに、整数の範囲で計算して、表示するときに、下から1桁の左に小数点を表示するなど。
一目見た感じではmainのローカル変数のサイズが大きすぎない？ 通常のＣやＣ＋＋ではローカル変数はスタック領域に確保するので、 あまり大きい変数を使うとスタック領域がオーバーフローします。 グローバル変数にするかmallocなどで動的メモリ確保する方が良いでしょう。
> (restlp / 6) 分で回復(上限値に到達)するんじゃ ないんですか? ごめんマチガイ。 1回復するのにlp分かかるんだから、restlp回復するのには restlp*lp 分。 これを60で割った商Qと余りRで Q時間R分。
全言語で共通というわけではありませんが、一般的に |= や &= がある言語では、 a |= b は、a = a | b a &= b は、 a = a & b と同じです。
逐次処理ではないですかね。文脈は構造化プログラミングの三つの構造化文「順次処理」「反復処理」「分岐処理」のことかと思いますので。
チャートを自作するなら、UIViewを継承してクラスを作成し、表示は全てグラフィックとして描画するのが一般的かな、と思います。
まず、24bit符号付きからintへの変換。 バイトオーダーに注意してint変数に入れて、0x800000 以上であれば負なので、0x1000000 を引きます。 これで符号付きのintになります。 次に、doubleを掛ける演算前に、intの正負の符号を確認しておきます。 doubleを掛けてintに格納したら、0x800000 と&を取って、24bitとしての符号を見ます。 これが、演算前の符号と異なっていたら、オーバーフローが起きた(24bit符号付きで表現できる範囲を超えた)ということなので、目的に応じた適切な処理を行います。
トランザクション終了後にすればいいだけでは？
見てみましたが、改行 (LF) もスペース (TAB) も入っています。 どのような OS で、どのようなエディタで表示しようとしているでしょうか？ 例えば、Wibndows のメモ帳で表示している場合は、メモ帳はこのファイルの改行を認識できないので、改行がない状態で表示されます。別のエディタソフトを導入するか、ワードパットで表示させてみて下さい。
sprintf(a[0],"%s",b); とすればどうかな。
実行して結果が出れば正しい。 実行して結果が出てこなければバグ。 プログラムの書き方は一種類ではない。 しないいけない書き方などありません。
回答No.1 氏の提示されているページに全て書かれていますが、やや煩雑なので端的に。 基本クラスのメソッドが実行されたときの動きに違いが出ます。 override は基本クラスのメソッド実行時に、派生クラスのメソッドが実行されます。 new は基本クラスのメソッド実行時に、基本クラスのメソッドが実行されます。 具体例を示します。 class BaseClass { 　　public virtual void Method1() { Console.WriteLine("Base - Method1"); } 　　public virtual void Method2() { Console.WriteLine("Base - Method2"); } } class DerivedClass : BaseClass { 　　public override void Method1() { Console.WriteLine("Derived - Method1"); } 　　public new void Method2() { Console.WriteLine("Derived - Method2"); } } ここで、 BaseClass obj = new DerivedClass(); // 変数は BaseClass 型なのがポイント obj.Method1(); obj.Method2(); と実行したら、コンソールにどのような結果になると思いますか？ 答えは Derived - Method1 Base - Method2 です。 同じオブジェクトのメソッドを呼び出したのに、実行されたものが基本クラスと派生クラスで違うのがわかるでしょうか。
こんにちわ。 Googleで探してみたところ、同じようなQAが見つかりました。 質問者様の状況と一致しているかわかりませんが、 "WindowsXPのVisualStyleを使う"を試してみてはどうでしょうか？ http://www.daccho-it.com/program/WinApi/XPvs.htm
USBは１つの高速シリアルバスを多数のデバイスで共有する形の為、USB-HDD等が帯域を占有してしまうと本来の性能が出せません USB-シリアル変換チップ送信バッファは128バイト程度なのでUSB転送が間に合わないと、オーバーフローを起こします これにはフロー制御で送信バッファのチェックを行うか、送信データにチェックサムを付加しデータエラーなら再送信要求をします FT2232Hチップは送受信バッファ4Kとなり改善されています。
グループボックスは種類としてはボタンのコントロールですが、グループボックスとして設定されている場合にはクリックされてもメッセージの処理を行いません。これは、クリックされた場合に処理が必要かどうかを判定する、WM_NCHITTESTというメッセージに対して、HTTRANSPARENTというコードを返しているためです。 逆にいうと、この処理があるからこそ、グループボックス内に配置されたコントロールは、クリック等のメッセージを受け取ることができます。 グループボックスがクリックされたことを知りたい場合は、ボタンコントロールをサブクラス化してWM_HITTESTでの処理を変更するなどの処理が必要になると思います。 MFCを使用しているなら、親ウィンドのPreTranslateMessageでも処理できると思います。
＞ USBメモリなどの外部媒体を使う事が禁止されています。 ということであれば、CD/DVDなども使用不可と考えた方がいいでしょうね。 Cコンパイラをどのように使用するかによりますね。 自分が常用する様なツールを作成したいのであれば、windowsの実行ファイルを作成できる必要がありますが、単にC言語の学習のために使いたいだけであれば、ブラウザ上でソースを入力して実行結果が確認できるオンラインコンパイラというものがあります。検索してみれば、いくつか見つかるはずです。 Windowsが32bit版であれば、16bitモジュールが実行可能なので、LSI-C試食版をダウンロードして展開すれば、コマンドプロンプトから使用できるんじゃないでしょうかね。
ここでは？ for (n = 0; sum[n] == 0; n++) { これで動いてるのが不思議ですが、第2パラメタで比較ではなく0を代入しちゃってますよね。最初のfor文も変ですけども。 ここ(↓)あたりのfor文の解説でも読んでみてください。 http://www9.plala.or.jp/sgwr-t/c/sec06-2.html
> raxを調べると、0x0002が返ってくるようです。 -2 (0xff..fe) ということですか？ 0,1,2 が stdin,out,err ですから正常なら >=3 が想定されるところです。 > ということは、「ファイルが存在しない」なのでしょうか？ 2==ENOENT ならそうなりますが、O_CREAT が指定されていればエラーするにしても別のエラーコードになりそうです。 > もしかして、パラメータの数字が違うのかも知れません。 自分も初めにこれを疑いました。 別 OS は当然として同じ OS でもバージョン違いの情報は当てにできません。もう一度 /usr/include 配下のヘッダファイルを確認するか、C に書き起して cc -E などでマクロ展開の結果と突き合わせることをお勧めします。 ヘッダのパスとかコンパイラドライバはお使いのものに読み換えてください
こちらの記事を見て下さい。 http://www.atinfinity.info/blog/archives/14
No1です。 forループ内で、変数宣言 int A = a*a; int B = b*b; int C = c*c; をやめてみればってこと
例えば、 main(){int i;printf("米\n");for(i=1;i<=3;i++){printf("米");}printf("\n");for(i=1;i<=5;i++){printf("米");}} とか。 まずは、 ＊ ＊＊ ＊＊＊ から考えては。 ↓＊ ↓＊＊ ↓＊＊＊ この↓ループ 1 2 3 と、 ↓＊ ↓＊→＊ ↓＊→＊→＊ この→向きのループ 1　1 2　1,2 3　1,2,3 するので、ループ変数は２つ必要、上のプログラムはループ変数１つで大丈夫か？ってのが確認できるかも。
(CでもCOMは扱えますが)IShellWindowsで列挙するとExplorerも列挙されるので、FullNameプロパティでの判定はあった方がいいかも知れません。 IEのURL取得 https://gist.github.com/kumatti1/a923097674c1804f0bfd
printf("加算される消費税額は%f.です\n,zeikin"); printf("総売上額は%f.です\n,goukei"); この2行、ダブルクオーテーションの位置がおかしい。
>そのライブラリの1部しか利用しない場合でも，利用側プログラムのバイナリにはライブラリのバイナリすべてが含まれてしまうのでしょうか． 　そのとおり。正解です。 　例え、１００個の関数の内、１個しか使わなくても、全部リンクされます。 　理由は、そのたった一個の関数が、巡り巡って、他の全部の関数を呼び出している「かも」しれないからです。リンカーが、必要な関数だけをリンクするようにしようとすると、内部に含まれている全ての関数が、自分にはどの関数が必要かをコンパイラーに宣言させる必要が出てきます。また、ライブラリーにグローバルな変数が含まれていれば、それも列挙する必要があります。 　そのような宣言があったとしても、今度は、リンカーは全ての必要な関数と変数等を列挙し、その部分だけをバイナリレベルで抜き出し、新しいライブラリーを構築する・・・という作業が必要です。単一のライブラリー内だけでその解析が収まれば良いですが、別のライブリー経由でもう一度自分のライブラリーの別の関数を呼ぶなんて可能性も考えれば、これ、相当困難な作業になります。 　というわけで、リンカーは、単純に、必要と宣言されたライブラリーを、ファイルまるごとターゲットファイルにリンクします。
GDIイメージオブジェクトを生成して、CopyRectで「範囲指定された矩形領域」を作成したGDIイメージオブジェクトにコピーして、GDIイメージオブジェクトにコピーされたイメージをpictureBox1にアサインして、pictureBox1.Image.Saveでセーブ。 上に書いてある事が理解できない場合は、理解できるまで参考書などを読み込むこと。
No.1補足　func() の処理時間を計る場合、MsTimer2 を使用せず　func()を通常関数としてコールし　micros() 　の　func()　実行前、実行後の時間差で処理時間がわかります　（1mS割り込みでないので出力データは無意味） 実際はfunc()を100回単位で実行し平均化します　、micros() 関数のカウントアップ割り込みがある為 micros() 　参照 http://www.musashinodenpa.com/arduino/ref/index.php?f=0&pos=2531
#ifndef _H1_ #define _H1_ ... #endif と同様の回避方法を型定義に用いる。 #ifndef struct_point_defined struct point { ... }; #define struct_point_defined #endif
こう言う場合は、一旦、問題になってる場所をコメントアウトしてみれば良いです。 ちなみに、今問題になってるのは「0って何だ?」って事なんでそこに注目してみます。 元のプログラムを実行して0を入力すると、例えばこう言う結果が返ってきますね。 /* ここから結果 */ 変換前の2進数 = 0 桁の重み1 × 桁の数値0 = 0 変換後の10進数 = 0 /* ここまで */ 2進数の0は10進数の0ですね。当たり前なんでこれは正しい結果です。 さて、じゃあ問題の箇所を次のようにコメントアウトしてみましょう。 /* こう言う風にコメントアウトしてみる */ val = binary[pos]; /* - '0'; */ /* セミコロンを付け忘れないように! */ こうするとbinary[pos]ってのが剥き出しでvalに代入されますね。 これでさっきやったようにコンパイルして実行、そして0を入力してみます。 そうするとどうなるでしょうか。 /* ここから結果 */ 変換前の2進数 = 0 桁の重み1 × 桁の数値48 = 48 変換後の10進数 = 48 /* ここまで */ コナン君なら 「あれれれぇ、おかしいな、0を入力したのに48が返ってきたよ?」 とか言うでしょうね(笑)。 さて、一体何が起こってるのでしょうか。 まず、このプログラムで特徴的なのは入力でgets関数を使ってる辺りですね。 ・C言語関数辞典(gets) http://www.c-tipsref.com/reference/stdio/gets.html んで解説読んで欲しいんですが、実際はC言語には(他の言語で言う)「文字列」って物は厳密には無いんですが、次のように書いてあります。 "gets 関数は標準入力 (standard input) から 1 行分※ 文字列を読み取り，s が指す配列に格納します．" つまり、このプログラムで「入力」してるのは、上のサイトの説明を借りると、「数値」を入力してるんじゃなくって「文字列」を入力してるわけです。 コードのこの部分ですよね。 gets(binary); もう一度言いますが、仮にここで「0」と入力しても、要するに「整数型」の0が入力されるわけじゃなくって「文字としての」0が入力されてる、って事です。ここまで良いでしょうか? 問題は、文字としての0と数値としての0が一致してれば良いんですが、さにあらず、文字の基本にASCIIコード表なるものがあって、実は「文字の数値」と、メモリに置かれる実際の数値は次のような対応になってるんです。 ・ASCIIコード表 http://e-words.jp/p/r-ascii.html 文字の0 -> 数値の48 文字の1 -> 数値の49 文字の2 -> 数値の50 文字の3 -> 数値の51 文字の4 -> 数値の52 文字の5 -> 数値の53 文字の6 -> 数値の54 文字の7 -> 数値の55 文字の8 -> 数値の56 文字の9 -> 数値の57 お分かりでしょうか?48って数値はさっき出てきましたね。 つまり、コンピュータでは極論、最期は全部数値になるんですが、「文字」と「文字としての数字(整数)」にはズレがある…要するに「48ズレがある」って事なんです。 従って、単純には、C言語上で「文字の数値」を単なる数値に変換するには48引けば良いわけですね。例えばこのプログラム上では次のように書ける。 /* 文字数値から整数への変換 */ val = binary[pos] - 48; そしてもっと端的にはASCIIでは文字'0'は48と定義されてるので、「次の数式も」意味的には上の数式と同値になるわけです。 /* もっとカッコイイ書き方? */ val = binary[pos] - '0'; まとめます。 gets関数は入力を文字として捉える入力関数で、そのままではASCIIコードに従った数値としてメモリへ格納されます。計算/出力する際に、その「文字としての」数値を単純な一桁の整数に変換しないといけません。 ASCIIコードに従う限り、一桁の数値は全て48、ないしは文字'0'を引くと単純な一桁の整数と一致し、これはよく使われる「文字数値 -> 数値」の変換となっています。
32768で割る。
「(2) １ビットで出力する場合」 を参照して下さい　（レジスタ名はヘッダファイルで定義されています） http://www.picfun.com/xcframe.html
boostの全てのヘッダファイルは”boost/*”というように、boostというディレクトリの直下に入れるのが正式です。 ですので、 ａ．インクルードディレクトリのパスをE:\にする ｂ．適当なディレクトリを作り（例えばE:\boost-1.58)、そこにboostフォルダを移動。更に、ライブラリディレクトリパスを変更する（E:\boost-1.58\boost\stage\libのように) などの方法で解決できると思います。
>剰余とはなんでしょうか？ >また、それをする意味はなんですか fmod()を使用していますが、それが剰余を計算する関数です。 剰余とは簡単に言うと、割り算の「あまり」のことです。 例： １０割る４の剰余は２です。
代入と比較を区別するためです。 Cおよびその影響を受けた言語では、「=」を代入に使うので、「等値比較」をそれと別の記号にせざるを得ず「==」としています。 言語によっては、代入を「:=」として、比較を「=」にしているもの(Algol/Pascal系)や、条件判断のところ代入を書けないために、代入も比較も「=」にしている言語（Basic系)もあります。 C系だと、式を書ける任意の場所に代入も比較も書けるので、Basic系のようなわけにはいきません。
できますよ。 if(A==0 || A==3){ 処理１ } else{ 　処理２ } || が or && が and
ダウンロード、インストール、起動、簡単なプログラムの作成まで説明したサイトがいくつかあります。 初心者向け！Visual Studio(Express)の使い方 | TechAcademyマガジン http://techacademy.jp/magazine/2696 連載：簡単！ Visual Studio 2013入門：第1回 初めてのVisual Studio 2013 (1/5) - ＠IT http://www.atmarkit.co.jp/ait/articles/1408/27/news118.html ・どのサイトの、どの方法で ・どのページ、何行目の、どういう風に書かれている手順で ・何を、どうしたら、何が、どうなるはずのものが、どうなって 結果、ソースを書くことが出来ないのか？ などを補足してくれないと、せいぜい上のようなサイトを紹介するくらいしか出来ません。
WindowsであればMicrosoftのVisualStudioが無料ですよ。
ソフトウェアの歴史になりますが、元々国家公務員が業務として作成したソフトウェアは無料であるべきとして、PDS、パブリックドメインソフトウェアというものがありました。 そして、ソフトウェア開発の商業化の流れとは別にソフトウェアを趣味で作る人達のボランティア的な組織がリチャード・ストールマン氏によって設立されたフリーソフトウェア財団が、確固たるポジションを得ました。 フリーソフトウェア財団は、ソフトウェアの譲渡を得て再配布可能としたのですが、利用ルールが厳格であったため、反発する人達も出てきました。その流れからオープンソースという、考えができ、発展していきました。 オープンソースも様々なものがありますが、そのソフトウェアに対してイニシアチブをとる人や組織がないとやがて廃れてしまいます。
使ってるぶえあう座が何かわかりませんが キャッシュを削除後ダウンロ度できないかを確認して下さい ダメな場合他のブラウザを使って確認してください
実際に確認したわけでは無いので参考程度に、 Sel初期値０：現在の処理モード if (Rise==1 && Sel==0){ KOSU=0;Captime[1]=0;Sel=1; } if (Rise==2 && Sel==1){ Max_Captime[1]=0;Sel=2; } if (Rise==2 && Sel==2){ Captime[1]=Captime_rise[2]-Captime_down[1]; if (Captime[1]>Max_Captime[1}){ Max_Captime[1]=Captime[1]; } }　// Max_Captime[1]　最大値計測中 if (Rise==1 && Sel==2){ Sel=0; // Max_Captime[1]によるKOSU加算処理 } if (Rise>2){ KOSU=9;Sel=0; } // Error
＞printf("a2\n");を関数内に用いて、実際にcompatibility関数を読み込んでいるのか確かめたのですが、コンパイラーにそう表示されることなく、関数を読み込んでいないのではと判断したしだいです。 であれば「damage()関数そのものが呼び出されて無い」と思います。 int damage(int i, int a[2][3], struct monster monster[], int b[2]) { int add; double damage; int s, t, u; の直後に printf("d1\n"); と入れて「damage()関数が本当に呼び出されているのかどうか？」を確かめましょう。 「d1」と言う表示が行なわれず、damage()関数が呼ばれていないようなら、更に「damage()関数を呼び出している上位の関数が、ちゃんと呼び出されているかどうか？」を、同じような方法で確かめ、更にその上位関数も同じように確かめましょう。 そうすれば「この関数まではきちんと呼び出されているが、ここに来た時点で、この関数が呼ばれてない」ってのが確認できる筈です。
monster2.name[a[1][0] - 1] を monster2[a[1][0] - 1].name にする。
monster.name[m] monster.name[x[t][i]-1] monster.name[x[t][i]-1] とすれば通りますね。
「ＡＫＩ－Ｈ８－ＵＳＢ開発ボード」回路図では、LEDアノード側がVCCにカソード側がPORTB 0-3へ接続されているのでLOWで点灯です スイッチもVCCでプルアップされている為、SW_OFF=HIGH / SW_ON=LOW になります これはN-MOS(TTL-IC)では通常、電流の吸い込みしか出来ない為、LOWで点灯するようになっていました C-MOSのロジックICでは、電流の吸い込み、吐き出し両方可能なので、PORT側にアノードを接続しカソードをGND側へ向けることにより、HIGH=点灯も可能です スイッチもTTL-ICでは、2V以上をHIGH,0.8V以下をLOWと認識する為、ノイズマージンを高くするためSW_OFF=VCC(HIGH),SW_ON=GND(LOW)が用いられます （TTL-ICではLOWを認識する為には0.8V以下0.4mA吐き出し電流が必要で、プルダウン抵抗は難しい） マイコンによっては内蔵プルアップ機能があり、プルアップ抵抗の省略も可能です。 回路図 http://akizukidenshi.com/download/ds/akizuki/AKI-H8-USB-SCH.pdf
先生やお友達にでもお尋ねください。 ソケット通信の内容もわからないし 関数searchdata(long key, char *dp, int size)の仕様もわからないしで 回答のしようがありませんし。
#include <stdio.h> #include <stdlib.h> int dice(void); int simulation(int i); int main(void) { 　　int i = 33; 　　simulation(i); 　　return 0; } int dice(void) { 　　return rand() % 6 + 1; } int simulation(int i) { 　　if (i == 0) { 　　　　return; 　　} else { 　　　　printf("%d\n", dice()); 　　　　return simulation(i-1); 　　} }
1) ラインカメラで物体の大きさと、通過個数をカウントしていると思われますが、物体の大きさを最初の一回しかチェックしていません、物体が通過する間の一番大きい値で比較する必要があるのでは？ 2) 割り込みキャプチャにおいて、Captime_rise[Rise]=IC2BUF、Captime_down[Down]=IC1BUF、のRise,Downの最大値のチェックが必要では？ デバッグ方法 物体が通過する際の全てのキャプチャデータをパソコンへシリアル転送すれば、全体の流れがつかめると思います。
こんな感じ？ int main(void) { VectorPtr v=create_vector(); append(v, "first"); append(v, "second"); append(v, "third"); append(v, "fourth"); append(v, "fifth"); append(v, "sixth"); append(v, "seventh"); print_vector(v); return 0; }
fp = fopen(argv[1], "r"); を fp = fopen(argv[1], "rt"); にしてみたらどうなりますか？ fgets系のioルーチンを使う場合、ストリームのオープンタイプが「テキストモード」じゃないと、何が起こるか判りません。
iの初期化とカウントアップは正しく処理されているという前提で。 ファイルポインタが進まないのではなくて、ファイル終端に達した場合の処理が正しくないのでは? if (feof(fp)){ break; } でfcをループカウンタとしたforループから抜けていますが、iを使ったwhileループでは、どこまでデータが読み込まれたか確認せずにMAX_SIZE-1までループしてますよね。 たとえばfc=0の時にfeof(fp)がtrueになったとして、そのあとのwhileループはMAX_SIZE-1回処理されてしまうので、一回前の処理で読み込まれたTDに対して処理を行い、結果ファイルポインタが進んでないように見えるということになりませんか? fcの上限がMAX_SIZEで、iの上限がMAX_SIZE-1というのもおかしいと思います。
C++/CLIは参考になるサイトは少ないですね…。 特にC++/CLIを使うケースって、マネージアプリ→ネイティブＤＬＬが主だと思うので、逆は見た覚えがありません。 私の場合は、主にMSDNと睨めっこしながら、小さなコード片で実験して、解らない所は個別にググり…という感じで覚えました。 ただまぁ、C++とC#が使いこなせていれば、C++/CLIはそんなややこしいものでもありません。 以下、C++/CLIでマネージクラスを定義せずC#のコードを呼び出すだけなら、このあたりを抑えておけば使えるだろうと思うものを上げておきます。 ・C++/CLI側でマネージ型オブジェクトの生成はgcnewというキーワードを使う ・gcnewやC#側で生成された.NETランタイムのマネージヒープ上に確保されたオブジェクトは、ガベコレの関係で特殊な扱いが必要になる ・マネージヒープ上のポインタに相当する「ハンドル（Object^）」という型がある ・マネージヒープ上のオブジェクトは普通の参照渡し（Object&）が使えず、代わりに「追跡参照（Object%）」というものを使う ・マネージ型←→アンマネージ型の型変換（マーシャリングといいます）をサポートするヘルパー関数が用意されている（marshal_as、marshal_context、msclr\marshal.hで定義されています） ・マネージ側のバイト列やオブジェクトを、アンマネージの関数にポインタとして渡す必要がある場合はpin_ptrというものを使う ・マネージ配列（.NETの配列型）はarray<type>^という型で、gcnewを確保する ・.NETの値型（C#でstructで定義する型）は、C++でも値型として変数を定義でき、実際にスタック上に確保される。 （注：私がC++/CLI使ったのが２，３年くらい前で、使い込んだという程使っていたわけでもないのでややうろ覚えです。間違いが含まれていたら申し訳ありません） このあたりを足がかりにしてみてください。 あまりお力になれていない回答ですが、少しでも参考になれば。 ※参考ＵＲＬ ・C++プログラマのためのC++/CLI入門 http://ambiesoft.fam.cx/cppcli/cli:%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB 説明は簡素ですが、C++/CLI特有の概念や機能を大まかに把握するには丁度いいサイトだと思います。 ・C++/CLI 移行ガイド（MSDN) https://msdn.microsoft.com/ja-jp/library/ms235289.aspx 突っ込んだ事を知るには本家に当たるのがベストです。 ・C++/CLI言語仕様書の非公式和訳 http://vene.wankuma.com/ecma372/StartingState.aspx MSDNは、文法などを確認したいとき、どこにあるのか良くわからない事が多いので、補助的に見てました。
パッと見の判断ですが， タイマー再開しても， if(tm > TimeLimit) がまたtrueになって，再度繰り返してしまうだけでは？ 再開する際は，StartTime を現在の時間に初期化し直さないといけないのでは？
一つの理由としては、Windows SDKの関数の役割や意味づけを示しています。 WINAPIはWin32APIの関数である、ということを示しているだけです。 基本的に自分で書くコードの関数にWINAPIを付けるのは意味的にはよろしくないでしょうね。 別に害は無いと思いますが。 APIENTRYはWinMain関数とかDllMain関数の定義につけるものですね。 この二つの関数は、Win32APIの仕様として引数や返すべき戻り値は決まっているものの、ユーザーが定義しプログラムの最初に呼ばれる特殊な関数（エントリー関数）ですので別に定義しているだけだと思います。 （昔はリファレンスのサンプルでもWinMainの定義はWINAPIだったと思うんですけど） この他にも、例えばメッセージプロシージャなどのコールバック関数を定義するときはCALLBACKを付けますが、これも実体は__stdcallです。 もう一つの理由もあります。 もし各APIが__stdcallで直接宣言されていたとしましょう。 そして、Win32APIの仕様が変更になって呼び出し規約がstdcallから別のものに変更されたとします。（まずありえないと思いますが） この場合、数万行あるとも言われるwindows.h及び関連ヘッダの全ての関数宣言も書き換えるという大変更が生じます。 それだけではなく、windows.hはあらゆるWindowsアプリケーションがインクルードし依存していますから、これはマイクロソフトだけで収まる問題ではなく、世界規模での問題になることは必至です。 しかし、マクロ定義されていればWINAPIの一カ所を修正するだけで済みます。 少なくとも、ヘッダ丸々書き換えるよりは手間も影響も少ない、という事を見越しての事です。
いろいろな解答が考えられるけど、たとえば ウ str3=str1+str2; エ str1=str1.substr(0,3)+str2.substr(1)+str1.substr(3); オ q!="quit"
f(1)=1 f(2)=2 f(n)=f(n-1)+f(n-2) をコード化すればよい。
>fscanfの使い方が間違っているのでしょうか？ 構造体のid2からはcharの配列のサイズが、'\0'文字分の計上がされていないように見えますけど。 それと質問に元のソースと異なるソースを書かれるのは構いませんが少なくとも現象が再現できるものにしましょう。
enter関数の中の /* キーが既に存在しているかどうかチェック（lookup() と同じ処理）*/ n = t->heads[index]; while (n != NULL) { if (strcmp(key, n->key) == 0) return n->id; /* 通し番号を返す */ のif文で、既存キーと同じキーが来た時（つまり、２回目の呼び出し時）に「通し番号を返すだけでreturnしている」から、新しいvalueをどこにも代入しないまま関数から抜けてしまう。 「どうすれば値が更新されるようになるか？」は、もう判るよね？
列挙型で許容される型は、byte、sbyte、short、ushort、int、uint、long、ulong です。配列は指定できません。 https://msdn.microsoft.com/ja-jp/library/sbbt4032.aspx
修正した関数：add_first 実装した関数：get_index, add 星印が付いているところが修正箇所です。 /* ★リスト l の先頭にセルを挿入 */ void add_first(ListPtr l, int val) { NodePtr n = NULL; /* ★今の先頭セルの次があるならそれを覚えておく */ NodePtr next = NULL; if(l && l->head) next = l->head; n = create_node(val); /* ★nの次はNULLまたは先頭であったノードなのでnextを入れる */ /*n->next = l->head; ←間違い */ n->next = next; l->head = n; } /* ★リスト l において値 val を持つセルの位置を返す */ int get_index(ListPtr l, int value) { int i; int len = get_list_size(l); for(i = 0 ; i < len ; i++) { if(get_value(l, i) == value) { return i; } } return -1; } /* ★リスト l の位置 index に値 val を持つセルを挿入 */ void add(ListPtr l, int index, int value) { int len = get_list_size(l); /* リストの先頭に追加する場合はここで処理をして抜ける */ if(index == 0) { add_first(l, value); return; } /* indexが1以上の場合は挿入する位置を探す。pは挿入する位置であり、p_prev_nodeはpの一つ手前のノードである */ NodePtr p = l->head; NodePtr p_prev_node = NULL; while(index > 0) { if(p == NULL) { /* 挿入する位置が無い場合で且つindexが0になっていない場合は指定された位置に正しく入れることができない。よって仕様では無視する事になっているためここで戻る。 */ return; } p_prev_node = p; p = p->next; index--; } /* 新しいノードを作る */ NodePtr new_node = create_node(value); /* 挿入する位置のひとつ前のノード(p_prev_node)の次に今作ったノードをつなぐ */ p_prev_node->next = new_node; /* 今作ったノードの次に、挿入する位置にあったノード(p)をつなぐ。pはNULLでもよい。その場合は最後のノードという意味である。 */ new_node->next = p; } /* 連結リストの使用例 */ int main(void) { FILE *fp = NULL; char buf[10]; int age; ListPtr l = NULL; l = create_list(); add_first(l, 28); add_first(l, 40); add_first(l, 33); add_first(l, 15); /* ★重複する場合のテストのため同じ値を追加 */ add_first(l, 33); print_list(l); /* ★ get_indexのテスト */ printf("値15の位置は%dです。\n", get_index(l, 15)); printf("値33の位置は%dです。複数ある場合は先に見つかった方。\n", get_index(l, 33)); printf("値40の位置は%dです。\n", get_index(l, 40)); printf("値28の位置は%dです。\n", get_index(l, 28)); /* ★ addのテスト1 */ printf("\nindex=0に値0をaddした結果\n"); add(l, 0, 0); print_list(l); /* ★ addのテスト2 */ printf("\nindex=99に値99をaddした結果(無視される)\n"); add(l, 99, 99); /* 無視される */ print_list(l); /* ★ addのテスト3 */ printf("\nindex=2に値2をaddした結果\n"); add(l, 2, 2); print_list(l); /* ★ addのテスト4 */ printf("\nindex=7に値7をaddした結果(最後のノードとして追加できることの検証)\n"); add(l, 7, 7); print_list(l); delete_first(l); print_list(l); delete_first(l); print_list(l); delete_first(l); print_list(l); delete_first(l); print_list(l); /* ★ 削除 */ delete_list(l); return 0; }
MFCは関係なく、標準ライブラリも該当します。 静的リンクをするだけで （厳密にはそれ以前）～XP～Win7/8/10まで動くプログラムが作ることができます。
INSTALLを読みましょう。 > shared In addition to the usual static libraries, create shared > libraries on platforms where it's supported. See "Note on > shared libraries" below. staticライブラリとリンクされている場合はビルドし直さないと反映されません。 sharedライブラリとリンクされている場合はケースバイケースです。
こんにちわ。 参考URLにそのまま答えが載っています！ ご質問者様の推測通り、メッセージが複数回送られて来るようですね。 countin/countoutの値も動作と一致しているのではと思います。 >スクロールバーの矢印をクリック SB_LINEUP -> SB_ENDSCROLL の順でWM_VSCROLLメッセージが送られる >スクロールバーの下矢印をクリック SB_LINEDOWN -> SB_ENDSCROLL の順でWM_VSCROLLメッセージが送られる >スクロールバーのつまみをクリック countout が+3 SB_THUMBTRACK(ドラッグ中に複数回) -> SB_THUMBPOSITION -> SB_ENDSCROLLの順でWM_VSCROLLメッセージが送られる
インストールが確認できたら問題はないと思いますが、 gdbなど、いくつかのバグが確認されていますから、 WEBにつないだままNo1の方法でSetup.exeを起動すると GRUからバグの訂正などがダウンロードされますから 一度、その方法で確認されてみられたらどうでしょうか。 gdbに関するものも入っているかはわかりませんが。
一番の近道は何かをどうしても作らないといけない状態になること＝仕事 2番めの近道は好きなモノを作ること ↓ >>私はウェブアプリケーションに関心があります。 言語は別のものになるかもしれないけど、↑これ作ってみては？
「ランタイムの要らないプログラム」と言う事はＵＳＢメモリに入れてそのまま実行できるポータブル版のソフトでもありますね。 既に御存知かもしれませんが、普通の実行ファイルの必要なモジュールをパッケージ化してポータブル化してくれる「Cameyo」というソフトがあります。 GIMP,Inkspace,LireOfficeなど多くのソフトがこれを使ってポータブル化されているみたいです。 http://www.forest.impress.co.jp/docs/review/20100825_389049.html http://onlinepckan.net/software/portable.html
問題なく実行してくれますよ。 Win7(64ビット)は32ビットプログラムを さぞ64ビットであるかのように実行します。
別に問題は有りません。vbからはやめた方が良いですが。C#とjavaは記述が似ていますがvbは別物です。あれになれるとあれしか出来なくなります。簡単すぎて抜けられなく成るからです。しかも出来ないことも多く、効率も悪い。
C++のランタイムに関しては、上位のものがあれば下位は不要ということはありません。 全てちゃんと残しておいてください。 残しておいてもたいした容量ではないので、気にしない方がよいですよ。
こんな感じ？ 以下変更点 ・関数kaiを追加。階乗を計算。 ・変数mを追加。(2 * n + 1)を計算した結果を入れる ・変数ｓを追加。符号を表現する。 その他ちょこちょこ変わってます。 #include<stdio.h> #include<math.h> double kai(int n) { double k = 1.0; while(n > 1) { k *= n; n--; } return k; } int main(void) { int i, n, m; double x, kotae, tmp, s; printf("n=? \n"); scanf("%d",&n); printf("x=? \n"); scanf("%lf",&x); kotae = 0.0; for(i = 0 ; i < n ; i++) { m = (2 * i + 1); s = ((i % 2) == 0) ? 1.0 : -1.0; tmp = s * pow(x, m) / kai(m); kotae += tmp; } printf("sin%fの値は%lf\n", x, sin(x)); printf("sin%fのテイラー展開第%d項までの和は%f \n" ,x ,n ,kotae); return 0; }
「\」の次の文字をエスケープします。「\」の次の文字は改行文字になっていますから，それをエスケープすると改行していないことになり，gStageDataを文字列として1行に書いたことと同じ意味になります。 2つの物理行ではあるが，1つの論理行と解釈させるために，このような書き方をしています。 結果として const char gStageData[] = "########\n# .. p #\n# oo #\n# #\n########"; と同じことになります。でもこれだとわかりにくいでしょ。
str1の型は const char const [5] (要素数5のconst char配列) なので、 str2の型の const char * (const charへのポインタ)とは別物です。 ただし、一部の例外を除いて、 配列はその先頭要素へのポインタ（つまりconst charへのポインタ）と見なされるため、両者が同じに見えることが多いのです。 その例外というのは、 1. sizeof演算子の引数となるとき 2. アドレス演算子&の引数となるとき 3. char型の配列を文字列リテラルで初期化するとき です。 今回の場合、2番目の「アドレス演算子&の引数」になっているので違いが出ます。 それから、str1と&str1[0]は等価と見なせることがありますが、&str1とは等価ではありません。 &str1の型は const char const (*)[5] (要素数5のconst char配列へのポインタ) なので型が違うからです。 【参考】6.3: Cで"ポインターと配列は同等"というのは何を意味しているのか。 http://www.kouno.jp/home/c_faq/c6.html#3
#include<stdio.h> int main(void) { int kekka,a,i; printf("a=? \n"); scanf("%d",&a); kekka=1; for(i=1;kekka<=a;i++) { kekka=kekka*i; } printf("%d!>%dです。\n",i-1,a); return 0; } この辺りかな。ループを抜けるとiは1増えているから-1しています。
回答No.1のソースは、今どきのコンパイラでは動作しませんね。 理由は↓ https://www.jpcert.or.jp/sc-rules/c-str30-c.html 今どきのコンパイラでも動作するようにしました。 char buff[256]; char buff2[256]; char *str1=buff; char *str2=buff2; strncpy(str1, "abcdef", 7); strncpy(str2, "123456", 7); str1++; memcpy(str1,str2,4); printf("str1=%s",str1);
そのままです。 if (fork()==0) { /* この部分に、５秒間スリープ後、exit()するプログラムを書く。*/ /* ２行です。子プロセスの実行結果（EXIT_SUCCESS）も忘れずに入れる。*/ sleep(5); exit(EXIT_SUCCESS); } sleep, exit というヒントが与えられているのですから $ man 3 sleep $ man 3 exit を見て、よく読めば答えが自ずと分かるはずです。 以下でも man の内容を閲覧できるのでよくお読み下さい。 sleep(3) http://linuxjm.osdn.jp/html/LDP_man-pages/man3/sleep.3.html exit(3) http://linuxjm.osdn.jp/html/LDP_man-pages/man3/exit.3.html
"CTreeCtrl OnInitDialog SetCheck"などで検索すると、正しく反映されないというページがいくつか見つかりますね・・・。 MSDNのサンプル(参考URL)を見ると、なぜか一度フラグの削除&追加をしているので、 この2行を追加してみてはどうでしょうか？ >mTree.ModifyStyle( TVS_CHECKBOXES, 0 ); >mTree.ModifyStyle( 0, TVS_CHECKBOXES ); 理由については理解しておりませんが・・・。
>>http://readwrite.jp/archives/19433 上記のサイトをみると、Ｃ＋＋は、言語の人気ではＣ＃と同じく５位になっていますね。 人気＝利用者数 とはいえないかもしれませんが、個人的な経験でも、Ｃ＋＋が一番多くのプログラマーに使われているってことはないと思います。 どこからＣ＋＋が一番多くのプログラマに使われていると判断されたのですか？
ヒントだけ。直し方の一例です。 エッジ検出は、/* image processing */の後にあります。 1. 畳み込み演算は下記のように。 変数LはLyとLxに、配列cはcxとcyに置き換えておきます。 配列cからcxとcyへと、どう直すかは簡単に想像できますね。 Ly = (float)(cy[0]*d[0] + cy[1]*d[1] + cy[2]*d[2] + cy[3]*d[3] + cy[4]*d[4] + cy[5]*d[5] + cy[6]*d[6] + cy[7]*d[7] + cy[8]*d[8]); Lx = (float)(cx[0]*d[0] + cx[1]*d[1] + cx[2]*d[2] + cx[3]*d[3] + cx[4]*d[4] + cx[5]*d[5] + cx[6]*d[6] + cx[7]*d[7] + cx[8]*d[8]); 2. エッジの強さは下記のように。 これは定義そのままに。 dat = (int)sqrt(Lx*Lx + Ly*Ly) * amp; if (dat < 0) dat = 0; if (dat > 255) dat = 255; 最後に、math.hをインクルードすること、数学ライブラリをリンクすることを忘れずに。 あとはご自分で。
「間違ってたら」も何も、まともに実行できないですよ。 コメント外してませんし。 それに「図3 は」と言われても。 とりあえず、濃度値の頻度の意味を理解しましょう。 (a)は、histogram[img[i][j]]++; です。 (b)は（コメントを外せば）よいとして。 (c)は、下記をヒントに。 length = H_height * histogram[j] / max_frequency; for (i=0; i<H_height; i++) { if (i <= length) work[H_height-1-i][j] = 255; else work[H_height-1-i][j] = 0; }
現時点では垂直方向の畳みこみだけなのね。 ならばその結果 L を Ly とし、 水平方向での係数cxとの畳み込みをやって Lx を求める。 で、それぞれを二乗して加え(Lx*+Lx + Ly*Ly)、その平方根を取ると |L| が求まる。
両者のスレッド間通信はどうやってるのかしら。 多くは producer-consumer-queue を使うものだけど。 1) queueを用意する、最大要素数はテキトーに決めて。 2) 受信スレッドは、”データを受信したら queueにpushする”を繰り返す。 3) 解析スレッドは 、”データをqueueから取り出し解析する。queueが空ならそこで待つ”を繰り返す。 2 と 3 が並行動作すれば、受信中に解析できますな。
findContours 関数の出力は、Contour"s" と複数形であることからもわかるように、「複数の」輪郭点群です。 つまり以下のようになっています。 vector<Point> → 輪郭点群 vector<vector<Point> > → 複数の輪郭点群 一つの画像内には、輪郭を持つ物体が複数ある可能性がありますから、このようなインターフェースになっています。 例えば、丸が１個、三角が１個が描いてある画像を入力とすると、2個の vector<Point> が得られることが期待されます。 何番目の輪郭点群が、どの物体に対応するか？ は、この結果だけからはわかりません。 （上の例で言うと、丸が [0] なのか、[1] なのかはわかりません） なので、 ・パターンマッチングなどで、どの物体に対応するかを判定する ・必ず１個しか検出されないように入力画像を工夫する など、適当な方法を決める必要があります。 入力が Kinect ということであれば、例えば座標（最も画像中央に近いものを採用する）や面積（最も面積が大きい物を採用する）またはそれらの組み合わせを元に判定すると良いのではないでしょうか。
どのように「正常に動作しない様」なのか不明なので、貴方様に適用できるか不明ですが、 当方では単に計算して表示するだけのプログラムなら動いていますので諦めず頑張ってください。 https://support.microsoft.com/en-us/kb/259403/ja http://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-40-13/7762.Untitled.png
https://msdn.microsoft.com/ja-jp/library/6sehtctf.aspx?f=255&MSPPError=-2147217396 コンパイル時に/Dオプションで指定するか、全てのソースファイルで必ずインクルードしているヘッダファイルで自分で#defineします。 どのバージョンのWindowsでどの値にすれば良いかは、上記記事に書いてあります。
GUIならQtとかGTKあたりでしょうか。これってC言語だけでしたっけ。C++は対応してましたっけ。 その他のクラスライブラリであれば、Boostあたりでしょうかね。
まず、テキストファイルにHTMLタグを出力するコードを書きましょう。 test.htmlとして出力するプログラムを書いてください。 ファイルの入出力のやり方はネットにあります。 出力例 <!DOCTYPE html> <html> <head> <title>TEST</title> </head> <body> <h1>test</h1> <h4>hoge</h4> </body> </html> うまくいったら、testやhogeの中身を 変数で変えられるように作ってください。 最終的には、テーブルタグを使ったり、 文字コードを指定したり作り込んでいく。 　 そして、保存したhtmlファイルをブラウザで開くコードを書く。 （ここまで求められているのかわからんが） 　 起動 ↓ 値を入力してもらう ↓ htmlファイルを出力 ↓ 出力したファイルをブラウザで開く ↓ 終了
回答例　回答不能 これでは、入力された物からHTMLをはき出すのか、ブラウザを作るのか、ブラウザを呼び出すのかも判らないし。 「綺麗な」では定義が曖昧です。 課題だったら何の授業課くらい書かないと丸投げすら出来ないよ。
一般的には無茶と言うか無理だと思います。 そもそも５０代の人を第一線のプログラマーとして雇用し続けている会社は少ないと思います。 個人差が大きいとは思いますが３０～３５歳が限度だと言われています。 それ以後の年代の人は今までの経験を活かしてプロジェクトリーダーなどのまとめ役や管理職などを務めるのが一般的です。 プログラマー３５歳定年説：http://bit.ly/1FXSPtX 年配者でもプログラムはできるとこの定年説を否定する話もありますが、若い年代の人に比べて能力が劣るのは事実で、プログラマーを続けるだけでも難しいかもしれないのに、更に開発言語を変えるなどは難しいと思います。
ここは、質問サイトであり、 プログラム作成サイトではありません。 プログラムを作る際、何かわからないことを質問するなら ここで良いですが、丸投げは受け付けられません。 それに、これは「宿題」でしょ？ 学校の先生に聞いてください。
○C++ にはデリゲートその物に対応する文法は存在しませんが、等価な機能を実現する方法は色々あります。 a. C++11 以降のラムダ式を用いればデリゲート(オブジェクトインスタンスに紐付いたメンバ関数)と同様の物を簡単に作成できます。 例: struct MyClass{ int instanceMemberFunction(int,int); } obj; auto func = [&obj](int _1,int _2) -> int{return obj.instanceMemberFunction(_1,_2);}; b. 或いは、C++11 以降で標準ライブラリに取り込まれた std::bind, std::placeholders 等を組み合わせるという事もできます。 例: // #include <functional> auto func = std::bind(std::mem_fun(&MyClass::instanceMemberFunction), &obj, std::placeholders::_1, std::placeholders::_2); c. C++03 以前でも、等価な事を実現する為のテンプレートを自分で書くことは勿論できます。 例えば、以下の様にして使える Function/CreateDelegate を作るのはそんなに難しくない(実際 Boost ライブラリの boost::function, boost::bind1st, boost::mem_fun あたりを拡張する様な感じでできるのでは)と思います。 Function<int(int,int)> func = CreateDelegate(&obj, &MyClass::instanceMemberFunction); 一旦この様なテンプレートを書いてしまえば、この方法が一番 C# に近い形で使えるのかなと思います。また、マルチキャストデリゲートの対応も、Function クラスの機能として自然に実装できます。 ○注意点 但し、C++ は C# と違ってガベージコレクションがないので、オブジェクトインスタンスの寿命に気を付けなければなりません。特にローカル変数として宣言したクラスインスタンスはスコープを抜けると(≒関数を抜けると)消えてなくなります。寿命の管理は、多くの場合 C++11 の std::shared_ptr で済ませられると思います(勿論、循環参照などには気をつける必要はあります)。 例: // #include <memory> std::shared_ptr<MyClass> pobj=std::make_shared<MyClass>(); auto func = [pobj](int _1,int _2) -> int{return pobj->instanceMemberFunction(_1,_2);}; 最後に: C# と比べると C++ でデリゲートの機能を利用するのは色々と面倒であり C# 使いから見れば C++ は劣っている様に思われるかもしれません。しかし、自分で色々と指定できる分、柔軟に設計できるのが C++ の強みです。効率的に開発するなら C# で、細部にこだわりたいのであれば C++ で、ということです…
http://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AC%E3%82%BC%E3%83%B3%E3%83%8F%E3%83%A0%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0 やりたいのはこういうことか？
何も間違ってないと思います。 > swapdata(&data[1], &data[1]); > となると思うのですが、そうすると同じデータを入れ替えることになってしまいます。 ここは、たまたま境界の右隣のデータを入れ替える時には 境界をずらした結果、無駄に同じ場所を入れ替えることになりますが、 それで意図しない結果が生じるわけではありません。 実際に動かして検証したわけではありませんが、おそらく このコーディングで正しくソートできると思います。 重いものを入れ替えるなら、入れ替えようとしているデータが 既に境界の左に入っているかどうかチェックする処理を入れた方が よいかもしれませんが、そのチェック処理が1stepであっても、 データ数が多くてたくさん入れ替えるならその数分のstepが増えます。 たった6個のデータの並べ替えではなく、もっとたくさんのデータの 並べ替えをする場合、たまたま境界の右隣を入れ替えるケースは 少ないですから、毎回入れ替える前にそのチェックをする方が コストがかかる可能性が高いです。 (そもそも重いものを直接移動して並べ替えてはいけませんよね。 重いものを並べ替えたいなら、その重いものにインデックスを 付与し、インデックスを並べ替えてインデックス経由でアクセス するべきですよね。) なお、クイックソートは、基準値の左右にデータを分けて行くという 考え方で、その分ける方法の違いは、本質的な違いではないと思います。 例えば http://ja.wikipedia.org/wiki/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88 は、左右の両方から基準値に反するデータを探して入れ替えるように していますし、 http://www.daccho-it.com/program/algo/quick.htm は、質問にあるのと同じような方法で左から順番にチェックして入れ替えて いますが、一番左のデータを基準値として処理しています。
0xFFFF00FFは、10進数で4,294,902,015という大きな数値の16進数表現であり、 int型で表現できる-2,147,483,648 ～ 2,147,483,647の範囲外だからです。 uintの0xFFFF00FFと同じビットパターンが格納されるint型の値は -0x0000FF01(=-65281)ですが、数値ではなくビットパターンを表現したい のであれば、uint型を使用すべきです。 ちなみに、C#と異なりC言語は、このあたりの型のチェックが緩いため int ret = 0xFFFF00FF; でも int ret = 4294902015; エラーにならず retの中に0xFFFF00FFというビットパターンを代入できます。 これは一見便利そうですが、本来格納できない場所に平気で格納できる仕様 (上記の例で言うと符号ビットの部分を都合で勝手に使う仕様) は、メモリ破壊に繋がる諸刃の剣でもあります。 このため、最近の言語は安全性に配慮してメモリ破壊に繋がる仕様を 極力排除するのが主流です。
私の場合は、ismbblead　が定義されてるヘッダーをインクルードします。
そういうＰＣで使える接点入力機器はコンテックやインターフェイスなどで販売されています。 もちろんＶＢやＣ＋＋などでソフト開発する為のライブラリもあります。 CONTEC　http://www.contec.co.jp/ Interface　http://www.interface.co.jp/ 接点入力が１秒間に何十回以上とか高速でなければ、もっと簡単に安く済ませる方法があります。 シリアルポートの信号ラインを入力に使う手もありますが、電圧などを規格に合わせないといけないので回路が少し複雑になります。 一番簡単そうなのがゲームコントローラを改造する方法です。 数百円で安く売っているＵＳＢで接続するゲームコントローラを買ってきて、それを改造して接点が入力されるとコントローラのボタンが押されるような回路を作ります。 プログラムはゲームのコントローラのボタンの状態を読む方法そのものです。 それについてはゲームのプログラム関係の本や資料を探せば見つかるでしょう。
すみません、名前では分からず、プロセスＩＤで分けると思います。 そのプロセスの名前は・・・・ 出てきません。すみません。でも、プロセスＩＤまで行けば、名前まで行き着けると思います。
まあ、ＶＢ６で開発した資産が沢山あって、新しく．Ｎｅｔ環境やＣ＃などの新しい言語に切り替えるとなると、その切替というか学習期間中に売上が激減する可能性が大です。 昔、オフコン（小さな汎用コンピュータみたいなの）上のアプリを、Windows上に移植した会社がありました。ソフト開発＆移行はなかなかうまくいかず、売上激減となり、その会社の社長は、「首をつるのに良さそうな木はどれかな？」なんて自殺するのに適した木を探して海岸を歩いたことがあると話していました。 また、マイクロソフトが．Ｎｅｔ構想を２０００年に発表して、もう１５年になるわけです。ですから．Ｎｅｔ環境においても、技術革新が何度かありましたし、昨年は大きな変化もありました。．Ｎｅｔを使っている会社だとしても、１０年以上前の技術レベルで停止しているところもあります。 いずれにしても、ＶＢ６で開発しているところが、最新技術に追いつくのは、小学生がいきなり大学を目指すような難しさがあると思います。が、今でもＣＯＢＯＬの需要があるわけですから、開き直って「ＶＢ６でも商売が成り立つなら、新しいことを覚えない」という選択枝もありかもしれませんね。
DPI設定が異なっているためと思われるので設定を確認してください。 以下は、Windows 7におけるDPI設定の説明です。 画面上の文字のサイズを大きくして読みやすくする － ＠IT http://www.atmarkit.co.jp/fwin2k/win2ktips/1362txtsize/txtsize.html
>変換エラーというのは、入力された値とsscanf関数で指定した書式が異なる場合は含まないのでしょうか。 含みません。 Linuxでの例になりますが http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/scanf.3.html のエラーの欄に書いてあるようなものです。
私は13インチMacBook Air(2013Mid)をiPhoneアプリの開発に 使っていますが、十分普通に使えます。 新しい12インチのMacBookは、それよりCPU性能が落ちますが プログラミング未経験者がiPhoneアプリの勉強を始めるには 十分かと思います。 ただ、XcodeにはInstrumentsという性能分析ツールがついていて それは結構な負荷がかかりますので、私が持っているMacBook Air だと少しつらいです。使えないわけではありません。 ただ、最初はあまり使う機会はないと思います。初心者の中には そんなツールがあることすら知らない人もいます。 普通にデザイン/コーディング/ビルド/テストするだけなら 全然問題ないと思います。
マルチバイト文字セットではだめみたいですね。 Unicode文字セットすれはできると思いますが、 マルチバイト文字セットである必要があれば CStdioFileを使用せずに、stdioのfputws() などを使用するしかないでしょう。
>funk(FILE* &fp)とfunk(FILE **fp)における概念に微妙な違いが >あるような気がしますが？詳細は分かりません・・ 前者はCにはないC++の参照渡し(call by reference)です。
おっと、直リンクじゃなくてもダメな模様なので 『DirectX8.0a』に日本語版が登場、ダウンロード配布を開始 http://ascii.jp/elem/000/000/320/320592/ にある「DirectXのダウンロードページ」あるリンクを http://archive.org/web/ で開いてみてください。カレンダーで2001年4月13日あたりで更に開くと ダウンロードページに辿り着けると思います。
一般的な話ですが FTPの解説ではコマンドに対して必ず応答が有るとされていますが、 FTPサーバによっては、こちらからのコマンドに対して（一部のコマンドに対して）応答を返さない設定になっているものが有ります。 実際にどんな応答が返っているのかは、telnetでつないでみて確認する必要が有ります。
こんにちわ。 ＞そこで思ったのが透過色に設定した色はしっかり透過されているが、 ＞下地の黒が見えている状態なのではないかと・・・。 失礼しました。 仰られる通りです・・・。 TransparentBltは透過して転送するだけなので、 透過されて上書きされないimage2の画素はそのまま=黒のままですね。。。 なので、image2をsaveする段階で透過色を指定できないとということですが、 また間違っているかもしれませんが、アルファチャネルつきのImageを作成してSaveするとできるかもしれません…。 以下は32ビットのアルファチャネル付きの画像(CImage)を作成し、保存するサンプルですが動くかはわかりません。。。 アルファチャネル画像については検索頂ければと思いますが、1画素がRGBに透明情報を追加した画像形式です。 もし宜しければお試しください…。 -- CImage Image; Image.CreateEx(50, 50, 32, BI_RGB , 0, CImage::createAlphaChannel); CDC* pDC = CDC::FromHandle( Image.GetDC( ) ); //Image(pDC)に図形を描画 ... // //アルファチャネル付き画像を1ピクセルずつ走査 for(int y = 0; y < 50; y ++) { for(int x = 0; x < 50; x ++) { unsigned char* pCol32 = (unsigned char *)Image.GetPixelAddress(x, y); if(pCol32[0] == 0 && pCol32[1] == 0 && pCol32[2] == 0) { //黒=RGB(0,0,0)の場合はα=0(透過)にする pCol32[3]=0; } else { //黒=RGB(0,0,0)以外はα=255(不透過)にする pCol32[3]=255; } } } //png形式で保存 Image.Save( L"c:\\icon\\maru.png" ); --
>として初めて中身を入れることができるようになるので >そこから中身をセットしないとできないよ >ということですかね？ そうです。 ただ#2で書いてる事の半分だけですね。 インスタンスメンバーとクラスメンバーが、それぞれどういったものなのか理解された方がよろしいかと思います。 これはC#に限らずC++,Javaなども同じですし。
Javaだけど、JDBCの実装を参考にしてみたら？あれもドライバ入れ替えでインターフェースはある程度共通だし、近しいんじゃない？
こんにちわ。 >その手前のQStringからQByteArrayへの変換時(toLocal8Bit()実行時)、QStringの一時オブジェクトは同じように開放されないのでしょうか？ >失敗しているのであれば、hoge1のパターンも変換失敗となりそうな気がしています。 はい、QStringの一時オブジェクトは開放されます。 toLocal8Bitの関数内部でQByteArrayが生成され返されますが、QByteArrayのコンストラクタで内部に別の配列を作成し、文字列自体をコピーしているのだと思います。 (= QString内部の配列とQByteArray内部の配列は別物 = QStringが開放されてもQByteArrayは無関係) また、参考URLのコンストラクの説明に"QByteArray makes a deep copy of the string data"とありますので、"deep copy"などのキーワードで検索されるとまた宜しいかと思います。 長々と説明が上手くできず申し訳ないのですが・・・、コードでなら以下のように確認できると思います。 -- QString* hoge = new QString("hoge"); QByteArray hogehoge = hoge->toLocal8Bit(); delete hoge; printf("%s\n", hogehoge.data()); ★QByteArray内部の別の配列に文字列がコピーされているので、hogeが解放されても表示されるはず
試してないので想像だけど、CreateProcessで起動されたプロセスが標準出力を掴んじゃってるのが原因なのではないかと。 CGIの出力って「起動されたプログラムの標準出力がWEBページとして出力される」のは判りますよね？ で、CreateProcessは「親のファイルハンドルを継承する筈」なので、標準出力も親プロセスから継承して「掴みっぱなし」になってる可能性があります。 じゃないと、親プロセスと子プロセスで「同時に標準出力に文字を出力」した時に、出力がごちゃ混ぜになっちゃう。 少なくとも、各スレッドで「バッファリング」はしている筈だし「他スレッドとの競合の回避」はしている筈。 で、結果的に「親が標準出力に書き出そうとした時、子プロセスが終了して親から継承した標準出力のファイルハンドルが開放されるまで、ずっと待たされる」って状態になってるのだと思います。 この辺の処理は「unixの時代からの伝統的な手法」で「標準入力、標準出力の競合回避」が必要になると思います。
1. 初期配置 2. ソート結果 3. 中央値 これを表示するだけということでよいでしょうか？ 単純にソートする前と、後に下記の様な表示処理を追加すれば、手っ取り早いです。 for (i = 0; i < DATA_NUM ; i++ ) { printf( "data[ %d ] = %d\n",i, data[i] ); }
<crtdefs.h>は標準のヘッダと同じディレクトリにおかれているはずですが、他の標準ヘッダはインクルードできているのでしょうか。 できているのなら、以下でcrtdefs.hを見つけることができているのでしょうか。 #include "c:\Program Files\Microsoft Visual Studio 9.0\VC\include\crtdefs.h" 2については、フォントを変えるしかありません。 Consolas などバックスラッシュを使っているフォントを選択してください。 お役に立てば幸いです。
サンプル書きました。 「IHTMLDocument2からのSystem::Windows::Forms::HtmlDocument変換」 https://gist.github.com/kumatti1/36422d319017d2ad10a7
No.1 read_line()中でadd_char()を呼んだ後、変数memoryがどうなってるのか確認しましょう。 No.2 read_line()の >pp = (Add_Type *)malloc(sizeof(Add_Type)); この後からadd_char()を最初に呼び出すまでの間に、pp->memoryの初期化がされてません。 malloc()はメモリを確保するだけであって、その中身の初期化はしません。 No.3 read_line()の >　Add_MEM pp[10];//<=NEW Add_MEMが10個分の配列をppという名前で用意してるだけで各要素は初期化されてません。 No.2, 3については「動いてる」といわれてますが、たまたま運良く動作してるように見えるだけです。
(1) C++は Win32、COM、.NET のいずれも作成できます。 C#は COM、.NET は作成できますが、Win32 は作れません。 .NET、COM は C++で作ってもC#で作っても基本的に違い はありません。(実装方式によって依存ライブラリが異なった ものになる可能性はありますが) (2) マニュアルを見ると、Win32 は使うことができるようです。 http://www.dr-ea.com/mql4/MQL4_Reference/01-07-04_ImportingOfFunctions.html (サンプルに載っている "user32.dll" は Win32 です) COM、.NET につてはパッと見では記述が見当たりませんね。 そのままでは使えない可能性が高そうです。
ASCIIコードはそもそも 0~127までしか存在しません。 『128以降』が受け取れないのは当然です。 http://e-words.jp/p/r-ascii.html よって『128以降の文字』が存在する時点で、送られてきて いるデータは普通の ASCII ではありません。 機器で独自に定義した『拡張ASCII』なのか、他のエンコード なのか、機器の仕様を確認されることをお勧めします。 なお、機器の独自仕様(拡張ASCIIなど)である場合は、自分で デコードするプログラムを書く必要があります。
> 【案３】 > Enumwindowで取ったハンドルを、 > Shdocvwを扱うポインタに紐付けて操作する。 これが一番簡単です。サンプルはこちら。 http://mitsu.three-atmarks.com/archives/7858
WebBrowserにURLを設定して、すぐにhtmlからコレクションを得ようとしていますが、ご存じのとおりブラウザというもは通信が間にあるのですぐには表示できない、つまりはすぐには全てのhtml要素を表示できていないので、その為にコレクションに入ってないのではないでしょうか。 WebBrowserのイベントで読み込みが終わると呼ばれるものがあるので、そのあたりから調べてみてはどうでしょうか。 頑張ってください。
　もしかして、windowsのVC++で、補足しようとしている例外は、０除算ですか？ 　だとすると、構造化例外処理がらみとなりますね。 　例えば、 　　http://www.ne.jp/asahi/hishidama/home/tech/vcpp/seh.html 　あたりを参照してみてください。 　前提が外れなら、ちょっと解らないです。
> 互換性のないポインタータイプということのようですが、どう訂正すればいいのかが分かりません。 NSStringじゃなくてNSNumberオブジェクトを作ればいいだけです。 NSNumber *current = [NSNumber numberWithDouble:[[NSDate date] timeIntervalSince1970]]; とするか、 あるいは最近のモダンシンタックスを使って NSNumber *current = @([[NSDate date] timeIntervalSince1970]); としてもよいです。 NSNumberクラスについてちゃんと勉強することをお勧めします。 (参考) https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNumber_Class/index.html http://iphone-tora.sakura.ne.jp/nsnumber.html
＞DivBdInfo[i].StgSizeAvgの変数iを３や５に変えるとこちらは値が入ります。 デバッグ時にSumとcntに値が入っているのは確認しました。 iはチェックしましたか？ for(i=0;i<movenum;i++){stringlist[i].chk=FALSE;} ここで使った値のままでいいんですか？ それと、 ＞ for(i=0;i<DIVBOARD_NUM;i++) { GetDivideRfXY(i,&rfx,&rfy); for(i=0;i<movenum;i++){stringlist[i].chk=FALSE;} iの２重ループでいいんですか？
申し訳ありませんが、私には質問者さまが掲示した式の意味がよく分からないんです。 更によく読むとどうやら10ドットは連続しているように思われます。私は円周上にばらばらに10点あるように勘違いしていたものですからGPSで地上の位置を最小二乗法で求めるようなイメージで最小二乗法と書きましたが、そうではないようですから最小二乗法では難しいかもしれないと思い始めています。GPSでも位置検出に使用する衛星が天空の一部地域に偏っていると精度が悪くなるようですから。ということでHough変換を最初に調査されることをお勧めします。Hough変換は通常線分の検出に使用されますが、工夫することで円の検出もできるようです。 10点が円周上にあるとおっしゃっていますが、y=√(a-x^2)で計算されるy値は必ずしも整数値にはならないわけですよね？　その辺が難しいところと思います。
見たところおかしいところはありません。 一応、念のためですが、 x,y　ともに intですね？ int point_y[20] = { 0 };　は、point_y[0]　のみ初期化する意図ですね？0～19すべて初期化するのであれば、 {0,0,0, …　} と0を20個書いてください。 ところで、”この時点”というのがどの時点か分かりませんが、恐らくなんらかのデバッガだと思いますが、 ステップ実行で見るなら、 c=c+1; まで実行させてから変数の内容を確認してみてください。 もっと確実なのは、printf()文を入れて出力させる方法です。
ポインタと配列の違いを、もういちどちゃんと勉強しなおした方がいいと思います。 foo = reinterpret_cast< Foo* >( bytData ) ; の後では 　アドレスbyData : foo->tenmpの領域 : 値=0x00000001 　アドレスbyData+4 : foo->countの領域 : 値=0x00000002 　アドレスbyData+8 : foo->dataの領域 : 値=0x0000000400000003 となっています。 dataは int**ですから、 data[0] は 「dataの値が示すアドレスにある、 int *の値」 です。 　アドレス 0x0000000400000003 : foo->data[0]の領域: 仮に 0x1000000000000000 とする *foo->data[ 0 ] とすれば、「上記のアドレスが示すアドレスにある、intの値」となります。 　アドレス 0x1000000000000000 : *foo->data[ 0 ]の領域: 仮に 0x000000010 とする → printf( "%d\n", *foo->data[ 0 ] ) ;// 0x000000010 = 16 foo->data=new int*[2]; では、 foo->dataの領域に、 new int*[2]の結果が代入されます。 new int*[2] で 0x2000000000000000 が確保されたとすると 　アドレスbyData+8 : foo->dataの領域 : 値=0x2000000000000000 よって > bytData[8]が破壊されてしまいます というのは当り前の現象です。 struct Foo { 　　　int　　tenmp ; 　　　int　　count ; 　　　int　　data[2] ; } ; と配列で宣言すると、dataとして int2個分の領域がFooの中に確保されます。 　アドレスbyData : foo->tenmpの領域 : 値=0x00000001 　アドレスbyData+4 : foo->countの領域 : 値=0x00000002 　アドレスbyData+8 : foo->data[0]の領域 : 値=00000003 　アドレスbyData+12 : foo->data[1]の領域 : 値=0x00000004 となる *** 可能性はあります *** ですが ○sizeof(int)がいくつになるか? ○メンバがこの順番に並んでいるか? ○メンバが隙間無く並んでいるか? ○3,0,0,0 は 3なのか、0x03000000 なのか、それ以外なのか といったことが、コンパイラ,CPU,OS,設定等によって違ってくることがあります。 精通している人が理解した上で、十分に注意して使う(でも使いたくない)裏技です。 // 特に、C++ではこれでは問題になることがあります
> gcc : fatal error : no input files compilation terminated これは、gccが動作していて、その上で入力するファイルが無い、というエラー > 'gcc'は内部コマンド、外部コマンド > 操作可能プログラムまたはパッチファイルとして認識されていません。 これは、そもそもgccが見付からない、という コマンドプロンプトが出すエラー。 まったく別のものです。 確認用には gcc --version を使いましょう。正しくインストールされていればGCCのバージョン情報が表示されます。 このエラーが出るということは ○PATHの設定が間違えている ○MinGWはインストールしたけど、gccはインストールしていない のどちらか(あるいは両方)です。 > ;C:\MinGW\bin」を追加。 したのなら、 DIR C:\MinGW\bin でファイル一覧を見てください(エクスプローラから上記フォルダを見てもいいです) その中に gcc.exe はありますか? また PATH とコマンドを入力すれば、現在のPATHが表示されます その中に追加したC:\MinGW\bin は入っていますか? > 次にコマンドプロント内に > HelloWorld.c > と入力しました。この際に、Visual Studio C++が開き、私の書いたコードが反映されます。 これは、エクスプローラからダブルクリックして、Visual Sutdioのテキストエディタで開いた、というのと同じです。 これだけではコンパイルはされていません。 > そして、コマンドプロントの方は何も表示されない状態になりました。 > おそらく、コンパイラしてエラーがなかったのだと思います。 違います。 コンパイルそのものが実行されていません。
例えばTextBoxのMaxLengthだった時 取得は可能だが、設定は許可しない例です。 【コンポーネントの実装】 class Class1 : TextBox { [Browsable(false)] [EditorBrowsable(EditorBrowsableState.Never)] [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)] public new int MaxLength { get { return 0; } protected set { } } private int _yyy; public int YYY { get { return this._yyy; } set { this._yyy = value; base.MaxLength = this._yyy; } } } 【利用時】 class11.MaxLength = 1; エラーメッセージ set アクセサーにアクセスできないため、プロパティまたはインデクサー 'WindowsFormsApplication1.Class1.MaxLength' はこのコンテキストでは使用できません。 EditorBrowsable(EditorBrowsableState.Never) 外部ソリューションで参照された際に、コード入力中に表示されるインテリセンスの候補として出現しなくなります。 勘違いしてはならないのが、同一ソリューション内の他プロジェクトでは効きません。 [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)] コンポーネントを設置した際、Designerファイルで自動生成されるコードとして除外します。 これを設定することで、Designerファイル上にプロパティの設定コードは自動生成されません。 上記例だと、結果的に以下の動作になります。 　・Designerファイルで制御文が入ってこない。 　・インテリセンスに表示されてこない。 　・直接入力されたとしても、値を設定することはできず、無意味？な値の取得のみ行える。 　　（無意味かどうかは実装に応じて・・・） Obsolete("使用不可", true)は、上記に加えてお好きにどうぞ、という感じです。 Obsolete()はメッセージが適切かどうか微妙では？ 操作不能としたいという要望では、上記の方法論の方が適切かもしれません。
> static void uint2Hex（）によって文字列に置き換えを行っているのですが とのことですが、unit2Hex() は一度も呼ばれていないようです。 つまり、文字列の置き換えなどされてないと言うことです。 また、data1, data2 をそれぞれ、0xfa00, 0xfa10 番地に割り当てているようですが、これも意図が理解できません。 ここには、未定義のレジスタが存在するようですが、定義されないところを何かに使うのは、良くない気がします。 その他にも、rs_puts() が定義してあるのに使っていないとか、ずいぶんと不思議な気がします。 他のところがあっているとすれば、 Getad() { unsigned int data; char buff[16]; initSCI3(); // SCI3初期化 data = AD.ADDRA >> 6; uint2Hex(data, 0,buff); rs_puts(buff); rs_putc(':'); // 区切り記号（適当に） data = AD.ADDRB >> 6; uint2Hex(data, 0, buff); rs_puts(buff); rs_putc('\x0d'); // 区切り記号（適当に） AD.ADCSR.BIT.ADF = 0; AD.ADCSR.BIT.ADST = 0; } こんな感じで、16進の文字列で出てくる気がします。 data も省くなら、 Getad() { char buff[16]; initSCI3(); // SCI3初期化 uint2Hex(AD.ADDRA >> 6, 0, buff); rs_puts(buff); rs_putc(':'); // 区切り記号（適当に） uint2Hex(AD.ADDRB >> 6, 0, buff); rs_puts(buff); rs_putc('\x0d'); // 区切り記号（適当に） AD.ADCSR.BIT.ADF = 0; AD.ADCSR.BIT.ADST = 0; } でも、いけるのではないかと思います。
例えばプログラム名をhogeとした場合 hoge と起動した場合 argc = 1 argv[0] = "hoge" hoge aaa bbb の様に起動した場合 argc = 3 argv[0] = "hoge" argv[1] = "aaa" argv[2] = "bbb" ↑の値が各変数にセットされます。 以後の処理で、それらの値を使用するのが 必須の場合、引数をつけずにプログラムを 起動したか、値が適切な物であるかどうか を「コマンドライン引数チェック」で確認 してチェック結果に応じた処理をします。
あまり自信は無いですが、 tmp[j]^=iv[j] ここで使う　iv[ｊ]; の値は、暗号化のときと復号化のときでは、 違った値になっていませんか？ iv1[]、 iv2[] を用意して 復号化と暗号化で別の領域を使ったらどうでしょうか。 　
> 　　　out_img->imageData[out_img->widthStep * 6 + 6 * 3] = 0; >　　　out_img->imageData[out_img->widthStep * 6 + 6 * 3 + 1] = 0; >　　　out_img->imageData[out_img->widthStep * 6 + 6 * 3 + 2] = 0; これでは座標(6,6)であり、6x6の画像(x=0～5,y=0～5)に存在しない点です > なぜか上のsrc_img_grayでは黒がゼロにはならない JPEGで保存しているようですが、JPEGは非可逆圧縮を使っています。 不可逆とは、元に戻らない、という意味です。 「見た目が似ていれば、ちょっとくらい色が違っていてもいい」という考えで、高圧縮率を実現しています。 元の色が黒(0)だったら、JPEG保存したものを読み出したときに「だいたい黒(1とか2とか)」になってればいい、というものです。 そのまま扱いたいのなら、PNG等の可逆圧縮やBMP等の非圧縮形式を使いましょう。 > uchar iro = tmp_img->imageData[tmp_img->widthStep * y + x * 3]; なぜ x *3 になっているのですか? 前にも言いましたが、配列や画像の範囲について注意が足りません。 まずは、imageDataに直接アクセスするのではなく、 cvSet2D/cvGet2D やcvSetReal2D/cvGetReal2D で x,y を指定するようにしては。 imageDataを使いたいのなら、C言語の配列とポインタをしっかり学習してマスターしてからにしましょう。
va_list 等は、可変長引数を扱うためのものです。 va_list 、 可変長引数 等で検索すると、より詳しい解説がみつかります。 例えば、 printf では、引数が1つのときもあれば、3つのときもあります printf("hello world"); /* 引数が一つ */ printf("No.%d is %f\n",i,d[i]) ; /* 引数が3つ */ こういうのが可変長引数です。 後半のループは、 配列 fmt と変数 k の内容を追い掛ければわかるかと思います。 %があったらmessからfmtにコピーを始めて、 s,d,x等があったら、fmt を書式文字列に指定して、fprintf を実行しています。そのとき、呼び出し元で指定された可変長の引数から順番に取り出して、fprintfに指定しています。 例えば error("aa%2c",'b') ; だったら a → fprintf(f2,"%c",'a') ; /* k==0だから */ a → fprintf(f2,"%c",'a') ; /* k==0だから */ % → fmt ="%" ; /*k=1に */ 2 → fmt ="%2" ; /*k=2に */ c → fmt ="%2c" ; fprintf(f2,"%2c",'b') /*k=0に */ つまりは error(msg, a0, a1, ... ) ; が { fprintf(f2, msg, a0, a1, ...) ; exit(1); } と「ほぼ同等」の意味になります。 ただ。 単純に{ fprintf(f2, msg, a0, a1, ...) ; exit(1); } とするなら、va_list をそのままfprintfに渡せる「 vfprintf 」という関数があります。 わざわざmsgを解析する必要はありません。 fprintf(f2,fmt,(char)va_arg(list,int)); の (char)va_arg(list,int) については、意図をわかりかねます。 Cの可変長引数のルールとして「int以下の整数は、intに変換される」というのがあります。 　char c ='a' ; 　printf("%c",c ) ; とした場合、実際には 　printf("%c",(int)c ) ; となります。よって、va_argで取り出す際には va_arg(list,int) なのが正解です。 しかし、それをまたcharに戻す理由はわかりません。 fprintfも可変長引数なので 　fprintf(f2,fmt,(char)va_arg(list,int)); は 　fprintf(f2,fmt,(int)( (char)va_arg(list,int) ) ); と同義です。 "%c"の方はまだ「charとして扱いたい」という(無意味な)理由が考え付きますが、 "%x","%d"の方はわかりません。 「int i ; error("%d",i) と指定なっていたら、iはintではなくcharとして下位8ビットしか見ない、ということなのでしょうか。
>このようにすると、key[0]=0x31,key[1]=0x32,key[2]=0x33,key[3]=0x34 key_buf[0]=0x31,key_buf[1]=0x32,key_buf[2]=0x33,key_buf[3]=0x34 の書き間違えでしょうか？ またstrtoul()に渡す文字列はNUL文字終端である必要があるので key_buf[0]='1',key_buf[1]='2',key_buf[2]='3',key_buf[3]='4',key_buf[4] = '\0' になってるのでしょうか。 また >これとpass=0x00001234 は同一と判定して、それ以外だとfalseと分岐されました。 strtoul()の第3引数が10ですから、"1234"は10進数での1234(16進数でいえば0x4d2)です。 0x00001234と同一と判断されるはずありません。
コンフィグファイルが、BOM（バイト・オーダー・マーク）付きのユニコードで保存されてしまっているようです。 ■■はおそらく、BOMです。 文字コードをASCII（メモ帳だと、ANSI)で保存してください。 プログラムファイルの文字コードも間違っている可能性がありますね。
ケアレスミスですね。 誤： double naiseki(int *vecterA, int *vecterB) { 正： double naiseki(double *vecterA, double *vecterB) {
>すいませんコメントつけたほうがよかったんですね… コメントを書かれいない場合、そこで何をやりたいのか他者には伝わりませんよ。 >そこは渡されたdataを16ワードごとに区切って一度tmpに入れて暗号化、それからもとのdataの位置にそれを戻してやるという動作をさせたくて書きました。 memcpyをちゃんと調べてみましょう。 第2引数にint *を渡してるからといって第3引数のintを指定した個数分(今回でいえばintを16個分)という意味になったりしません。 memcpyをちゃんと調べれば >memcpy(data,init,16); >memcpy(data2,init2,isize); などもおかしいことがわかると思います。
Expression : (str !=NULL) で検索すると http://okwave.jp/qa/q459729.html 等が見つかります。 そう考えてプログラムを見ると if( (fp = fopen( "zahyou1.csv", "r")) == NULL ) { printf( "can not open the file.\n" ); } if( (out = fopen( "out.csv", "w")) == NULL ) { printf( "can not open the file.\n" ); } いずれも、fopenの戻り値がNULLかどうかのチェックはしていますが、NULLであるとき(=fopenに失敗したとき)にはメッセージを出力するだけで、そのまま実行を続けています。 このままでは、実際にfpやoutを使おうとしたときに、問題となります。 エラーの場合は、後の処理をしないような工夫をしましょう。(exitやreturnで終了させるなど) また、Visual Studioを使った場合の、よくある話なのですが。 fopen( "zahyou1.csv", "r") このようにファイル名だけ指定すると、カレントディレクトリにあるディレクトリから探します。 このあたりの詳細は、「作業ディレクトリ」「カレントディレクトリ」等で検索してください。 VisualStudioからデバッグ実行した場合は、プロパティの中にある「デバッグ時の実行ディレクトリ」になっています。 初期では、 bin\Debug やbin\Relase 等の、実行ファイルのあるディレクトリになっています。 ソースコード(～.c)と同じディレクトリに zahyou1.csv があっても、bin\Debug に無ければ fopenは成功しません。 ・ファイルの置き場所を変える ・作業ディレクトリをzahyou1.csvのあるディレクトリに指定する ・ファイル名だけではなく、ディレクトリの場所もフルパスまたは相対パスで指定する といった対策が必要です。
ほかのプログラムを呼び出すと言っているのは，このプログラムの引数を他のファイルにして実行すると言う意味だと思う。 >#1 そういう意味なら，当然，別のファイルでも動きますよ。なお，引数がテキストファイルでなくバイナリファイルだと行数と言われても困りますと言う状況になるが，とにかく結果は返ってくる。
＞ループの条件にi=1,2,3,…,n/2 for (i = 1; i <= n/2; i++)
fputs(str, stdout); fprintf でもいいけど。
[Q1]word3とword４ではなぜ、*word3, *word4とポインタで設定するのでしょうか？ [A1]別にchar word3 [] = "ABD";としても問題はないと思います。気まぐれとしか思えません。 [Q2]「word4 = strchr(word4, *word2)」とポインタ指定するのは何故か？ [A2] ポインタ指定なんかしていない。ポインタが指している実体を引数にしている。 char a = 'A' ; char *pa ; pa = &a ; char c ; のような場合、'A'をアクセスする場合には c = *pa ; と書くでしょ ? それと同じです。 つまり、 word4 = strchr(word4, *word2) は word4 = strchr(word4, 'a') と同じです。
> 思い通りの解答になりません。 具体的に、どのようになっているかわかりますか? ただ「思い通りにならない」と言われても、何の解決策も思い付きません。 具体的にどうなっているかを調べ、 どうしてそうなるのかを調べる というのが、プログラム修正の基本です。 おそらく ○何を入れても「正解」になる。 という現象が起っているのでは。 この現象から、想像力を働かせて、どうしてそうなるかを考えます。 例えば ○合否判定を間違えたら「全部正解」になりそうだ ○結果を保存する箇所を間違えたら「全部正解」になるかもしれない ○保存した結果を出力するときに間違えて「全部正解」と出力してしまっているかもしれない 　合否判定は ans==a+b 　ぉの結果を収納するのが if(ans==a+b) kaitou[i+1]=seikai; else kaitou[i+1]=huseikai; 　出力するのが if(kaitou[i+1]==seikai) printf("○\n",seikai); else printf("×\n",huseikai); ここだけ取り出すと、判定は正しいように見えなくもないですが kaitou[]に代入されている具体的な数値をよく考えると、間違っていることが判明します。 kaitou[i+1]=seikai; kaitou[i+1]=huseikai; それぞれ、kaitou[i+1]にどんな値が入るか、考えてみましょう。 あと。 > int kaitou[10]; と宣言したとき kaitou[?]～kaitou[??] の?～??はいくつになるでしょう? forでi=0～9になっていますが、i=9のとき、 kaitou[i+1]はどうなるでしょうか? > printf("○\n",seikai); > printf("×\n",huseikai); エラーにはなりませんが、seikai,huseikaiが無意味です。
No1です。 このソフトだと、バイナリデータ（0x00～0xff）をそのまま送信するのと、 16bit分データを送信していないのでデータが化けて当然です。 文字を送信しなさいということは、16bitのデータが0x01faなら"01fa"と 文字列に変換して、 sendCharSCI('0'); sendCharSCI('1'); sendCharSCI('f'); sendCharSCI('a'); という風に送信するようにプログラムしてください。
>１、インチ単位の数を引数として何cmかを出力する関数を作成しなさい。 インチが何かわからないのか 引数がわからないのか ｃｍがわからないのか 出力とは何かわからないのか 関数がわからないのか どれ？ それとも、宿題するの嫌だから誰かに作って欲しいということ？ ＞２、f(x)=ax^2+bx+cのa,b,cを順に引数として、f(x)=0の実数解の個数を出力する関数を作成しなさい。 　 1 と同様。
モードフラグをバイナリ指定しているのでテキスト形式では数値に該当する文字コードの文字が見えてしまいます。 数字をテキストで読めるように書き込みたい場合は，数値を文字列に変換後のほうが良いかと思います。
> 改行（\n）までをファイルに書き込めばいいと思うのですが、プログラムでどう書けばいいかが分かりません その通りに書けばいいだけでは? > /*半角スペース部分をとばし、p1をBの最初の文字にする*/ > *p1++; /* ここでの * p1 ++ の * は不要というか無意味というか */ で、 p1はBの先頭に来ているわけですから p1の指す先が改行になるまで繰り返す { 　p1の指す先を1文字出力 　p1 ++ } でOKです。 ○元プログラムでの注意点 ・wordへ7文字コピーしていますが、終端文字('\0')を入れている様子がありません。 wordの状態によっては、正しく動作するように見えることもありますが、大抵は何かの問題が発生します。 症状が軽ければ文字化けで済みますが、最悪はシステム破壊まで有り得ます。 ・1行が、改行込みで「半角英数」199文字までなら問題ありませんが、それ以上の長い行があるようなら、扱いに注意が必要です。 ○別解1 > 　ここで工程3を行う の時点で、 p1 は、「B\tC\n」という文字列の先頭アドレス、と解釈もできます。 あらかじめbuffの改行コードを'\0'にしておけば、p1 は「B\tC」という文字列の先頭アドレスということになります。 そうすれば fprintf(fout,"%s;;;%s\n",p1,word); で済みます。 ○別解2 C言語での文字列操作は、正直面倒です。 この内容なら ・UNIX系OS標準のsedコマンド (Windows移植版もある) ・Perl,Ruby,Python等のテキスト処理が得意な言語 ・「正規表現による置換」機能を持つ、ある程度高級なテキストエディタ 等で簡単にできます。
stdio.h 系でやるならば FILE* fp = fopen(ログファイル, "r"); ログファイルを末尾まで読み取る処理(fp); long pos = ftell(fp); fclose(fp); 一定間隔にて以下を繰り返し fp = fopen(ログファイル, "r"); fseek(fp, pos, SEEK_SET); ログファイルを末尾まで読み取る処理(fp); pos = ftell(fp); fclose(fp); iostream 系でも同じ考え方で処理できます。
for (m = 0; m < renzoku + 1; m++); になってるので、このfor文は空文を繰り返すだけですね。;を外しましょう。
>一応、ReadFileをおわったあとにdwReadを確認したのですが、５０になっていました。 であれば、ReadFile()が失敗したとかはなさそうですね。 # ReadFile()の戻り値を確認していないのであればdwReadはReadFile()コール前にクリアしておいた方がいいかと思いますが。 >なんらかの失敗といわれるとどういった失敗がありえるのでしょうか？ タイムアウトがないのであれば…基本的には失敗はない…でしょうね。 コネクタ類が接触不良でデータが化けるとか、XON/XOFFフロー制御している…とかでなければ。 >（ボーレートの設定がおかしければデータがかわることはあるでしょうが・・・） ボーレート以外の設定が異なっていた場合も化けると思われます。 >接続先がデータを送らなくとも、ReadFileがデータを格納することがあるのでしょうか？ 受信バッファに残っていた場合は読み出す…でしょうね。 CreateFile()でシリアルポートを開く処理、シリアルポートの設定を行っている部分も掲示された方がいいかも知れません。 # が、私自身はAPI叩いてシリアルポート操作したことは無かったりします。 WindowsAPIのパターンとして…構造体は0x00でクリアして必要な部分だけ設定する。 という方法を採らないと妙な挙動することもありますので、その辺りは確認された方がいいでしょう。 APIに構造体のアドレスを渡して、情報を取得(上書きされる)から…ということで、未初期化の構造体渡したらエラーで何も設定してくれなかった。 なんて場合もあります。 # 構造体のメンバに「構造体のサイズ」を格納する場合、その構造体のサイズで対応バージョンを判別する。 # なんて挙動をしている場合もありますので。
> 対人戦でなく、CPUを相手にするゲームなのですが、対戦する相手を > ランダムで順番に対戦相手の中から選ぼうとしています。 > > ただ、それだけなら一件一件ランダムで拾えばいいと思われますが、 > 一度勝ち進んできた対戦相手とさかのぼってもう一度やってみたいと > いう機能を付けてみたいと思っています。 > そのため、どういう順番で対戦相手が出てきたかの履歴が必要になります。 なるほど、そういう背景があるんですね。 でも、それだったらランダムが必要なのはゲームの開始時ではなく新規の対戦相手の選択時ですよね。 自分だったら、現在のテーブル構成でという制約なら 3 番目の列名を「対戦順」と呼ぶとして 　(1)ゲーム開始時に全レコードの「対戦順」を未対戦を表す値に設定する。 　(2)新規対戦時にはテーブルから「対戦順」が未対戦のものを捜し、その中からランダムに選択する。そののちその選択したレコードの「対戦順」を新規対戦が何番目かの値に書き換える。 　(3)過去にさかのぼって対戦する場合には「対戦順」が未対戦ではないものを「対戦順」でソートして捜し、その中から一つを選ばせる。 　(4)次の対戦相手は「対戦順」が現在の対戦順 +1 のものを捜し、見つかればその対戦相手を選択する。見つからなければ新規対戦として (2) を行う。 という風にしますしあなたもその案を考慮したでしょうが、そのうえであえて『データベースのフィールドにランダムでインデクスを振る』理由はなにかございますでしょうか。
90度回転した画像なら、画像の一括変換機能なんかのあるソフトでまとめて作成できます。 お勧めはIrfanView。 IrfanView 日本語版のページ http://www8.plala.or.jp/kusutaku/iview/ 上を利用すれば、 ・元の画像 ・15度傾けた画像 ・30度傾けた画像 ・45度傾けた画像 ・60度傾けた画像 ・75度傾けた画像 の５つ作れば、更に90度ずつ回転して15度刻みの画像が360度分の24枚作れるとか。
> SMTP-AUTH の場合は、AUTH-PLAIN　が　must になっていたと思うのです。 mustではないです。 例えば、メールサーバーがPostfixの場合だと、 smtpd_sasl_security_options に　noplaintext　を指定すると、AUTH-PLAINでの認証が出来ません。 つまり、通信する相手（メールサーバー）の設定次第です。 ただし、OutlookやOutlook ExpressがPLAIN認証しか対応していないので 一般的なメールサーバーでは、PLAINに対応するのが普通だと思われます。 （社内・学内などでメールソフトが限定的な運用環境なら外せるでしょうけど） telnet メールサーバー名 ポート番号(25や587) でつないで EHLO local を叩いてみれば、 250-AUTH CRAM-MD5 LOGIN NTLM PLAIN DIGEST-MD5 等が返ってくるので、これでSMTP-AUTHでどんな認証方法が使えるかが分かりますよ。 なので、MUA(メールソフト側）から言えば、これをみて、どんな認証を使うかを 決めればよいことになりますね。
>>SMTP AUTH で、ポート　587　への接続ですが、 AUTH PLAIN 　で接続できるサーバーと、接続できないサーバーがあるようです。 セキュリティアップということでしょうか？特に最近は「野良ＡＰ］というか「野良ＷｉＦｉ」「無償ＷｉＦｉ」への接続等で、ＩＤ，Ｐａｓｓが盗まれることも多いように思えますから、メールサーバ側で「ＰＬＡＩＮ」接続を受けないものが増えているのだと思えます。 私の場合、独自ドメインを取得して、自前のメールサーバを立ち上げたのですが、電信８号といったシンプルなメールソフトでは、問題なく送受信できるけど、thunderbirdでは、メールアドレスの登録で、なんどやっても私のサーバが「見つかりません」と拒否される状態が続きました。 それで、メールサーバのセキュリティ設定のレベルを強化したら、thunderbirdにアドレスが登録可能となりました。 とはいえ、私がメールサーバ設定するとき、thunderbirdが接続できず、いろいろとサーバ側の設定変更を繰り返していたため、同時に変更した他のサーバ設定項目によって、登録可能となったという可能性もあるのですけど・・・・ その後、androidにインストールしたメールソフトにおいて、私のメールサーバに接続して、新しいアドレス登録をするとき「暗号化したパスワード」を選ばないとエラーになりました。ですので、ＡＵＴＨ　ＰＬＡＮかどうか判りませんが、接続のセキュリティを強化したモードでないと受け付けないサーバが増えているのだと思います。
基本は日本人が英語を話すのと同じです、日本の学校で形だけ覚えた所であまり使えないでしょう、必用だから英語を使う訳で、やりたいことが明確だからその手段などを英語で考える事さえ出来るようになるのです、Ｃ言語もアルファベットを使う一つの言語と考えて下さい、英語圏が人がドイツ語やフランス語で考えるようなもので、スペルも近いですし、意味も近いです、ただ文法的な所での違いはあります、Ｃ言語はそれら英語と近い別の言葉と考えれば良いだけで、プログラミングで問題なのは、スクリプトとは違いハード的な部分を理解していないといけないと言う所です、Ｃはアセンブラに続き色々な事が出来、制約が少ないですが、逆に制約が少ないという事は全部自分でやらないければないらないという事です、 家を建てるので言えば、スクリプトは２Ｘ４の出来上がっている部品を組み立てて家を作るのと、木材を山から切り出し作るのがアセンブラ、Ｃは製材された木材からのこぎりやノミで加工して家を作ると言った感じです。 つまり作る物のイメージや目標があり設計や手順（プロトコル）をあらかじめ準備する、下準備をきちんとしないと、難しいと感じてしまいます、大工だって図面も引かずにいきなり家を作れと言ったって無理ですし、ましてや素人では不可能です、ですから最初は見習いがやるように、やり方を覚える訳ですから、こうやる時はこの手順でこう、と言うのを自分勝手や手抜きをせずに、基礎を覚えれば、良いと思います、独学だとそこの部分で安易な方法を取ってしまいがいちで、ある条件下では使えるが、別の条件だと使えないという事が起き、難しさが倍増してしまうみたいです（反省）。
> この連載では，以下のような開発環境をベースに解説を行っていきます。 > バージョン：OpenCV 1.0 > OS：Winodows XP > IDE：Microsoft Visual C++ 2005 現在、OpenCVは2.xになっています。 ディレクリ構造が1.xのころから少し変っています。 2.x用に書かれた資料を探すか、自分で修正できる程度にC/C++言語の知識を深めるかしましょう。 私としては後者をお勧めしたいところです。
コンテナに巣の配列を要素として入れることはできません. C++11 (以降) なら std::array を使えばいい. C++98 なら ・あきらめる ・Boost の boost::array を使う ・C++11 の std::array 相当のものを自作する のいずれか, かな.
＞パラメータ 'argc' は一度も使用されない(関数 main )・・・ 2行目で、argcが宣言されていますが、それ以降でどこでも使われていません。 ということで、文字通りの意味のメッセージです。 警告メッセージですが、この場合は使っていないのは意図的なので、特に気にする必要はありません。 で、bcc32 ～～～.c で行うのはコンパイルです。 コンパイルとは ～.c というソースファイルから ～.exe という実行ファイルを作ります。 bcc32 を実行した後、dir とすると、 example9.exe example9.obj example9.tds というファイルが出来ているのがわかると思います。 example9 と打ち込んで実行してください。 ～.obj と ～.tds は、単純なコンパイル＆実行の場合は不要です。
旧いコンパイラで作られたライブラリをリンクしていませんか?
最後に printf("%20.15f\n", a); を追加したらどんな表示が得られますか?
つ https://www.youtube.com/watch?v=u0GwWnoTYGY というか、たしか以前の質問で VS をインストールしてて C 言語でのコンパイル方法を質問してたよね? どうしてそれでコンパイルしてみないんでしょうか。
> intがなかったらOKですかね Xも小文字のxの誤記ですので、それらを修正すればＯＫですよ。 #include <stdio.h> int main(){ int x = 5; int y = 8; printf("%d * %d = %d\n" , x,y, x * y); x = 3 ; y = 11; printf("%d * %d = %d\n" , x,y, x * y); return 0; }
元のソースに手を加えたくないという事なら既に行われてるようにincludeするくらいしか手はないと思います。 あとはソース作成段階でテストできるような仕組みを用意しておくとか。
私は上の方を使用しています。 その理由は、hが100だったとして、iが30の時にヒープが足りなくなってしまった場合に、エラー処理として既に確保済の30個はfreeで開放しなければなりませんが、上の方であれば、一回のmallocで100個分の全体が確保できるかできないかのどちらかです。従って既に確保済の部分だけを開放するという細かい操作が必要なくなります。
確保するときと、開放するときとで、iの値がどのように変化するのか考えてみましょう。
> #4 #1です。ご指摘、ごもっとも。自動変数が初期化されるシステムでもダメですね。 > 質問者 warningはコンパイラからのツッコミなので文法的に是正していけばいいですが、segmentation faultや一般保護エラーは実行環境(OSとか)からのツッコミですので、実行環境であなたのプログラムが何か「悪いこと」をやらかしているわけです。 それが何かを理解する必要があるので、C言語の文法的な問題ではないのかもしれないという予想と、実行環境が何を嫌がっている(何をしたらシステムが発狂する)かを知るべきです。 ちなみにOSがないシステム(組み込み機器とか)なら誰からもツッコミが入ることなく、ただ暴走もしくはフリーズするだけですがね。 「int a;」という記述はコンパイラによって、とあるRAM領域のどこかにint型の値を記録できる領域を確保して、そのアドレスに紐付けされたaというラベルを提供するという処理に置き換えると考えることができます。そして「a=1;」は、aというラベルに紐付けされているRAM領域に1が書き込まれます。(感覚的な表現であって、アセンブリ言語レベルでは違う処理かもしれませんが。) それに対し「int *a;」という記述は、とあるRAM領域のどこかに「int型の値を記録できる領域」のアドレスを記録できる領域を確保して、そのアドレスに紐付けされたaというラベルを提供します。そして「a=1;」は冗長に書くと「a=(int*) 1;」であって、つまりint型変数のアドレスとして「1番地」をaに紐付けされたRAM領域に書き込みます。さらに「*a=1;」は、「1番地のRAM領域」にint型の1という値を書き込みます。 WindowsやMacのようなメモリ保護前提のOSでRAMアドレスを直接指定するということはまずないと思いますが、μITRON系OSやOS無しマイコンでは絶対的なアドレスを指定して値を書き込む場面は多々あります。 で、なんで「int *a; a = 1;」がダメなのか。 「int *a;」ではaは、書き込んでも良いアドレスで初期化されないからです。「int型を記録できる領域のアドレス値」の入れ物が定義されただけで、aが持っている値は不定なわけです。それは0番地かもしれないし1番地かもしれないし、100番地かも知れないし、1000番地かもしれません。 その後の「a=1;」はどこだかわからないアドレス番地に1を書き込んでいることになります。 で、ここからが実行環境の話です。 実行環境、特にOSがある場合は、RAM領域の中でシステム専用のアドレス領域やmalloc()で取り出す元になる領域などといったように用途ごとに区画分けがされています。そして1という値は、あなたにとってはint型の1であっても、それぞれの区画では別の意味でしょう。書き込むアドレスによっては、もしかするとパソコンを爆破する命令を指す値かもしれません。 そういった不定な領域に任意の値を書き込む行為は、(あなたにその意志がなくても)実行環境にとってはテロなわけです。テロへの対抗手段として、実行環境があなたの実行したプログラムを(自衛のために)殺すのが不正終了と呼んでいる挙動、その原因である不定な領域に不正な値を書き込む行為を指すエラー名がsegmentation faultや一般保護エラーです。 ちなみに0番地に書き込むのも大多数の実行環境ではテロにあたる事が多いので、「int *a = 0;*a=1;」もsegっちゃうよ、というのが#4の指摘だと思います。(外してたら恥ずかしいな・・・) だったらどうしたらいいのか？ですね。 int *a; としたら、 if ((a = (int*) malloc(sizeof int)) == NULL) exit 1; として、終了(exit)しなかったら、 *a = 1; といった感じで、まずはaに有効なアドレスを与えてあげなければいけません。 他には、 int b; int *a; a = &b; *a = 1; でもいいし、 int c[100]; int *a; a = c; *a = 1; でも(文法的には)いい。 で、ソースコードに立ち戻って、まずは「Node **p;」から「*p = root;」の間で「p=」で始まる処理を探しましょう。 もし無いなら、p(==不定なアドレス)への代入がsegの原因でしょう。 そして、じゃあどこに「p=」で始まる文を入れるべきなのかを検討しましょう。 それがいわゆるデバッグってやつです。 すべてを自分で考えてソースコードを書くならともかく、他人が別の実行環境向けに作ってテスト方法や検証結果も提供していないソースコードをせしめて使いたいなら、デバッグは必須と考えましょう。 特に今回のような、「Node **p;」のような「Node型へのポインタへのポインタ」とかいった多段の参照関係や、あるいは関数ポインタによるコールバックや抽象化は、「C言語で作ったプログラム」としてはごく普通というか、「それがしたくて未だにC言語を使っている」といった類の手法ですが、ポインタの基礎的な知識が不足している状態でそのレベルのソースコードを引っ張って来て流用するというのは、相当の覚悟と努力が必要だと思います。 まさに賞賛に値します。
ああそうそう, 「どう書けばいいか」は, その型の変数が宣言できる人ならわかるはずです. たとえば今の例の「int の大きさ 3 の配列へのポインタ」だったら int (*pai)[3] って書いてるでしょ? そこから識別子の pai を消せばいい. それだけ. typedef 使えばいいのに, って話もあるな.
コードの掲示もない状態では…なかなか難しいのですが。 >LINUXの設定にある自動起動するアプリケーションにとうろくしました。 >パソコンを立ち上げてみて自動起動することは確認できましたが、CSV作成で失敗してしまう >事象が発生しました. ・権限に問題はありませんか？ ・出力先はどのように指定していますか？ ・カレントディレクトリがどこになっていますか？
>if(**ppdate = NULL){ 代入になっているのはおかしい。 というのは既に指摘されてますが…。 NULLポインタアクセスになってませんかね？ *は不要かと思いますが。
srand の引数にシステム時間を使った場合、同じような時間に 実行すると値の変化が少ないために 1回目の rand の値が似た ような値になります。これは rand の仕様というか癖です。 これを防ぐために、最初に rand を何回か呼び出しておく、 というのは、わりと一般的な対策です。
printfの"%d"と、それに対応する引数をよく考えてください。 質問に書かれてるのは以下のような事です。 int i = 0; printf("%d", &i);
ああそうだ, 引数の順番はどうしても unsigned char *a, int y, int x じゃないとダメ?
×wsprintf(buf, "%.1f", temperature); ○wsprintf(buf, L"%.1f", temperature);
回答No.2 です(No.3で名乗りを回答No.1と間違えました)。 難しく考えすぎだと思います。 ○.NET 版 　⇒ 具体的に言えば、.NET の System.Windows.Forms.Control 　　 クラスまたは System.Windows.UIElement クラスを継承して 　　 作ったコントロールです。.NET のクラスを継承しているので、 　　 当然 .NET 上でしか使えませんが、VisualStudio.NET のデザ 　　 イナが使えるので便利です。 　　 System.Windows.Forms.WebBrowser は、実装は SHDocVw.dll 　　 をラップしたものですが System.Windows.Forms.Control を 　　 継承していますので純然たる .NET コントロールです。 ○ActiveX(OLE) 版 　⇒ MFC または ATL を使用して開発し、IOleControl などの COM 　　 のインターフェイスを実装したコントロールです。このインター 　　 フェイスは、Internet Explorer や Excel などでも使用できる 　　 ため、(きちんと作れば).NET版よりも幅広い用途が見込めます。 　　 　　 ActiveX 版は VisualStudio.NET(c# 言語など) で参照設定する 　　 と、自動的にラッパークラスが作られます。このラッパークラス 　　 は Control または UIElement を継承した .NET コントロール 　　 です。 　　 ただし、開発環境が自動的に作ったラッパー(コントロール)な 　　 ので、実装は効率的とは言えないことがあります。 　　 今回の質問者さんの状況は、私が想像するに 　・実装は ActiveX コントロールで作る 　・ActiveX コントロールは VisualStudio.NET で参照設定すると 　　ラッパークラスが自動生成されるが、この自動生成クラスを使う 　　のは避けたい。なので .NET開発向けに ActiveX コントロール 　　のラップクラス (.NET コントロール) を開発して提供する。 ということなのではないかと思われます。 　　
動的に眺める必要がなければ、XPM形式の書き出しならfprintfで用意に達成できるかとおもいます。 形式はリンク先のWikipediaあたりを参考にしてください
当方の VC2010Expressですと 『+』のクリックだけでBeforeExpandおよびAfterExpandが呼ばれましたよ ハンドラの登録がうまくいっていないだけなのでは … デザイナで登録したのであれば this->treeView1->BeforeExpand += gcnew System::Windows::Forms::TreeViewCancelEventHandler(this, &Form1::treeView1_BeforeExpand); this->treeView1->AfterExpand += gcnew System::Windows::Forms::TreeViewEventHandler(this, &Form1::treeView1_AfterExpand); といった記述があると思います
可能です。ですが簡単ではありません。 『手書きパッドのコントロール』のようなものを期待されて いるのであれば、そのようなものはありません。 『IMEの手書きパッド部分を取り込み』を期待されているの であれば、そのようなことはできません。 できるのは『マウスの軌跡を解析して、文字を自動判別する プログラムを自分で作る』ことです。このようなプログラムを .NET技術で作ることは可能です。唯一の問題は、すんごく 大変だということでしょうか。
画像は小さくて、全然わかりません。 lap_img->imageData[lap_img->widthStep * k + (j + 1) * 3 ] = 0; を直したようですが、そもそもこれは何のために入れているのですか? 範囲外になる、という他にも、ループの最後にある cb = lap_img->imageData[lap_img->widthStep * k + j * 3]; は、 その前でj++された状態なので、 lap_img->imageData[lap_img->widthStep * k + (j + 1) * 3 ] = 0; で0にした場所です。ということは、cbは必ず0になります。 つまり 　j=0、cb=-1でループに入る 　x座標0 を0にする 　x座標1 も0にする 　j++ 　x座標j(つまりx座標1) の値をcbに代入する。(つまり、cb=0) 　ループ終了 となります j = j++; これ、意味わかってますか? たまたま期待通りに動いているかもしれませんが、それはたまたまであって、常にそうなるわけではありません。 j ++ のように、++を後に付けると j の値を使う → j=j+1 にする と動作します。 　j0 = j ++ なら 　oldJ = j ; 　j0 = oldJ ; 　j = j + 1 ; と等価です。 では、 j= j++ がどうなるか、というと、決まっていません。 　j= oldJ と 　j=j+1 が、どちらが先に実行されるか、C言語としては決まっていないのです。 　oldJ = j ; 　j = oldJ ; 　j = j + 1 ; で実行されれば、 j は一つ増えますが 　oldJ = j ; 　j = j + 1 ; 　j = oldJ ; だったら、jは前のままです。 単に一つ増やしたいだけなら、 j++ だけ書きましょう。 で、前回も書きましたが、 jを0にしてから始めるのですから、素直に 　for( j=0; j < 11 && cb == -1; j ++ ) にして、ループ後のj++を抜いた方がいいのではないでしょうか? さらに 　while(j < 11 && cb == -1){ // j = x軸 となっているのを 　for( j=0; j < 11; j ++ ) { 　　cb = lap_img->imageData[lap_img->widthStep * k + j * 3]; 　　if ( cb != -1 ) { break ; } とすれば、ループ終わりのcb=～が不要になります。
strtok() 使えば','区切りで文字列を抽出できるので、 'V'/'N'の直後を取り出せるでしょ。
>考えられる原因は何かありますでしょうか？ ソースコードの掲示なしでは回答の範囲が狭まるだけですよ？ 現状だと…リソースリークでもしているんじゃないですか？としか。 描画処理、どうやってます？ GDIオブジェクト作成して、使用したあと破棄してますか？ # というか、こういうパターンだと最初に作成して使い回すモノかと。 # 描画のたびに生成と破棄を繰り返すのではなく。
お礼への返信です。 > VC++ってCもC++も対応していませんでしたっけ？ 対応しているというのは混ぜて書けるという意味ではないですよね。 例えば、GNU Compiler Collection (gcc)は C、C++だけでなくFortran、Java、Adaなんかにも対応していますが、ソースファイルに特殊な命令などを書かず、混ぜて書くことはできません。 あと、C言語とC++は文法がたまたま似ているだけの全く別の言語だと思ったほうがよいです。C言語で自然な書き方とC++で自然な書き方は全く異なります。 C++で書くとしたら、例えばこう書くのではないでしょうか。(C++11に対応していないコンパイラーではコンパイルできません) #include<vector> #include<iostream> using std::vector; struct DATA{ int x; char name[32]; }; void info(const vector<DATA>& students); int main(void){ vector<DATA> students = { { 1, "a" }, { 2, "b" }, { 3, "c" }, }; info(students); return 0; } void info(const vector<DATA>& students){ for (const auto& student : students) { std::cout << student.x << " " << student.name << std::endl; } } > この書き方ならポインタ宣言の*は書く必要はなく、 > 関数にアドレスが渡っているということですか？ info関数の中身を見る限り全く必要ありません。C言語でvoid info(struct DATA status[])とvoid info(struct DATA *status)とは同じ意味になります。配列変数は配列の先頭要素のアドレスが格納されていますので、それを引数に渡すということはアドレスを渡すということです。また、配列を受け取るということは、配列の先頭要素のアドレスを受け取るということです。 質問者のように書いたらどういう意味になると思いますか？struct DATAの配列へのポインターを受け取るわけですので、2次元配列を受け取ることになってますが、それは意図通りなのでしょうか？ 配列変数は配列の先頭の要素のアドレスが入っていますから、status[0]も*statusも同じデータを示します。ちなみに、C言語でstatus[0] と *(status + 0) と *(0 + status) と 0[status]が同じ意味になるのを知っていますか？ > あと、->は使えないんですか？ 使う必要ありません。 そもそも、->がどういう意味かご存知でしょうか？ (*a).xと書く代わりに、a->xと書けるわけで、info関数のどこにその必要性がったのでしょうか？ あえて使うコードを考えるなら、statusの値をインクリメントしながら表示するコードにするなどがあるかもしれません。.x == 0を番兵 (http://ja.wikipedia.org/wiki/%E7%95%AA%E5%85%B5 )として置いておき、こんなふうに書くこともできます。 int main(void){ struct DATA student[] = { { 1, "a" }, { 2, "b" }, { 3, "c" }, { 0, "sentinel"}, }; info(student); return 0; } void info(struct DATA status[]){ for (;status->x != 0;status++) { printf("%d %s\n", status->x, status->name); } } あと、技術者同士の交流は相互扶助し、切磋琢磨しあうのが基本です。初心者だからだと気後れせず、答えられそうな質問を見つけたらどんどん回答してみてください。
No.2の方が回答されているように、そういう決まりです。 Cコンパイラは'\0'の直前の文字までを一連の文字列と見なします。 そして、No.1の方が回答されているように、 while(*to) や while(*from) は while(*to != 0) や while(*from != 0) と書いているのと同じことになります。 そして '\0' は数値としては 0 と同じなので while(*to != '\0') や while(*from !='\0') と書いているのと同じことになります。 そしてmystrcatの第一引数の文字列の空きスペースには 元々どんな値が入っているかわからないので、確実に'\0'を設定して、 意図しない位置まで文字列と見なされないようにする必要があります。
http://www.rfc-editor.org/search/rfc_search_detail.php?rfc=3501&pubstatus[]=Any&pub_date_type=any によると、 Updated by RFC 4466, RFC 4469, RFC 4551, RFC 5032, RFC 5182, RFC 5738, RFC 6186, RFC 6858 とのことです。全部読む必要があるかどうかわかりませんが。 IMAPプロトコルの勉強をするのが目的で無ければ、何らかの出来合いのIMAPライブラリを使うのがいいと思います。
InvalidateRgnで無効にした領域だけを再描画するため 右下が欠けたようになるのだと思います CreateEllipticRgnでリュージョンを生成するのを 描画側でやります 描画には FillRgnとFrameRgnで行い 描画位置更新イベント側では GetRgnBoxでリュージョンの矩形範囲を取得し 進行方向へ膨らませて InvalidateRectを実行して見ましょう // 描画側 hRgn = CreateEllipticRgn(x - hankei, y - hankei, x + hankei, y + hankei); HBRUSH hBrFrame = CreateSolidBrush(RGB(255,0,0)); // hBr： 塗りつぶしようのブラシは生成済みと仮定 FillRgn(hWnd, hRgn, hBr); FrameRgn(hWnd, hRgn, hBrFrame, 3, 3); DeleteObject(hBrFrame); // 消去側 RECT r = {0}; if (hRgn) { 　　// 矩形範囲を取得 　　GetRgnBox(hRgn, &r); 　　// 再描画の増分を考慮 　　r.right += 4; 　　r.bottom += 2; 　　/* 　　　　左上に動かすなら left, topを更新 　　　　右上なら right,top 　　　　左下なら left,bottom 　　*/ 　　InvalidateRect(hWnd, &r, TRUE); 　　// 使用済みなので リュージョンを破棄 　　if (DeleteObject(hRgn)) { 　　　　hRgn = NULL; 　　} } x += 4; y += 2;
windowsストアアプリ開発 開発環境でのテスト visualstudio(以下vs)をインストールした開発用pcでのストアアプリのテストに関して。 win7 + vs2012にてwindowsformアプリを作成する際、コンパイルをしますとDebugフォルダ内にexeファイルが作られ、vs2012を起動しなくても開発中のアプリを直接起動できると思います。 しかしストアアプリの場合、exeから直接起動は出来ないとのことです。 一方で、win8.1 + vs2013でwindowsストアアプリを作る際、コンパイルすると開発用pcにインストールされ、タイルが作られるという書き込みをみました。 これは、vs2013を起動していなくても開発pc上でテストができるということであっていますでしょうか？ よろしくお願いします。 ストア アプリは開発環境 (Visual Studio) がインストールされていない PC でもテストすることが可能です。 ただしテストには開発者ライセンスと呼ばれる、Windows ストア アプリをテスト目的で PC にインストールするためのライセンスが必要です。 （Visual Studio がインストールされている PC でテストする時もこのライセンスが必要だったと思います） テスト用 PC にこのライセンスをインストールし、Visual Studio で作成したインストール パッケージを使ってアプリをインストールします。 開発者ライセンスは不正利用を防ぐために有効期限が ３ヶ月に絞られており、このライセンスを使ってインストールしたアプリは期限が来ると使用できなくなります。 その場合は開発者ライセンスの更新を行ってください。 1. テスト用 PC で新規に開発者ライセンスを取得する # 開発者用ライセンスの取得 (ストア アプリ) # PowerShell で取得する。 http://msdn.microsoft.com/ja-jp/library/windows/apps/hh974578.aspx 2. Visual Studio でインストール用パッケージを作成する。 # Windows ストア アプリをテストインストールする方法 http://blogs.msdn.com/b/osamum/archive/2014/03/18/windows-test-install-method.aspx
> しかし、この考えでも、なぜ確保外の領域が構造体のサイズ分ずつ区切られているのか納得いきません。 #1の回答にに補足します。 int x[10]; とあったとき、x + 3と(char*)(x) + 3は同じ値でしょうか違う値でしょうか？ *(x + 3)とあったら、コンパイラーはxはint型の配列だからということで、xが100だったとして、x + 3は100 + sizeof(int) * 3の値になります。(char*)(x) + 3は100 + sizeof(char)*3の値になります。 確保しているわけではなく、コンパイラーがそう扱うというだけです。確保されているかどうかをコンパイラーは気にしませんし、実行してみるまでそれはわかりません。(配列として確保している場合、コンパイラーによっては警告くらい出しそうですが。) 「何かヒープ領域を使う場合に勝手に上書きされてしまう可能性がある」どころか、ライブラリーが管理のために作っている構造を破壊して、予測不能な動きをさせることもありそうですが。 mallocの動きはmallocの実装によって異なります。 様々なmallocの実装の解説はすでに多数公開されていますからそれらを読んでみてはいかがでしょうか。 http://ja.wikipedia.org/wiki/Malloc glibc http://www.slideshare.net/kosaki55tea/glibc-malloc http://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/ ソースコード: https://sourceware.org/git/?p=glibc.git;a=tree;f=malloc;h=da19ef618bb9565ea526243de099f2a18a76cbe6;hb=HEAD tcmalloc http://goog-perftools.sourceforge.net/doc/tcmalloc.html ソースコード: https://code.google.com/p/gperftools/source/browse/#git%2Fsrc%2Fgperftools jemalloc https://www.facebook.com/note.php?note_id=480222803919 和訳: http://d.hatena.ne.jp/repeatedly/20110110/1294634486 ソースコード: http://fxr.watson.org/fxr/source/stdlib/malloc.c?v=FREEBSD-LIBC
ああ失礼、修正後の方のコードの変更点を演算子しか見てませんでした。 確かに修正後の方は "CQ DE SHIN" を正しく変換してくれますね。 じゃあ、" SOS" や "SOS "はどう変換されるべきとお考えで、それはその通りになりますか? また、spacesbtwletters　はその名の通り「文字の間の空白」という役目を果たしていますか?
>みなさん、どの様にして三角マークに変えているのでしょうか？ ……オーナードロー、じゃないかなぁ。実際やるとしたらどういう風なのかは知らないけど。 http://msdn.microsoft.com/ja-jp/library/system.windows.forms.treeview.drawnode(v=vs.110).aspx http://nekojarasikou.seesaa.net/article/130329098.html
ほかにも正規表現のライブラリはいろいろありますね。 例えば ＢＲＥＧＥＸＰ ＤＬＬ http://www.hi-ho.ne.jp/babaq/bregexp.html とか VC++ 6.0 の .lib も用意されていますし、文字列の置き換えも出来るようです。
2 12 4 9 7 8 5 3 6 11 15 1 2 1 4 9 7 8 5 3 6 11 15 12 2 1 4 3 7 8 5 9 6 11 15 12 2 1 4 3 5 8 7 9 6 11 15 12 2 1 3 4 5 8 7 9 6 11 15 12 1 2 3 4 5 8 7 9 6 11 15 12 1 2 3 4 5 6 7 9 8 11 15 12 1 2 3 4 5 6 7 9 8 11 15 12 1 2 3 4 5 6 7 8 9 11 15 12 1 2 3 4 5 6 7 8 9 11 12 15 だと思うけど、これ見ただけじゃわからないと思うんですが。 http://sorting.at/ こういうの見た方がわかりやすいんじゃないかなぁ
> ……可能でしょうか。 はい。可能です。
1,2は不要。 ＞最初にヒットした該当ブラウザが開いている各タブが、 ＞「データを突っ込みたいページのURLかどうかをチェック」 IShellWindows::FindWindowSW method http://msdn.microsoft.com/en-us/library/windows/desktop/cc836568%28v=vs.85%29.aspx VC++でGoogle検索の例を書いてみました。 https://gist.github.com/kumatti1/f39822171f105de439f4
このプログラムをそのまま実行させて、データを1行で 20 30 40[Enter] と入力するだけでできます。 scanfの書式指定%dは改行も空白も（Tab文字も）無視してそれ以外の文字だけを取り込みます。したがって、scanfを3回使っていても、データを3行に分ける必要はありません。なお、キーボードからの入力では、[Enter]を入力しないと入力データがプログラムに渡りませんので最後の[Enter]は必要です。
少しは、頭を使って考えたり、身体を使って検索してみよう http://ja.wikipedia.org/wiki/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88 読んで理解できるかどうかは別として
実際にプログラムを作って確認するのが早いです。 確認は次の方法等でできます。 ・デバッガでステップ実行する ・途中経過を出力するように、プログラムを変更する for(i=～ 　for(j=～ 　　printf("%d番目と%d番目を比較します\n",i,j) ; 　　if ( a[i]>a[j] ) { 　　　printf("%d番目と%d番目を交換します\n",i,j) ; ... 　　　print_array(a,n) ; /* 配列の内容を出力する関数を自作する */ ,,,
分割前 key=_getch(); 分割後 key=_getwch(); 分割の前後でここの関数を変えたのは何故でしょうか。
＞XXXXX.exe has triggered a breakpoint. 意味は「XXXXX.exeはブレークポイントで停止した」です。 malloc.cの所で出るとしたら「ヒープ領域を破壊している」と思います。 Visual C++ 2013の場合、ヒープ領域を破壊すると、mallocの内部で「ブレークポイントで例外停止」するようになっています。 んで dcmplx *Phi = (dcmplx*)malloc(sizeof(double)* N); は、明らかにおかしいです。 dcmplx型をN個分確保したいのに、double型をN個分しか確保してません。 正しくは dcmplx *Phi = (dcmplx*)malloc(sizeof(dcmplx)* N); じゃないかと思います。 あと、MacのXcodeでは、ヒープを破壊すると APPNAME_XXX(????,0x????????) malloc: *** error for object 0x????????: pointer being freed was not allocated *** set a breakpoint in malloc_error_break to debug と言うエラーが出る筈だけど、Visual C++ 2013とは実装が異なるので、偶然「使ってないヒープ領域を壊しただけ」の場合は、エラーも出ないし、何も起きず、普通に「ちゃんと実行したフリ」をする筈です。 ヒープ領域は、壊し方によっては、Visual C++ 2013でも「エラーも出ないし、何も起きず、普通にちゃんと実行したフリをする」で終わるので、なかなかバグが見付からない場合もあります。
デストラクタにとって「いかなる理由で呼び出されたのか」を知る方法はありません. 従って「明示的にデストラクタを呼び出しても問題なく, かつ (スコープの外に出るなどの理由で) インスタンスを＊本当に＊破棄したいときには＊その場で＊メモリを解放する」などという都合のよい方法は存在しません. 「必要もないのに明示的にデストラクタを呼び出す」ようなやつにはちゃんとした躾をすべきなのです.
一応、コンパイラ側では違いはないかと。 当人にとって見やすいかどうか？ と、 使用するツール類にとって都合がいいかどうか？ という問題だと認識していますけどね。 ちなみに、私はif文などのブロック区切りは1.の書き方を好んで使っています。 # ブロックの終了位置が判りやすい。(ブロック内部はインデントしてる) 関数は2.ですけどね。 # 構造体定義では開始の{は行末。基本的に関数の開始の{だけ行頭で、他は文末に置くようにしていますね…。 2.の書き方だと、「行頭の括弧」でブロックの範囲が見やすい。 となります。 使用しているエディタなどで検索する際にも便利でしょう。 # grepする時に行頭に"{"か"}"がある行を抽出とすると、関数の中身を除いた結果が出てくる。 まあ、いろいろなスタイルがある…ということで。 # 複数人で作業する時はコーディング規約などで既定されるパターンがありますね。 # 私の経験では守らない場合が多かったですが…。(各人のスタイルで記述される) 突き詰め過ぎると宗教戦争になりかねないのでほどほどに。 # 昔から出てくるネタなので…Web検索するといろいろ出てくると思いますよ。 # 「コーディング規約 メリット デメリット」辺りで検索でしょうか…。
たぶんMovieCreator.hの #import <Foundation/Foundation.h> を #import <UIKit/UIKit.h> に修正すれば3つともエラーは無くなると思います。 この本はxcode5(SDK7)を対象にしていますが、 xcode6(SDK8)でビルドする場合は、UIKitをincludeするよう 修正しないとエラーになった経験があり、このケースもおそらく それだと思います。 この問題について詳しい解説記事を見つけることはできませんでしたが、 本来UIImageクラスを使うにはUIKit.hをincludeしないといけないけど、 おそらくxcode5まではFoundation.hをincludeすることで、たまたま 内部でUIKit.hのincludeも行われていたのだと思います。 それがxcode6になって、そのたまたま状態が解消されたので ちゃんとUIKit.hの方をincludeしないといけなくなった (正しい状態に強制されるようになった)のだろうと思います。 ちゃんと調べてませんが、たぶんそういう理解でよいと思います。
No2のkansuu()はviod型なのに最後にreturn 0とありますが無意味な1行ですね。 return 0が必要だというのならint kannsuu(){}とするべきですね。 結果として「kansuu de hyouji」と出力されるのはそれで正しい。 printf()関数というのは標準出力(STDOUT)に文字列を表示する関数ですからね。 興味があるならstdout.hでprintfがどう定義されるか探してみてください。
Profile機能を使います(iniファイル） この様な記述のファイルが出来ます [aaa] bbb=0 ccc=1 [ddd] eee=0 fff=1 記述の意味は↓ [セクション名] キー名=値 http://msdn.microsoft.com/ja-jp/library/cc429763.aspx 参考 http://park1.wakwak.com/~ima/visualcpp_tips0005.html
「ポインタ」です
http://stackoverflow.com/questions/25884801/ios-8-snapshotting-a-view-that-has-not-been-rendered-results-in-an-empty-snapsho を参考にしてください。 おそらくiOS8のバグで余計なメッセージが出ているだけだと思います。 他に支障がないなら放っておいてよいと思います。 私が作ったアプリでもこのメッセージは出ています。
print()がprint.cに記述してあることは どこの書いているのでしょう？ あなたは作った本人だから知っているけど、 コンピュータにはわかりません。
> １つのＸファイルに１つのＭＥＳＨの場合は、法線情報数が頂点数とも面数とも一致しないということはないですよね 例えば円盤をかんがえてみてください。 中心に1点頂点を置き、そこから放射状に20枚程度のポリゴンを敷き詰めて円盤を作ったとします。 完全な円盤であれば法線はどこを見ても一緒なはずなので、データとして1個だけ法線を持ち、 全ての面と法線がそれを参照する、といった形でデータを作ることもできます。 上記の場合、ファイル内の要素数は 点数→21 面数→20 法線数→1 となります。 法線数を点数、面数と一致するようにデータを作ることは可能です。 ですが、xファイルの仕様としてはそれは保障されていません。
> 当てはまる箇所がありますか？ に対しては「あります」ですが、 その前に 「関数」 「引数」 の意味を理解してますか? 理解できていれば、こんな質問する必要がないはずです。
＞→int i と int rad がスコープ内の変数として新しく宣言される？ 正解。 スコープ（forの終わりの}の外に出たらdoubleの値になります。
printf("%p animal[%d] : %s, アドレス : %p\n", ではなくて printf("%p animal[%d] : %p, アドレス : %p\n", にするとアドレスが出ますよ。
以下のようにしてください。 方法1 red_fの戻り値でf_pを返すようにする ---------------------------------- #include <stdio.h> #include <stdlib.h> FILE *read_f(void); void output_f(FILE *f_p); int main(void){ FILE *fp; fp = read_f(); output_f(fp); fclose(fp); return 0; } FILE *read_f(void){ int fn=0; FILE *f_p; char f_name[256]; printf(" text number 1, 2, 3, 4 : "); scanf("%d",&fn); sprintf(f_name,"map%d.txt",fn); if((f_p=fopen(f_name,"r"))==NULL){ /*f_nameを " " で囲まない!*/ printf("You will not be able to open the file\n"); exit(1); } return f_p; } void output_f(FILE *f_p){ int i,j; int array[10][10]; for(j=0;j<10;j++){ for(i=0;i<10;i++){ fscanf(f_p,"%d",&array[i][j]);//画面表示 10*10 printf("%d",array[i][j]); } } printf("\n"); } ----------------------------------------------------- 方法２ read_fの出力パラメータでf_pを返すようにする ---------------------------------------------------- #include <stdio.h> #include <stdlib.h> void read_f(FILE **f_p); void output_f(FILE *f_p); int main(void){ FILE *fp; read_f(&fp); output_f(fp); fclose(fp); return 0; } void read_f(FILE **f_p){ int fn=0; char f_name[256]; printf(" text number 1, 2, 3, 4 : "); scanf("%d",&fn); sprintf(f_name,"map%d.txt",fn); if((*f_p=fopen(f_name,"r"))==NULL){ /*f_nameを " " で囲まない!*/ printf("You will not be able to open the file\n"); exit(1); } } void output_f(FILE *f_p){ int i,j; int array[10][10]; for(j=0;j<10;j++){ for(i=0;i<10;i++){ fscanf(f_p,"%d",&array[i][j]);//画面表示 10*10 printf("%d",array[i][j]); } } printf("\n"); } ------------------------------------------------------ どちらでも問題ありませんが、方法１のほうが理解しやすいので、そちらを推奨します。 なお、printf("%d",array[i][j]);の位置が誤っていますので、正しい位置に修正してあります。
> 「<<<<===」ですが、これはHogeクラスが持っている演算子です。Fooクラスをセットするというものです。 「<<<<===」という演算子は C++ にはありませんが、本当は別の演算子だけど、仮にこう書いているということですよね？ > なんか見づらいので下記のように書き換えて欲しいと言われたのですが、どう書き換えていいものかわかりません。 > hoge <<<<=== _SET( hoge, 1, 2, 3 ) ; 見やすくなってませんが、 1. hoge <<<<=== _SET( 1, 2, 3 ); か 2. hoge._SET( 1, 2, 3 ); の間違いでは？ Hoge クラスをいじっても良い場合は 2. 、そうでない場合は 1. になるでしょう。 1. の場合、単に _SET を Foo のインスタンスを返す関数にするだけです。 例： inline Foo _SET(__a, __b, __c) { Foo ret; ret.SetParamA( __a ) ; ret.SetParamB( __b ) ; ret.SetParamC( __c ) ; return ret; } 2. の場合は、今あるマクロをそのままメンバ関数にするだけです。 ただ、引数の型が不明の場合は、関数にするにはテンプレートなどを使う必要があるでしょう。
ほとんどプログラムの経験の無い方とお見受けします。 どのようなアルゴリズムで探索するのかわからないのにどのようにすべきかなんてわかりません。 「迷路 探索 アルゴリズム」で検索すればいろいろな方法がひっかかるので、まずはどのアルゴリズムを採用するか決めてください。 以下のようなページがあります。 http://spheresofa.net/blog/?p=1044 ある程度自分でやってみて、うまくいかない部分を質問するぐらいでないとまともな回答は期待できませんよ。
関数内で宣言した関数は、その関数内でのみ有効な変数になります。関数が異なれば、同じ変 数名で宣言することができます。例えば、main関数と(C)kansuu関数で、同じ(A, D)hennsuuという名 前の変数を宣言することができます。 　int main() { int (A)hensuu = 0; (B)kansuuu(1); } int (C)kansuu(int hikusuu) { int (D)hensuu = 10; } 　列のmain関数で宣言されている(A)hensuuと、さ(C)kansuu関数で宣言されている(D)hensuuは 同じ名前ですが、独立した異なるものです。(C)kansuu関数が実行されているときに、(D)hensuuの値 を変更しても、main関数で宣言されている(A)hensuuの値は変更されません。 また、(C)kansuu関数を実行している間だけ、(C)kansuu関数で宣言されている(D)hensuuが有効です。 (C)kansuu関数から呼び出し元でるmain関数に戻った際は、(C) kansuu関数で宣言した (D)hensuuはもう有効ではなくな、値を参照することもなくなります。
>Form3にはForm2のインスタンス、frm2は与えられています public partial class Form3 : Form{ 　Form2 from2; 　public Form3(Form2 form2){ 　　EventHandler handler = (_s, _e)=>{ this.Close(); } 　　form2.Closed +=handler // (A) 　　this.Closed += (_s, _e)=>{ form2.Closed -= handler; } // (B) 　} } (A)form2が閉じるときに自分も閉じる (B)自分が閉じる場合にイベント解除（自分を先に閉じた時用）
http://www.kurims.kyoto-u.ac.jp/~ooura/fftman/index.html FFT (高速フーリエ・コサイン・サイン変換) の概略と設計法 上記サイトを参照下さい。 3. 多次元 FFT 等の項目等が処理の参考になると思います。 その他、参考文献　FFT Links から数多くのサイトや参考パッケージ、ソースコード等が辿れます。
Parseメソッドの NumberStyles付に変更すればいいですよ this.textBox1.Text = string.Format("{0,#0}",ulong.Parse(this.textBox1.Text, System.Globalization.NumberStyle.Number)); といった具合です Windowsの桁区切りが『,』であれば 上記でうまくいくと思います
まぁ、もろもろ指摘が既に入っていますが……。 nodePrepend()にブレークポイント張って、変数の「中身」を確認しながらステップ実行して下さい。 たぶん、forループが1回まわる前に気づくでしょう。
面倒だからコピペしているんでしょうけど…… http://oshiete.goo.ne.jp/qa/8819889.html で指摘されたところ直っていないよ？ コピペ元が。 >回答を頂いてそこを直すと正しく実行できたと勘違いして ってコトで、先の回答が勘違いだったそうですが… >else if(L=-1&&M==0&&N==-1){ というコードがどういう結果をもたらすか。というのはちゃんと把握した上でのコードってことでいいんですかね？ 今時のコンパイラなら警告なり出ていると思いますけど。 で、大本の質問に関しては…コード読む気にもならないので検証すらしていません。 インデントはともかく、説明のコメントもない２つの質問にまたがるコードを調べよう。という気にはなりませんので。 # 現象が再現できる程度までコード削るとかしてみません？ 結果を格納する変数が異なるだけで、途中の演算が同一。というのであれば…… 演算部分を関数化するか、結果を受け取る変数を配列にして添え字の方を処理するか、ポインタ使うか…そういう対処しますかねぇ。おそらく。 まぁ、回答じゃないんで削除されるかも知れませんけど。 # 回答貰いやすくする為のアドバイス…にもなっていないか。
面倒くさいから見てないけど ×　else if(L=-1&&M==0&&N==-1){ ○　else if(L== -1&&M==0&&N==-1){ じゃないの？
1. まずmain文から処理が始まる（約束事） 2. 「kansuu(2, 3)」で関数kansuuを呼び出す。引数は2、3。 3. 関数kansuuの処理が始まる。hikisuu1の値は2、hikisuu2の値は3。 4. 「hikisuu1 * hikisuu2」を計算する。2×3＝6なので計算結果は6。 5. 上記4より「return hikisuu1 * hikisuu2;」は、関数の呼び出し元に6を返す。 6. 上記5より「modori = kansuu(2, 3);」は、変数modoriに6が代入される。 以上。
回答はNo1の方を参考にされるとして、コンパイラは Visual Studio Express 2013 for Windows Desktopをご利用になればいかがですか http://www.visualstudio.com/ja-jp/products/visual-studio-express-vs.aspx 上記で Express 2013 for Windows Desktop を選んでください。 Microsoft アカウントは必要になると思いますが無料です。
AllBooks=全ての本の情報 みたいにして、 http://dobon.net/vb/dotnet/programing/arrayfilter.html にあるような方法で、必要に応じて Star5 = Allbooks.フィルタ(Rate-5を検索) のように抽出して foreach(book in Star5 ){ 星5の処理; } と該当したものだけ処理をする。 というのが素直でいいと思います。 別解。 データはデータベースに保存する。 必要なときに、必要なものだけを抽出したり更新したりする。
C++に詳しい人から回答付くと思われますが…… >enum Lang {USA, UK}; クラスdateの中の列挙型です。 グローバルな状態で存在する列挙型ではないので、 >Lang date::format = USA; だけでは、どこのLang？ ってことになりませんか？
あと、そこが解決すれば終り、では無いと思われます。 期待通りかどうか、ちゃんと確認しましょう。 計算結果が出ていることと、それが正しいかどうかは、無関係です。 Hdx3no2=((-ux2/pow(r,3))+3*X*(ux2*X+uy2*Y+uz2*Z)/pow(r,5)); や、同様の箇所ですが、例えば if(L==0&&M==0&&N==-1||L==0&&M==0&&N==0||L==0&&M==0&&N==1) だと、ループ中 L==0, M==0, N==-1 L==0, M==0, N==0 L==0, M==0, N==1 の3回実行されます。 その最後の結果だけが記録され、他は上書きされています。 よって Hdx3=Hdx3no1+Hdx3no2; で使われるのは、最後の値だけです。 それって、正しいのでしょうか?
> 　以下の使い方がいまいちわかりません？ > printf("kansuu de hyouji\n"); > modori = hikisuu1 * hikisuu2; > printf("modori = %d\n", modori); 使い方というか、元のコードは関数の作成例だと思いますが、関数を利用しないで使ってる変数は利用するとして同じような流れだと以下のような感じでしょうか。 int main() { int modori; int hikisuu1; int hikisuu2; hikisuu1=2; hikisuu2=3; printf("kansuu de hyouji\n"); modori = hikisuu1 * hikisuu2; printf("modori = %d\n", modori); return 0; }
というワケで簡単に。 # 手動で閉じた場合だとか、タイマーのキャンセルしてないとか…まあ、いろいろありますけど。 全角スペースでインデントしていますので、コピペする際にはご注意を。 public partial class Form1 : Form { 　private Timer CloseTimer; 　public Form1() 　{ 　　InitializeComponent(); 　　CloseTimer = new Timer(); 　　CloseTimer.Stop(); 　　CloseTimer.Interval = 3000; 　　CloseTimer.Tick += new EventHandler(CloseTimer_Tick); 　} 　void CloseTimer_Tick(object sender, EventArgs e) 　{ 　　this.Close(); 　} 　private void button1_Click(object sender, EventArgs e) 　{ 　　label1.Text = "正解です。"; 　　CloseTimer.Start(); 　} 　private void button2_Click(object sender, EventArgs e) 　{ 　　label1.Text = "間違いです。"; 　} }
C 言語の仕事は「0 なり 1 なり 2 なりを返す」までであり, その値にどう対処するかは (「C のプログラム」としては処理を完全に終了しているので) C のあずかり知らぬところです. なので, 「どんなバクなのでしょうか！？」というのはあなたの使っている OS なりシェルなりなんなりに聞いてください.
# 書いている間に別の方から似たようなことをすでに回答されていますが、、そのまま投稿しちゃいます。 プロパティもカプセル化手段の一つですので「プロパティをできるだけ使わずにカプセル化して」というのはちょっとよく分かりません。 読み取り専用プロパティを設けたい場合には、以下のような自動実装プロパティを読み書き別のアクセス権にすると楽です。 public string ISBN { get; private set; } リスト状のデータをXML保存するための標準的な考え方は「用途に応じて適切な手法を用いる」です。 たとえば、出力形式は決まっておらずアプリの都合で保存/復元が出来れば良いのであればシリアライザを用いてまとめて保存しても良いでしょうし、出力するXMLのスキーマを特定の構造にしたいとか、きめ細かいエラー処理をしたいという場合には自前の保存処理を作れば良いでしょう。 シリアライザを利用する場合、XmlSerializerでもよいですけれど、個人的には DataContractSerializer をおすすめします。 privateメンバの保存/復元も出来ますし、メンバがリスト状でも大丈夫です。 こんな風にデータクラスに属性のマーキングをして、 // System.Runtime.Serialization への参照設定をしておく。 [DataContract(Namespace = "")] public class Book { public Book(string isbn, string name) { this.ISBN = isbn; this.Name = name; } [DataMember] public string ISBN { get; private set; } [DataMember] public string Name { get; private set; } } こんな風にリストごと保存/復元をすることが出来ます。(エラー処理等は除く) private void xmlSerialize(string filePath, List<Book> bookShelf) { var confDir = Path.GetDirectoryName(filePath); Directory.CreateDirectory(confDir); var xmlSettings = new XmlWriterSettings(); xmlSettings.Indent = true; using (var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read)) using (var xmlWriter = XmlTextWriter.Create(fileStream, xmlSettings)) { var dataContractor = new DataContractSerializer(bookShelf.GetType()); dataContractor.WriteObject(xmlWriter, bookShelf); } } private List<Book> xmlDeserialize(string filePath) { using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read)) { var dataContractor = new DataContractSerializer(typeof(List<Book>)); return (List<Book>)dataContractor.ReadObject(fileStream); } } 注意点としては、デシリアライズ時にはコンストラクタが呼び出されないため、データクラスに以下のようなメソッドを加えてシリアライズ前後に処理を行う必要がある場合も、あるでしょう。 [OnDeserializing] private void onDeserializing(StreamingContext context) { // シリアライズ直前の処理 } [OnDeserialized] private void onDeserialized(StreamingContext context) { // シリアライズ後の処理 } 自前で保存を行うならば、XDocumentを利用したLINQ to XMLによる処理をおすすめします。 以下の例では Select で射影して一括で処理していますが、エラー時に場所や値を詳細に出したい場合などは foreach で回したり要素をもっと細かく見る処理にしても良いかと思います。 private void saveLinqToXml(string filePath, List<Book> bookShelf) { var confDir = Path.GetDirectoryName(filePath); Directory.CreateDirectory(confDir); var shelfXml = new XDocument(); shelfXml.Add( new XElement("BookShelf", bookShelf.Select(book => new XElement("Book", new XElement("ISBN", book.ISBN), new XElement("Name", book.Name) ) ) ) ); shelfXml.Save(filePath); } private List<Book> loadLinqToXml(string filePath) { var shelfXml = XDocument.Load(filePath); return shelfXml.Root .Elements("Book") .Select(bookNode => new Book((string)bookNode.Element("ISBN"), (string)bookNode.Element("Name"))) .ToList(); }
スレッドセーフを意識する場合、ライブラリ内でグローバル変数を持つ事は許されません。 「一連の呼び出しの中で、グローバルなスコープが必要」なのであれば、fopen関数でやっているように「開始関数で一意のハンドラを返し、一意のハンドラを指定して一連の呼び出しを行ってもらい、終了処理で一意のハンドラを開放する」と言うような書き方をしないといけません。 fopenが「グローバル変数で、次に使える、空いているハンドラの番号を持っている」と言う実装があったとします。 もし、メインのスレッドでfopenが３番のハンドラを返そうと準備している真っ最中（fopenから、まだ帰って来てない状態）に、サブのスレッドがfopenを呼び出して３番のハンドラを受け取ったら、どうなると思いますか？ メインのスレッドも、サブのスレッドも、どっちも「３番のハンドラ」を受け取ります。 メインとサブで異なるファイルをオープンしているのに、ライブラリがグローバル変数で「次の空きは３番」なんて情報を持っていた所為で、両方とも「３番」を受け取ってしまったのです。 もちろん、実際のfopenは「マルチスレッドであっても一意」になっているヒープ領域を用いて「スレッドが切り替わっても大丈夫」な作り（つまり、スレッドセーフ）になっているので、こういう事は起きません。 ライブラリ内にグローバル変数を作ると「マルチスレッド禁止」になっちゃうので、スレッドセーフにするなら、グローバル変数は作ってはいけません。ライブラリ内の変数は、必ず「外にスコープを持たないstatic変数」にしないといけません。
>if(cnt>3&&cnt%4==0){//サイズが足りなくなった時 >char **tmp2; >if((tmp2=(char **)realloc(*words,sizeof(char *)*(4+4*(cnt%4))))==NULL){ ifの条件とrealloc()するサイズをよくみましょう。 また直接関係する事ではありませんがポインタ値を"%x"で出力させるのは間違ってます(sizeof(int) == sizeof(void *)の環境では動きはしますが)。
GetDitailOfの第2引数に 194を指定すればサブタイトルが取得できるみたいですよ 　　Dim sh As New ShellClass 　　Dim f As Folder = sh.NameSpace("ファイルのディレクトリーパス") 　　Dim item As FolderItem = f.ParseName("対象のファイル名") 　　MsgBox(f.GetDetailsOf(item, 194)) といった具合です
C++の中には包括的にC言語の仕様も含まれてますので同じようなことは学べます。 ただC++は複雑ですし最初に学ぶ言語としては今の時代では適切ではないと思います。よほどC++にこだわる目的があれば別ですけど。
できなくはありません。bool型をToString()などで文字列に変換すれば全て文字列の配列として返すことはできますが、プログラムの作りとしては良くないプログラムの典型になってしまいます。 複数の値を返したい場合は、他の人が書いているように専用のクラスを作成して、それを使って返すようにする方法が良いと思います。（場合によっては、メソッドの粒度や役割が適切かどうか見直しも必要です。1つのメソッドで複数の処理を行わせようとすると、複雑なコードになりがちです） 専用のクラスを使う方法であれば、boolとstring型を格納するResultItemというクラスを作成し、 public class ResultItem{ 　public bool IsSuccess{get;set;} 　public string Message{get;set;} } これを、メソッドの中で返すようにします。 public ResultItem YourMethod(){ 　ResultItem item = new ResultItem(); 　// 処理 　item.IsSuccess = true; 　item.Message = "関数内で取得した文字列など"; 　return item; }
kansuu de hyouji modori = 6 上記のメッセージはプログラムで画面上の表示する(printf)という関数を実行することで表示されています。 2つあるprintfが呼ばれた順に実行されています。 #include <stdio.h> int kansuu(int hikisuu1, int hikisuu2); int main() { int modori; //kansuu関数を実行し、結果を受け取ります。 //kansuu関数内でprintfを実行しているのでこの時点で"kansuu de hyouji\n"が表示されます。 modori = kansuu(2, 3); //"modori = ？？\n"の結果を表示します。 printf("modori = %d\n", modori); //終了します。 return 0; } int kansuu(int hikisuu1, int hikisuu2) { //"kansuu de hyouji\n"を表示します。 printf("kansuu de hyouji\n"); //引数で受け取ったhikisuu1×hikisuu2の結果を返します。 return hikisuu1 * hikisuu2; } 一つ一つ解説するとこうなります。 kansuu内でprintf("kansuu de hyouji\n");を実行していますが、 kansuu関数は掛け算をしているだけなのでprintfをしなくても良さそうですね。 なので下記のように。 #include <stdio.h> int kansuu(int hikisuu1, int hikisuu2); int main() { int modori; modori = kansuu(2, 3); printf("modori = %d\n", modori); printf("kansuu de hyouji\n"); return 0; } int kansuu(int hikisuu1, int hikisuu2) { return hikisuu1 * hikisuu2; }
ifstream inStream(str); の行が、何をやっているか、理解してますか？ 「strで指定されたファイルをストリームとしてオープンして、ファイルの読み込みポインタを先頭にする」のですよ。 そして return inStream; の行で、オープンしたストリームを「ifstream型の変数」として返しています。 なので while (inStream(argv[1]) >> input) とやると「毎回、argv[1]で指定されたファイルをオープンして、読み込み位置を１行目にする」ってのを繰り返します。 なので「何回ループしようが、１行目しか返って来ない」のです。 しかも、ストリームをクローズしないまま、何度も再オープンを繰り返しているので、何十回か繰り返した段階で、リソースを使い尽くしてオープンエラーが出る筈です。 ともかく「クローズしないでオープンを何度も繰り返す」ってのは、絶対に駄目です。 オープンしたストリームハンドラは「プログラム終了時に自動的にクローズされる」ので、明示的にクローズしない人が殆どですが、本来であれば「ストリームハンドラを変数に受け取って、最後にクローズするべき」なのです。 #include <iostream> #include <string> #include <fstream> using namespace std; ifstream inStream(char *str); int main(int argc, char *argv[]) { if (argc < 2) cout << "ファイル名を指定してください" << endl; else { try { string input; //オープンしていいのは最初の１回だけ！ //ストリームハンドラは変数に受け取る ifstream instream = inStream(argv[1]); //受け取った変数でループを回す while (instream >> input) cout << input << endl; } //終わったらちゃんとクローズ！ instream.close(); //ここから例外処理 catch (int i) { cerr << argv[1] << "を開けません" << endl; } } return 0; } ifstream inStream(char *str) { ifstream inStream(str); if (!inStream) throw 1; return inStream; }
何月何日の問題は解答してあるという情報は何がどのように保持していますか。 >このカレンダー内の各日付（label）をクリックすると、各問題ページへ行きます。（カレンダーは閉じ、問題ページを開く。） 「カレンダーは閉じ」というのは具体的にはどのようにしていますか。 Close()ですか？ Hide()ですか？ >カレンダーへ戻り（問題ページを閉じ、カレンダーを表示） 「カレンダーへ戻り」というのは具体的にはどのようにしていますか。 カレンダーのFormを新しく作ってShow()ですか？ Hide()していたものをShow()ですか？
MSDN を調べたら以下の記述が見つかりました。 「フィールドを static const として宣言することはできませんが、const フィールドは、その動作において本質的に静的です。 const フィールドは、型のインスタンスではなく型に属します。 そのため、const フィールドにアクセスするには、静的フィールドに対して使用するのと同じ ClassName.MemberName 表記法を使用します。 オブジェクト インスタンスは必要ありません」 http://msdn.microsoft.com/ja-jp/library/79b3xss3.aspx つまりフィールド変数の場合（ちょっと問題のある記述かもしれませんが）const（C#） == static final（Java）という事になります。 const の使用例の ConstTest でも生成したインスタンスを通して const 変数を使った後にクラス名から直接 const 変数を使っています。 http://msdn.microsoft.com/ja-jp/library/e6w8fe1b.aspx ……というか、C# の話なんだから第三者の比較説明サイトよりもまず総本山の MSDN を調べようよｗ
>コンパイラがそれを変数aが読み取り専用であることを判断するのに使っているのではないか？ コンパイラはそんな事では判断していません。 コンパイラはaが配列として書かれているので書き換えできないようにしてるだけです。 >ちなみに、 >char *p = "fuga"; >とした場合は、pと&pのアドレスは異なって、pの中身は書き換えられます。 pはポインタ変数であって配列じゃないからです。
#include<stdio.h> void main(void){ FILE *fin; FILE *fout; char buff[200]; char *p1,*p2; /*読み込み用ファイルを開く*/ fin = fopen("input.txt", "rt"); if( fin == NULL ){ printf( "File open error\n" ); return; } /*書き込み用ファイルを開く*/ fout = fopen("output.txt", "wt"); if( fout == NULL ){ printf( "File open error\n" ); return; } /*1行ずつ読み込む*/ /*読み込める間繰り返す*/ while(fgets(buff,200,fin) != NULL){ for (p1=buff;*p1;p1++) if (*p1 == '\t') { *p1++ = '\0'; break; } /*保存できているかの確認*/ printf("%s\t",buff); fprintf(fout,"%s\t",buff); for (p2=buff;*p2;p2+=2) { *(short *)p2 = *(short *)p2 + 41217; if ((p2[1] < 0) || (p2[1] == 127)) p2[1]++; } printf("%s\t%s\n",buff,p1); fprintf(fout,"%s\t%s\n",buff,p1); } fclose(fin); fclose(fout); }
元の 　　　「ここでは、関数kansuuの定義とプロトタイプ宣言に 、引数を追加しました。 の意味は、関数　int kansuu( ) に、 引数　int hikisuu　　を 追加しました、　という意味だと思うのですが、単に、関数のプロトタイプを追加したということだと思います。 C言語は、基本的に　前方参照なので、関数、変数などを呼び出す前にそれらの定義文があるのが前提です。 一般的には、main()　は、ソースコードの最後に置かれ、そこで呼び出す関数はmain()よりも前に記述するのが多いです。そうすれば基本的に前方参照になるので、プロトタイプ宣言をいちいち記述する手間が省けます。 何らか都合で、もしくは外部で定義される関数を呼び出す時は、プロトタイプ宣言を参照される前に記述します。 単なる定義文なので、呼び出し元と先で定義が間違っていなければ、コンパイル結果に影響は与えません。 呼び出し元と先の定義がもし間違っていると、コンパイルエラー（ワーニング）になるか、コンパイルが通ったとしても、間違った計算がなされるか、暴走するかいずれかでしょう。C言語の型宣言などの非常に重要なところです。 詳しくは、C言語、前方参照（前方宣言）などを参考書などで良く調べてみてください。
#include <iostream> #include <iomanip> #include <sstream> #include <string> using namespace std; int main() { long double val = 1.0 / 3.0; ostringstream stream; stream << setprecision(20) << val; string str = stream.str(); cout << str << endl; } /* 実行結果 (VC++12) 0.33333333333333331 */
たとえば、ご質問のコードだと ・プロトタイプを削除して ・関数呼び出しを modori = kansuu(2.0); （引数が、2.0 になっている点に注意） とするだけで、予期しないことが発生します。 （プロトタイプがあれば、とりあえず、思った通りの結果にはなります）
普通のアプリケーションは、終了するまでソケットを開きっぱなしということはなく、終了する前のどこかの段階で閉じたり、また開いたりします。 ということは、サンプルはソケットを閉じる方法を教えるべきです。 サンプルは教えるためのものであって、完成されたプログラムではありませんから、目的を見失って重箱の隅をつついても意味がありません。実践ではどうなるかを考えましょう。
一応それっぽく動くだけなら、if(GetTouch(CH_2) == 1){ ... の処理を while(GetSensor(CH_3) > kuro); /* 入力ポート3ライトセンサーが ... のループの中に入れれば動きそうです。 ただし、このやり方ではもう少し複雑な動きをさせようとすると途端に破綻します。 ソースを書く前に、例えば状態遷移図などを使って動作を設計する手法を覚える必要があるでしょう。
write.zip自体に「write」フォルダが作成されているのでは無く、zipの展開に使っているソフトが「write」フォルダを生成しているように思えます。 使用しているソフトによっては「アーカイブ名でフォルダを作成」のようなオプションがある場合があるので、そのチェックを外すとフォルダは作られなくなるはずですよ。 zipファイル自体にフォルダが含まれているかどうかは、zipファイルをエクスプローラーなどで開くと確認できると思います。
. main(){ こんな書き方、最近ではやりません。 ○参考にしたものがとても古い ○主目的が別にあり(ゲームプログラミング入門とか、数値解析とか)C言語はオマケ程度にしか解説していない のどちらかではないかと。 前者なら、それのことは忘れて、新しい本を買ってください。 後者なら、内容だけを参考にして、C言語は別の本を買って勉強してください。 > 変数iの有効範囲 「スコープ」といいます。 とても大事なことです。 ちゃんとした解説書で勉強してください。 このプログラムでは、あまり理解の助けにならないでしょう。
○コメントが少ない 　何が目的で、どんな考えでこう書いてあるのか、よくわかりません。 　よくわからないので、改善点の提案もできません。 　例えば if(GetSensor(CH_3) > kuro){ ですが。 　kuro と判定してるので、黒かどうかを判定していることは予想できます。 　ですが、この判定は 黒のときTrueなのか、黒でないときTrueなのか、どちらの意味かがわかりません。 ○同じ処理を何度も書いている 　「同じことを3度書いたら、マクロか関数にしろ」という格言があります。 　例えば、何度も出てくる GetSensor(CH_3) > kuro)ですが、この判定をマクロや関数にして 　if ( isBlack() ) (もしかしたらはisWhite?) 等と書けば、次のメリットがあります。 　・文字が減らせる。 　・意味がわかる。→コメント代りになる 　　　さらに抽象的にして onLine() (線上にいる) 等とすると、何を意味するかがはっきりする 　・判定方法が変わっても、一箇所直すだけで全体に反映させることができる 　　　例えば、 精度向上のためにセンサーを増やして、複合的に判定させようとします。 　　　「CH_3のセンサーが>kuro かつ CH_4のセンサーが<kuro」になったとして現状どこを変更すればいいか、わかりますか? ○main関数に全部の処理を書く 　mainプログラムには、全体の流れだけを書くようにします。 int main(){ 　while(1) { // メインループ 　　動作スイッチ待ち(); 　　if ( 交差点 ) { 　　　前回曲った方向記録 = 曲がる(前回曲った方向記録) ; 　　} else { 　　　直進する(); 　　} 　} } // さっき曲がった方向を指定→実際に曲った方向を返す関数 左右記録型 曲がる(さっき曲がった方向) { 　　if ( さっき曲がった方向=左 ) { 　　　左に曲がる(); 　　　return 左; 　　} else { 　　　右に曲がる(); 　　　return 左; 　　} } あってるかどうかわかりませんが、例えば、こんな感じになると思います。 これだと、何をしているか、よくわかるのではないでしょうか。
関数呼び出し時の引数の割り当ては基本的に「初期化」として処理されます. つまり, 今の例だと関数呼び出しによって double val = i; double val2 = i*2; という初期化がなされることになります. 右辺にキャストは必要でしょうか?
端子 要素 ループ始端 判断 要素 ループ終端 端子
応用と行っても、C++のオブジェクト指向など基礎部分を深めるのか（アルゴリズムやboostやデザインパターンなど）、実際に組み込み機器で作る方なのかによって話は変わりますよね？ 何らかの応用をやろうとすれば、自然と基礎の振り返りに成るとは思いますけど。 これの答えに正解はないと思うので自分の弱点をやってみた方が良いのでしょう。 > C++の応用のサイトを探しているのですがどれがためになるのかあまりわかりません これが判断出来ないのは自分の弱点が分かっていないのでは？ あるいは基礎の理解が曖昧なのかも知れません。
PICのデバイスIDが読み出せない、→　接続されているPICの種類が不明 PICKIT3からの電源供給能力は30mAまでなので、電流不足だと思われます 外部電源をつないで書き込んでみて下さい。 参考 http://raku-raku-pic.ldblog.jp/archives/15655758.html
>int kansuu(int hikisuu1, int hikisuu1); >　にすると以下のエラーが出ます。 >Line 2: error: redefinition of parameter 'hikisuu1' >Line 2: error: previous definition of 'hikisuu1' was here >　なぜerroｒとなるのでしょうか 1年A組に同姓同名(漢字は違うけど読みが一緒)の田中さんがいます。 『1年A組の田中さん、至急職員室まで来て下さい。』と放送で呼び出しがありました。 で、どちらが職員室に呼ばれたんでしょうか？？ 二人の田中さんそれぞれ職員室に呼び出しを受ける心当たりはありません。
同じような質問を複数されていますが、宿題か何かでしょうか。 ・http://okwave.jp/qa/q8787993.html ・http://okwave.jp/qa/q8787999.html もしそうであれば、誰かに答えを聞くのでは無く、自分で理解できるようになる事が重要ですよ。「教えてください」という事なので、答えでは無く「解き方」について書いてみます。 ソースコードは提示してあるので、その処理の流れをフローチャートで表現するという問題ですね。 この場合、ソースコードの意味（どのような処理なのか）と、フローチャートの記述方法を理解できれば解けるはずです。 「解けない」と言うことは、どこかでつまづいていると思うのですが、どの部分が分からないのでしょうか？ どこまで理解していて、どの部分が分からないのかを教えていただけると、適切な回答が得られると思いますよ。
間違っちゃいないけど、直に const string でかまわんのでは? #include <iostream> #include <string> const std::string STR1 = "mojiretu"; bool even_length(const std::string& str) { return str.length() % 2 == 0; } int main() { if ( even_length(STR1) ) { std::cout << STR1 << " : even\n"; } else { std::cout << STR1 << " : odd\n"; } }
いま確認できる環境がありませんが。 WNDPROC (*finc[])() だと 『「WNDPROC 名前()というプロトタイプの関数」へのポインタ』の配列 である、配列fincの宣言になります。 よって、fincの各要素(finc[0],finc[1]...)は「引数無し、戻り値WNDPROCの関数へのポインタ」です。 それを、(WNDPROC)WndProcA,等と、WNDPROC型で初期化しようとしています。 「引数無し、戻り値WNDPROCの関数へのポインタ」 と 「WNDPROC型」は別のものでは? まずは、具体的にどんなエラーメッセージになっているか、書いてください。 「WNDPROCはWNDPROC (*)()に変換できない」とかいうものではないですか?
in を close() するタイミングが遅すぎますし、out を生成するタイミングも早すぎます。 これを変えた後で、in の生成で指定しているファイルと out の生成で指定しているファイルを同一にすればお望みの動作となります。
お作りになっているソフトのプラットフォームは何でしょう？ MFCならば DDX_Radioを使うといった手があります ラジオボタンのGruupプロパティをTrueにしたコントロールに対してメンバー変数を追加します このとき 変数の型を intにして 変数の種類をControlからValueに変更します これで メンバー変数が 0ならば1番目、1ならば2番目 といった具合の対応になります ダイアログの状態を変数に反映するには UpdateData(FALSE); を実行 逆に 変数の状態をダイアログに反映するには UpdateData(TRUE); を実行します 別のプラットホーム(Win32や C++/CLI)ならば その旨の返信をお願いします
> read関数を何回も受信することになりますか？ > それとも一回だけread関数をじっこうすることによりできるのでしょうか？ 知らんよそんなの。 少なくとも35msのうちに1024byte取り込まんならんのだけは確か。 相手側機器が用意できなくても 折り返しケーブルが用意できるなら、 「10秒ごとに190011Byte送信する」小さなアプリ作って 試せばいいやん。
MSVCはMicrosoft Visual C++の事であってVisual Studioでは有りません。 (VSがVCを含む) MSVCの「バージョン12」が「製品名2013」です。 http://ja.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B WindowsだってWindows7のバージョンは6.1です。 製品の名前とバージョンは連動しません。
まずは、Releaseモードに切り替えましょう。Debugとか論外でしょ。 あと、 http://kidd0320.hatenablog.com/entry/2014/06/06/142355 上記を参考に、「ランタイムライブラリ」を「DLL」の記載が無いものに切り替えましょう。
そうではありません。 x=x+23 ということは、現在のxに+23したものが、次のxになります。 iの変化が、i=i+1だけだとすると ループ開始 　x=0 終了直前 　i=i+1 /* i=1+1=2 になる */ forの式3の評価 　x=x+11*(i-1)+1 　/* x= 0 + 11*(2-1)+1 =0+12=12になる */ 次のループ開始 　x=12 終了直前 　i=i+1 /* i=2+1=3 になる */ forの式3の評価 　x=x+11*(i-1)+1 　/* x= 12 + 11*(3-1)+1 =12+23=35になる */ ... となっています。 よく見たら、いろいろと間違ってますね。 cvSetImageROI(dst_img, cvRect(y, x, 11, 11)); は、 dst_img の 横y,縦xの位置から11x11のROIを設定して、以降、cvClomeImage(dst_img)等としたときに、dst_imgが、そのROIで指定した範囲だけの画像のように扱われる、というものです。 2回目では、x=12なので「 dst_img = cvCreateImage(cvSize(12, 12), IPL_DEPTH_8U, 1); で確保した 12x12(横0～11,縦0～11)の画像dst_img」の 座標(0,12)から11x11画素を抜き出した画像、という意味になるので、エラーになるのも当り前です。
> list<string>::iterator p; > p = str.begin(); > while (!in.eof()){ //------------ここを、よく考えてみたらどうかな > cout << *p; > out << *p++; > }
こんにちは、それほどクワシイわけではありませんが・・・ 再帰関数というのは簡単に言えば自分自身を呼び出す関数です。 分かりにくいのは確かですね。 階層になってる繰り返しの処理なんかに向いているんです。 実際に動かしてみるといいですよ。 ここにある例がわかり易いかも知れません。 http://nonbank.malmalserver.com/ それとサイトだけでなく、解説している本を読むのもお奨めです。
こんにちは ドキュメントを読みましたか？ flat propertyで表示できるようですね。 http://qt-project.org/doc/qt-5/qgroupbox.html#flat-prop -上記urlより引用--------------- flat : bool This property holds whether the group box is painted flat or has a frame. A group box usually consists of a surrounding frame with a title at the top. If this property is enabled, only the top part of the frame is drawn in most styles; otherwise, the whole frame is drawn. ---------------------------------------------- Group Box Example http://qt-project.org/doc/qt-5/qtwidgets-widgets-groupbox-example.html
Xcode6になって、シミュレータが起動できないトラブルは何度か経験して います。他の人も結構遭遇するようで、そのエラーメッセージをそのまま googleで検索すればいろいろ情報を得られます。 私の場合は、とりあえず http://qiita.com/tajihiro/items/f6f50b56162c93d25c90 にある方法でシミュレータをリセットするだけで動くようになりました。 他にも http://toshi586014.net/2014/09/06/ios8-simulator-boot/ や http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q10136305890 といった情報があります。
>もしかして何もしなくていいのかな、、、というところです。 >ホントですかね？？？ Windows の場合は、アプリでは何もしなくてよいことも多いですよ。 ただし、Windows では整数型のサイズが変わらないので、 動きますけど、32ビットの制限がそのまま残ったりします。
input_fileの配列数と文字数はあってますか？
タイトルが２の倍数となっていたので、１００個の数値（５０ペア）の双方が偶数のケースを拾い出す形で記述してみました。 取りあえず　数値を入力してTRUE, FALSEを返す関数 funcA()　は、２の倍数ならTRUEという形にしてあります。 参考にしてみてください。 #include <stdio.h> typedef enum _boolean { FALSE, TRUE } boolean; #defineRW50 #defineCL2 booleanfuncA( int a ) { if ( (a % 2) == 0 ) return( TRUE); else return( FALSE ); } void main( void ) { inti,j,n; intnm; intdata[RW][CL]; intresult[RW][CL]; for ( i = 0; i < RW ; i++ ) { for( j = 0; j < CL ; j++ ) { printf( "input data[%#d][%d] =?", i,j ); scanf( "%d", &data[i][j]); } } n = 0; for ( i = 0; i < RW; i++ ) { if ( funcA( data[i][0] ) && funcA( data[i][1] ) ) { result[ n ][0] = data[ i ][0]; result[ n ][1] = data[ i ][1]; n++; } } printf( "Number = %d\n",n ); for ( i=0; i < n ; i++ ) { printf( "result[ %#d ] = %d,%d\n", i,result[i][0],result[i][1] ); } }
コピーコンストラクタをConfigに作ればいいかと Copyメソッドを作るのであれば 引数を ref引数にするとか … // コピーコンストラクタ public Config(ref Config src) { 　　this.H = src.H; 　　this.V = src.V; } // ref引数の Copyメソッド … public void Copy(ref src) { 　　src.H = this.H; 　　src.V = this.V; } といった具合で …
示されているリンク先に対処例が載っています。 > Win32SDKに書き換えるか、CWnd::Attach()する必要があるわけですね。 Win32 SDKのほうはリンク先のサンプルを見ていただくとして、 MFCを使う場合は CWnd cWnd; cWnd.Attach(IDC_HOGE); cWnd.EnableWindows(TRUE); cWnd.Detach(); とか。実体を宣言してAttach()/Detach() をワンセットにして使う感じですね。 コントロール固有のメソッドを使いたいなら 上記CWnd を CEdit とか CButton とかに置き換えればいいかな。
QTの開発環境は全然知りませんが、 コード上不都合があるとすると、LPWSTR　の部分と思われます。 ↓この辺りをヒントにしてみてください。（同じ開発環境のCOM PORTに関するサンプルコードがあれば、それも参考になるはず） http://www.atmarkit.co.jp/fdotnet/dotnettips/025w32string/w32string.html 色々検索すると、開発環境は異なりますが、類似問題で解決している例が多々見つかります。
自分で探させましょう。それが出来ないようではすぐに挫折します。 質問も自分でさせてほうが良いです。 ちなみに、私見ながらC++はVisualBasicの数百倍難易度が高いのでVisualBasicが太刀打ち出来ないなら到底無理です。
関数の定義の方法は、理解できていますか? 型　関数名（引数）{ ※ここ } って感じですよね? では、「{※ ここ}」は何するためのものですか?
以下の2点の補足をお願いします。 (1) 「最初の#includeのところがペーストしてもエラーが出ます」とのことですがそのエラーメッセージには何と書いてありますか? エラーメッセージをそのままコピー&ペーストしてください。 (2) あなたが参考にしているページは以下の URL だと思うのですが、その 2.3「Windows 系 OS にインストールする」の手順は実行しましたか? http://www.wakayama-u.ac.jp/~tokoi/opengl/libglut.html
これは、割と議論の対象になる話題です。 詳細は、 http://www.kouno.jp/home/c_faq/c5.html#0 が詳しいかと思います。 話は微妙なのですが、 ・Ｃで、「何も指していないポインタ」の（ポインタとしての）値は、NULL ・それは、必ずしも、０番地を指しているとは限らない ・しかし、「定数０」とは、必ず等しいと評価される。 ・NULL でないどのようなポインタも、「定数０とは等しくない」と評価される。 なので、 for(p = header; p; p=p->next) というのは、標準に合致したＣであれば、正しく動作します。 けれど、それは、あくまでも、 ・このfor は、暗黙のうちに、 for(p = header; p != 0 ; p=p->next) と見なされる。 ・有効な（NULL でないポインタは、0に等しくないと評価される） という決まりがあるから、必ずしも、NULL を指しているときのポインタが「０（番地）とは限らない」ということになっています。 ※処理系（コンパイラなど）によりきまります。
「わかりません」の一言では何が/どうわからんのかが伝ってこないので答えようがない。
WDK使ったことはありませんが……。 Ws2tcpip.hのinet_pton()のプロトタイプ宣言周辺を見ると… >#if (NTDDI_VERSION >= NTDDI_VISTA) >WINSOCK_API_LINKAGE >INT >WSAAPI >inet_pton( となっています。 NTDDI_VERSIONの設定次第で、後のプロトタイプ宣言は無効になるワケで……。 NTDDI_VERSIONはどう設定されています？ http://msdn.microsoft.com/ja-jp/library/windows/hardware/ff554695%28v=vs.85%29.aspx http://k639.blog121.fc2.com/blog-entry-46.html
>UTF-16の場合「0x0d0x000x0a0x00」 >ですよね？ ということが前提ならLEであるはずなので以下です。 00 00 0d 00 00 00 0a 00 もしもBEなら以下です。 00 00 00 0d 00 00 00 0a UAX  #19: UTF-32 http://www.unicode.org/reports/tr19/tr19-9.html
Ｃ＃は、Ｃの流れをくんでいますので、いずれも可能です。
リソースにVERSIONを追加して その中の ProductVersionを希望の内容に変更してやればいいようです 取得方法 String^ ss = Application::ProductVersion;
>visual stdio 2013では、ファイルが開けませんとなり、途中で、終了してしまうのですが、 >mingwでは、ちゃんとファイルが開けて、プログラムが、最後まで動作するのですが、なぜでしょうか? こういう時の「お約束」ですが… 『カレントディレクトリ』って言葉は知っていますか？ フルパスで指定していないので、カレントディレクトリからの相対パスになります。 その際にカレントディレクトリが何処なのか…と言うことを意識しないと、 「ファイルはあるはずなのにオープンに失敗する」ということになります。 オープンに失敗しているのであると思っているファイルは「カレントディレクトリから見ると」無いんですよ。 Visual Studioなら、プロジェクトの設定でカレントディレクトリ(作業ディレクトリとか書かれているかもしれない)を設定できます。
for(i=0; i<=n-1; n++)の　iがずっと0のままだからではないでしょうか。 nはn++でインクリメントされますが、iは何回ループしても0のままです。
未定義のシンボルという意味ですが、#include したライブラリへのリンク指定がされていないとかはありませんでしょうか。
定義が #define PD (*(volatile struct st_pd *)0xFFFF83A0) /* PD Address*/ に場合は、自分が書いたプログラムの中に struct st_pd　a ; というようなものがあったとして、 PD = a ; とすれば構造体aの内容を全て書き込めて、 a = PD ; とすれば構造体aに全て読み込める訳です。 定義が #define PD ((volatile struct st_pd *)0xFFFF83A0) /* PD Address*/ となっている場合は *PD = a ; a = *PD ; となるだけの話です。 前者はあたかもPDという構造体の実態がどこかにあるかのようにコーディングできますけど、 後者はプログラマがPDはポインタであるという意識の下にコーディングすることになります。 どちらがプログラマにとって自然に感じられるかということではないでしょうか ?
mallocで2次元配列を確保するためには まず各行の先頭アドレスを確保してから、各行の先頭アドレスに各列を確保するようにします。 具体的には10行20列を確保したい場合 int c = 10, r = 20; char **s; s = (char**)malloc(c*sizeof(char*)); for(i=0; i<c; i++){ 　　s[i] = (char*)malloc(r*sizeof(char)); } と確保します。 注意としてはメモリの解放のfreeは、メモリを確保した各場所で行わないと適正に解放されないので for(i=0; i<c; i++){ 　　free(s[i]); } free(s); とします。
こんにちは QTを触ったのははるか昔で、かつ、QT Designerも使用したことが無いので外したらゴメンナサイ。 メインフォームの隙間にフォームAとして、QStackedLayoutか、QStackedWidgetを配置。 フォームBやC（と非表示ということで何もないフォームDも必要？）をQWidgetで作成して、 A.addWidget()でB,C,Dをスタックに追加。 A.setCurrentIndexで切り替えを行うと良いのではないでしょか？
ProgressBarを操作したいとなると Mainクラス側の処理関数に BackgroundWorker型とDoEventArgs型を引き渡してやる必要がありそうです BackgroundWorkerは中断処理と ReportProgressメソッドを使うため DoEventArgsは中断処理のCancelフラグを設定するためです funcを void Main::func(BackgroundWoker^ worker, DoEventArgs^ e) { ... do while( funcの終了条件 ) ... { ... ... if ( worker->CancellationPending ) { ... ... ... e->Cancel = true; ... ... ... break; ... ... } ... ... // 重い処理 ... } } といった具合になりそうです あと BackGroundWorkerのWorkerReportProgressとWorkerSupportCancellationをtrueに設定し ProgressChangedイベントをForm側に設置しましょう また RunWorkComplatedも実装したほうがいいでしょう …
＞(1)プロジェクトのプロパティ⇒構成プロパティ⇒C++⇒コマンドライン ここは、他のシートで設定した項目を適用した結果を確認するためのものです。 設定は別のシートで行います。 /FU であれば、下記が該当します。 プロジェクトのプロパティ⇒構成プロパティ⇒C++⇒詳細設定⇒必ず使用する #using 指定ファイル ※各シートの項目をクリックすると下部にスイッチ名と説明が表示されます。 ＞(2)ソリューションエクスフローラ⇒Setup⇒見つかった依存関係 これは、コンパイラがみつけてくれた（自動検出した）依存関係なので、 ソースとかリンクしているライブラリとかから、DLLの依存関係を調べる必要があります。 たとえば、ソースに下記があれば、urlmon.dll とリンクされます。 #pragma comment( lib , "urlmon.lib" ) DLL の依存関係について調べたい場合、 Dependency Waliker などで調べることができます。
Image Mastering API (Windows) http://msdn.microsoft.com/en-us/library/windows/desktop/aa366224%28v=vs.85%29.aspx とか。
記述するイベント箇所は、Form.Deactivateでしょう。
STLでのアルゴリズムは，一般に言うアルゴリズムの一部です。 STLでのアルゴリズムは，例えば http://msdn.microsoft.com/ja-jp/library/yah1y2x8.aspx ここに一覧があります。 generic algorithmとは，一般に言うアルゴリズムのひとつの例です。 しかし，STLでのアルゴリズムには含まれていません。
#intはSystem.Int32のC#での呼び名。 #stringはSystem.StringのC#での呼び名。
下記に具体的な方法が載っています。 http://l.inolv.jp/2013/02/27/disable-and-enable-network-by-comman/ ただし、文字列の区切りが違っています(半角のダブルクオートです)。 無効化（disabled） netsh interface set interface "ローカル エリア接続" disabled 有効化（enabled） netsh interface set interface "ローカル エリア接続" enabled 「ローカルエリア接続」の箇所は、「ipconfig /all」で「イーサネット アダプター」の後にかかれています。例えば「イーサネット アダプター イーサネット:」であれば「イーサネット」です。
どうも、intellisenseの「仕様」のようです。 ※ intellisenseは、入力時に候補を選ばせたりするやつです。 手許のVS2010で試したところ #if 0 #endif class TestClass {}; int main(void) { return (0); } という意味の無い#if～#endifを入れてもエラーは消えました。 「蛇足」部分について、検索したら同様のことがありました。 http://tanjoin.hatenablog.com/entry/20121213/1355382807
>お薦めの「C++」の入門書をご存じでしたら C++は私もちゃんと習得していませんからねぇ。 なんとなくで読めるけど自分でコード書けるほどじゃないし。 で、書籍に関しては……大きめな本屋に行って数冊の内容を立ち読みで確認し、 自分に合っていそうだな。 と思われる本を2～3冊購入してみる。 としか言えませんね。 なかには今回のような標準関数の扱いについてあやしいものもあるかも知れませんし。 そういう意味でも複数。ある程度身についたら別系統のもの…とか。 # ちなみに私は機能逆引き系とかそういうの好む傾向がありますな。 # C#でこういう機能を実装したいときのコーディング例…とか、こういうコード書くとこんな問題がある…とか。 そこそこ評価のよい著者のものを購入する。ということもありますかね。 # アマゾンとかのユーザレビューも参考になるかも知れません。(ただし、全部が信頼できるレビューというワケでもない場合があるので割り引いて読んだ方がいいかもしれませんが) 安い買い物でもないし。 # 1000円以下だと疑って掛かる。1000円～3000円位だと購入検討する。3000円超えると…結構悩む(買うこともあるが)。 # 入門書代わりにムック本を買うことはありますかねぇ。日経ソフトウェアのとか。 他には…言語だけでなく環境に関する理解なんかも必要かも知れませんね。 「ファイルはあるのにオープンできないのはなんで？」「カレントディレクトリってなんのこと？」「相対パスってなに？」 とか、ツッコミどころあるような理解だとどうにもなりませんし。 あとは、統合開発環境の使い方とか…でしょうかねぇ。 こっちは書籍よりWebで探した方がいいかもしれませんけど。 # Visual StudioならMSのページとかにも載っていたりしますし。 書籍だと突っ込んだ操作方法とか載っていないイメージが。 # 今回のような1ソリューションに複数プロジェクトとか。
EnumWindowsを呼び出す前に BOOL EnumWindows(WNDENUMPROC lpEnumFunc , LPARAM lParam); と言うプロトタイプ宣言が必要です。 このプロトタイプ宣言をし忘れると、EnumWindowsの第一引数の関数の呼び出し規則が__stdcallとなり、宣言と一致しなくなります。 ＞キャストすればよいのかと思い下行のようにしました。 キャストは駄目です。呼び出し規則は変更出来ません。 呼び出し規則を無理矢理にキャストしてしまうと、呼び出し元と呼ばれた関数の整合性が取れなくなり、暴走したり、メモリリークしたり、致命的例外を発生したりしますので、通常はキャストできないようになっています。
GSLはどうですか？ 日本語訳のマニュアルも探せばでてきます。 http://www.gnu.org/software/gsl/
ToolStripMenuItemにはClickイベントがありますから，Clickイベントを普通に検出すればよいです。 詳しくはC#の文法書をお読みください。 a) ラムダ式を使ってハンドラを書く openLabel.Click += (_, __) => { MessageBox.Show(this, "Export"); }; deleteLabel.Click += (_, __) => { MessageBox.Show(this, "Import"); }; b) 別途メソッドを用意してハンドラを追加する private openLabel_Click (object sender, EventArgs e) { MessageBox.Show(this, "Export"); } private deleteLabel_Click (object sender, EventArgs e) { MessageBox.Show(this, "Import"); } openLabel.Click += openLabel_Click; deleteLabel.Click += deleteLabel_Click;
こちらで使っている市販コンパイラではベクトル化してもベネフィットはないとメッセージが出てきます。 unrollの最適化はしています。加算していますのでベクトル化は確かにちょっと効果はなさそうに見えます。 関数にして（inlineにはしなくて）遅めのCPUでやってみましたが、1000万回で7秒程度です。 これで遅いのなら、他にも手は有りますが。
>参考書にも「配列変数」の解説がありません！ 参考書ですか？ 入門書ですか？？ いずれにしろ、配列変数について記載されていないような入門書なら廃棄しちゃっていいんじゃないかと思いますけどねぇ……。 >　以上のプログラムで！ >　「配列変数」が”どこ”に当たるのか >　？いまいちピンとこないです！。 >int suuretsu[10]; が配列変数です。 int型でsuuretsuという名前の配列で、suuretsu[0]～suuretsu[9]までの10個が使えます。 そして、掲示されたコードはどこから持ってきたものか不明ですが、 かなり高い確率でバッファオーバーランします。 未初期化のローカル変数の内容は「不定」ですので、suuretsu[0]～suuretsu[9]の中に値が0になるものがなければ、そのまま突っ走ります。(0が見つかるまで) で、アクセス禁止な領域を参照してOSに止められます。 # 書き込んではいないからまだマシ…かなぁ……。
共有する属性だけをソリューション直下のSharedAssemblyInfo.csに集めて， そのファイルをプロジェクトからリンクする形で取り込む，ということをやったことがあります。 1. [プロジェクト] - [既存項目の追加]と辿り，[既存項目の追加]ダイアログを開く 2. SharedAssemblyInfo.csを選択する 3. [開く]ボタンの右側の三角を押し，[リンクとして追加]を選択する という手順でリンクを追加できます。 SharedAssemblyInfo.csには，AssemblyInfo.csのコードのうち， AssemblyVersionやAssemblyCopyrightなどの属性を移動しておくことになると思います。
private: System::Void button1_Click(System::Object^ sender, System::EventArgs^ e) { int input; if ( Int32::TryParse(textBox1->Text, input) ) { label1->Text = String::Format(L"あなたは {0} を入力しました", input); } else { label1->Text = L"intに変換できませんね..."; } } > 初心者につき、できるだけ噛み砕いて、説明を加えて、回答お願いします。 どこまで砕いていいかわからんので無理。 わからんとこあったら訊けばいいやないの。
math.h のライブラリにある関数を使うには、libm をリンクする必要があるので、gcc のコマンドラインに -lm という指定が必要です。 printf などの関数は、libc に入っており、これは指定しなくても参照されます。 pow(10,-1)で -lm がなくてもエラーにならなかったのは、他の方が書いてますが、コンパイラが結果を計算してしまって実際にpowを呼ぶようなコードを生成しなかったからでしょう。 つまり、printf("%f",pow(10,-1)); が、printf("%f",1e-1); に最適化された。
振幅の最大値を求める計算は、2乗してから1/2乗して正の値で比較するってことは、単純に振幅値がマイナスのときはマイナス1をかけて正の値にして比較すれば良さそうだけど。C言語仕様書なりで数学関数を調べておけば、累乗、平方根を求めるときに使う関数はわかるよね。 まず、振幅の最大値を求める。これは、最大値を代入する変数を用意して、初期値0か負の値で初期化しておいて、一行ずつ読み込んでは比較用の正の値に直した振幅値と比べて読み込んだほうが大きければ最大値用の変数に代入。という繰り返し処理で、ファイルの終わりに到達したら繰り返し処理を終了。 次に、振幅の最大値の２割に達した時間を求める。たぶんぴったり２割という値じゃないときもありそうだから、振幅の最大値の２割以上で最小値になる時間を求めることになるだろう。最小値を求める変数を用意して、振幅の最大値かその変数のデータ型でとりうる最大値で初期化しておいて、ファイルの先頭から一行ずつ読み込んでは、振幅の値が振幅の最大値の２割以上だったら最小値の変数と比較して、最小値の変数の値のほうが大きければ最小値の変数へ代入して更新。並行して、振幅の最大値の２割に達した時間を代入しておく変数の値も更新とともに出力。これをファイルの終わりまで繰り返し。 ひとつの振幅周期しかファイルに記録されていなければ、こんな感じで処理できると思うよ。 構造体、構造体を入れる配列、クイックソートを勉強すると、もっとうまく処理できるプログラムになるだろう。 ほかに細かな注意事項を挙げておくと、変数のデータ型、特に数値データ型は表現できる値の下限値、上限値、オーバーフロー、アンダーフローに注意。また、異なる数値データ型での型変換(cast)で情報落ちしないかに注意。 ファイル操作では、ファイルのオープン、クローズ、読み込み、書き込みのときにエラーが起きたときの処理も追加するのが安全。ファイルを作ったOS 環境とプログラムを動かすOS 環境とで文字コードの違いがないか、改行コードの違いがないか、ファイル先頭のBOM情報に適した処理にしなくてはならないのか注意。エスケープシークエンス文字の使い方にも注意。時間データ値が数値データなのか、文字列データなのか、時間データと振幅データを区切るのはTABコードなのかホワイトスペースなのかなど。 サンプルプログラムはパッと見、arrival 変数が振幅の最大値の２割を超えていればどんどん更新され続けるバグがある。ほかに、sscanf の書式指定で、時間データと振幅データを区切るセパレータ文字列の扱いが抜けているから、正しい振幅データがamp 変数に取り込めていなそう。この辺は、デバッガを使って変数の値をトレースするやり方を身につけるか、デバッグ用のprintfを付け足して確認するのがいいでしょう。
こんな感じ。 確認はしていません。 質問にあるプログラムと、ほとんど同じ（max20 は毎回確認せずに、max * 0.2 で計算していますが）なので、よく確認してください。 おそらく、いくつかの「例題」をそのまま引っ張ってきて、一本にしたのでしょう。 たとえば、 FILE *fp = fopen(fname, "r"); という、「決り文句」が２回（ファイルを２回スキャンする必要があるので）出てきますが、同じ関数の中で、これを二つ書くことはできません。（実は、書く方法もあります） そこで、二番目の FILE *fp = fopen(fname, "r"); のまえに、いつも書いている main() を持ってきたというのは何となくわかります。 エラーが出たときに、「なぜエラーなのか？」を理解せずに「とにかくエラーを消す」という方針で進むと、いずれ困ったことになります。 あと、プログラムの動作を記述する言葉の使い方にも慣れましょう。 > 振幅の２割を超える時間まで読み込み越えた際の時間を 　振幅の最大値の２割を、始めて超えたときの時間　ですね。 -------------- form here ------------------------ #include <stdio.h> int main(void) { const char * fname = "C1rbc1(50,0)sq,almi00001.dat"; char line[BUFSIZ]; double amp, time,arrival, max=0; FILE *fp = fopen(fname, "r"); while (fgets(line, BUFSIZ, fp)) { sscanf(line, "%lf%lf", &time, &amp); if (amp > max) { max = amp; } } fclose(fp); printf("max: %.7lf\n", max); fp=fopen(fname,"r"); while (fgets(line, BUFSIZ, fp)){ sscanf(line,"%lf%lf",&time,&amp); if(amp > max * 0.2){ arrival=time; break; } } fclose(fp); printf("arrival:%.7lf\n",arrival); return 0; }
たとえば、こんなサイトが参考になるかも。 http://www.geocities.co.jp/Playtown-Knight/6845/sd_doc/format_windib.html 他にも、似たようなサイトがありますので探してみてください。
ごめんなさい、間違えてますね。 ご指摘の通り、hogehoge.cを実行しようとしています。 hogehoge.exeを実行しにいくために以下のコードで cd $(CURRENT_DIRECTORY) npp_run $(NAME_PART) あとテキストエディタ上では、対話式のプログラムを動作させることができません。ご注意を。 （例）scanf等で文字を入力する等 リダイレクトを使えば入力を扱うことはできますが。
もう少しちゃんと見てみましたが、やはり不思議な仕様のコードですね。 > //被加数,被減数,被乗数,被除数と演算の判定 > i=0; > while((str[0][i]=getchar())!='\n'){ と書いているので'\n'で入力が終了することを期待しているのでしょうが、実際に四則演算を入力しようとすると、次のところでループから脱出します。 > if(str[0][i]=='+' || str[0][i]=='*' || str[0][i]=='/' || str[0][i]=='-'){ > cont=1; //2つ目の数字を読み込むか否かの判定 > break; 例えば、"1+2"という入力をしたら、"1+"(ただし、NULL文字では終わっているとは限らない)がstr[0]に入った状態でループを出ます。 その後、次のコードを実行します。 > //加数,減数,乗数,除数の判定 > if(cont==1 && err!=1){ > j=0; > while(str[1][j]!='\n'){ なぜか、str[1]となっているので、中に何が入っているか不明なところを\nが出てくるまで探し続けます。 > if(isdigit(str[0][i])==0){ > err=1; //数字以外の入力があればエラー > } > j++; > } と、数値以外が来てもお構いなしにstr[1]の中身を読み続け、str[1]に運良く'\n'が入っていない限り、OSがメモリーへのアクセス違反を検出して強制終了となるまでメモリーを読み続けるでしょう。 ちなみに、whileの条件を while(str[1][j]!='\n'){としてもダメです。なぜなら、'\n'が入っていないから。 他にも色々と不思議なところはありますが、 多分、2項の自然数の四則演算をするプログラムだと思ったので、質問文にあるコードを元に、プログラムを読みにくくするところを省いて多分やりたいことだろうというコードに書き換えてみました。 #include<stdio.h> #include<ctype.h> #include<stdlib.h> int main(void) { char str [128] = {0}; int i , j, err = 0, op_pos = 0, wari = 0; double dans; long a , b, lans; puts("自然数の四則演算('+''-''*''/')を計算"); //被加数, 被減数, 被乗数, 被除数と演算の判定 i = 0; while ((str[i] = getchar()) != '\n') { if (str[0] == '+' || str[0] == '*' || str[0] == '/' || str[0] == '-') { err = 1; } if (str[i] == '+' || str[i] == '*' || str[i] == '/' || str[i] == '-') { //オペレーターの位置を保存 if (op_pos != 0) { err = 1; break; } op_pos = i; } else if (!isdigit(str[i])) { err = 1; //数字と演算方法以外の入力はエラー } i++; } if (err == 1) { printf("エラー入力"); return 0; } a = atol(&str[0]); b = atol(&str[op_pos + 1]); switch (str[op_pos]) { case '+': lans = a + b; break; case '-': lans = a - b; break; case '*': lans = a * b; break; case '/': if (b == 0) { // devided by 0. err = 1; } else { dans = (double)(a) / (double)(b); wari = 1; } break; default: break; } if (err == 0) { if (wari == 0) { printf("計算結果:%ld\n", lans); } else if (wari == 1) { printf("計算結果:%f\n", dans); } } else { printf("エラー入力です\n"); } return 0; } 今後、1+2*3に7と答えるようにするなら、字句解析や演算子順序解析に付いて勉強したほうがよいかもしれません。
私なら・・ありきたりと言いますか、Socketのサーバとクライアントを作って、HELOと言えばHELOと返す、ようなものを動かすかなあと。 それを発展させて、単純なKey-ValueストアのDBみたいなのを作るのは面白いとは思いますが。
> できれば、どういう場合に変更することに意味があるのか詳しく知りたいです。 昔、プログラムで使えるメモリが貴重だった頃は、どうやってメモリを節約するかが 重要でした。そういう世界では、入力パラメータを解析するのにメモリを消費しないで 解析するのがよいコーディングでした。 カンマ区切りのパラメータを解析する時は、strtok()を使って 入力パラメータ(argv)を分解する(区切り文字を\0で書き換えてパラメータを取り出す) というのが普通の方法でした。 strtokのマニュアルでも、サンプルソースにargvで入力されたパラメータを strtokで分解する例が書かれています。 http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/strtok.3.html 今でも組み込み系でメモリがあまり使えないところでは、こういう手法は よく使われると思います。 パラメータを分解するのに、わざわざ新しいメモリ領域を確保して別の領域に 取り出すなんて、(環境によっては)メモリの無駄遣いということです。 このために、C言語の規格でargc,argvは書き換え可能でなければならない ことが明記されています。
聞いたことが無いならまずググるくらいのことはしましょう。 とりあえず入口となるページの URL は載せるけど。 ソフトウェア開発でのかんばん http://ja.wikipedia.org/wiki/%E3%81%8B%E3%82%93%E3%81%B0%E3%82%93_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA) リーン開発 http://www.itmedia.co.jp/im/articles/0803/10/news113.html
ん～と、少なくとも 2 年使う場合はその値段だったらあと 3 万円足してオープンライセンスを買った方がトータルで得だと思いますよ。 http://licenseonline.bbss.co.jp/valumore/?lolcid=msdnBizStore
for( i = 1; i <= 5; i++){ 　sprintf(input_file,"./testin/%d.txt",i); 　if((fi = fopen(input_file,"r")) == NULL){ 　　puts("Error:cannot open input file \n"); 　} else { 　　printf("input_file=%s\n", input_file); 　　fclose(fi); 　} } ではダメなんでしょうか？ # if文の条件を逆にするかどうかは…好みの問題ですかねぇ。 # 私の場合は、失敗の時にelseでエラー処理…という書き方する方が多いですね。
MSDN をさらっと眺めただけですが、その TreeView の AfterSelect イベントの中で、SelectedNode.Nodes.Count が 0 か否かで確認できそうに読み取れます。 TreeView.AfterSelect イベント http://msdn.microsoft.com/ja-jp/library/system.windows.forms.treeview.afterselect(v=vs.110).aspx TreeView.SelectedNode プロパティ http://msdn.microsoft.com/ja-jp/library/system.windows.forms.treeview.selectednode(v=vs.110).aspx TreeNode.Nodes プロパティ http://msdn.microsoft.com/ja-jp/library/system.windows.forms.treenode.nodes(v=vs.110).aspx TreeNodeCollection.Count プロパティ http://msdn.microsoft.com/ja-jp/library/system.windows.forms.treenodecollection.count(v=vs.110).aspx
普通、#1の回答のとおりだと思いますが、わざわざ聞いているのでsetjmp/longjmpの使い方を聞きたいのかと思ってしまいました。まあ、setjmp、longjmpはgotoと同様、それをどうしても使わないといけない合理的な理由がない限り、まず使いませんが。 #include <setjmp.h> #include <stdio.h> static jmp_buf env; void func1() { printf("func1\n"); longjmp(env, 1); } void func2() { printf("func2\n"); if (setjmp(env) != 0) { return; } func1(); printf("subsequent processing"); } int main(void) { func2(); return 0; } #1に補足すると、関数1の返り値に基づいてreturnした方が後続処理を飛ばしたいという質問にあってそうな気がします。 void 関数2() { if (!関数1()) { return; } ***後続処理*** }
もし本当に何をすればいいか分からないのであれば、「ActiveReports アンバウンド」で検索してみるといい。 さすれば、DBを使わずにレポートに定義したフィールドにどうやってプログラムから値を流し込めばいいか分かることでしょう。
> LinkedListとListの違いについて教えていただきますようお願いいたします。 マニュアルを読むべし。 > Linkを使用した下記プログラムをLinkedListに書き換えるにはどのようにしたらよいのでしょうか。 LinkedList<Values> list01 = new LinkedList<Values>(new Values[] { new Values{ID=1,Value="あいうえお"}, new Values{ID=2,Value="かきくけこ"} });
DBを使わないはずなのにDataReaderが出てくる理由がよくわかりません…… http://intd.componentone.com/arJPhelp_Internal_v7/GrapeCity.ActiveReports.v7~GrapeCity.ActiveReports.SectionReport~FetchData_EV.html ↑のURLあたりのコードをそのまま引っ張ってきたのかもしれませんが、 これはレポートスクリプトに書くコードではなく、本体側(NewActiveReport1側)に書くコードです。 (そもそも、要件的にFetchDataイベントを使うのが適切がどうかも疑問です) このあたりが参考になるかと思います(バージョンは違うので注意)。 http://www.grapecity.com/tools/support/technical/knowledge_detail.asp?id=33914
char *fname1; ... sprintf(fname1, "sankasha%d.txt", count); fname1はポインターであって、配列ではないですよね。 そこにsprintfしてもアクセス違反などで強制終了でしょう。 char fname1[100]; のように配列をちゃんと確保するか、 glibcやBSD系のlibcが使えるならsprintfではなくasprintfを使うかでしょうね。 asprintf(&fname1, "sankasha%d.txt", count); fp = fopen(fname1, "r"); if (fp == NULL){ printf("%s can't open a file\n", fname1); return -1; } free(fname1); あと、バッファが溢れないという自信がよほど無い限りはsprintfは使わないですね。 ISO C99で標準化されたsnprintfを使うのが普通だと思います。 まあ、何かのデータの整理をするプログラムはよほど速度が問題にならない限り、自分だったらPython、Perl、Rubyなどのスクリプト言語でプログラムを書くと思いますが。
Qt Creator の使い方がわからないということですね。 参考URLをどうぞ。 ちなみに、「Qt Creator 使い方」で検索して2番目に出てきたページです。 http://polymer.apphy.u-fukui.ac.jp/~koishi/lecture/qt_program/qt_program1.php?type=mol_sim ウィンドウのデザインを、ソースで書くのではなく Qt Designer を使いたい場合はこちらのほうが適切です。 http://blog.qt.digia.com/jp/2010/03/24/helloworld-from-qt-creator-2/
> エラーでビルドしません エラーメッセージは何でしょうか。 2010のSP1はインストールしてありますか。Windows Updateは実行してありますか。
MultilineをTrueにしてください。
ん～... そこまでできてて, なにで困っているんだろう.... 単純には FILE *gp = popen("gnuplot -persist","w"); fprintf(gp,"set terminal png\n"); fprintf(gp,"set xrange [0:5]\n"); fprintf(gp,"set yrange [0:50]\n"); for (int i = 0; i < てきとうなところ; i++) { char data_file[いくつか]; sprintf(data_file, "out%d.data", i); FILE *data = fopen(data_file, "w"); /* データファイルに出力するところは全部ばっさり省略 */ fclose(data); fprintf(gp, "set output 'out%d.png'\n", i); fprintf(gp,"plot \"%s\"with lines linetype 1 \n", data_file); } pclose(gp); でいいと思うんだが, なにかおかしなところはあるのかな?
10で割ったときのあまりが1であれば含まれている。 そうでなければその数を10で割り、最初にもどる。 割った数が0になれば終了。 こんなかんじでどうでしょ。
んー、ちょっとわかりません。 ここで聞くより、MSDNフォーラムで聞いた方が、有識者がたくさんいますので、 そちらで質問してみてはいかがでしょうか。 http://social.msdn.microsoft.com/Forums/ja-JP/home カテゴリは Visual Studio Development -> Visual Studio 共通 フォーラム が適切と思います。
最初に断っておきますが組み込み系において、ＧＵＩを作る場合Win32APIもVisualStudioに付属のフレームワークであるＭＦＣも使うことはまずありません。あと.NETのC++/CLIのフォームアプリも使いません。 まぁ、ポスレジとか自販機とかでそのままWindowsPCが入っている例があるので、その場合は使うことが有るかもしれません。それでもC#かも知れませんが。 組み込み系でGUIだと特殊なのも多いので・・・。 そうですね。ラズベリーパイとかマイコンをＣ++でやってみるのも良いかもしれません。 「こじ研（Raspberry Pi）」 http://www.myu.ac.jp/~xkozima/lab/raspTutorial2.html VisualStudioは使いませんけどね。
凸多角形になることが保証されているなら, 例えば 1. y座標が最小の点を見つける 2. その点から他の各点を結んだ直線の, x軸からの偏角を求める 3. 偏角の小さい順にソートする でできるはず. 一般的には Jarvis march (ジャービスの行進) とかで調べてくれ.
まず，処理方法から。 ・イベントの処理をバックグラウンドのスレッドで行うようにする →Taskクラス，BackgroundWorkerクラス ・処理内容の変更を要求する方法を用意する →AutoResetEvent, ManualResetEventなどの同期オブジェクト，Booleanフィールド等 ・イベント処理コードは，定期的に処理内容の変更要求を確認し，変更要求が出ていればそれに従う という手順を踏みます。 UIスレッドで何らかの処理を行っている最中に，別のUIイベントは発生しません。 このため，UIスレッドでの処理は短くし，長時間かかる処理は別のスレッドで行うようにします。 簡易な方法はBackgroundWorkerクラスをを使う方法ですが，BackgroundWorker自体がコンポーネントであるため， 色々なイベントで別のスレッドを使って処理を行うには向いていません。 複数のイベントで長時間処理を行うような場合は，Taskクラスを使って処理を行います。 さて，別のスレッド (ワーカースレッド) に要求を伝える場合 (典型例はキャンセル)， UIスレッドから直接ワーカースレッドの処理に介入することはできません。 なので，ワーカースレッドにはフィールドや同期用オブジェクトを使って，UIスレッドから処理をお願いすることになります。 もちろん，お願いをフィールドに設定しただけではだめで，ワーカースレッドがそれを見にいく必要があります。 これは，意図的に見にいくように処理を作ることになります。 処理を依頼するようなサンプルプログラムを簡単に組んでみました。 Console Applicationで動作します (VS2013/.NET 4.5.1で確認しているため，VS2010では未サポートのものがあるかもしれません) インデントの為に_を使っています。_をスペースに置換して使ってください。 Enterを押すたびに表示される値が2倍になり，Ctrl + Zで終了します。 Imports System.Threading Module Module1 ____Private doubleRequest As Boolean ____Private source As New CancellationTokenSource() ____Sub Main() ________doubleRequest = False ________Dim t As New Task(AddressOf WorkerTask, source.Token) ________t.Start() ________Do ____________Dim s As String = Console.ReadLine() ____________If s Is Nothing Then ________________source.Cancel() ________________Exit Do ____________End If _____________doubleRequest = True ________Loop ________t.Wait() ________Console.WriteLine() ________Console.WriteLine("Finished.") ________Console.ReadLine() ____End Sub ____Sub WorkerTask() ________Dim number As Integer = 1 ________While Not source.Token.IsCancellationRequested ____________If doubleRequest Then ________________doubleRequest = False ________________Console.WriteLine("Doubled Requested ({0} to {1})", number, number * 2) ________________number *= 2 ____________End If ____________Console.WriteLine(number) ____________number += 1 ____________Thread.Sleep(TimeSpan.FromSeconds(1)) ________End While ____End Sub End Module
http://msdn.microsoft.com/ja-jp/library/4e964t5e%28v=vs.90%29.aspx GroupBoxとPanelの組み合わせ…らしいです。
gnuplotは標準入力から命令を受け取ってそれを実行しますので、Cで書いたプログラムを、gnuplotの命令をテキスト形式で出力するように改造し、パイプでgnuplotに送れば(3)までできます。 やり方はgnuplot、パイプで検索すればたくさんでてきます。 例えば http://akita-nct.jp/yamamoto/lecture/2006/5E/gnuplot/html/node4.html これはpopenでパイプを作っていますが、shell上で|で繋いでも構いません。
合っているか分かりませんが DocumentProperties の事ですかね。 DocumentProperties↓ http://msdn.microsoft.com/ja-jp/library/cc428447.aspx 設定を変更する際の手順は複雑ですが↑のページの > ローカルプリンタの設定を変更するには、次の手順に従ってください。 という所に 1. 2. 3. 4. 5. と手順が載っています。 DocumentProperties の引数に指定する、設定項目の構造体 DEVMODE については↓ http://msdn.microsoft.com/en-us/library/windows/desktop/dd183565(v=vs.85).aspx
あなたが何を指して「プレースホルダー」と呼んでいるのかさっぱり分からんので全く保証の対象外だが, たぶんないんじゃないかな. たぶん理解したと思うけど「プレースホルダー」は本来「コードの記載において簡略表記する方法」じゃないわけで.
あなたは、「extern “C” int StrCount(const char* str, char ch); で StrCount と言う関数がどこかにあるからコンパイル後にリンクしてね」と宣言しています。 それなのに、 StrCountがどこにもないので、リンカーが「そんな関数ないよ？」とエラーを出しています。 本がないからわかりませんが、StrCountの関数があるヘッダファイルをインクルードするか、StrCountの関数をあなたが定義しなければいけません。
> 悩んでいるのは EndReceive から、 > 二回目のBeginReceiveまでの間に送られたデータを取りこぼしてしまうのではないかということです。 大丈夫よん。 プログラムがBeginReceive～EndReceiveでひとかたまりの受信データブロックを取得するのはあくまで「同じコンピューターのOSから」なので、その時「同じコンピューターのOS」は相手からのデータ送信をどんどこどんどこ受け付けている。 そもそも最初のBeginReceiveをしなくてもコネクションが確立された瞬間からOSは相手からデータを受け取っているのだ。 これは、次のようなイメージだ。 （１）あなたは一階に総合受付がある雑居ビルで仕事をしてる。（あなた＝プログラム、総合受付＝NIC） （２）一階の総合受付の中にあなた宛の郵便受けを置いたとする。(Socket#Listen、Socket#Accept） （３）郵便屋さんはそこにあなた宛の郵便をどんどこどんどこ持ってくる。 （４）あなたは部下に「郵便受けに何かないか見てこい。何もなかったら何か来るまでそこで見張ってろ。郵便が有ったら報告せよ。」という。（BeginReceive） （５）部下は降りていった時に郵便があればそのまま持って上がる。無ければ来るまで待つ。（コールバック） （６）あなたは部下から郵便を受け取って再び（４）を命じる。（EndReceive、AsyncState、BeginReceive） ここで、（３）と（４）～（６）は非同期にかつ独立して行われる。あなたや部下が郵便を取りに行こうが取りにいくまいが郵便屋さんは郵便を持ってきて便受けに入れるだけだ。具体的には（６）でEndReceiveとBegenReceiveの間に郵便屋さんが来たとしてもそれは便受けに郵便を入れるだけだ。 もちろん、あなたのプログラムが終了しようとしている時に郵便受けに溜まってるのにあなたが読まなかった郵便はプログラム終了（というかSocket#Close）とともにロストする。 TCPはこの郵便受けがぱんぱんになってしまったら郵便屋さん（というか郵便を送りつけてくる相手）にちょっと待って貰うとかそういう制御もしている。 イメージ的にはこんなイメージであなたはBeginReceiveとEndReceiveを実行するタイミングによる伝送データロストを気にする必要はない。もし本当にそんなちょっとしたタイミングの差でそんな事が起こるんならMicrosoftさんだってそんなコンポーネント作らんじゃろ。
RenderTransformにRotateTransform渡せば回転します。 RenderTransformはUIElementの依存関係プロパティなのでTextBoxに限らないですが……。 http://msdn.microsoft.com/ja-jp/library/system.windows.media.rotatetransform.aspx http://msdn.microsoft.com/ja-jp/library/system.windows.uielement.rendertransform.aspx ただし，RenderTransformOriginを指定しないと，左上隅が回転の中心点になるので，中心を指定するなどした方がよいでしょう。 XAMLで関係する部分はこんな感じです。 <TextBox RenderTransformOrigin="0.5,0.5"> <TextBox.RenderTransform> <RotateTransform Angle="90"/> </TextBox.RenderTransform> </TextBox>
>インターネットを検索しているとフォーム情報を次の遷移先の画面のフォームクラスに渡す >というような処理をやっていたのですがこの方法だと画面数が多いと大変だと思います。 データをまとめて保持するクラスを作って、フォームのプロパティなどで受け渡しするようにする。 とかありそうですが……。 面倒なら受け渡しする為のプロパティを組み込んだクラスをFormクラスから継承して、そのクラスを継承してそれぞれのフォームを作ればコード書く場所は限定できますし。 # まぁ、フォームを追加するたびにコードの一部を修正する必要があるでしょうけど。(どうせ追加時の１回だけです) あとは…Program.csにフィールド追加でしょうかね？ やったことはありませんけど。 http://oshiete.goo.ne.jp/qa/4740138.html http://social.msdn.microsoft.com/Forums/ja-JP/56f0d319-d1b6-4adb-b91a-c92e16c3bdfc/formclass?forum=csharpgeneralja などなど。
verではなくvarだと思います。
http://dobon.net/vb/dotnet/system/osversion.html 上記のページの下の方に「サーバーかどうか調べる」という記載がありますね。
失礼、先に回答した内容は事象１についてです。 事象２についてはやはりソース量の問題でしょうね。 VS2010は重いとも言われていますし、 軽く検索したところ低スペックのPCで同様のメッセージが出ている方がいるようです。
遅くなってすみません インストーラの実行時の条件に.NET Frameworkを指定する事で、 インストール時に.NET Frameworkが無ければ、メッセージが表示され、 .NET Frameworkのインストールが先に行われるようになります。 設定方法は↓を参照していただいた方が、私のつたない文章より判りやすいと思います http://dobon.net/vb/dotnet/deployment/dotnetbootstrap.html ちなみに、新しいＰＣだと4.0が標準なので、必須コンポーネントも態々2.0にせず、 4.0を指定する事をお勧めします。
(1) NULL を使った方が良いという意見と 0 を使った方が良いという意見の両方がある 規格にはどちらかを使ってはいけないなどという記述はありません。また、C++ では NULL は #define NULL 0 とされるので、実質的にはどちらも同じです。従って、どちらかが推奨されるとしたら、可読性やミスを減らすという観点から議論される事になると思います。因みに、No.3 の #define NULL ((void*)0) は C 言語の場合です。 先ず、NULL を使うと「意味的にそれがポインタを意図している」という事がプログラムの読み手に伝わりやすく、良いとする人があります。(これが、そもそもマクロとして NULL を定義した切っ掛けだと思います。) しかし、問題点は NULL は単なる 0 に展開されるので、それが「ポインタを意図した 0 である」という事がコンパイラに伝わらないという所にあります。例えば、 void f(int*); void f(int); の前者を呼び出そうと思って f(NULL); と書くと f(0); に展開され、実際には後者が呼び出されます。null ポインタを 0 と書いていれば f(0); まで書いた時点で「おや、これはまずいぞ」と気付く可能性が高いですが、NULL と書いていると認識として「NULL はポインタ」という先入観がある為に f(int*) の方が呼び出される様に錯覚してしまいます。因みに、前者の f を正しく呼び出す為には f((int*)NULL) または f((int*)0) とする必要があります (別に 0 と表記していれば何も注意が要らないという訳ではなくやはりキャスト (int*) が必要になりますが、その事に気付きやすいという事です)。 これに対して、そもそもポインタを受け取る関数と整数を受け取る関数を同名で多重定義する事自体が問題なのではないかという反論もあります。つまり、f(int*) f(int) の呼出の問題は、引数に NULL を指定した事に問題があるのではなくその様な多重定義をしてしまった事に問題があるのであって、これは NULL を敬遠する理由にはならないという主張です。 何れにしても、 > 「NULLは単なるマクロなので本来は0を使わなければだめ」 の記述は、違います。0 が推奨される理由は NULL がマクロだからだとかではありません。マクロは偽物で即値が本物なので、即値の方が良いなどという議論は成立しません。マクロの方が読みやすければ、即値ではなくマクロを使うべきです。例えば EXIT_SUCCESS, EXIT_FAILURE, SEEK_SET などのマクロ定数は使った方が分かりやすいプログラムになります。 NULL に関して賛否両論があるのは、C言語からC++への発展の際の矛盾 (ここでは説明しませんでしたが) などの複雑な背景があるからなのです。 (2) C++11 では nullptr 先に述べたように NULL と書くのも 0 と書くのも欠点があるので、それを補う為に C++ の 2011 の規格で nullptr という新しいキーワードが追加されました。今後は、C++11 に対応している新しいコンパイラでは nullptr を使っていくと良いでしょう。(勿論、古いコンパイラでコンパイルできなくなるという問題点はありますが)。 (3) null ポインタを表す整数リテラルは常に 0 です No.1 補足。 確かに NULL ポインタの「内部表現」(機械の中でどう表されるか) は処理系依存なので、null ポインタのビットパターンをそのまま整数として解釈 (reinterpret_cast) した時に 0 になるとは限りません。しかし、ソースコードの上では常に 0 と表します。なぜならば、整数を普通にポインタに変換 (static_cast) する場合は、整数の 0 と null ポインタが対応する様に変換されるという事が保証されているからです。
>１）C++の概念ではこのような使い方は考えられないのですが、 >　　C#ではあたりまえでしょうか？ 「このような」というのは、一体どの部分を指しているのでしょう。 (a) 「ref object で渡した物が VARIANT* で受け取れる」という部分に関してであれば、 これは C# と C++ の相互運用の為に、間に Marshaller (変換機構) が存在している為で、C# の中だけで使っている限りにおいては、C++ と同様に、勝手に引数の型が変換されるといった事はありません。 (b) 「参照を引数に渡して、そのオブジェクトを初期化してもらう」といった使い方に関してであれば、 この方法は C++ でも普通に使われる方法です。むしろ、C# ではその様な使い方の濫用を防ぐ為に、意識して ref や out などのキーワードをつけないと、その様な使い方ができない様になっています。 >２）この場合、配列数と配列の要素を取出す方法を教えてくれませんか？ data を対応する配列型にキャストして下さい。 例えば VT_ARRAY | VT_UI4 ならば (uint[])data, VT_ARRAY | VT_BSTR ならば (string[])data など。 ---------- 例を載せます // C++ 側 (okwave.dll とする) extern "C" __declspec(dllexport) void excute(VARIANT* data){ static const int numberOfElements=10; SAFEARRAYBOUND abound={numberOfElements,0}; SAFEARRAY* parray=SafeArrayCreate(VT_UI4,1,&abound); DWORD* elem; if(SUCCEEDED(SafeArrayAccessData(parray,reinterpret_cast<void**>(&elem)))){ for(int i=0;i<numberOfElements;i++) elem[i]=i*(i+1)/2; SafeArrayUnaccessData(parray); } VariantInit(data); V_VT(data)=VT_ARRAY|VT_UI4; V_ARRAY(data)=parray; } //-------------------- // C# 側 using System.Runtime.InteropServices; static class Program{ [DllImport("okwave.dll")] static extern void excute([Out][MarshalAs(UnmanagedType.Struct)]out object data); static void Main(){ object data; excute(out data); if(data==null){ System.Console.WriteLine("data is null"); return; } System.Console.WriteLine("data = {0} : {1}",data,data.GetType()); uint[] data_=data as uint[]; // キャスト→ data_ は通常の配列と同じに使える、というか、通常の配列である。 if(data_==null){ System.Console.WriteLine("data is not an array."); return; } for(int i=0;i<data_.Length;i++){ uint elem=data_[i]; System.Console.WriteLine("data[{0}] = {1}",i,elem); } } }
この分野には詳しくはないのですがFortranを使うことが多いです。歴史的な要素も有るのですが、Fortranの方がCより速いプログラムになることが多いのも関係していると思います。 入出力を除いてはCとFortranもそんなにに変わらないので、ある程度自分で作る気があるのでしたらFortranでも簡単にCで書き換えらると思いますがいかがでしょうか？ ただ配列要素が1から始まるのと0から始まる違いがあるので気をつけないと間違いがおきやすいです。 さて、現実的な解決法としては、CからFortranのサブルーチンを呼び出すことができますので、参考書にある部分はFortranでそのまま利用し、自分で一から書く部分はCで書かれてはいかがでしょうか？ Fortran2003らかはC bindingで検索すれば出てきますが、Cのサブルーチンとほとんど変わらない呼び出し方ができますので、簡単に共存ができます。古いポインタ渡しの解説記事が多いと思います、手間さえかければでできるのですが、C binding機能を使うことをお勧めします。
#pragma section data = ".rodata" //ROM配置したいデータ #pragma section data = default 等のコンパイラやアセンブラのコマンドを使ってデータが配置される領域をROM領域に設定してください。 必要に応じてリンカディレクティブファイルまたはリンクディレクティブなどと呼ばれるファイルを編集してROM領域を示すセクションを追加してください。 注）他の回答にあるようにあなたの使用している環境に合わせてください。
>APIはCStdioFile の Open()でファイル名を与えるところ APIではないようですが……。 http://msdn.microsoft.com/ja-jp/library/ee247566.aspx ならば、そのままCStringの変数渡せば、よろしく処理してくれると思いますけど。
フルパス指定でも良いけど…。 ALT+F7でVCのプロパティ ページが開ける。 VC2008では左側に「デバッグ」というのがあってそこを押す。 右側に「作業ディレクトリ」というのがあるので、そこにファイルがあるディレクトリを指定する。 これによればプログラムを修正する必要はない。
>doc3p」ってなんでしょう・・・。 ソースから察するにMSHTML::IHTMLDocument3Ptrなんでは。 (グローバル変数の) (APIでなくて)_bstr_tクラスを使った方が解放を自動でやってくれるので楽かも。
>接続状態で着信信号を出せればぶるっトゥースを >振動させることができる為、 >着信信号を出す方法を探している状態です。 その「着信信号」というのは何の事やらわかりませんが、 Bluetooth機器同士は、それらがサポートしているプロファイルのコマンドでしかやりとりができません。 (ぶるっトゥースのサポートしているプロファイルはHSP,HFPの2つ) http://www.princeton.co.jp/product/ptmicn.html#spec ぶるっトゥースは、おそらくHSP,HFPの状態通知か何かのコマンドを受信することで振動するんだと思います。 なのでHSPかHFPを実装すればという話をしたんです。 HSP,HFPの仕様は#2に書いているurlを読んで調べてください。
>よくiPhone版アプリで好評なものはAndroid版のリリースとなると結構待たされることがありますが >そういう理由ですね… 違います（笑）。 Androidは、Cではなくて、「Java」という言語で開発されます。また、iOSとはライブラリもまったく違いますから、基本的にはすべて一から作り直しになります。 個人的には、AndroidアプリのほうがiPhoneより簡単だと思いますよ。Androidの場合、Javaだけでなくて、使える開発環境がいろいろとあります。例えば、Googleが開発し、現在、MITで公開されているApp Inventorという開発ツールは、マウスで画面を設計し、アイコンを並べてプログラミングをするというもので、簡単なゲームなら小中学生でも作れるぐらいです。「App Inventor」で検索してみるといろいろ情報が見つかります。 Cを覚えることが目標ならそれでいいのですが、「スマホのアプリを作る」というのが目標ならば、Cにこだわる必要はないように思えますよ。
＞基本方針を教えていただけませんか? http://msdn.microsoft.com/ja-jp/library/system.windows.shapes.shape(v=vs.110).aspx をご覧下さい。
EXCELの場合、用紙の地の色を変えても「セルの印刷時に、セルの背景色ですべてが塗り潰される」ので、用紙の地の色を変えても無駄です。 やろうと思っても「すべてのセルの背景色を薄い黄色にする」くらいしか出来ません。 折角、黄色いカバーを重ねても、その上から「セルが描画されて、セルの背景色で塗り潰される」のですから、黄色いカバーを重ねても無意味です。
"invalid language characters in property" で検索すると似たような質問・相談が色々出てきます。 * http://www.tech-archive.net/Archive/DotNet/microsoft.public.dotnet.framework.setup/2006-08/msg00055.html * http://www.vbforums.com/showthread.php?538029-Resovled-About-Building-Setup-Project * 他にも沢山 解決するか分かりませんが、以下の事を確認されてみては: (1) プロジェクト(ソリューション)に含まれるファイル名に日本語(やその他の特別な文字、文字化けした文字)などが含まれていないか。 もし該当したらファイル名を変更して下さい。 (2) プロジェクト(ソリューション)自体が存在しているディレクトリのパスに日本語が含まれていないか (例 C:\日本語\foo\bar\MyProject) もし該当したらプロジェクト(ソリューション)をASCII文字だけで構成されたパスの下に移動して、開き直して下さい。 その際に、もしリンク切れしている項目(ソースファイル、アイコンファイル、リソース、インクルードパス、ライブラリパスなど)が在れば再度設定し直して下さい。
>　　*p=100　は*p = 100;で終わっていますが！出力結果として文字が出てきたいるのはなぜですか！ その直後にprintf()で出力指定しているからではなかったのですか？ 試しに全部のprintf()をコメントアウトしてみましょう。 printf("p=%p &hensuu=%p\n", p, &hensuu); の結果が、 p=0xff930a1c &hensuu=0xff930a1c # 改行はないはずですけどね。 次の printf("*p=%d\n", *p); の結果が *p=0 # ポインタが指しているhensuuは0ですからね。 その次の printf("*p=%d\n", *p); の結果が *p=100 # 間にある処理で書き換えていますからね。 さらに次の printf("hensuu=%d\n", hensuu); の結果が hensuu=100 # ポインタ使って書き換えましたからね。 間違っても、 *p = 100; が文字列として出力された訳ではありません。 あなたはそう理解しているようですが。
具体的な手順はすでに回答ついているのでいいとして… >リソースにはjpegで書いた画像aを追加しました。 画像ファイルではアイコンやマウスカーソルには使用できないかと。 アイコンエディタとかフリーでありますからそういうのでアイコンファイル(カーソルファイル)を作成してください。
バブルソートではないですね。 http://ja.wikipedia.org/wiki/%E3%83%90%E3%83%96%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88 選択ソートではないかと思います。 http://ja.wikipedia.org/wiki/%E9%81%B8%E6%8A%9E%E3%82%BD%E3%83%BC%E3%83%88 > また、ほかのソートの仕方も教えてください。 「ソート アルゴリズム」などで検索するといっぱい見つかると思います。 他の回答である通り、C++でプログラムを書くとしたら、std::sortを使うのが普通です。今回は勉強のために自分で書いてみているのでしょうけれど。 quick sortとか? template <typename T> void Swap(T& i0, T& i1) { T tmp = i0; i0 = i1; i1 = tmp; } template <typename BiderectIter> void QuickSort(BiderectIter begin, BiderectIter end) { typedef typename std::iterator_traits<BiderectIter>::value_type value_type; if (begin < end) { BiderectIter pivot_index = end - 1; value_type pivot_value = *(end - 1); BiderectIter store_index = begin; for (BiderectIter it = begin; it != end - 1; it++) { if (*it < pivot_value) { Swap(*it, *store_index); store_index++; } } Swap(*store_index, *pivot_index); QuickSort(begin, store_index); QuickSort(store_index + 1, end); } } merge sortとか? template <typename Iter> void Merge(Iter begin, Iter middle, Iter end) { typedef typename std::iterator_traits<Iter>::value_type type; std::vector<type> tmp; tmp.reserve(end - begin); Iter fhead = begin, lhead = middle; while (fhead != middle && lhead != end) { if (*fhead < *lhead) { tmp.push_back(*fhead); fhead++; } else { tmp.push_back(*lhead); lhead++; } } if (fhead == middle) { for (; lhead != end; lhead++) { tmp.push_back(*lhead); } } if (lhead == end) { for (; fhead != middle; fhead++) { tmp.push_back(*fhead); } } Iter it = begin; for (size_t i = 0; i < tmp.size(); i++) { *it++ = tmp[i]; } } template <typename Iter> void MergeSort(Iter begin, Iter end) { size_t size = end - begin; if (size < 2) return; Iter middle = begin + size / 2; MergeSort(begin, middle); MergeSort(middle, end); Merge(begin, middle, end); } 呼び出し方はこんな感じになりますが。 QuickSort(&c[0], &c[10]); MergeSort(&i[0], &i[10]);
残念ながら無理。 PerformClick()メソッドはSystem.Windows.Forms.Buttonクラスの持ち物で、System.Windows.Forms.PictureBoxクラスにはそれに相当するものがない。 英語のQAサイトを漁っても、「直接pictureBox1_Click(this.pictureBox1, null);を呼べとかそんな風にしか書かれていない。 と、まぁここまでだったらあなたをがっかりさせる普通の何の解決にもなってない回答だ。恐らくあなたがインターネットを検索して得た情報と何も変わりはすまい。 PictureBoxにPerformClick()が無いなら追加すればいいじゃない！ by まりーあんもちねっと といっても、System.Windows.Forms.PictureBoxクラスを書き換えるわけではないし使う側も面倒な手順を踏む必要がある。 プロジェクトを右クリックして追加→新しい項目でカスタムコントロールを選ぶ。ファイル名はClickablePictureBox.csとしようか。 で、そうするとControl（System.Windows.Forms.Control）から派生したクラスが自動的にできるのだが、これをSystem.Windows.Forms.PictureBoxに書き換える。 とりあえずさくっとサンプルコードを示す。サンプルでは名前空間をWindowsFormsApplication1にしてるけどお好きなものをどうぞ。 namespace WindowsFormsApplication1 { 　public partial class ClickablePictureBox : System.Windows.Forms.PictureBox { 　　public ClickablePictureBox() { 　　　InitializeComponent(); 　　} 　　public void PerformClick() { 　　　this.OnClick(new EventArgs()); 　　} 　} } これで、PerformClick()というメソッドが追加されてかつそれがClickイベントを引き起こす以外は全てPictureBoxと同じ振る舞いを行うコントロールを使う事が出来るようになる。 で、使う側もSystem.Windows.Forms.PictureBoxの変わりにWindowsFormsApplication1.ClickablePictureBoxを使う。 そうすると、それ以外にあなたのプログラムは何一つ変える事無くあなたのやりたい事が実現できるぜ。 あ、これは.Net 2.0相当の普通のWindows Formアプリケーションを想定してます。まぁWPFにはPictureBox自体無いので大丈夫だと思うけど。
惜しい。これが正解。 #include <stdio.h> #include <stdlib.h> /* EXIT_SUCCESS */ int main(void) { □int n, bit, s; □scanf("%d", &n); □ □s = 0; □while(n) { □□printf("%d/2=%d・・・余り%d\n",n,n/2,n%2); □□bit = n % 2; □□n /= 2; □□if (bit) □□□s++; □} □printf("%d", s); □return EXIT_SUCCESS; } ヒントとして途中経過を表示しているから考えてみてください。
(1)ソリューションエクスプローラーで対象のプロジェクトを右クリック (2)表示されたプロパティ画面の左側で「ビルド」を選択 (3)(2)で表示されたページの中の「アンセーフコードの許可」にチェックを入れてプロパティ画面を閉じる ……でも、ポインタに挑戦するならポインタが異物な C# よりもポインタの本場の C 言語をやった方がいいと思うのですが。
XBee ZigBee 基本編 ワイヤレス通信を始めよう～XBeeの使い方～ http://www.geocities.jp/bokunimowakaru/diy/xbee/xbee-tutorial_0.html 　こういった情報で何とか・・・なりませんかね？ 　ペアリング（ネットワークへの参加）さえできればどうにかなりそうな気がしますが。
C++03 だとそもそもメンバの初期化をその場で指定する事はできません。 C++11 でメンバを初期化する時はコンストラクタ呼出の形式ではなくて、統一的な初期化構文(uniform initialization)を使う必要があります。 std::unique_ptr<Hoge> test{new Hoge}; // () ではなく {}
質問者さんの意図に、いちばん近い形にするとなると、こういう書き換えになるでしょうか？ ＞ *(array + 3) = 0; int *ptr = &array[0][0]; *(ptr + 3) = 0;
> 色々調べましたらＣ＋＋のコンパイラの設定に関連するエラーらしいです 違います。関数の呼び出し方が間違っていることを表すエラーです。 Windows 関連の C/C++ で LP~ で始まる型を見たら ~ 型のポインタを意味するものと考えてまず間違いないです。今回の場合は POINT 型のポインタを要求されているところに POINT 型そのものを渡しているために問題のエラーが発生しています。 したがって、今回の場合は bool rtn = MoveToEx(hdc, 0, 0, &MyPoint); としてやれば OK ……とはなりません。このコード片にはそれ以外の問題があるからです。 (1)なぜ POINT 型を自分で定義しているのでしょうか? この関数が要求しているのは windef.h で定義されている POINT 構造体のはずで、この関数を使用するために windows.h をインクルードしていれば使えるはずです。 http://msdn.microsoft.com/ja-jp/library/8kk2sy33.aspx (2)この関数の戻り値の型は C++ の bool 型ではなく Windows SDK で定義されている BOOL 型です。実験してみたところ VC++ では問題なく変換できるようですが、型は合わせたほうが安心でしょう。
OutputDebugString()のことですかね？ DLLに限った話ではありませんし、printf()のようにコンソールには出ませんけど。
＞XXX.configが見当たりません。 無いなら作ってしまう、と言うのは試しましたか？ 単なるテキストファイルなので、メモ帳で新規作成して、保存後にXXX.exe.configにリネームすればよいです。 あと、こういうシステムファイルは、デフォルトで「非表示」になっている場合があるので、エクスプローラーの表示設定を「システムファイルも隠しファイルもすべて表示する状態」にして下さい。 作ってみて駄目であれば「この方法では解決しない」ので、ランタイムライブラリを古い物に戻す、ランタイムライブラリを新しい物に更新する、ランタイムライブラリを使わないでアプリの中に全部のライブラリを抱え込む形式でビルドし直すなど、他の方法での対処が必要になると思います。
★display をどう宣言していますか? クラスのメンバ関数として定義されていると想定して、以下の点の確認を。 (1) display をクラスのメンバ関数にする時は静的メンバ関数である必要がある。 static をつければ良いです。勿論、非静的データメンバなどにはさわれなくなりますが。 或いは、クラスのメンバ関数にするのをやめて、普通の関数として定義して下さい。 これは glutDisplayFunc の第一引数の型が "関数型 void (*)()" だからです。一方で (非静的) メンバ関数の型は "メンバ関数型 void (プロジェクト名::*)()" の様な類になります。(非静的) メンバ関数は、呼び出す為に「引数」に加えて「オブジェクトへの参照 (つまり、this ポインタの参照先)」も必要になるので、通常の関数とは異なる種類の物なのです。従って、メンバ関数は glutDisplayFunc に指定できません。 所で、static を伴って宣言された静的メンバ関数は、参照にオブジェクトへの参照を必要としないので、その型は "普通の関数型 void(*)()" になります。従って、静的メンバ関数は glutDisplayFunc に指定できます。 (2) display はクラス外部からアクセス可能でなければならない。(public: をつける。基本クラスから継承する場合は public 継承にするのも忘れずに。) ★あと、 (1) glutDisplayFunc(プロジェクト名::display); よりは (エラーメッセージにある通り)、 glutDisplayFunc(&プロジェクト名::display); と書いた方が良いでしょう。両者とも意味は全く同じ(前者は後者に暗黙変換される)ですが、コンパイラ・他のプログラマに意図が伝わりやすいのは後者です。 (2) プロジェクトの構成要素をまとめるのに class プロジェクト名{ ... }; としているのだとしたら、namespace を使用する (namespace プロジェクト名{ ... } とする) 方が一般的に適切です。実際にどちらが良いかは、プロジェクトの性質に依存するでしょうが、再考をお薦めします。 namespace にすれば中身はクラスのメンバではないので、静的メンバ関数・非静的メンバ関数などの違いに悩まされる事もありません(glutDisplayFunc に渡すのに関数宣言の static は不要)。 (3) エラーメッセージ C3867 の "関数呼び出しには引数リストがありません" は、プロジェクト名::display が glutDisplayFunc で受け取れないので、コンパイラが「プロジェクト名::display() と書きたかったのかもしれない」と邪推した為に出力したエラーメッセージです。この推測は誤っているので、今回はこのエラーメッセージは無視して構いません。 因みに、宣言の void display(void) の (void) は引数が空という事を意味するので、自分で呼び出すならば "display()" で正しいです。というよりそもそも "display(void)" 等という関数呼出の方法はありません。 (4) C2275,C2227 これは glutDisplayFunc(&this->display); の行ですね。この様な書き方はありません。
int *x ; で宣言された変数x は 「int *」型 mallocが返すのは 「void * 」型 です。 x=malloc(sizeof(int)); では 「int * 」型 = 「void *」型 なので、型が一致しません。 そこで、 (int *)を使って、 「void *」型を「int *」型に型変換しています。 わざと「ポインタ」という言葉を使わずに説明しました。 混乱の原因は、ポインタを特別なものだと思い過ぎているからではないでしょうか。 ちなみに。 ・C++を使っているのなら、(型)というキャストは使わないようにするのがよいでしょう。 詳しくは「C++ キャスト」で検索すると解説サイトが見つかります ・C++では、領域割り当て用の演算子 new というものがあります。 これは、型を指定するので、キャストの必要はありません。 また、classやstructは、mallocで確保してしまうとコンストラクタが呼ばれません。 なお、mallocに対してfreeがあるように、new には deleteです。
すみません、こういう操作は素人なので、的外れかもしれませんが、ソースを見てみると、Yahoo! JAPAN IDのテキストボックスは、ソースの129行目の <input type="text" maxlength="32" name="yid" id="yid" value="" class="txtbox stop" tabindex="10"> ではないでしょうか？ 「u」ではなく、「yid」でやってみては？
ソースコードが書かれたソースファイルが１つしか無いプログラムなら「コンパイルしたら直に実行形式のプログラムファイルが出来上がる」でも良いですよね。 それだと「オブジェクトファイルなんか要らない」ですもんね。 しかし、それで済むのは「ソースファイルが１つだけ」の時だけです。 ソースファイルが３０００ファイルあって、それら３０００個から１つの実行ファイルが作られている場合を考えてみましょう。 「コンパイルしたら直に実行形式のプログラムファイルが出来上がる」のですから、どこか１箇所を書き換えたら、３０００ファイルをすべてコンパイルしないと実行形式のプログラムファイルが作れません。 「全部コンパイルし直し」になっちゃいます。 なので「コンパイルはするけど、３０００個のファイルを実行形式ファイルに組み立てないまま置いておく」って事をして、書き換えた物だけをコンパイルする事にしました。 そして「コンパイルだけして、実行形式ファイルに組み立てる前の状態を保存しておくファイル」を「オブジェクトファイル」と呼ぶ事にしました。 こうすると、書き換えたソースファイルだけコンパイルすれば、残り２９９９個はコンパイル済みなので、すぐに「組み立てて実行形式ファイルを作成可能」になります。 なお「ライブラリファイル」ってのは「便利な関数を、コンパイル済みのオブジェクトファイルにして、集めてある物」の事です。 便利なライブラリ関数がすぐ使えるのも「オブジェクトファイルという仕組みがあるから」です。
＃1です。 >tail->nextはtailポインタとは関係ないものなんでしょうか? >tail->nextの値はtail自体を変えるとtail->nextも変わってしまうのかなと思っているのですが…。 なんとなく、わからないところがわかりました。 多分、ポインタの概念がまだしっくりときていないのかと思います。 tailというのはポインタなので、実体はありません。 リスト構造の最後のitemを指し示す目印のようなものです。 なので、 >tail=item; というのは、tailの中身を操作するものではなく、tailの指し示しているものを新しいitemに変更するという意味になります。 なので、それまでのtail->nextの値に変化はありませんが、これ以降はtailの指し示す対象が新しいitemになるので、tail->nextで参照すると変わっているように見えます。 それまでのtail->nextが変わっていないのを確認するために、以下のようにしてデバッガで値を確認してみるのもひとつの方法です。 list* oldtail = tail; //ここでtail->nextの値を確認 if(tail)tail->next=item; tail=item; list* a = oldtail->next; //ここで前に確認したtail->nextの値と比較する nextの値に変化が無いのが確認できると思います。 ただ、ちょっと気になったのは教科書的なリスト構造とはちょっと異なっているので、その他のリスト構造のサンプル等も参考にすると良いと思います。 C言語のポインタは実感しにくくつまづく人も多いので、それだけの内容の本も結構あります。 http://www.amazon.co.jp/s/ref=nb_sb_noss_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&url=search-alias%3Dstripbooks&field-keywords=%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF どうしても理解できない場合は評判の良い本を選んで1冊読んでみることをお勧めします。
何をしたいのか書かれていないのですが、 (C# 側の hBitmap) = (C++/CLI 側の m_hBitmap); という感じの事をしたいという事で良いですか? ★hBitmap に代入をしたいのであれば、「hBitmap の中身(hBitmap)」ではなくて「hBitmap の場所(&hBitmap)」を C++/CLI に渡さなければなりません。C++/CLI 側でも、引数(↓のphBitmap = hBitmapの場所情報)を書き換えるのではなく、引数が指し示す先(↓*phBitmap = hBitmap 本体)を書き換えなければなりません。 ------------------------------ C# System.IntPtr hBitmap; p.GetBitmapHandle((void**)&hBitmap); ------------------------------ C++/CLI (MFC) void GetBitmapHandle( void** phBitmap ){ *phBitmap = (void*)m_hBitmap; } HBITMAP m_hBitmap; ------------------------------ ★しかし、折角 C++/CLI ならば、より CLI 的な方法を使いたい物です(以下)。 ------------------------------ C# System.IntPtr hBitmap; p.GetBitmapHandle(out hBitmap); ------------------------------ C++/CLI (MFC) void GetBitmapHandle([System::Runtime::InteropServices::Out] System::IntPtr% hBitmap){ hBitmap = (System::IntPtr)m_hBitmap; } HBITMAP m_hBitmap; ------------------------------ 「[System::Runtime::InteropServices::Out] System::IntPtr% hBitmap」は C# でいう「out System.IntPtr hBitmap」です。やっている事は初めの例と全く同じで、ただ単に型(と文法)が異なるだけです。
>・数字一文字打てばまた入力待ちになる 既に回答されているように「数値」として処理される為、「数字」ではないのでisdigit()が偽を返します。 ので、ループ抜けられません。 >・数字以外を一文字打てば永遠にprintf関数とscanf関数が実行される 数字ではなかったので、scanf()が数値に変換不可能でエラーを返します。 その際、標準入力には「数字以外」が残ったままになります。 で、paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 　　： paymentの値は変わらないのでisdigit()が偽を返しループ継続します。 ループでもう一度scanf()がコールされたので標準入力のバッファの先頭にある文字を読み込んで数値変換を試みようとします。 が、やはり数字ではないのでそのままバッファに残してエラーを返却します。 Ctrl+Cなどで停止させるまで、愚直に繰り返します。 こういう場合、"%d"でうけるのではなく、"%s"で文字列として受け取って、その後で変換可能か処理する。 というのが一般的でしょう。
HBITMAPからSystem.Drawing.Bitmapを作る話なのになぜHDCが関係するのかわかりませんが……。 まず，HBITMAPからSystem.Drawing.Bitmapを作るには，System.Drawing.Image.FromHbitmapを使います。 http://msdn.microsoft.com/ja-jp/library/k061we7x.aspx で，HBITMAPはポインタ型なので，System.IntPtrへの変換はSystem.IntPtrのコンストラクタが利用可能です。 また，明示的なキャストでも変換ができます。 http://msdn.microsoft.com/ja-jp/library/z82h6h45.aspx http://msdn.microsoft.com/ja-jp/library/e4y9h1at.aspx 流れとしては，HBITMAP => IntPtr => Bitmapという変換を行い， あとはCLIの世界で処理を行えばよいです。
scanf("%f,%f,%f",&e1,&e2,&e3); ではなく、 scanf("%d,%d,%d",&e1,&e2,&e3);　です。 if((x+y>=z)||(x+z>=y)||(y+z>=x))　　この判定は間違っています。 x=10,y=10,z=10　で考えてみましょう。 (x+y>=z)　は(20>=10) になり、成立しますね。でもこれは三角形です。
WPFはやってないので見当違いなら申し訳ないのですが、 ファイルの拡張子がcsってことはC#ですよね？ > String^ Text = gcnew String( "文字列" ); このコードはC++/CLIのコードですのでC#のコンパイラに怒られるのは当然では？ 　String Text = "文字列"; でいいかと思います。
>>何で文字は”数字”ではないの・記憶できる範囲で！-128から始まっているのですか！！？？ そのような説明もありですが、数字として、0～255という解説でもＯＫです。また、その0～255を数字とみなすか、文字とみなすか？は、プログラムを設計した人が決めることです。 コンピュータからすれば、文字も数字も同じビットの並びです。 >>文字のマイナス -　の範囲はどんな概念なのでしょうか！？ 文字として扱う場合、基本的にプログラマさんは、文字データですから、マイナスという考えは持ちません。 ただ、Ｃ言語の場合は、読み込んでいるファイルの最後を意味する値として、特別なケースとして（－１）を扱うことはあります。
わかる分だけ。 >２．１５行目の変更方法は？ >オリジナル >CFLAGS= $(cflags) $(cdebug) $(cvars) -I. >これにオプションを追加する記載はこの様に２行になると、２行目しか認識されませんよね？ >どの様に記載するのか教えていただけないでしょうか？ 1行目の定義は2行目の定義で置き換えられるのは確かですが、6の文章をよく読みましょう。 6に書いてあるのは、「マルチスレッド」「マルチスレッド デバッグ」「マルチスレッド DLL」「マルチスレッド デバッグ DLL」をそれぞれ作る度にCFLAGSを書き換えてくださいって事です。 >３．「release用の場合は nodebug=1 オプションを末尾に付ける」とは以下の様にするのでしょうか？ あってます。 >※release用を別メイクするのなら、２．のオプションはデバッグとリリースで別々に作成して実行するのでしょうか？ リリース用とデバッグ用はmake時にnodebug=1を指定するかしないかで行われるので別々に作成する必要はありません。
既存のShowDialog()を利用せず、FormBでShowDialog()をオーバーロードすればいいのでは。 【Form1.cs】 Form2 form = new Form2(); int result = form.ShowDialog(); Console.WriteLine(result); 【Form2.cs】 DialogResult result = base.ShowDialog(); if (result == System.Windows.Forms.DialogResult.OK) { return 0; } else { return 1; } みたいな。 また、ShowDialog()で制御がFormAに戻ってくるタイミングは、FormBが閉じられた時です。 つまり、(3)の前半部分はShowDialog()では実現できません。
>文面から見るに、「ベクタ領域のアドレうがROM領域に重複している」 >ということで宜しいのでしょうか？ おおむねその様な意味です、ROMかどうかは設定次第です。 >お手数ですが、このエラーが発生する主な原因を教えて頂けないでしょうか？ １　領域の設定が間違っている。 　初期値でいつも正しいわけではない。 ２　プログラムが大きすぎる。 　プログラムサイズの見積もりミス。 　コーディングミスなどでサイズが増大している。 など
「ポインタは特に指示しなくても、大きさが確定する」でだいたい当たり. まず, C において配列には「1次元配列」しか存在しません. で, 配列の要素には非常に大雑把にいうと「宣言の時点で大きさが確定しなければならない」という条件が付きます (正確な条件はめんどくさいので省略). ということで ・int p[][]: p の要素は「int []」であるが, この [] の中に大きさが書かれていない→要素の大きさが確定しないのでアウト ・int *p[]: p の要素は「int *」で, 大きさが確定しているのでセーフ ・int p[][4]: p の要素は「int [4]」. これは大きさが確定するのでセーフ ついでに余談: 関数の仮引数に配列を書くと自動的にポインタと解釈される.
つ /OUT http://msdn.microsoft.com/ja-jp/library/8htcy933.aspx
使う人からすれば、どの言語で作られていたとしても、あまり関係がありません。（.NETのランタイム読み込みで起動が少し遅いとか、パフォーマンスの差はあるにしても） MFC C++からC#に移行させるメリットがあるかどうかですが、プログラムの内容や、今後の展開などによって変わってくると思います。 実際のプロジェクトでも、基本的にはC#で作成し、一部の処理だけC++を使う…という事もありますが、この場合はC++でしか出来ない、C++の方が効率が良い、過去の膨大なC++資産を活用したい…など、明確な理由がある場合のみです。 もし、そのような理由が無いのであれば、ロジックなどを含め全てC#に移行してしまった方が良いと思います。 あげられているメリットとしては、どちらかというと「個人のスキルに対するメリット」という感じだと思いますが、もしそうであればロジック部分も含めて.NET系に置き換えてみるのも良いかもしれませんよ。 もしくは、ネイティブ（C++）との連携方法もきちんと理解しておくために、あえて一部処理はC++で残しておくのも手ですが。
scanfはC言語の「文法」ではありません。 「標準ライブラリ」と呼ばれる、ライブラリに含まれる関数の一つでしかありません。 あと、具体的にどんなエラーメッセージが出たのですか? メッセージの内容を読んで理解することも、プログラミング技術向上に大事なことです。 http://ja.wikipedia.org/wiki/Scanf#scanf.E3.81.AE.E5.95.8F.E9.A1.8C.E7.82.B9.E3.81.A8.E5.9B.9E.E9.81.BF.E6.96.B9.E6.B3.95 にあるように、scanfは使い方を間違えるととても「危険」な関数です。 そこで http://msdn.microsoft.com/ja-jp/library/9y6s16x1%28v=vs.100%29.aspx > セキュリティに関するメモ とあるように、Microsoftとしてはセキュリティ強化版を使うことを推奨しています。 # 根本対策にはなってないという説もありますが。 そのため、設定次第では、scanfを使っただけで警告、またはエラーになります。
MicrosoftUpdate(WindowsUpdate)の際に「空き容量の大きいドライブ」にDLされて放置されるファイルですかね？ 削除しちゃって大丈夫だと思いますよ。 Visual Studio ExpressEditionのインストール時に…だったかも知れませんが。
HTMLは使えませんが、NSAttributedStringクラスで、文字列を修飾することができます。下線も引けます。Apple Developに、クラスリファレンスもガイドもありますから、まずはそれらをお調べになってください。
No.1の回答は撤回します。（完全な誤情報というわけではないんですけど……） Storyboardのみで、オブジェクトのレイアウトができないはずはないなあという思いで、いろいろネット検索していたら、下のブログを見つけました。 http://qiita.com/sora0077@github/items/2e513d9fc2b6fc2b5365 このブログの解説どおりにすれば、Storyboardのみでレイアウト可能です。 ただし、Autolayoutの使い方に習熟している必要がありますので、そちらの方面の勉強がまだでしたら、Autolayout入門から始めてください。 Autolayoutを使わない場合、No.1の回答どおり、プログラムでcontentSizeの調節が必要です。
こんにちは。 全てを網羅的に知っている訳ではないので、どれが良いかなどには答えられませんが、コメントを。 【1. 標準機能】 > 画像データを変形毎に計算して求めるのは非現実的なので どの様なライブラリ・APIを使ったとしても、(プログラマーが意識しなくても) 内部的には変形された画像データを計算している事には変わりありません。従って、画像データを変形の度に計算する事自体に関しては非現実的とは思いません。ただ、実際的な問題として、コーディングの手間と計算時間があるかと思います。標準機能の範囲内で実現するとしたら、コーディングの手間は惜しまないとしても、計算時間が問題として残りそうではあります。 しかし、実測していないので usami99 さんの目的の計算で、どれくらいの時間になるかは分かりません。もしかすると無視できるぐらい時間が短いかもしれませんし、或いは非現実的に遅いかもしれません。ところで、計算時間を評価する上で以下の事は確認した方が良いです: 「変形対象の画像サイズが大きすぎないか?」 画像サイズが実際の表示に用いている物よりも大きい場合には、画像サイズを表示する大きさに縮小してから表示するべきです。計算時間は画像の面積(∝長さの二乗)に比例しますので。 因みに OpenCV, OpenGL, DXLib, (それから、もしその様な機能が在れば Direct2D も) では、GPU の機能を呼び出して変形を計算していると思われるので、愚直に計算するよりは格段に速いと予想されます。 この方法を採用する場合に考慮するべきは ★コーディングの手間 ★計算時間の評価 (過大評価しているかもしれないので、効率的な実装にしてから、実測) 【2. OpenCV】 使った事がないので分かりません。ただ、 > (視点の変更で形状こそ求めているものに近くなるが、 という事であれば、「どの様に視点を変更すれば目的の形になるか」を計算すれば良いのではないでしょうか。三次元の幾何学の計算(数式変形)が必要になると思いますが。 > ・透過処理がアルファブレンドなので、同サイズの… 何をしているのか良く分かりませんが、例えば、↓にある様な事をしようとしているという事でしょうか。 http://www3.pf-x.net/~chopper/home2/WinAPI/WinGDI21.html それならば、上記URLに書いてあるように、変形した後の余白に対応するマスク画像を生成すれば良いのではないでしょうか。 ★4点に対応する視点の計算方法が分かればする ★マスクは可能か? 【3. OpenGL】 余り使った事がないので分かりませんが… > ４の変形時にマッピング画像が追従するようにする必要がある 勘違いしているかも知れませんが、テクスチャ(及びポリゴン上の UV 座標)はそのままで、平面ポリゴンの方を傾けるのでは駄目なのでしょうか。この場合も 4 点に対応するテクスチャの傾け方を考える必要がありますが。 ★テクスチャの方を傾けるのは可能か? 【4. DXLib】 すみません分かりません。 DXLib は他の枠組と相互運用できない様に思われます。DXLib の上で UI を全て作り直すのであれば可能そうですが。 【5. GDI+】 他の方が回答されている様に C++/CLI との親和性は高いですが、4点を指定して画像を変形する機能は GDI+ にはないと思うのですが…(勘違いでしたら済みません)。 というのも、.NET Framework の System::Drawing は元々 Gdiplus のラッパーとして設計されているからです。従って、GDI+ と System::Drawing の親和性が高いのは、そもそも同一の物ですから当然です。そして、4点を指定して画像を変形する機能は GDI+ にないので、標準の機能 (.NET Framework System::Drawing) にもないのです。 > 同じ名称の物が有るたびに > 一つ一つ、動作確認しながらクラスの定義をしなくてはならず、難儀しています。 > > 回答No.2 なにか言葉を湾曲して捉えられていませんか？ 質問者さんは「System::Drawing::Graphics と Gdiplus::Graphics を混同している」とか「CLI からうまく使えない」とかいうのではなくて、例えば、「その辺りにある解説サイトに登場する Graphics オブジェクトが Systen::Drawing::Graphics の事なのか Gdiplus::Graphics の事なのか解説サイトに明記されていない(or分かりにくい)」事を嘆いていられるのですよね。お気持ち分かります。 ★GDI+ は標準の機能とほぼ同等 【6. Direct2D】 これも知りませんが、Wikipedia によると GDI/GDI+ と相互運用できるとあるので、 System::Drawing::Graphics^ g の g->GetHdc() で得られる HDC に対して描画できるのではないでしょうか。 もしこれでできるのであれば、この方法が一番綺麗だと思われます。 サンプル (C++) http://code.msdn.microsoft.com/windowsapps/Direct2D-perspective-7db78f51 -------- 4点を指定して変換するという事が今回の鍵になると思うのですが、その辺りの経緯を分かり易くする為にも、過去の関連する質問へのリンクがあった方が良いかもしれません。 http://okwave.jp/qa/q8696755.html http://okwave.jp/qa/q8679117.html http://okwave.jp/qa/q8662361.html
> その方法をC#で記述するには、どのようにすればよいでしょうか 「C# レジストリ」で検索してみてください。 多くの情報が得られます。 例えば下記などが参考になるかと思います。 http://fernweh.jp/b/csharp-regedit/ http://dobon.net/vb/dotnet/system/registrykey.html http://ch.nicovideo.jp/laz/blomaga/ar471835
>フォーカスされていない時に変化しない様にするには、 >どの様にすればよいのか教えていただけないでしょうか？ GetFocus だったですかね、それが自分自身でなければメッセージを無視すれば良いのではないでしょうか。 でもフォーカスを持っているからこそメッセージが届いている気がしますが... >起動直後のどのスクロールバーにもフォーカスがされていない状態で、 まさか目視ではないと思いますが、これはどのようにして確認していますか？
少なくとも、そのプログラムにASPは関係ありません。 > "プロジェクト→参照の追加"からSystem.Windows.Formsを追加しようとした 具体的にどのように操作したのでしょう? 追加の画面の「.NET」から「System.Windows.Forms」を選んで追加 としましたか?何かのDLLファイルを直接指定するようなことはしていませんか? また、そのプロジェクトはどうやって用意しましたか? Windowsフォームプロジェクトを最初から選べば、参照も元から追加されているはずです。 > どの語を使うときusingを追加するか、とか記述規則など、本当は手順を踏んで学習していきたいのですが、 > そういったことが掲載されていて なおかつ理解できる書籍やサイトがない VSに付属のヘルプや、MSDNのサイトがありますが。 例えば、 Point でエラーになる件ですが、 .NET Frameworksの Point を検索すると http://msdn.microsoft.com/ja-jp/library/system.drawing.point%28v=vs.110%29.aspx が見付かります。4.5のものは今現在は機械翻訳のもので、ちょっとあやしい日本語になっていますので英語で読むのがよいでしょう。 また、過去のバージョンの資料も読めます。例えば3.5なら http://msdn.microsoft.com/ja-jp/library/system.drawing.point%28v=vs.90%29.aspx です。 で、マニュアルですが、必ず次のような記述があります > 名前空間 : System.Drawing > アセンブリ : System.Drawing (System.Drawing.dll 内) usingに使うのは「名前空間」です。usingで使わないなら、 System.Drawing.Point のようにして使います。 アセンブリは、参照に追加しなければならないものです。 > 当面の目標は、特定のウェブページからキーワードを拾ってExcelに出力することで、 > そのためにマウスの右クリックなどをプログラムから使いたいと思っています。 どんなことを目指しているのか、ちょっとよくわかりません。 もし、「IEの画面にマウスを移動させて右クリック→コピー」をプログラムから行いたい、ということなら、 UWSCのような自動操作用ツールを使うのが楽です。逆にC#でどこまでできるか不明です。 データが欲しいだけなら、直接ダウンロードしてHTMLを解析して必要な部分を抜き出す、という方法もあります。 これらは「ウェブスクレイピング」(あるいは単にスクレイピング)と呼ばれるものです。 http://ja.wikipedia.org/wiki/%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B9%E3%82%AF%E3%83%AC%E3%82%A4%E3%83%94%E3%83%B3%E3%82%B0
無理。　managedクラスはnativeなメンバ変数を持てません。
ちゃんとしたコンパイラと実行環境用意した方がいいと思いますけどね……。 >　実行結果の >　kaisuu >KURIKAESHI 0のKURIKAESHI 0って何でしょうか！？ >printf("kaisuu >"); と >printf("KURIKAESHI %d\n", syori_kaisuu); の出力結果です。 本来なら >scanf("%d", &kaisuu); で入力待ちになるんでしょうが…… http://codepad.org/ では入力待ちになってくれないんでしょうね。 まぁ、ブラウザ経由で動作しているのにどう入力待ちしろと？とは思いますが…。 >何でプログラム上”KURIKAESHI 0”が現るのですか！？ なんでって…… >printf("KURIKAESHI %d\n", syori_kaisuu); の出力結果です。 syori_kaisuuは最初に0で初期化しているじゃないですか。 >いきさつが分かりません！？ scanf()が期待通りに動作しないからそのまま突っ走っているだけです。 kaisuuの初期化が無かったら悲惨なことになっていた可能性もあるでしょう。 # およそ2分の1の確率で"KURIKAESHI 0"の表示すらなかった…かも知れませんけど。 # コンパイラの既定がint=signed intだったら…ですけどね。
>>コンピュータは"数字"か「文字」かどうやって!判断 プログラム言語によりそれは差があります。 基本的にコンピュータは、数字を扱うだけです。人間が書いたプログラムにより、数字として扱うか、文字として扱うかが決まります。 なので、古い言語のＣＯＢＯＬでは、”１＋２”なんて、人間にとっては計算可能なものであっても、そのまま式を与えると、エラーになって停止します。 でも、”１＋２”を数式として認識する処理を言語に人間が組み込み、数式として処理できるルーチンを用意しておけば、エラーにならず、”３”という値を返すことが可能になります。 ですから、”どうやって判断しているか”といえば、「数字か文字か判断するルーチンを、人間が用意して、言語に組み込んでいて、それに従ってコンピュータが判断している」ということになります。 なので、人間の組み込んだルーチンがいまいちだと、「これは数式だろう！」というケースでも、文字とみなしてしまい、エラーになることもあるでしょうね。
#include<stdio.h> int main (void) { int num,i,j,h; int k; printf("ピラミッドの高さを入力してください : "); scanf("%d" ,&num); for(i=1; i<=num; i++){ for(j=num; j>=i+1; j--){ printf("　",j); } for(h=1; h<=2*j-1; h++){ printf("■"); } printf("\n"); } return 0; }
u-=*q;　　⇒ u = u - s と等価　u は 5 になる *q=*p;　　⇒ s = t と等価　s は 3 になる *p=u+1;　 ⇒ t = u + 1 と等価　t は 6 になる h=p;　　　⇒ ポインタのみコピー(a) p=q;　　　⇒ ポインタのみコピー(b) q=h;　　　⇒ ポインタのみコピー(c) *p+=*q;　 ⇒ s = s + t と等価　s は 9 になる (a), (b), (c) のポインタのコピーを繰り返すことで、 *q が t を指し、*p が s を指すようになります。 このポインタのコピーがこの問題のキモですね。
>Ch[i].x=cos(radian)*Ch[i].speed; >Ch[i].y=sin(radian)*Ch[i].speed; +=にしないと中心(0,0)で半径Ch[i].speedの円周上しか動けなくなる気がします。
Microsoftアカウントで登録作業を行えばよいかと。 http://gurigumi.s349.xrea.com/programming/visualcpp/install2013_1.html とか http://homepage1.nifty.com/rucio/main/material/VB2013Install.htm とか…。 私はWindowsLiveID時代に取得したもので登録しています。 2013だと…起動後にMicrosoftアカウントへのログインを求めてくることもあったかと思いますが。
＞printf("合計は%5.lfです。\n", (double)(na ＋ nb ＋ nc); をよ～く見てください　)　が足りません
1. TimerはForm2のメンバですか? 2. TimerのIntervalは適切な値が設定されていますか? 2. TimerのEnabledプロパティはtrueになって/していますか?
　今初めて知ったので試したことはありませんが。 ＞3.自己解凍ファイルの作り方　.exe ＞http://mbsupport.dip.jp/watson/lhaz3.htm 　プログラムを組まなくてもツールがすでに提供をされているらしい。 　ＸＰで可能ということは、それ以降でも何か提供をされていそうな？ ＞自己解凍型zipファイルの作り方 ＞http://blogs.wankuma.com/hatsune/archive/2009/12/01/183431.aspx 　初めて知った（汗）
> 予約語とキーワードは同義語なのでしょうか？ 厳密な意味では同義ではありません。 キーワードの方が予約語よりも範囲が広いです。 例えばC言語で標準に用意されている関数があります。 これらの関数名とか変数名はキーワードではありますが予約語ではありません。 例えば、freadとかfwrite、これらの関数名は予約語ではありませんから、 プログラマが自分の関数名などに使うことが出来ます。 しかしキーワードとして重要なので、まずどこでも使ってはならない、と コーディング規約などで定められる対象です。 「出来るコト」と「すべきコト」は違う訳です。 またコンパイルやリンクを行う時に、コンパイルオプションやリンクオプションが あります。 これらはコーディングとは関係が無いようですが、経験上それらのキーワードを 使うと妙なエラーが生じるとことがあると思っています。
それで問題ないです。 ですけどエディションはUltimateであってますか？ パッケージ版で約55万円するんですけど・・・
この例だとCPUIDでCPUの情報を取得したいということですね。 intrin.hをインクルードして、__cpuid()を使えば良いのではないでしょうか。
え?もしかして http://oshiete.goo.ne.jp/qa/8688489.html これって、派生クラスじゃなかったの? 多くの言語では、クラス同士の互換性が無いと、キャストしたりできません。 ですが、C言語のキャストはとても強力で、どんな型でも無理矢理に変換します。 特にポインタは、アドレスに続くデータをどう扱うかの違いだけなので、 m_pEnv = (env_t *)new env02_t; としてもコンパイルエラーにはなりません。(動作時におかしくなるかもしれませんが) C++の参考書、参考サイトで「クラスの継承」「アップキャスト」「仮想関数」とかいうあたりをよく勉強しましょう。 そもそも、最初からenv_tを書き換えてenv_02_t相当にしちゃだめなの?
